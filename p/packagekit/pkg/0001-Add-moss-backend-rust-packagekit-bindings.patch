From a6b51a6feaf1c8b3e976aa399ba84efd454e74b8 Mon Sep 17 00:00:00 2001
From: Joey Riches <josephriches@gmail.com>
Date: Thu, 7 Aug 2025 12:37:21 +0100
Subject: [PATCH 1/1] WIP: Add moss backend and bindings for rust

---
 Cargo.lock        | 3885 +++++++++++++++++++++++++++++++++++++++++++++
 Cargo.toml        |   21 +
 build.rs          |   35 +
 src/lib.rs        | 2531 +++++++++++++++++++++++++++++
 src/packagekit.rs |    6 +
 wrapper.h         |   55 +
 6 files changed, 6533 insertions(+)
 create mode 100644 Cargo.lock
 create mode 100644 Cargo.toml
 create mode 100644 build.rs
 create mode 100644 src/lib.rs
 create mode 100644 src/packagekit.rs
 create mode 100644 wrapper.h

diff --git a/Cargo.lock b/Cargo.lock
new file mode 100644
index 000000000..195140a45
--- /dev/null
+++ b/Cargo.lock
@@ -0,0 +1,3885 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+version = 4
+
+[[package]]
+name = "addr2line"
+version = "0.24.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1"
+dependencies = [
+ "gimli",
+]
+
+[[package]]
+name = "adler2"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"
+
+[[package]]
+name = "aho-corasick"
+version = "1.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "alloc-no-stdlib"
+version = "2.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cc7bb162ec39d46ab1ca8c77bf72e890535becd1751bb45f64c597edb4c8c6b3"
+
+[[package]]
+name = "alloc-stdlib"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "94fb8275041c72129eb51b7d0322c29b8387a0386127718b096429201a5d6ece"
+dependencies = [
+ "alloc-no-stdlib",
+]
+
+[[package]]
+name = "allocator-api2"
+version = "0.2.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"
+
+[[package]]
+name = "android-tzdata"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"
+
+[[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "anstream"
+version = "0.6.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "301af1932e46185686725e0fad2f8f2aa7da69dd70bf6ecc44d6b703844a3933"
+dependencies = [
+ "anstyle",
+ "anstyle-parse",
+ "anstyle-query",
+ "anstyle-wincon",
+ "colorchoice",
+ "is_terminal_polyfill",
+ "utf8parse",
+]
+
+[[package]]
+name = "anstyle"
+version = "1.0.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "862ed96ca487e809f1c8e5a8447f6ee2cf102f846893800b20cebdf541fc6bbd"
+
+[[package]]
+name = "anstyle-parse"
+version = "0.2.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
+dependencies = [
+ "utf8parse",
+]
+
+[[package]]
+name = "anstyle-query"
+version = "1.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6c8bdeb6047d8983be085bab0ba1472e6dc604e7041dbf6fcd5e71523014fae9"
+dependencies = [
+ "windows-sys 0.59.0",
+]
+
+[[package]]
+name = "anstyle-wincon"
+version = "3.0.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "403f75924867bb1033c59fbf0797484329750cfbe3c4325cd33127941fabc882"
+dependencies = [
+ "anstyle",
+ "once_cell_polyfill",
+ "windows-sys 0.59.0",
+]
+
+[[package]]
+name = "arrayref"
+version = "0.3.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "76a2e8124351fda1ef8aaaa3bbd7ebbcb486bbcd4225aca0aa0d84bb2db8fecb"
+
+[[package]]
+name = "arrayvec"
+version = "0.7.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"
+
+[[package]]
+name = "async-broadcast"
+version = "0.7.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "435a87a52755b8f27fcf321ac4f04b2802e337c8c4872923137471ec39c37532"
+dependencies = [
+ "event-listener",
+ "event-listener-strategy",
+ "futures-core",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "async-channel"
+version = "2.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "924ed96dd52d1b75e9c1a3e6275715fd320f5f9439fb5a4a11fa51f4221158d2"
+dependencies = [
+ "concurrent-queue",
+ "event-listener-strategy",
+ "futures-core",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "async-compression"
+version = "0.4.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ddb939d66e4ae03cee6091612804ba446b12878410cfa17f785f4dd67d4014e8"
+dependencies = [
+ "brotli",
+ "flate2",
+ "futures-core",
+ "memchr",
+ "pin-project-lite",
+ "tokio",
+ "zstd",
+ "zstd-safe",
+]
+
+[[package]]
+name = "async-executor"
+version = "1.13.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bb812ffb58524bdd10860d7d974e2f01cc0950c2438a74ee5ec2e2280c6c4ffa"
+dependencies = [
+ "async-task",
+ "concurrent-queue",
+ "fastrand",
+ "futures-lite",
+ "pin-project-lite",
+ "slab",
+]
+
+[[package]]
+name = "async-io"
+version = "2.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "19634d6336019ef220f09fd31168ce5c184b295cbf80345437cc36094ef223ca"
+dependencies = [
+ "async-lock",
+ "cfg-if",
+ "concurrent-queue",
+ "futures-io",
+ "futures-lite",
+ "parking",
+ "polling",
+ "rustix",
+ "slab",
+ "windows-sys 0.60.2",
+]
+
+[[package]]
+name = "async-lock"
+version = "3.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ff6e472cdea888a4bd64f342f09b3f50e1886d32afe8df3d663c01140b811b18"
+dependencies = [
+ "event-listener",
+ "event-listener-strategy",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "async-process"
+version = "2.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "65daa13722ad51e6ab1a1b9c01299142bc75135b337923cfa10e79bbbd669f00"
+dependencies = [
+ "async-channel",
+ "async-io",
+ "async-lock",
+ "async-signal",
+ "async-task",
+ "blocking",
+ "cfg-if",
+ "event-listener",
+ "futures-lite",
+ "rustix",
+]
+
+[[package]]
+name = "async-recursion"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3b43422f69d8ff38f95f1b2bb76517c91589a924d1559a0e935d7c8ce0274c11"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "async-signal"
+version = "0.2.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f567af260ef69e1d52c2b560ce0ea230763e6fbb9214a85d768760a920e3e3c1"
+dependencies = [
+ "async-io",
+ "async-lock",
+ "atomic-waker",
+ "cfg-if",
+ "futures-core",
+ "futures-io",
+ "rustix",
+ "signal-hook-registry",
+ "slab",
+ "windows-sys 0.60.2",
+]
+
+[[package]]
+name = "async-task"
+version = "4.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8b75356056920673b02621b35afd0f7dda9306d03c79a30f5c56c44cf256e3de"
+
+[[package]]
+name = "async-trait"
+version = "0.1.88"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e539d3fca749fcee5236ab05e93a52867dd549cc157c8cb7f99595f3cedffdb5"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "atomic-waker"
+version = "1.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"
+
+[[package]]
+name = "autocfg"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"
+
+[[package]]
+name = "backtrace"
+version = "0.3.75"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6806a6321ec58106fea15becdad98371e28d92ccbc7c8f1b3b6dd724fe8f1002"
+dependencies = [
+ "addr2line",
+ "cfg-if",
+ "libc",
+ "miniz_oxide",
+ "object",
+ "rustc-demangle",
+ "windows-targets 0.52.6",
+]
+
+[[package]]
+name = "base64"
+version = "0.22.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"
+
+[[package]]
+name = "bindgen"
+version = "0.71.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f58bf3d7db68cfbac37cfc485a8d711e87e064c3d0fe0435b92f7a407f9d6b3"
+dependencies = [
+ "bitflags",
+ "cexpr",
+ "clang-sys",
+ "itertools 0.13.0",
+ "log",
+ "prettyplease",
+ "proc-macro2",
+ "quote",
+ "regex",
+ "rustc-hash",
+ "shlex",
+ "syn",
+]
+
+[[package]]
+name = "bitflags"
+version = "2.9.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1b8e56985ec62d17e9c1001dc89c88ecd7dc08e47eba5ec7c29c7b5eeecde967"
+
+[[package]]
+name = "blake3"
+version = "1.8.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3888aaa89e4b2a40fca9848e400f6a658a5a3978de7be858e209cafa8be9a4a0"
+dependencies = [
+ "arrayref",
+ "arrayvec",
+ "cc",
+ "cfg-if",
+ "constant_time_eq",
+ "memmap2",
+ "rayon-core",
+]
+
+[[package]]
+name = "block-buffer"
+version = "0.10.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
+dependencies = [
+ "generic-array",
+]
+
+[[package]]
+name = "blocking"
+version = "1.6.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e83f8d02be6967315521be875afa792a316e28d57b5a2d401897e2a7921b7f21"
+dependencies = [
+ "async-channel",
+ "async-task",
+ "futures-io",
+ "futures-lite",
+ "piper",
+]
+
+[[package]]
+name = "blsforme"
+version = "0.1.0"
+source = "git+https://github.com/AerynOS/blsforme.git?rev=a09fa783aab22c8a057fc38f827d2fd2d3d157d9#a09fa783aab22c8a057fc38f827d2fd2d3d157d9"
+dependencies = [
+ "blake3",
+ "fs-err",
+ "gpt",
+ "log",
+ "nix 0.30.1",
+ "os-info",
+ "serde",
+ "serde_json",
+ "snafu",
+ "topology",
+]
+
+[[package]]
+name = "brotli"
+version = "8.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9991eea70ea4f293524138648e41ee89b0b2b12ddef3b255effa43c8056e0e0d"
+dependencies = [
+ "alloc-no-stdlib",
+ "alloc-stdlib",
+ "brotli-decompressor",
+]
+
+[[package]]
+name = "brotli-decompressor"
+version = "5.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "874bb8112abecc98cbd6d81ea4fa7e94fb9449648c93cc89aa40c81c24d7de03"
+dependencies = [
+ "alloc-no-stdlib",
+ "alloc-stdlib",
+]
+
+[[package]]
+name = "bumpalo"
+version = "3.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"
+
+[[package]]
+name = "bytes"
+version = "1.10.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"
+
+[[package]]
+name = "camino"
+version = "1.1.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0da45bc31171d8d6960122e222a67740df867c1dd53b4d51caa297084c185cab"
+
+[[package]]
+name = "cc"
+version = "1.2.30"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "deec109607ca693028562ed836a5f1c4b8bd77755c4e132fc5ce11b0b6211ae7"
+dependencies = [
+ "jobserver",
+ "libc",
+ "shlex",
+]
+
+[[package]]
+name = "cexpr"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
+dependencies = [
+ "nom",
+]
+
+[[package]]
+name = "cfg-expr"
+version = "0.15.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d067ad48b8650848b989a59a86c6c36a995d02d2bf778d45c3c5d57bc2718f02"
+dependencies = [
+ "smallvec",
+ "target-lexicon",
+]
+
+[[package]]
+name = "cfg-if"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9555578bc9e57714c812a1f84e4fc5b4d21fcb063490c624de019f7464c91268"
+
+[[package]]
+name = "cfg_aliases"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"
+
+[[package]]
+name = "chrono"
+version = "0.4.41"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c469d952047f47f91b68d1cba3f10d63c11d73e4636f24f08daf0278abf01c4d"
+dependencies = [
+ "android-tzdata",
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "serde",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
+name = "clang-sys"
+version = "1.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b023947811758c97c59bf9d1c188fd619ad4718dcaa767947df1cadb14f39f4"
+dependencies = [
+ "glob",
+ "libc",
+ "libloading",
+]
+
+[[package]]
+name = "clap"
+version = "4.5.41"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "be92d32e80243a54711e5d7ce823c35c41c9d929dc4ab58e1276f625841aadf9"
+dependencies = [
+ "clap_builder",
+ "clap_derive",
+]
+
+[[package]]
+name = "clap_builder"
+version = "4.5.41"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "707eab41e9622f9139419d573eca0900137718000c517d47da73045f54331c3d"
+dependencies = [
+ "anstream",
+ "anstyle",
+ "clap_lex",
+ "strsim",
+]
+
+[[package]]
+name = "clap_complete"
+version = "4.5.55"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a5abde44486daf70c5be8b8f8f1b66c49f86236edf6fa2abadb4d961c4c6229a"
+dependencies = [
+ "clap",
+]
+
+[[package]]
+name = "clap_derive"
+version = "4.5.41"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ef4f52386a59ca4c860f7393bcf8abd8dfd91ecccc0f774635ff68e92eeef491"
+dependencies = [
+ "heck",
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "clap_lex"
+version = "0.7.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b94f61472cee1439c0b966b47e3aca9ae07e45d070759512cd390ea2bebc6675"
+
+[[package]]
+name = "clap_mangen"
+version = "0.2.28"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e2fb6d3f935bbb9819391528b0e7cf655e78a0bc7a7c3d227211a1d24fc11db1"
+dependencies = [
+ "clap",
+ "roff",
+]
+
+[[package]]
+name = "colorchoice"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"
+
+[[package]]
+name = "concurrent-queue"
+version = "2.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4ca0197aee26d1ae37445ee532fefce43251d24cc7c166799f4d46817f1d3973"
+dependencies = [
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "config"
+version = "0.25.6"
+source = "git+https://github.com/joebonrichie/os-tools?rev=f6e6070#f6e6070a9ed61e07389bf963db281b29df8df816"
+dependencies = [
+ "dirs",
+ "fs-err",
+ "serde",
+ "serde_yaml",
+ "thiserror 2.0.12",
+]
+
+[[package]]
+name = "console"
+version = "0.15.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "054ccb5b10f9f2cbf51eb355ca1d05c2d279ce1804688d0db74b4733a5aeafd8"
+dependencies = [
+ "encode_unicode",
+ "libc",
+ "once_cell",
+ "unicode-width",
+ "windows-sys 0.59.0",
+]
+
+[[package]]
+name = "constant_time_eq"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7c74b8349d32d297c9134b8c88677813a227df8f779daa29bfc29c183fe3dca6"
+
+[[package]]
+name = "container"
+version = "0.25.6"
+source = "git+https://github.com/joebonrichie/os-tools?rev=f6e6070#f6e6070a9ed61e07389bf963db281b29df8df816"
+dependencies = [
+ "fs-err",
+ "nix 0.27.1",
+ "snafu",
+ "strum",
+]
+
+[[package]]
+name = "convert_case"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bb402b8d4c85569410425650ce3eddc7d698ed96d39a73f941b08fb63082f1e7"
+dependencies = [
+ "unicode-segmentation",
+]
+
+[[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
+name = "cpufeatures"
+version = "0.2.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "crc"
+version = "3.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9710d3b3739c2e349eb44fe848ad0b7c8cb1e42bd87ee49371df2f7acaf3e675"
+dependencies = [
+ "crc-catalog",
+]
+
+[[package]]
+name = "crc-catalog"
+version = "2.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "19d374276b40fb8bbdee95aef7c7fa6b5316ec764510eb64b8dd0e2ed0d7e7f5"
+
+[[package]]
+name = "crc32fast"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
+dependencies = [
+ "cfg-if",
+]
+
+[[package]]
+name = "crossbeam-deque"
+version = "0.8.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
+dependencies = [
+ "crossbeam-epoch",
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-epoch"
+version = "0.9.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
+dependencies = [
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-utils"
+version = "0.8.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"
+
+[[package]]
+name = "crossterm"
+version = "0.29.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d8b9f2e4c67f833b660cdb0a3523065869fb35570177239812ed4c905aeff87b"
+dependencies = [
+ "bitflags",
+ "crossterm_winapi",
+ "derive_more",
+ "document-features",
+ "mio",
+ "parking_lot",
+ "rustix",
+ "signal-hook",
+ "signal-hook-mio",
+ "winapi",
+]
+
+[[package]]
+name = "crossterm_winapi"
+version = "0.9.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "acdd7c62a3665c7f6830a51635d9ac9b23ed385797f70a83bb8bafe9c572ab2b"
+dependencies = [
+ "winapi",
+]
+
+[[package]]
+name = "crypto-common"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
+dependencies = [
+ "generic-array",
+ "typenum",
+]
+
+[[package]]
+name = "dag"
+version = "0.25.6"
+source = "git+https://github.com/joebonrichie/os-tools?rev=f6e6070#f6e6070a9ed61e07389bf963db281b29df8df816"
+dependencies = [
+ "petgraph",
+]
+
+[[package]]
+name = "darling"
+version = "0.20.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc7f46116c46ff9ab3eb1597a45688b6715c6e628b5c133e288e709a29bcb4ee"
+dependencies = [
+ "darling_core",
+ "darling_macro",
+]
+
+[[package]]
+name = "darling_core"
+version = "0.20.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0d00b9596d185e565c2207a0b01f8bd1a135483d02d9b7b0a54b11da8d53412e"
+dependencies = [
+ "fnv",
+ "ident_case",
+ "proc-macro2",
+ "quote",
+ "strsim",
+ "syn",
+]
+
+[[package]]
+name = "darling_macro"
+version = "0.20.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc34b93ccb385b40dc71c6fceac4b2ad23662c7eeb248cf10d529b7e055b6ead"
+dependencies = [
+ "darling_core",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "deranged"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9c9e6a11ca8224451684bc0d7d5a7adbf8f2fd6887261a1cfc3c0432f9d4068e"
+dependencies = [
+ "powerfmt",
+]
+
+[[package]]
+name = "derive_more"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "093242cf7570c207c83073cf82f79706fe7b8317e98620a47d5be7c3d8497678"
+dependencies = [
+ "derive_more-impl",
+]
+
+[[package]]
+name = "derive_more-impl"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bda628edc44c4bb645fbe0f758797143e4e07926f7ebf4e9bdfbd3d2ce621df3"
+dependencies = [
+ "convert_case",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "unicode-xid",
+]
+
+[[package]]
+name = "dialoguer"
+version = "0.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "658bce805d770f407bc62102fca7c2c64ceef2fbcb2b8bd19d2765ce093980de"
+dependencies = [
+ "console",
+ "shell-words",
+ "tempfile",
+ "thiserror 1.0.69",
+ "zeroize",
+]
+
+[[package]]
+name = "diesel"
+version = "2.2.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "229850a212cd9b84d4f0290ad9d294afc0ae70fccaa8949dbe8b43ffafa1e20c"
+dependencies = [
+ "diesel_derives",
+ "libsqlite3-sys",
+ "time",
+]
+
+[[package]]
+name = "diesel_derives"
+version = "2.2.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1b96984c469425cb577bf6f17121ecb3e4fe1e81de5d8f780dd372802858d756"
+dependencies = [
+ "diesel_table_macro_syntax",
+ "dsl_auto_type",
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "diesel_migrations"
+version = "2.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8a73ce704bad4231f001bff3314d91dce4aba0770cee8b233991859abc15c1f6"
+dependencies = [
+ "diesel",
+ "migrations_internals",
+ "migrations_macros",
+]
+
+[[package]]
+name = "diesel_table_macro_syntax"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "209c735641a413bc68c4923a9d6ad4bcb3ca306b794edaa7eb0b3228a99ffb25"
+dependencies = [
+ "syn",
+]
+
+[[package]]
+name = "digest"
+version = "0.10.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
+dependencies = [
+ "block-buffer",
+ "crypto-common",
+]
+
+[[package]]
+name = "dirs"
+version = "6.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c3e8aa94d75141228480295a7d0e7feb620b1a5ad9f12bc40be62411e38cce4e"
+dependencies = [
+ "dirs-sys",
+]
+
+[[package]]
+name = "dirs-sys"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e01a3366d27ee9890022452ee61b2b63a67e6f13f58900b651ff5665f0bb1fab"
+dependencies = [
+ "libc",
+ "option-ext",
+ "redox_users",
+ "windows-sys 0.60.2",
+]
+
+[[package]]
+name = "displaydoc"
+version = "0.2.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "document-features"
+version = "0.2.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "95249b50c6c185bee49034bcb378a49dc2b5dff0be90ff6616d31d64febab05d"
+dependencies = [
+ "litrs",
+]
+
+[[package]]
+name = "dsl_auto_type"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "139ae9aca7527f85f26dd76483eb38533fd84bd571065da1739656ef71c5ff5b"
+dependencies = [
+ "darling",
+ "either",
+ "heck",
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "either"
+version = "1.15.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"
+
+[[package]]
+name = "encode_unicode"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "34aa73646ffb006b8f5147f3dc182bd4bcb190227ce861fc4a4844bf8e3cb2c0"
+
+[[package]]
+name = "encoding_rs"
+version = "0.8.35"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
+dependencies = [
+ "cfg-if",
+]
+
+[[package]]
+name = "endi"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a3d8a32ae18130a3c84dd492d4215c3d913c3b07c6b63c2eb3eb7ff1101ab7bf"
+
+[[package]]
+name = "enumflags2"
+version = "0.7.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1027f7680c853e056ebcec683615fb6fbbc07dbaa13b4d5d9442b146ded4ecef"
+dependencies = [
+ "enumflags2_derive",
+ "serde",
+]
+
+[[package]]
+name = "enumflags2_derive"
+version = "0.7.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "67c78a4d8fdf9953a5c9d458f9efe940fd97a0cab0941c075a813ac594733827"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "equivalent"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"
+
+[[package]]
+name = "errno"
+version = "0.3.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "778e2ac28f6c47af28e4907f13ffd1e1ddbd400980a9abd7c8df189bf578a5ad"
+dependencies = [
+ "libc",
+ "windows-sys 0.60.2",
+]
+
+[[package]]
+name = "event-listener"
+version = "5.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3492acde4c3fc54c845eaab3eed8bd00c7a7d881f78bfc801e43a93dec1331ae"
+dependencies = [
+ "concurrent-queue",
+ "parking",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "event-listener-strategy"
+version = "0.5.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8be9f3dfaaffdae2972880079a491a1a8bb7cbed0b8dd7a347f668b4150a3b93"
+dependencies = [
+ "event-listener",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "eyre"
+version = "0.6.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7cd915d99f24784cdc19fd37ef22b97e3ff0ae756c7e492e9fbfe897d61e2aec"
+dependencies = [
+ "indenter",
+ "once_cell",
+]
+
+[[package]]
+name = "fastrand"
+version = "2.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"
+
+[[package]]
+name = "fixedbitset"
+version = "0.5.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1d674e81391d1e1ab681a28d99df07927c6d4aa5b027d7da16ba32d1d21ecd99"
+
+[[package]]
+name = "flate2"
+version = "1.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4a3d7db9596fecd151c5f638c0ee5d5bd487b6e0ea232e5dc96d5250f6f94b1d"
+dependencies = [
+ "crc32fast",
+ "miniz_oxide",
+]
+
+[[package]]
+name = "fnmatch"
+version = "0.25.6"
+source = "git+https://github.com/joebonrichie/os-tools?rev=f6e6070#f6e6070a9ed61e07389bf963db281b29df8df816"
+dependencies = [
+ "regex",
+ "serde",
+ "snafu",
+]
+
+[[package]]
+name = "fnv"
+version = "1.0.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"
+
+[[package]]
+name = "foldhash"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"
+
+[[package]]
+name = "form_urlencoded"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
+dependencies = [
+ "percent-encoding",
+]
+
+[[package]]
+name = "fs-err"
+version = "3.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "88d7be93788013f265201256d58f04936a8079ad5dc898743aa20525f503b683"
+dependencies = [
+ "autocfg",
+ "tokio",
+]
+
+[[package]]
+name = "futures-channel"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
+dependencies = [
+ "futures-core",
+ "futures-sink",
+]
+
+[[package]]
+name = "futures-core"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"
+
+[[package]]
+name = "futures-io"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"
+
+[[package]]
+name = "futures-lite"
+version = "2.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f5edaec856126859abb19ed65f39e90fea3a9574b9707f13539acf4abf7eb532"
+dependencies = [
+ "fastrand",
+ "futures-core",
+ "futures-io",
+ "parking",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "futures-macro"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "futures-sink"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"
+
+[[package]]
+name = "futures-task"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"
+
+[[package]]
+name = "futures-util"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
+dependencies = [
+ "futures-core",
+ "futures-io",
+ "futures-macro",
+ "futures-sink",
+ "futures-task",
+ "memchr",
+ "pin-project-lite",
+ "pin-utils",
+ "slab",
+]
+
+[[package]]
+name = "generic-array"
+version = "0.14.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
+dependencies = [
+ "typenum",
+ "version_check",
+]
+
+[[package]]
+name = "getrandom"
+version = "0.2.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
+dependencies = [
+ "cfg-if",
+ "js-sys",
+ "libc",
+ "wasi 0.11.1+wasi-snapshot-preview1",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "getrandom"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "26145e563e54f2cadc477553f1ec5ee650b00862f0a58bcd12cbdc5f0ea2d2f4"
+dependencies = [
+ "cfg-if",
+ "js-sys",
+ "libc",
+ "r-efi",
+ "wasi 0.14.2+wasi-0.2.4",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "gimli"
+version = "0.31.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"
+
+[[package]]
+name = "glib-sys"
+version = "0.18.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "063ce2eb6a8d0ea93d2bf8ba1957e78dbab6be1c2220dd3daca57d5a9d869898"
+dependencies = [
+ "libc",
+ "system-deps",
+]
+
+[[package]]
+name = "glob"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a8d1add55171497b4705a648c6b583acafb01d58050a51727785f0b2c8e0a2b2"
+
+[[package]]
+name = "gpt"
+version = "4.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3696fafb1ecdcc2ae3ce337de73e9202806068594b77d22fdf2f3573c5ec2219"
+dependencies = [
+ "bitflags",
+ "crc",
+ "simple-bytes",
+ "uuid",
+]
+
+[[package]]
+name = "h2"
+version = "0.4.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "17da50a276f1e01e0ba6c029e47b7100754904ee8a278f886546e98575380785"
+dependencies = [
+ "atomic-waker",
+ "bytes",
+ "fnv",
+ "futures-core",
+ "futures-sink",
+ "http",
+ "indexmap",
+ "slab",
+ "tokio",
+ "tokio-util",
+ "tracing",
+]
+
+[[package]]
+name = "hashbrown"
+version = "0.15.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5971ac85611da7067dbfcabef3c70ebb5606018acd9e2a3903a0da507521e0d5"
+dependencies = [
+ "allocator-api2",
+ "equivalent",
+ "foldhash",
+]
+
+[[package]]
+name = "heck"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"
+
+[[package]]
+name = "hermit-abi"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc0fef456e4baa96da950455cd02c081ca953b141298e41db3fc7e36b1da849c"
+
+[[package]]
+name = "hex"
+version = "0.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"
+
+[[package]]
+name = "http"
+version = "1.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f4a85d31aea989eead29a3aaf9e1115a180df8282431156e533de47660892565"
+dependencies = [
+ "bytes",
+ "fnv",
+ "itoa",
+]
+
+[[package]]
+name = "http-body"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1efedce1fb8e6913f23e0c92de8e62cd5b772a67e7b3946df930a62566c93184"
+dependencies = [
+ "bytes",
+ "http",
+]
+
+[[package]]
+name = "http-body-util"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b021d93e26becf5dc7e1b75b1bed1fd93124b374ceb73f43d4d4eafec896a64a"
+dependencies = [
+ "bytes",
+ "futures-core",
+ "http",
+ "http-body",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "httparse"
+version = "1.10.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6dbf3de79e51f3d586ab4cb9d5c3e2c14aa28ed23d180cf89b4df0454a69cc87"
+
+[[package]]
+name = "hyper"
+version = "1.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cc2b571658e38e0c01b1fdca3bbbe93c00d3d71693ff2770043f8c29bc7d6f80"
+dependencies = [
+ "bytes",
+ "futures-channel",
+ "futures-util",
+ "h2",
+ "http",
+ "http-body",
+ "httparse",
+ "itoa",
+ "pin-project-lite",
+ "smallvec",
+ "tokio",
+ "want",
+]
+
+[[package]]
+name = "hyper-rustls"
+version = "0.27.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e3c93eb611681b207e1fe55d5a71ecf91572ec8a6705cdb6857f7d8d5242cf58"
+dependencies = [
+ "http",
+ "hyper",
+ "hyper-util",
+ "rustls",
+ "rustls-pki-types",
+ "tokio",
+ "tokio-rustls",
+ "tower-service",
+ "webpki-roots",
+]
+
+[[package]]
+name = "hyper-util"
+version = "0.1.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7f66d5bd4c6f02bf0542fad85d626775bab9258cf795a4256dcaf3161114d1df"
+dependencies = [
+ "base64",
+ "bytes",
+ "futures-channel",
+ "futures-core",
+ "futures-util",
+ "http",
+ "http-body",
+ "hyper",
+ "ipnet",
+ "libc",
+ "percent-encoding",
+ "pin-project-lite",
+ "socket2",
+ "tokio",
+ "tower-service",
+ "tracing",
+]
+
+[[package]]
+name = "iana-time-zone"
+version = "0.1.63"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b0c919e5debc312ad217002b8048a17b7d83f80703865bbfcfebb0458b0b27d8"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
+name = "icu_collections"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "200072f5d0e3614556f94a9930d5dc3e0662a652823904c3a75dc3b0af7fee47"
+dependencies = [
+ "displaydoc",
+ "potential_utf",
+ "yoke",
+ "zerofrom",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_locale_core"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0cde2700ccaed3872079a65fb1a78f6c0a36c91570f28755dda67bc8f7d9f00a"
+dependencies = [
+ "displaydoc",
+ "litemap",
+ "tinystr",
+ "writeable",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_normalizer"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "436880e8e18df4d7bbc06d58432329d6458cc84531f7ac5f024e93deadb37979"
+dependencies = [
+ "displaydoc",
+ "icu_collections",
+ "icu_normalizer_data",
+ "icu_properties",
+ "icu_provider",
+ "smallvec",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_normalizer_data"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "00210d6893afc98edb752b664b8890f0ef174c8adbb8d0be9710fa66fbbf72d3"
+
+[[package]]
+name = "icu_properties"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "016c619c1eeb94efb86809b015c58f479963de65bdb6253345c1a1276f22e32b"
+dependencies = [
+ "displaydoc",
+ "icu_collections",
+ "icu_locale_core",
+ "icu_properties_data",
+ "icu_provider",
+ "potential_utf",
+ "zerotrie",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_properties_data"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "298459143998310acd25ffe6810ed544932242d3f07083eee1084d83a71bd632"
+
+[[package]]
+name = "icu_provider"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "03c80da27b5f4187909049ee2d72f276f0d9f99a42c306bd0131ecfe04d8e5af"
+dependencies = [
+ "displaydoc",
+ "icu_locale_core",
+ "stable_deref_trait",
+ "tinystr",
+ "writeable",
+ "yoke",
+ "zerofrom",
+ "zerotrie",
+ "zerovec",
+]
+
+[[package]]
+name = "ident_case"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"
+
+[[package]]
+name = "idna"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "686f825264d630750a544639377bae737628043f20d38bbc029e8f29ea968a7e"
+dependencies = [
+ "idna_adapter",
+ "smallvec",
+ "utf8_iter",
+]
+
+[[package]]
+name = "idna_adapter"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3acae9609540aa318d1bc588455225fb2085b9ed0c4f6bd0d9d5bcd86f1a0344"
+dependencies = [
+ "icu_normalizer",
+ "icu_properties",
+]
+
+[[package]]
+name = "indenter"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ce23b50ad8242c51a442f3ff322d56b02f08852c77e4c0b4d3fd684abc89c683"
+
+[[package]]
+name = "indexmap"
+version = "2.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fe4cd85333e22411419a0bcae1297d25e58c9443848b11dc6a86fefe8c78a661"
+dependencies = [
+ "equivalent",
+ "hashbrown",
+]
+
+[[package]]
+name = "indextree"
+version = "4.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cb9e21e48c85fa6643a38caca564645a3bbc9211edf506fc8ed690c7e7b4d3c7"
+dependencies = [
+ "indextree-macros",
+]
+
+[[package]]
+name = "indextree-macros"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f85dac6c239acc85fd61934c572292d93adfd2de459d9c032aa22b553506e915"
+dependencies = [
+ "either",
+ "itertools 0.14.0",
+ "proc-macro2",
+ "quote",
+ "strum",
+ "syn",
+ "thiserror 2.0.12",
+]
+
+[[package]]
+name = "indicatif"
+version = "0.17.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "183b3088984b400f4cfac3620d5e076c84da5364016b4f49473de574b2586235"
+dependencies = [
+ "console",
+ "number_prefix",
+ "portable-atomic",
+ "unicode-width",
+ "web-time",
+]
+
+[[package]]
+name = "io-uring"
+version = "0.7.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b86e202f00093dcba4275d4636b93ef9dd75d025ae560d2521b45ea28ab49013"
+dependencies = [
+ "bitflags",
+ "cfg-if",
+ "libc",
+]
+
+[[package]]
+name = "ipnet"
+version = "2.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "469fb0b9cefa57e3ef31275ee7cacb78f2fdca44e4765491884a2b119d4eb130"
+
+[[package]]
+name = "iri-string"
+version = "0.7.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dbc5ebe9c3a1a7a5127f920a418f7585e9e758e911d0466ed004f393b0e380b2"
+dependencies = [
+ "memchr",
+ "serde",
+]
+
+[[package]]
+name = "is_terminal_polyfill"
+version = "1.70.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"
+
+[[package]]
+name = "itertools"
+version = "0.13.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "413ee7dfc52ee1a4949ceeb7dbc8a33f2d6c088194d9f922fb8318faf1f01186"
+dependencies = [
+ "either",
+]
+
+[[package]]
+name = "itertools"
+version = "0.14.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2b192c782037fadd9cfa75548310488aabdbf3d2da73885b31bd0abd03351285"
+dependencies = [
+ "either",
+]
+
+[[package]]
+name = "itoa"
+version = "1.0.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"
+
+[[package]]
+name = "jobserver"
+version = "0.1.33"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "38f262f097c174adebe41eb73d66ae9c06b2844fb0da69969647bbddd9b0538a"
+dependencies = [
+ "getrandom 0.3.3",
+ "libc",
+]
+
+[[package]]
+name = "js-sys"
+version = "0.3.77"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "lazy_static"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
+
+[[package]]
+name = "libc"
+version = "0.2.174"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1171693293099992e19cddea4e8b849964e9846f4acee11b3948bcc337be8776"
+
+[[package]]
+name = "libloading"
+version = "0.8.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "07033963ba89ebaf1584d767badaa2e8fcec21aedea6b8c0346d487d49c28667"
+dependencies = [
+ "cfg-if",
+ "windows-targets 0.53.2",
+]
+
+[[package]]
+name = "libredox"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4488594b9328dee448adb906d8b126d9b7deb7cf5c22161ee591610bb1be83c0"
+dependencies = [
+ "bitflags",
+ "libc",
+]
+
+[[package]]
+name = "libsqlite3-sys"
+version = "0.30.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2e99fb7a497b1e3339bc746195567ed8d3e24945ecd636e3619d20b9de9e9149"
+dependencies = [
+ "cc",
+ "pkg-config",
+ "vcpkg",
+]
+
+[[package]]
+name = "linux-raw-sys"
+version = "0.9.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cd945864f07fe9f5371a27ad7b52a172b4b499999f1d97574c9fa68373937e12"
+
+[[package]]
+name = "litemap"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "241eaef5fd12c88705a01fc1066c48c4b36e0dd4377dcdc7ec3942cea7a69956"
+
+[[package]]
+name = "litrs"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b4ce301924b7887e9d637144fdade93f9dfff9b60981d4ac161db09720d39aa5"
+
+[[package]]
+name = "lock_api"
+version = "0.4.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "96936507f153605bddfcda068dd804796c84324ed2510809e5b2a624c81da765"
+dependencies = [
+ "autocfg",
+ "scopeguard",
+]
+
+[[package]]
+name = "log"
+version = "0.4.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"
+
+[[package]]
+name = "lru-slab"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "112b39cec0b298b6c1999fee3e31427f74f676e4cb9879ed1a121b43661a4154"
+
+[[package]]
+name = "memchr"
+version = "2.7.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"
+
+[[package]]
+name = "memmap2"
+version = "0.9.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "483758ad303d734cec05e5c12b41d7e93e6a6390c5e9dae6bdeb7c1259012d28"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "memoffset"
+version = "0.9.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "488016bfae457b036d996092f6cb448677611ce4449e970ceaf42695203f218a"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "migrations_internals"
+version = "2.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3bda1634d70d5bd53553cf15dca9842a396e8c799982a3ad22998dc44d961f24"
+dependencies = [
+ "serde",
+ "toml 0.9.2",
+]
+
+[[package]]
+name = "migrations_macros"
+version = "2.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffb161cc72176cb37aa47f1fc520d3ef02263d67d661f44f05d05a079e1237fd"
+dependencies = [
+ "migrations_internals",
+ "proc-macro2",
+ "quote",
+]
+
+[[package]]
+name = "mime"
+version = "0.3.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"
+
+[[package]]
+name = "minimal-lexical"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"
+
+[[package]]
+name = "miniz_oxide"
+version = "0.8.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
+dependencies = [
+ "adler2",
+]
+
+[[package]]
+name = "mio"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "78bed444cc8a2160f01cbcf811ef18cac863ad68ae8ca62092e8db51d51c761c"
+dependencies = [
+ "libc",
+ "log",
+ "wasi 0.11.1+wasi-snapshot-preview1",
+ "windows-sys 0.59.0",
+]
+
+[[package]]
+name = "moss"
+version = "0.25.6"
+source = "git+https://github.com/joebonrichie/os-tools?rev=f6e6070#f6e6070a9ed61e07389bf963db281b29df8df816"
+dependencies = [
+ "blsforme",
+ "bytes",
+ "camino",
+ "chrono",
+ "clap",
+ "clap_complete",
+ "clap_mangen",
+ "config",
+ "container",
+ "dag",
+ "derive_more",
+ "diesel",
+ "diesel_migrations",
+ "fnmatch",
+ "fs-err",
+ "futures-util",
+ "hex",
+ "itertools 0.14.0",
+ "libsqlite3-sys",
+ "log",
+ "nix 0.27.1",
+ "os-info",
+ "rayon",
+ "reqwest",
+ "serde",
+ "sha2",
+ "stone",
+ "strum",
+ "thiserror 2.0.12",
+ "tokio",
+ "tokio-util",
+ "tools_buildinfo",
+ "tracing",
+ "tracing-subscriber",
+ "triggers",
+ "tui",
+ "url",
+ "vfs",
+ "xxhash-rust",
+ "zbus",
+]
+
+[[package]]
+name = "nix"
+version = "0.27.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2eb04e9c688eff1c89d72b407f168cf79bb9e867a9d3323ed6c01519eb9cc053"
+dependencies = [
+ "bitflags",
+ "cfg-if",
+ "libc",
+]
+
+[[package]]
+name = "nix"
+version = "0.30.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "74523f3a35e05aba87a1d978330aef40f67b0304ac79c1c00b294c9830543db6"
+dependencies = [
+ "bitflags",
+ "cfg-if",
+ "cfg_aliases",
+ "libc",
+ "memoffset",
+]
+
+[[package]]
+name = "nom"
+version = "7.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
+dependencies = [
+ "memchr",
+ "minimal-lexical",
+]
+
+[[package]]
+name = "nu-ansi-term"
+version = "0.46.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "77a8165726e8236064dbb45459242600304b42a5ea24ee2948e18e023bf7ba84"
+dependencies = [
+ "overload",
+ "winapi",
+]
+
+[[package]]
+name = "num-conv"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"
+
+[[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "number_prefix"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "830b246a0e5f20af87141b25c173cd1b609bd7779a4617d6ec582abaf90870f3"
+
+[[package]]
+name = "object"
+version = "0.36.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
+[[package]]
+name = "once_cell_polyfill"
+version = "1.70.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a4895175b425cb1f87721b59f0f286c2092bd4af812243672510e1ac53e2e0ad"
+
+[[package]]
+name = "option-ext"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "04744f49eae99ab78e0d5c0b603ab218f515ea8cfe5a456d7629ad883a3b6e7d"
+
+[[package]]
+name = "ordered-stream"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9aa2b01e1d916879f73a53d01d1d6cee68adbb31d6d9177a8cfce093cced1d50"
+dependencies = [
+ "futures-core",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "os-info"
+version = "0.1.0"
+source = "git+https://github.com/AerynOS/os-info?rev=503a4bb97d558d8c821bcd4362d3ec06db29e0a6#503a4bb97d558d8c821bcd4362d3ec06db29e0a6"
+dependencies = [
+ "chrono",
+ "serde",
+ "serde_json",
+ "snafu",
+]
+
+[[package]]
+name = "overload"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39"
+
+[[package]]
+name = "packagekit"
+version = "0.0.0"
+dependencies = [
+ "bindgen",
+ "config",
+ "eyre",
+ "fs-err",
+ "glib-sys",
+ "itertools 0.14.0",
+ "moss",
+ "stone",
+ "url",
+ "vfs",
+]
+
+[[package]]
+name = "parking"
+version = "2.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f38d5652c16fde515bb1ecef450ab0f6a219d619a7274976324d5e377f7dceba"
+
+[[package]]
+name = "parking_lot"
+version = "0.12.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "70d58bf43669b5795d1576d0641cfb6fbb2057bf629506267a92807158584a13"
+dependencies = [
+ "lock_api",
+ "parking_lot_core",
+]
+
+[[package]]
+name = "parking_lot_core"
+version = "0.9.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bc838d2a56b5b1a6c25f55575dfc605fabb63bb2365f6c2353ef9159aa69e4a5"
+dependencies = [
+ "cfg-if",
+ "libc",
+ "redox_syscall",
+ "smallvec",
+ "windows-targets 0.52.6",
+]
+
+[[package]]
+name = "percent-encoding"
+version = "2.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"
+
+[[package]]
+name = "petgraph"
+version = "0.8.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "54acf3a685220b533e437e264e4d932cfbdc4cc7ec0cd232ed73c08d03b8a7ca"
+dependencies = [
+ "fixedbitset",
+ "hashbrown",
+ "indexmap",
+ "serde",
+]
+
+[[package]]
+name = "pin-project-lite"
+version = "0.2.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"
+
+[[package]]
+name = "pin-utils"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"
+
+[[package]]
+name = "piper"
+version = "0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "96c8c490f422ef9a4efd2cb5b42b76c8613d7e7dfc1caf667b8a3350a5acc066"
+dependencies = [
+ "atomic-waker",
+ "fastrand",
+ "futures-io",
+]
+
+[[package]]
+name = "pkg-config"
+version = "0.3.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"
+
+[[package]]
+name = "polling"
+version = "3.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8ee9b2fa7a4517d2c91ff5bc6c297a427a96749d15f98fcdbb22c05571a4d4b7"
+dependencies = [
+ "cfg-if",
+ "concurrent-queue",
+ "hermit-abi",
+ "pin-project-lite",
+ "rustix",
+ "windows-sys 0.60.2",
+]
+
+[[package]]
+name = "portable-atomic"
+version = "1.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f84267b20a16ea918e43c6a88433c2d54fa145c92a811b5b047ccbe153674483"
+
+[[package]]
+name = "potential_utf"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e5a7c30837279ca13e7c867e9e40053bc68740f988cb07f7ca6df43cc734b585"
+dependencies = [
+ "zerovec",
+]
+
+[[package]]
+name = "powerfmt"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"
+
+[[package]]
+name = "ppv-lite86"
+version = "0.2.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
+dependencies = [
+ "zerocopy",
+]
+
+[[package]]
+name = "prettyplease"
+version = "0.2.35"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "061c1221631e079b26479d25bbf2275bfe5917ae8419cd7e34f13bfc2aa7539a"
+dependencies = [
+ "proc-macro2",
+ "syn",
+]
+
+[[package]]
+name = "proc-macro-crate"
+version = "3.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "edce586971a4dfaa28950c6f18ed55e0406c1ab88bbce2c6f6293a7aaba73d35"
+dependencies = [
+ "toml_edit",
+]
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.95"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "quinn"
+version = "0.11.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "626214629cda6781b6dc1d316ba307189c85ba657213ce642d9c77670f8202c8"
+dependencies = [
+ "bytes",
+ "cfg_aliases",
+ "pin-project-lite",
+ "quinn-proto",
+ "quinn-udp",
+ "rustc-hash",
+ "rustls",
+ "socket2",
+ "thiserror 2.0.12",
+ "tokio",
+ "tracing",
+ "web-time",
+]
+
+[[package]]
+name = "quinn-proto"
+version = "0.11.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "49df843a9161c85bb8aae55f101bc0bac8bcafd637a620d9122fd7e0b2f7422e"
+dependencies = [
+ "bytes",
+ "getrandom 0.3.3",
+ "lru-slab",
+ "rand",
+ "ring",
+ "rustc-hash",
+ "rustls",
+ "rustls-pki-types",
+ "slab",
+ "thiserror 2.0.12",
+ "tinyvec",
+ "tracing",
+ "web-time",
+]
+
+[[package]]
+name = "quinn-udp"
+version = "0.5.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fcebb1209ee276352ef14ff8732e24cc2b02bbac986cd74a4c81bcb2f9881970"
+dependencies = [
+ "cfg_aliases",
+ "libc",
+ "once_cell",
+ "socket2",
+ "tracing",
+ "windows-sys 0.59.0",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.40"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
+dependencies = [
+ "proc-macro2",
+]
+
+[[package]]
+name = "r-efi"
+version = "5.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"
+
+[[package]]
+name = "rand"
+version = "0.9.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6db2770f06117d490610c7488547d543617b21bfa07796d7a12f6f1bd53850d1"
+dependencies = [
+ "rand_chacha",
+ "rand_core",
+]
+
+[[package]]
+name = "rand_chacha"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
+dependencies = [
+ "ppv-lite86",
+ "rand_core",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.9.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "99d9a13982dcf210057a8a78572b2217b667c3beacbf3a0d8b454f6f82837d38"
+dependencies = [
+ "getrandom 0.3.3",
+]
+
+[[package]]
+name = "rayon"
+version = "1.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b418a60154510ca1a002a752ca9714984e21e4241e804d32555251faf8b78ffa"
+dependencies = [
+ "either",
+ "rayon-core",
+]
+
+[[package]]
+name = "rayon-core"
+version = "1.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1465873a3dfdaa8ae7cb14b4383657caab0b3e8a0aa9ae8e04b044854c8dfce2"
+dependencies = [
+ "crossbeam-deque",
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "redox_syscall"
+version = "0.5.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7e8af0dde094006011e6a740d4879319439489813bd0bcdc7d821beaeeff48ec"
+dependencies = [
+ "bitflags",
+]
+
+[[package]]
+name = "redox_users"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dd6f9d3d47bdd2ad6945c5015a226ec6155d0bcdfd8f7cd29f86b71f8de99d2b"
+dependencies = [
+ "getrandom 0.2.16",
+ "libredox",
+ "thiserror 2.0.12",
+]
+
+[[package]]
+name = "regex"
+version = "1.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-automata",
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-automata"
+version = "0.4.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-syntax"
+version = "0.8.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"
+
+[[package]]
+name = "reqwest"
+version = "0.12.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cbc931937e6ca3a06e3b6c0aa7841849b160a90351d6ab467a8b9b9959767531"
+dependencies = [
+ "async-compression",
+ "base64",
+ "bytes",
+ "encoding_rs",
+ "futures-channel",
+ "futures-core",
+ "futures-util",
+ "h2",
+ "http",
+ "http-body",
+ "http-body-util",
+ "hyper",
+ "hyper-rustls",
+ "hyper-util",
+ "js-sys",
+ "log",
+ "mime",
+ "percent-encoding",
+ "pin-project-lite",
+ "quinn",
+ "rustls",
+ "rustls-pki-types",
+ "serde",
+ "serde_json",
+ "serde_urlencoded",
+ "sync_wrapper",
+ "tokio",
+ "tokio-rustls",
+ "tokio-util",
+ "tower",
+ "tower-http",
+ "tower-service",
+ "url",
+ "wasm-bindgen",
+ "wasm-bindgen-futures",
+ "wasm-streams",
+ "web-sys",
+ "webpki-roots",
+]
+
+[[package]]
+name = "ring"
+version = "0.17.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a4689e6c2294d81e88dc6261c768b63bc4fcdb852be6d1352498b114f61383b7"
+dependencies = [
+ "cc",
+ "cfg-if",
+ "getrandom 0.2.16",
+ "libc",
+ "untrusted",
+ "windows-sys 0.52.0",
+]
+
+[[package]]
+name = "roff"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "88f8660c1ff60292143c98d08fc6e2f654d722db50410e3f3797d40baaf9d8f3"
+
+[[package]]
+name = "rustc-demangle"
+version = "0.1.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "989e6739f80c4ad5b13e0fd7fe89531180375b18520cc8c82080e4dc4035b84f"
+
+[[package]]
+name = "rustc-hash"
+version = "2.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "357703d41365b4b27c590e3ed91eabb1b663f07c4c084095e60cbed4362dff0d"
+
+[[package]]
+name = "rustix"
+version = "1.0.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "11181fbabf243db407ef8df94a6ce0b2f9a733bd8be4ad02b4eda9602296cac8"
+dependencies = [
+ "bitflags",
+ "errno",
+ "libc",
+ "linux-raw-sys",
+ "windows-sys 0.60.2",
+]
+
+[[package]]
+name = "rustls"
+version = "0.23.29"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2491382039b29b9b11ff08b76ff6c97cf287671dbb74f0be44bda389fffe9bd1"
+dependencies = [
+ "once_cell",
+ "ring",
+ "rustls-pki-types",
+ "rustls-webpki",
+ "subtle",
+ "zeroize",
+]
+
+[[package]]
+name = "rustls-pki-types"
+version = "1.12.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "229a4a4c221013e7e1f1a043678c5cc39fe5171437c88fb47151a21e6f5b5c79"
+dependencies = [
+ "web-time",
+ "zeroize",
+]
+
+[[package]]
+name = "rustls-webpki"
+version = "0.103.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0a17884ae0c1b773f1ccd2bd4a8c72f16da897310a98b0e84bf349ad5ead92fc"
+dependencies = [
+ "ring",
+ "rustls-pki-types",
+ "untrusted",
+]
+
+[[package]]
+name = "rustversion"
+version = "1.0.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8a0d197bd2c9dc6e53b84da9556a69ba4cdfab8619eb41a8bd1cc2027a0f6b1d"
+
+[[package]]
+name = "ryu"
+version = "1.0.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"
+
+[[package]]
+name = "scopeguard"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"
+
+[[package]]
+name = "serde"
+version = "1.0.219"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
+dependencies = [
+ "serde_derive",
+]
+
+[[package]]
+name = "serde_derive"
+version = "1.0.219"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "serde_json"
+version = "1.0.141"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "30b9eff21ebe718216c6ec64e1d9ac57087aad11efc64e32002bce4a0d4c03d3"
+dependencies = [
+ "itoa",
+ "memchr",
+ "ryu",
+ "serde",
+]
+
+[[package]]
+name = "serde_repr"
+version = "0.1.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "175ee3e80ae9982737ca543e96133087cbd9a485eecc3bc4de9c1a37b47ea59c"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "serde_spanned"
+version = "0.6.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bf41e0cfaf7226dca15e8197172c295a782857fcb97fad1808a166870dee75a3"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "serde_spanned"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "40734c41988f7306bb04f0ecf60ec0f3f1caa34290e4e8ea471dcd3346483b83"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "serde_urlencoded"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
+dependencies = [
+ "form_urlencoded",
+ "itoa",
+ "ryu",
+ "serde",
+]
+
+[[package]]
+name = "serde_yaml"
+version = "0.9.34+deprecated"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6a8b1a1a2ebf674015cc02edccce75287f1a0130d394307b36743c2f5d504b47"
+dependencies = [
+ "indexmap",
+ "itoa",
+ "ryu",
+ "serde",
+ "unsafe-libyaml",
+]
+
+[[package]]
+name = "sha2"
+version = "0.10.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
+dependencies = [
+ "cfg-if",
+ "cpufeatures",
+ "digest",
+]
+
+[[package]]
+name = "sharded-slab"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
+dependencies = [
+ "lazy_static",
+]
+
+[[package]]
+name = "shell-words"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "24188a676b6ae68c3b2cb3a01be17fbf7240ce009799bb56d5b1409051e78fde"
+
+[[package]]
+name = "shlex"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"
+
+[[package]]
+name = "signal-hook"
+version = "0.3.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d881a16cf4426aa584979d30bd82cb33429027e42122b169753d6ef1085ed6e2"
+dependencies = [
+ "libc",
+ "signal-hook-registry",
+]
+
+[[package]]
+name = "signal-hook-mio"
+version = "0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "34db1a06d485c9142248b7a054f034b349b212551f3dfd19c94d45a754a217cd"
+dependencies = [
+ "libc",
+ "mio",
+ "signal-hook",
+]
+
+[[package]]
+name = "signal-hook-registry"
+version = "1.4.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9203b8055f63a2a00e2f593bb0510367fe707d7ff1e5c872de2f537b339e5410"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "simple-bytes"
+version = "0.2.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c11532d9d241904f095185f35dcdaf930b1427a94d5b01d7002d74ba19b44cc4"
+
+[[package]]
+name = "slab"
+version = "0.4.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "04dc19736151f35336d325007ac991178d504a119863a2fcb3758cdb5e52c50d"
+
+[[package]]
+name = "smallvec"
+version = "1.15.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"
+
+[[package]]
+name = "snafu"
+version = "0.8.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "320b01e011bf8d5d7a4a4a4be966d9160968935849c83b918827f6a435e7f627"
+dependencies = [
+ "snafu-derive",
+]
+
+[[package]]
+name = "snafu-derive"
+version = "0.8.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1961e2ef424c1424204d3a5d6975f934f56b6d50ff5732382d84ebf460e147f7"
+dependencies = [
+ "heck",
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "socket2"
+version = "0.5.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
+dependencies = [
+ "libc",
+ "windows-sys 0.52.0",
+]
+
+[[package]]
+name = "stable_deref_trait"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"
+
+[[package]]
+name = "static_assertions"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"
+
+[[package]]
+name = "stone"
+version = "0.25.6"
+source = "git+https://github.com/joebonrichie/os-tools?rev=f6e6070#f6e6070a9ed61e07389bf963db281b29df8df816"
+dependencies = [
+ "strum",
+ "thiserror 2.0.12",
+ "xxhash-rust",
+ "zstd",
+]
+
+[[package]]
+name = "strsim"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"
+
+[[package]]
+name = "strum"
+version = "0.27.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "af23d6f6c1a224baef9d3f61e287d2761385a5b88fdab4eb4c6f11aeb54c4bcf"
+dependencies = [
+ "strum_macros",
+]
+
+[[package]]
+name = "strum_macros"
+version = "0.27.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7695ce3845ea4b33927c055a39dc438a45b059f7c1b3d91d38d10355fb8cbca7"
+dependencies = [
+ "heck",
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "subtle"
+version = "2.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"
+
+[[package]]
+name = "superblock"
+version = "0.1.0"
+source = "git+https://github.com/AerynOS/disks-rs?rev=0768fe553b123b2086980bc809011e9786bffd95#0768fe553b123b2086980bc809011e9786bffd95"
+dependencies = [
+ "serde",
+ "serde_json",
+ "snafu",
+ "uuid",
+ "zerocopy",
+]
+
+[[package]]
+name = "syn"
+version = "2.0.104"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "17b6f705963418cdb9927482fa304bc562ece2fdd4f616084c50b7023b435a40"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
+]
+
+[[package]]
+name = "sync_wrapper"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bf256ce5efdfa370213c1dabab5935a12e49f2c58d15e9eac2870d3b4f27263"
+dependencies = [
+ "futures-core",
+]
+
+[[package]]
+name = "synstructure"
+version = "0.13.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "system-deps"
+version = "6.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a3e535eb8dded36d55ec13eddacd30dec501792ff23a0b1682c38601b8cf2349"
+dependencies = [
+ "cfg-expr",
+ "heck",
+ "pkg-config",
+ "toml 0.8.23",
+ "version-compare",
+]
+
+[[package]]
+name = "target-lexicon"
+version = "0.12.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "61c41af27dd6d1e27b1b16b489db798443478cef1f06a660c96db617ba5de3b1"
+
+[[package]]
+name = "tempfile"
+version = "3.20.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e8a64e3985349f2441a1a9ef0b853f869006c3855f2cda6862a94d26ebb9d6a1"
+dependencies = [
+ "fastrand",
+ "getrandom 0.3.3",
+ "once_cell",
+ "rustix",
+ "windows-sys 0.59.0",
+]
+
+[[package]]
+name = "thiserror"
+version = "1.0.69"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
+dependencies = [
+ "thiserror-impl 1.0.69",
+]
+
+[[package]]
+name = "thiserror"
+version = "2.0.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "567b8a2dae586314f7be2a752ec7474332959c6460e02bde30d702a66d488708"
+dependencies = [
+ "thiserror-impl 2.0.12",
+]
+
+[[package]]
+name = "thiserror-impl"
+version = "1.0.69"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "thiserror-impl"
+version = "2.0.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7f7cf42b4507d8ea322120659672cf1b9dbb93f8f2d4ecfd6e51350ff5b17a1d"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "thread_local"
+version = "1.1.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
+dependencies = [
+ "cfg-if",
+]
+
+[[package]]
+name = "time"
+version = "0.3.41"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8a7619e19bc266e0f9c5e6686659d394bc57973859340060a69221e57dbc0c40"
+dependencies = [
+ "deranged",
+ "itoa",
+ "num-conv",
+ "powerfmt",
+ "serde",
+ "time-core",
+ "time-macros",
+]
+
+[[package]]
+name = "time-core"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c9e9a38711f559d9e3ce1cdb06dd7c5b8ea546bc90052da6d06bb76da74bb07c"
+
+[[package]]
+name = "time-macros"
+version = "0.2.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3526739392ec93fd8b359c8e98514cb3e8e021beb4e5f597b00a0221f8ed8a49"
+dependencies = [
+ "num-conv",
+ "time-core",
+]
+
+[[package]]
+name = "tinystr"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5d4f6d1145dcb577acf783d4e601bc1d76a13337bb54e6233add580b07344c8b"
+dependencies = [
+ "displaydoc",
+ "zerovec",
+]
+
+[[package]]
+name = "tinyvec"
+version = "1.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09b3661f17e86524eccd4371ab0429194e0d7c008abb45f7a7495b1719463c71"
+dependencies = [
+ "tinyvec_macros",
+]
+
+[[package]]
+name = "tinyvec_macros"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
+
+[[package]]
+name = "tokio"
+version = "1.46.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0cc3a2344dafbe23a245241fe8b09735b521110d30fcefbbd5feb1797ca35d17"
+dependencies = [
+ "backtrace",
+ "bytes",
+ "io-uring",
+ "libc",
+ "mio",
+ "parking_lot",
+ "pin-project-lite",
+ "signal-hook-registry",
+ "slab",
+ "socket2",
+ "tokio-macros",
+ "windows-sys 0.52.0",
+]
+
+[[package]]
+name = "tokio-macros"
+version = "2.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "tokio-rustls"
+version = "0.26.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8e727b36a1a0e8b74c376ac2211e40c2c8af09fb4013c60d910495810f008e9b"
+dependencies = [
+ "rustls",
+ "tokio",
+]
+
+[[package]]
+name = "tokio-util"
+version = "0.7.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "66a539a9ad6d5d281510d5bd368c973d636c02dbf8a67300bfb6b950696ad7df"
+dependencies = [
+ "bytes",
+ "futures-core",
+ "futures-sink",
+ "pin-project-lite",
+ "tokio",
+]
+
+[[package]]
+name = "toml"
+version = "0.8.23"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dc1beb996b9d83529a9e75c17a1686767d148d70663143c7854d8b4a09ced362"
+dependencies = [
+ "serde",
+ "serde_spanned 0.6.9",
+ "toml_datetime 0.6.11",
+ "toml_edit",
+]
+
+[[package]]
+name = "toml"
+version = "0.9.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ed0aee96c12fa71097902e0bb061a5e1ebd766a6636bb605ba401c45c1650eac"
+dependencies = [
+ "indexmap",
+ "serde",
+ "serde_spanned 1.0.0",
+ "toml_datetime 0.7.0",
+ "toml_parser",
+ "toml_writer",
+ "winnow",
+]
+
+[[package]]
+name = "toml_datetime"
+version = "0.6.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "toml_datetime"
+version = "0.7.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bade1c3e902f58d73d3f294cd7f20391c1cb2fbcb643b73566bc773971df91e3"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "toml_edit"
+version = "0.22.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "41fe8c660ae4257887cf66394862d21dbca4a6ddd26f04a3560410406a2f819a"
+dependencies = [
+ "indexmap",
+ "serde",
+ "serde_spanned 0.6.9",
+ "toml_datetime 0.6.11",
+ "winnow",
+]
+
+[[package]]
+name = "toml_parser"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "97200572db069e74c512a14117b296ba0a80a30123fbbb5aa1f4a348f639ca30"
+dependencies = [
+ "winnow",
+]
+
+[[package]]
+name = "toml_writer"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fcc842091f2def52017664b53082ecbbeb5c7731092bad69d2c63050401dfd64"
+
+[[package]]
+name = "tools_buildinfo"
+version = "0.25.6"
+source = "git+https://github.com/joebonrichie/os-tools?rev=f6e6070#f6e6070a9ed61e07389bf963db281b29df8df816"
+dependencies = [
+ "chrono",
+ "thiserror 2.0.12",
+]
+
+[[package]]
+name = "topology"
+version = "0.1.0"
+source = "git+https://github.com/AerynOS/blsforme.git?rev=a09fa783aab22c8a057fc38f827d2fd2d3d157d9#a09fa783aab22c8a057fc38f827d2fd2d3d157d9"
+dependencies = [
+ "fs-err",
+ "gpt",
+ "log",
+ "nix 0.30.1",
+ "snafu",
+ "superblock",
+]
+
+[[package]]
+name = "tower"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d039ad9159c98b70ecfd540b2573b97f7f52c3e8d9f8ad57a24b916a536975f9"
+dependencies = [
+ "futures-core",
+ "futures-util",
+ "pin-project-lite",
+ "sync_wrapper",
+ "tokio",
+ "tower-layer",
+ "tower-service",
+]
+
+[[package]]
+name = "tower-http"
+version = "0.6.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "adc82fd73de2a9722ac5da747f12383d2bfdb93591ee6c58486e0097890f05f2"
+dependencies = [
+ "bitflags",
+ "bytes",
+ "futures-util",
+ "http",
+ "http-body",
+ "iri-string",
+ "pin-project-lite",
+ "tower",
+ "tower-layer",
+ "tower-service",
+]
+
+[[package]]
+name = "tower-layer"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "121c2a6cda46980bb0fcd1647ffaf6cd3fc79a013de288782836f6df9c48780e"
+
+[[package]]
+name = "tower-service"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8df9b6e13f2d32c91b9bd719c00d1958837bc7dec474d94952798cc8e69eeec3"
+
+[[package]]
+name = "tracing"
+version = "0.1.41"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
+dependencies = [
+ "pin-project-lite",
+ "tracing-attributes",
+ "tracing-core",
+]
+
+[[package]]
+name = "tracing-attributes"
+version = "0.1.30"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "81383ab64e72a7a8b8e13130c49e3dab29def6d0c7d76a03087b3cf71c5c6903"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "tracing-core"
+version = "0.1.34"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
+dependencies = [
+ "once_cell",
+]
+
+[[package]]
+name = "tracing-subscriber"
+version = "0.3.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e8189decb5ac0fa7bc8b96b7cb9b2701d60d48805aca84a238004d665fcc4008"
+dependencies = [
+ "nu-ansi-term",
+ "sharded-slab",
+ "thread_local",
+ "tracing-core",
+]
+
+[[package]]
+name = "triggers"
+version = "0.25.6"
+source = "git+https://github.com/joebonrichie/os-tools?rev=f6e6070#f6e6070a9ed61e07389bf963db281b29df8df816"
+dependencies = [
+ "dag",
+ "fnmatch",
+ "serde",
+ "thiserror 2.0.12",
+]
+
+[[package]]
+name = "try-lock"
+version = "0.2.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"
+
+[[package]]
+name = "tui"
+version = "0.25.6"
+source = "git+https://github.com/joebonrichie/os-tools?rev=f6e6070#f6e6070a9ed61e07389bf963db281b29df8df816"
+dependencies = [
+ "crossterm",
+ "dialoguer",
+ "indicatif",
+]
+
+[[package]]
+name = "typenum"
+version = "1.18.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f"
+
+[[package]]
+name = "uds_windows"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "89daebc3e6fd160ac4aa9fc8b3bf71e1f74fbf92367ae71fb83a037e8bf164b9"
+dependencies = [
+ "memoffset",
+ "tempfile",
+ "winapi",
+]
+
+[[package]]
+name = "unicode-ident"
+version = "1.0.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"
+
+[[package]]
+name = "unicode-segmentation"
+version = "1.12.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"
+
+[[package]]
+name = "unicode-width"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4a1a07cc7db3810833284e8d372ccdc6da29741639ecc70c9ec107df0fa6154c"
+
+[[package]]
+name = "unicode-xid"
+version = "0.2.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ebc1c04c71510c7f702b52b7c350734c9ff1295c464a03335b00bb84fc54f853"
+
+[[package]]
+name = "unsafe-libyaml"
+version = "0.2.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "673aac59facbab8a9007c7f6108d11f63b603f7cabff99fabf650fea5c32b861"
+
+[[package]]
+name = "untrusted"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8ecb6da28b8a351d773b68d5825ac39017e680750f980f3a1a85cd8dd28a47c1"
+
+[[package]]
+name = "url"
+version = "2.5.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "32f8b686cadd1473f4bd0117a5d28d36b1ade384ea9b5069a1c40aefed7fda60"
+dependencies = [
+ "form_urlencoded",
+ "idna",
+ "percent-encoding",
+ "serde",
+]
+
+[[package]]
+name = "utf8_iter"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"
+
+[[package]]
+name = "utf8parse"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"
+
+[[package]]
+name = "uuid"
+version = "1.17.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3cf4199d1e5d15ddd86a694e4d0dffa9c323ce759fea589f00fef9d81cc1931d"
+dependencies = [
+ "getrandom 0.3.3",
+ "js-sys",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "vcpkg"
+version = "0.2.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"
+
+[[package]]
+name = "version-compare"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "852e951cb7832cb45cb1169900d19760cfa39b82bc0ea9c0e5a14ae88411c98b"
+
+[[package]]
+name = "version_check"
+version = "0.9.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"
+
+[[package]]
+name = "vfs"
+version = "0.1.0"
+source = "git+https://github.com/joebonrichie/os-tools?rev=f6e6070#f6e6070a9ed61e07389bf963db281b29df8df816"
+dependencies = [
+ "indextree",
+ "thiserror 2.0.12",
+]
+
+[[package]]
+name = "want"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
+dependencies = [
+ "try-lock",
+]
+
+[[package]]
+name = "wasi"
+version = "0.11.1+wasi-snapshot-preview1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"
+
+[[package]]
+name = "wasi"
+version = "0.14.2+wasi-0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9683f9a5a998d873c0d21fcbe3c083009670149a8fab228644b8bd36b2c48cb3"
+dependencies = [
+ "wit-bindgen-rt",
+]
+
+[[package]]
+name = "wasm-bindgen"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-futures"
+version = "0.4.50"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "555d470ec0bc3bb57890405e5d4322cc9ea83cebb085523ced7be4144dac1e61"
+dependencies = [
+ "cfg-if",
+ "js-sys",
+ "once_cell",
+ "wasm-bindgen",
+ "web-sys",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "wasm-streams"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "15053d8d85c7eccdbefef60f06769760a563c7f0a9d6902a13d35c7800b0ad65"
+dependencies = [
+ "futures-util",
+ "js-sys",
+ "wasm-bindgen",
+ "wasm-bindgen-futures",
+ "web-sys",
+]
+
+[[package]]
+name = "web-sys"
+version = "0.3.77"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33b6dd2ef9186f1f2072e409e99cd22a975331a6b3591b12c764e0e55c60d5d2"
+dependencies = [
+ "js-sys",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "web-time"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a6580f308b1fad9207618087a65c04e7a10bc77e02c8e84e9b00dd4b12fa0bb"
+dependencies = [
+ "js-sys",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "webpki-roots"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7e8983c3ab33d6fb807cfcdad2491c4ea8cbc8ed839181c7dfd9c67c83e261b2"
+dependencies = [
+ "rustls-pki-types",
+]
+
+[[package]]
+name = "winapi"
+version = "0.3.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
+dependencies = [
+ "winapi-i686-pc-windows-gnu",
+ "winapi-x86_64-pc-windows-gnu",
+]
+
+[[package]]
+name = "winapi-i686-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
+
+[[package]]
+name = "winapi-x86_64-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
+
+[[package]]
+name = "windows-core"
+version = "0.61.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c0fdd3ddb90610c7638aa2b3a3ab2904fb9e5cdbecc643ddb3647212781c4ae3"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"
+
+[[package]]
+name = "windows-result"
+version = "0.3.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-sys"
+version = "0.52.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
+dependencies = [
+ "windows-targets 0.52.6",
+]
+
+[[package]]
+name = "windows-sys"
+version = "0.59.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
+dependencies = [
+ "windows-targets 0.52.6",
+]
+
+[[package]]
+name = "windows-sys"
+version = "0.60.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
+dependencies = [
+ "windows-targets 0.53.2",
+]
+
+[[package]]
+name = "windows-targets"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
+dependencies = [
+ "windows_aarch64_gnullvm 0.52.6",
+ "windows_aarch64_msvc 0.52.6",
+ "windows_i686_gnu 0.52.6",
+ "windows_i686_gnullvm 0.52.6",
+ "windows_i686_msvc 0.52.6",
+ "windows_x86_64_gnu 0.52.6",
+ "windows_x86_64_gnullvm 0.52.6",
+ "windows_x86_64_msvc 0.52.6",
+]
+
+[[package]]
+name = "windows-targets"
+version = "0.53.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c66f69fcc9ce11da9966ddb31a40968cad001c5bedeb5c2b82ede4253ab48aef"
+dependencies = [
+ "windows_aarch64_gnullvm 0.53.0",
+ "windows_aarch64_msvc 0.53.0",
+ "windows_i686_gnu 0.53.0",
+ "windows_i686_gnullvm 0.53.0",
+ "windows_i686_msvc 0.53.0",
+ "windows_x86_64_gnu 0.53.0",
+ "windows_x86_64_gnullvm 0.53.0",
+ "windows_x86_64_msvc 0.53.0",
+]
+
+[[package]]
+name = "windows_aarch64_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"
+
+[[package]]
+name = "windows_aarch64_gnullvm"
+version = "0.53.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "86b8d5f90ddd19cb4a147a5fa63ca848db3df085e25fee3cc10b39b6eebae764"
+
+[[package]]
+name = "windows_aarch64_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"
+
+[[package]]
+name = "windows_aarch64_msvc"
+version = "0.53.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c7651a1f62a11b8cbd5e0d42526e55f2c99886c77e007179efff86c2b137e66c"
+
+[[package]]
+name = "windows_i686_gnu"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"
+
+[[package]]
+name = "windows_i686_gnu"
+version = "0.53.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c1dc67659d35f387f5f6c479dc4e28f1d4bb90ddd1a5d3da2e5d97b42d6272c3"
+
+[[package]]
+name = "windows_i686_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"
+
+[[package]]
+name = "windows_i686_gnullvm"
+version = "0.53.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ce6ccbdedbf6d6354471319e781c0dfef054c81fbc7cf83f338a4296c0cae11"
+
+[[package]]
+name = "windows_i686_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"
+
+[[package]]
+name = "windows_i686_msvc"
+version = "0.53.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "581fee95406bb13382d2f65cd4a908ca7b1e4c2f1917f143ba16efe98a589b5d"
+
+[[package]]
+name = "windows_x86_64_gnu"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"
+
+[[package]]
+name = "windows_x86_64_gnu"
+version = "0.53.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2e55b5ac9ea33f2fc1716d1742db15574fd6fc8dadc51caab1c16a3d3b4190ba"
+
+[[package]]
+name = "windows_x86_64_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"
+
+[[package]]
+name = "windows_x86_64_gnullvm"
+version = "0.53.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0a6e035dd0599267ce1ee132e51c27dd29437f63325753051e71dd9e42406c57"
+
+[[package]]
+name = "windows_x86_64_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"
+
+[[package]]
+name = "windows_x86_64_msvc"
+version = "0.53.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "271414315aff87387382ec3d271b52d7ae78726f5d44ac98b4f4030c91880486"
+
+[[package]]
+name = "winnow"
+version = "0.7.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f3edebf492c8125044983378ecb5766203ad3b4c2f7a922bd7dd207f6d443e95"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "wit-bindgen-rt"
+version = "0.39.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6f42320e61fe2cfd34354ecb597f86f413484a798ba44a8ca1165c58d42da6c1"
+dependencies = [
+ "bitflags",
+]
+
+[[package]]
+name = "writeable"
+version = "0.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ea2f10b9bb0928dfb1b42b65e1f9e36f7f54dbdf08457afefb38afcdec4fa2bb"
+
+[[package]]
+name = "xxhash-rust"
+version = "0.8.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fdd20c5420375476fbd4394763288da7eb0cc0b8c11deed431a91562af7335d3"
+
+[[package]]
+name = "yoke"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f41bb01b8226ef4bfd589436a297c53d118f65921786300e427be8d487695cc"
+dependencies = [
+ "serde",
+ "stable_deref_trait",
+ "yoke-derive",
+ "zerofrom",
+]
+
+[[package]]
+name = "yoke-derive"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "38da3c9736e16c5d3c8c597a9aaa5d1fa565d0532ae05e27c24aa62fb32c0ab6"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "synstructure",
+]
+
+[[package]]
+name = "zbus"
+version = "5.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4bb4f9a464286d42851d18a605f7193b8febaf5b0919d71c6399b7b26e5b0aad"
+dependencies = [
+ "async-broadcast",
+ "async-executor",
+ "async-io",
+ "async-lock",
+ "async-process",
+ "async-recursion",
+ "async-task",
+ "async-trait",
+ "blocking",
+ "enumflags2",
+ "event-listener",
+ "futures-core",
+ "futures-lite",
+ "hex",
+ "nix 0.30.1",
+ "ordered-stream",
+ "serde",
+ "serde_repr",
+ "tracing",
+ "uds_windows",
+ "windows-sys 0.59.0",
+ "winnow",
+ "zbus_macros",
+ "zbus_names",
+ "zvariant",
+]
+
+[[package]]
+name = "zbus_macros"
+version = "5.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ef9859f68ee0c4ee2e8cde84737c78e3f4c54f946f2a38645d0d4c7a95327659"
+dependencies = [
+ "proc-macro-crate",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "zbus_names",
+ "zvariant",
+ "zvariant_utils",
+]
+
+[[package]]
+name = "zbus_names"
+version = "4.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7be68e64bf6ce8db94f63e72f0c7eb9a60d733f7e0499e628dfab0f84d6bcb97"
+dependencies = [
+ "serde",
+ "static_assertions",
+ "winnow",
+ "zvariant",
+]
+
+[[package]]
+name = "zerocopy"
+version = "0.8.26"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1039dd0d3c310cf05de012d8a39ff557cb0d23087fd44cad61df08fc31907a2f"
+dependencies = [
+ "zerocopy-derive",
+]
+
+[[package]]
+name = "zerocopy-derive"
+version = "0.8.26"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ecf5b4cc5364572d7f4c329661bcc82724222973f2cab6f050a4e5c22f75181"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "zerofrom"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
+dependencies = [
+ "zerofrom-derive",
+]
+
+[[package]]
+name = "zerofrom-derive"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "synstructure",
+]
+
+[[package]]
+name = "zeroize"
+version = "1.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"
+
+[[package]]
+name = "zerotrie"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "36f0bbd478583f79edad978b407914f61b2972f5af6fa089686016be8f9af595"
+dependencies = [
+ "displaydoc",
+ "yoke",
+ "zerofrom",
+]
+
+[[package]]
+name = "zerovec"
+version = "0.11.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4a05eb080e015ba39cc9e23bbe5e7fb04d5fb040350f99f34e338d5fdd294428"
+dependencies = [
+ "yoke",
+ "zerofrom",
+ "zerovec-derive",
+]
+
+[[package]]
+name = "zerovec-derive"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5b96237efa0c878c64bd89c436f661be4e46b2f3eff1ebb976f7ef2321d2f58f"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "zstd"
+version = "0.13.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e91ee311a569c327171651566e07972200e76fcfe2242a4fa446149a3881c08a"
+dependencies = [
+ "zstd-safe",
+]
+
+[[package]]
+name = "zstd-safe"
+version = "7.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8f49c4d5f0abb602a93fb8736af2a4f4dd9512e36f7f570d66e65ff867ed3b9d"
+dependencies = [
+ "zstd-sys",
+]
+
+[[package]]
+name = "zstd-sys"
+version = "2.0.15+zstd.1.5.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "eb81183ddd97d0c74cedf1d50d85c8d08c1b8b68ee863bdee9e706eedba1a237"
+dependencies = [
+ "cc",
+ "pkg-config",
+]
+
+[[package]]
+name = "zvariant"
+version = "5.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d91b3680bb339216abd84714172b5138a4edac677e641ef17e1d8cb1b3ca6e6f"
+dependencies = [
+ "endi",
+ "enumflags2",
+ "serde",
+ "winnow",
+ "zvariant_derive",
+ "zvariant_utils",
+]
+
+[[package]]
+name = "zvariant_derive"
+version = "5.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3a8c68501be459a8dbfffbe5d792acdd23b4959940fc87785fb013b32edbc208"
+dependencies = [
+ "proc-macro-crate",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "zvariant_utils",
+]
+
+[[package]]
+name = "zvariant_utils"
+version = "3.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e16edfee43e5d7b553b77872d99bc36afdda75c223ca7ad5e3fbecd82ca5fc34"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "serde",
+ "static_assertions",
+ "syn",
+ "winnow",
+]
diff --git a/Cargo.toml b/Cargo.toml
new file mode 100644
index 000000000..69aae4e2d
--- /dev/null
+++ b/Cargo.toml
@@ -0,0 +1,21 @@
+[package]
+name = "packagekit"
+edition = "2024"
+
+[lib]
+crate-type = ["cdylib"]
+
+[build-dependencies]
+bindgen = "0.71.0"
+
+[dependencies]
+config = { git = "https://github.com/joebonrichie/os-tools", rev="f6e6070", package="config" }
+moss = { git = "https://github.com/joebonrichie/os-tools", rev="f6e6070", package="moss" }
+stone = { git = "https://github.com/joebonrichie/os-tools", rev="f6e6070", package="stone" }
+vfs = { git = "https://github.com/joebonrichie/os-tools", rev="f6e6070", package="vfs" }
+glib-sys = "0.18"
+fs-err = "3.1.1"
+itertools = "0.14.0"
+url = "2.5.4"
+#ffi-convert = "0.6.2"
+eyre = "0.6.12"
diff --git a/build.rs b/build.rs
new file mode 100644
index 000000000..8cd40397a
--- /dev/null
+++ b/build.rs
@@ -0,0 +1,35 @@
+use std::env;
+use std::path::PathBuf;
+
+fn main() {
+    // Tell cargo to look for shared libraries in the specified directory
+    println!("cargo:rustc-link-search=/usr/lib/");
+
+    // Tell cargo to tell rustc to link the system bzip2
+    // shared library.
+    println!("cargo:rustc-link-lib=packagekit-glib2");
+
+    // The bindgen::Builder is the main entry point
+    // to bindgen, and lets you build up options for
+    // the resulting bindings.
+    let bindings = bindgen::Builder::default()
+        // The input header we would like to generate
+        // bindings for.
+        .header("wrapper.h")
+        .clang_args(&["-I./lib/", "-I./lib/packagekit-glib2", "-I./src/", "-I/usr/include/glib-2.0", "-D__PACKAGEKIT_H_INSIDE__", "-DPK_COMPILATION"])
+        // Tell cargo to invalidate the built crate whenever any of the
+        // included header files changed.
+        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
+        // It's parsing %G_OPTION_ARG_NONE: %gboolean as a macro
+        .generate_comments(false)
+        // Finish the builder and generate the bindings.
+        .generate()
+        // Unwrap the Result and panic on failure.
+        .expect("Unable to generate bindings");
+
+    // Write the bindings to the $OUT_DIR/bindings.rs file.
+    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
+    bindings
+        .write_to_file(out_path.join("bindings.rs"))
+        .expect("Couldn't write bindings!");
+}
diff --git a/src/lib.rs b/src/lib.rs
new file mode 100644
index 000000000..f0081eb2f
--- /dev/null
+++ b/src/lib.rs
@@ -0,0 +1,2531 @@
+#![allow(non_upper_case_globals)]
+#![allow(non_camel_case_types)]
+#![allow(non_snake_case)]
+
+use std::collections::{BTreeSet, HashSet};
+use std::ffi::{CStr, CString, c_void};
+use std::os::raw::c_char;
+use std::path::Path;
+use std::ptr;
+use std::sync::{
+    Arc,
+    atomic::{AtomicPtr, Ordering},
+};
+use std::time::Duration;
+use std::{fmt, u64};
+
+use eyre::Result;
+//use ffi_convert::RawPointerConverter;
+//use ffi_convert::{CReprOf, CStringArray};
+use fs_err::File;
+use itertools::Itertools;
+use moss::client::DownloadCallback;
+use url::Url;
+
+use glib_sys::GVariant;
+use glib_sys::g_variant_get;
+use glib_sys::{G_LOG_LEVEL_DEBUG, g_log};
+
+mod packagekit;
+use packagekit::{
+    _GVariant, GError, GKeyFile, PK_PACKAGE_ID_ARCH, PK_PACKAGE_ID_DATA, PK_PACKAGE_ID_NAME,
+    PK_PACKAGE_ID_VERSION, PkBackend, PkBackendJob, PkBitfield,
+    PkErrorEnum_PK_ERROR_ENUM_FAILED_FINALISE, PkErrorEnum_PK_ERROR_ENUM_FAILED_INITIALIZATION,
+    PkErrorEnum_PK_ERROR_ENUM_INTERNAL_ERROR, PkErrorEnum_PK_ERROR_ENUM_NOT_SUPPORTED,
+    PkErrorEnum_PK_ERROR_ENUM_PACKAGE_ALREADY_INSTALLED,
+    PkErrorEnum_PK_ERROR_ENUM_PACKAGE_DOWNLOAD_FAILED,
+    PkErrorEnum_PK_ERROR_ENUM_PACKAGE_ID_INVALID, PkErrorEnum_PK_ERROR_ENUM_PACKAGE_NOT_FOUND,
+    PkErrorEnum_PK_ERROR_ENUM_REPO_CONFIGURATION_ERROR, PkErrorEnum_PK_ERROR_ENUM_REPO_NOT_FOUND,
+    PkFilterEnum_PK_FILTER_ENUM_INSTALLED, PkFilterEnum_PK_FILTER_ENUM_NEWEST,
+    PkFilterEnum_PK_FILTER_ENUM_NOT_INSTALLED, PkFilterEnum_PK_FILTER_ENUM_NOT_NEWEST,
+    PkGroupEnum_PK_GROUP_ENUM_UNKNOWN, PkInfoEnum_PK_INFO_ENUM_AVAILABLE,
+    PkInfoEnum_PK_INFO_ENUM_DOWNLOADING, PkInfoEnum_PK_INFO_ENUM_INSTALL,
+    PkInfoEnum_PK_INFO_ENUM_INSTALLED, PkInfoEnum_PK_INFO_ENUM_NORMAL,
+    PkInfoEnum_PK_INFO_ENUM_REMOVE, PkInfoEnum_PK_INFO_ENUM_UPDATING,
+    PkRestartEnum_PK_RESTART_ENUM_NONE, PkStatusEnum_PK_STATUS_ENUM_DEP_RESOLVE,
+    PkStatusEnum_PK_STATUS_ENUM_DOWNLOAD, PkStatusEnum_PK_STATUS_ENUM_INSTALL,
+    PkStatusEnum_PK_STATUS_ENUM_REFRESH_CACHE, PkStatusEnum_PK_STATUS_ENUM_REMOVE,
+    PkStatusEnum_PK_STATUS_ENUM_UPDATE,
+    PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD,
+    PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_SIMULATE,
+    PkUpdateStateEnum_PK_UPDATE_STATE_ENUM_UNKNOWN, g_ptr_array_add, g_ptr_array_new_full,
+    pk_backend_job_details, pk_backend_job_details_full, pk_backend_job_error_code,
+    pk_backend_job_files, pk_backend_job_finished, pk_backend_job_package, pk_backend_job_packages,
+    pk_backend_job_repo_detail, pk_backend_job_set_item_progress, pk_backend_job_set_percentage,
+    pk_backend_job_set_status, pk_backend_job_thread_create, pk_backend_job_update_detail,
+    pk_debug_add_log_domain, pk_package_id_build, pk_package_id_check, pk_package_id_split,
+    pk_package_new, pk_package_set_id, pk_package_set_info, pk_package_set_summary,
+};
+
+use moss::{
+    Installation, Package, Provider, Repository,
+    client::{self, Client, ProgressStage, cache::UnpackedAsset},
+    environment,
+    package::Flags,
+    package::{self, Id},
+    registry::transaction,
+    repository::{self, Priority},
+    runtime,
+    state::Selection,
+};
+use stone::payload::layout;
+use stone::payload::meta;
+use stone::read::PayloadKind;
+use vfs::tree::BlitFile;
+
+//include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
+
+fn c_char_ptr_to_str(ptr: *const c_char) -> Option<&'static str> {
+    if ptr.is_null() {
+        return None;
+    }
+
+    unsafe {
+        let c_str = CStr::from_ptr(ptr);
+        match c_str.to_str() {
+            Ok(s) => Some(s),
+            Err(_) => None, // not valid UTF-8
+        }
+    }
+}
+
+fn c_char_array_to_vec(ptr: *mut *const c_char) -> Vec<String> {
+    let mut result = Vec::new();
+    if ptr.is_null() {
+        return result;
+    }
+
+    let mut i = 0;
+    loop {
+        let p = unsafe { *ptr.add(i) };
+        if p.is_null() {
+            break;
+        }
+
+        let cstr = unsafe { CStr::from_ptr(p) };
+        match cstr.to_str() {
+            Ok(s) => result.push(s.to_string()),
+            Err(_) => (), // skip invalid UTF-8
+        }
+
+        i += 1;
+    }
+
+    result
+}
+
+trait PkErr<T> {
+    fn pk_err(self, job: *mut PkBackendJob) -> T;
+}
+
+impl<T, E: std::fmt::Display> PkErr<T> for Result<T, E> {
+    fn pk_err(self, job: *mut PkBackendJob) -> T {
+        match self {
+            Ok(val) => val,
+            Err(e) => unsafe {
+                let msg = e.to_string();
+                let c_msg = CString::new(msg.clone())
+                    .unwrap_or_else(|_| CString::new("unknown error").unwrap());
+
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_INTERNAL_ERROR,
+                    c_msg.as_ptr(),
+                );
+                // we want packagekit to handle this and cleanup naturally
+                // TODO: still some testing to do here
+                std::thread::sleep(Duration::from_millis(2000));
+                panic!("Hopefully packagekit cleans up in time..., error: {msg}")
+            },
+        }
+    }
+}
+
+// println will just get eaten, ensure we can print logs to packagekitd --verbose output
+pub fn log_debug(args: fmt::Arguments) {
+    unsafe {
+        let domain = CString::new("PackageKit").unwrap();
+        let formatted = format!("{}", args);
+        let message = CString::new(formatted).unwrap();
+        g_log(domain.as_ptr(), G_LOG_LEVEL_DEBUG, message.as_ptr());
+    }
+}
+
+#[macro_export]
+macro_rules! log_debug {
+    ($($arg:tt)*) => ({
+        $crate::log_debug(format_args!($($arg)*))
+    });
+}
+
+// Complex C Macros do not get translated to FFI
+#[inline]
+fn pk_bitfield_value(val: u32) -> PkBitfield {
+    1 << val
+}
+
+#[inline]
+fn pk_bitfield_contain(bitfield: PkBitfield, enum_val: u32) -> bool {
+    (bitfield & pk_bitfield_value(enum_val)) > 0
+}
+
+/// Keep a percentage within a global range e.g. scale from 50-75%
+fn scale_percentage(percentage: f32, start: f32, end: f32) -> f32 {
+    start + (percentage * (end - start) / 100.0)
+}
+
+struct MossBackend {
+    client: Client,
+    installation: Installation,
+}
+
+fn get_moss_client() -> MossBackend {
+    //let installation = Installation::open("/home/ninya/aeryn/img-tests/virt-manager-vm/sosroot/", None).expect("failed to open installation");
+    let installation = Installation::open("/", None).expect("failed to open installation");
+    let client =
+        Client::new(environment::NAME, installation.clone()).expect("failed to create client");
+    MossBackend {
+        client,
+        installation,
+    }
+}
+
+/// Convert a moss package into a pk_package_id
+fn moss_build_package_id_from_registry(pkg: &Package, client: &Client) -> Result<*mut c_char> {
+    // Get the version of the pkg available in the repo plugin (remote)
+    let available_pkg = client
+        .registry
+        .by_name(&pkg.meta.name, package::Flags::default())
+        .filter(|p| !p.flags.installed)
+        .next();
+
+    // We have to fully resolve by id to get origin and meta.uri fully
+    // populated
+    let repo_resolved_pkg = if let Some(pkg) = available_pkg {
+        client
+            .registry
+            .by_id(&pkg.id)
+            .find(|pkg| !pkg.flags.installed)
+    } else {
+        None
+    };
+
+    let status = if pkg.flags.installed {
+        match repo_resolved_pkg.and_then(|pkg| pkg.meta.origin) {
+            Some(origin) => format!("installed:{}", origin),
+            None => "installed".to_string(),
+        }
+    } else {
+        repo_resolved_pkg
+            .and_then(|pkg| pkg.meta.origin)
+            .unwrap_or("unknown".to_string())
+    };
+
+    let c_name = CString::new(pkg.meta.name.to_string())?;
+    let c_version = CString::new(pkg.meta.version_identifier.as_str())?;
+    let c_arch = CString::new(pkg.meta.architecture.as_str())?;
+    let c_status = CString::new(status)?;
+
+    Ok(unsafe {
+        pk_package_id_build(
+            c_name.as_ptr(),
+            c_version.as_ptr(),
+            c_arch.as_ptr(),
+            c_status.as_ptr(),
+        )
+    })
+}
+
+/// Gets a moss pkg from the registry from a pk_package_id
+// TODO: should this be a Result? plently of error oppotunities
+fn moss_get_pkg_from_package_id(package_id: *const c_char, client: &Client) -> Option<Package> {
+    unsafe {
+        // I assume packagekit already does this internally so may not be neccessary
+        if pk_package_id_check(package_id) == 0 {
+            return None;
+        }
+
+        let parts = pk_package_id_split(package_id);
+
+        let name_ptr = *parts.add(PK_PACKAGE_ID_NAME as usize);
+        let version_ptr = *parts.add(PK_PACKAGE_ID_VERSION as usize);
+        let arch_ptr = *parts.add(PK_PACKAGE_ID_ARCH as usize);
+        let data_ptr = *parts.add(PK_PACKAGE_ID_DATA as usize);
+
+        if name_ptr.is_null() || version_ptr.is_null() || arch_ptr.is_null() || data_ptr.is_null() {
+            return None;
+        }
+
+        let name_str = CStr::from_ptr(name_ptr).to_str().unwrap();
+        let version_str = CStr::from_ptr(version_ptr).to_str().unwrap();
+        let arch_str = CStr::from_ptr(arch_ptr).to_str().unwrap();
+        let data_str = CStr::from_ptr(data_ptr).to_str().unwrap();
+
+        let kind = data_str.splitn(2, ':').next().unwrap_or("");
+        let flags = if kind == "installed" {
+            Flags::new().with_installed()
+        } else {
+            Flags::new().with_available()
+        };
+
+        let provider = Provider::from_name(name_str).unwrap();
+        let result = client.registry.by_provider(&provider, flags).next();
+
+        if let Some(pkg) = result {
+            if pkg.meta.architecture == arch_str && pkg.meta.version_identifier == version_str {
+                Some(pkg)
+            } else {
+                None
+            }
+        } else {
+            None
+        }
+    }
+}
+
+/// Emit a vec of moss packages to a combined pk_backend_job_packages signal
+fn moss_emit_package_list(pkgs: Vec<Package>, client: &Client, job: *mut PkBackendJob) -> () {
+    let pk_packages = unsafe { g_ptr_array_new_full(pkgs.len() as u32, None) };
+    for pkg in pkgs {
+        let id = moss_build_package_id_from_registry(&pkg, &client).pk_err(job);
+
+        let pk_package = unsafe { pk_package_new() };
+        let error: *mut *mut GError = ptr::null_mut();
+
+        unsafe {
+            if pk_package_set_id(pk_package, id, error) == 0 {
+                // TODO: get the error
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_PACKAGE_ID_INVALID,
+                    CString::new(format!("Failed to set package ID: {:?}", id))
+                        .pk_err(job)
+                        .as_ptr(),
+                );
+                continue;
+            }
+            // TODO: Take the PkInfoEnum as a param instead so this helper can be used in more places
+            if pkg.flags.installed {
+                pk_package_set_info(pk_package, PkInfoEnum_PK_INFO_ENUM_INSTALLED);
+            } else {
+                pk_package_set_info(pk_package, PkInfoEnum_PK_INFO_ENUM_AVAILABLE);
+            }
+            pk_package_set_summary(
+                pk_package,
+                CString::new(pkg.meta.summary).pk_err(job).as_ptr(),
+            );
+            g_ptr_array_add(pk_packages, pk_package as *mut c_void);
+        }
+    }
+    unsafe {
+        if !pk_packages.is_null() && (*pk_packages).len > 0 {
+            pk_backend_job_packages(job, pk_packages);
+        }
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_get_description(_backend: *mut PkBackend) -> *const c_char {
+    static DESCRIPTION: &str = "Moss - atomic stateful package manager\0";
+    DESCRIPTION.as_ptr() as *const c_char
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_get_author(_backend: *mut PkBackend) -> *const c_char {
+    static AUTHOR: &str = "Aeryn OS Developers <copyright@aerynos.com>\0";
+    AUTHOR.as_ptr() as *const c_char
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_initialize(_conf: GKeyFile, _backend: *mut PkBackend) -> () {
+    log_debug!("HEY HO, WHAT IS UP FROM MOSS YO...");
+}
+
+#[unsafe(no_mangle)]
+pub unsafe extern "C" fn pk_backend_destroy(_backend: *mut PkBackend) -> () {
+    log_debug!("moss backend destroyed.");
+}
+
+// This function is LLM slop i have no fucking idea how to do this nicely
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_get_mime_types(_backend: *mut PkBackend) -> *mut *mut c_char {
+    let mime_types = vec![CString::new("application/x-stone-binary").unwrap()];
+
+    // Convert to raw pointers
+    let mut ptrs: Vec<*mut c_char> = mime_types
+        .into_iter()
+        .map(|cs| cs.into_raw()) // transfers ownership to C
+        .collect();
+
+    ptrs.push(ptr::null_mut()); // null terminate
+
+    // Convert Vec to raw pointer
+    let array_ptr = ptrs.as_mut_ptr();
+
+    // Leak the Vec so the pointer remains valid
+    std::mem::forget(ptrs);
+
+    array_ptr
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_download_packages_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut package_ids: *mut *const c_char = std::ptr::null_mut();
+    let mut directory: *const c_char = std::ptr::null();
+    let format = CString::new("(^a&ss)").pk_err(job);
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(
+            gvariant_ptr,
+            format.as_ptr(),
+            &mut package_ids as *mut _,
+            &mut directory as *mut _,
+        );
+    }
+
+    let backend = get_moss_client();
+    let client = &backend.client;
+
+    let _guard = runtime::init();
+
+    let ids = c_char_array_to_vec(package_ids);
+    for (idx, id) in ids.iter().enumerate() {
+        let c_id = CString::new(id.clone()).pk_err(job);
+        if let Some(pkg) = moss_get_pkg_from_package_id(c_id.as_ptr(), client) {
+            // NOTE: we'll re-resolve to ensure we get the available in the repo version, in case the pkg is
+            //       already installed. Next, we need to re-resolve the pkg against the registry to get the
+            //       full meta.uri otherwise we just get the endix path missing the index base uri.
+            //       Is this horrible and stupid? Yes.
+            let available_pkg = client
+                .registry
+                .by_name(&pkg.meta.name, package::Flags::new().with_available())
+                .filter(|p| !p.flags.installed)
+                .next()
+                .unwrap();
+            let full_pkg = client.registry.by_id(&available_pkg.id).next().unwrap();
+            match runtime::block_on(async {
+                client::cache::fetch(&full_pkg.meta, &backend.installation, {
+                    let package_id = c_id.clone();
+                    let id_len = ids.len().clone();
+                    //log_debug!("Attempting to download {:?}", full_pkg.meta.uri);
+                    move |progress: moss::client::cache::Progress| {
+                        let item_percentage = progress.pct();
+                        let pk_percentage = (item_percentage * 100.0).floor() as u32;
+
+                        let global_pct = ((idx as f32) + item_percentage) / (id_len as f32);
+                        let global_percentage = (global_pct * 100.0).floor() as u32;
+
+                        unsafe {
+                            pk_backend_job_set_item_progress(
+                                job,
+                                package_id.as_ptr(),
+                                PkInfoEnum_PK_INFO_ENUM_DOWNLOADING,
+                                pk_percentage,
+                            );
+                            pk_backend_job_set_percentage(job, global_percentage);
+                        }
+                    }
+                })
+                .await
+            }) {
+                Ok(download) => {
+                    unsafe {
+                        // God this is horrible
+                        let rust_dir = Path::new(CStr::from_ptr(directory).to_str().pk_err(job));
+
+                        let parsed = Url::parse(&full_pkg.meta.uri.unwrap()).pk_err(job);
+                        let filename = parsed.path_segments().and_then(|segments| segments.last());
+                        let target = rust_dir.join(&filename.unwrap());
+
+                        std::fs::rename(download.path, &target).pk_err(job);
+
+                        let target_vec = vec![target.as_path().to_str().unwrap().to_string()];
+                        let mut c_target = OurCStringArray::from_vec(target_vec);
+
+                        pk_backend_job_files(job, c_id.as_ptr(), c_target.as_ptr());
+                    }
+                }
+                Err(e) => {
+                    let c_err = CString::new(e.to_string()).pk_err(job);
+                    unsafe {
+                        pk_backend_job_error_code(
+                            job,
+                            PkErrorEnum_PK_ERROR_ENUM_PACKAGE_DOWNLOAD_FAILED,
+                            c_err.as_ptr(),
+                        );
+                    }
+                }
+            }
+        } else {
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_PACKAGE_NOT_FOUND,
+                    CString::new(format!("Failed to find package {:?}", id))
+                        .pk_err(job)
+                        .as_ptr(),
+                );
+            }
+        }
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_download_packages(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _package_ids: *const *const c_char,
+    _directory: *const c_char,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(
+            job,
+            Some(backend_download_packages_thread),
+            ptr::null_mut(),
+            None,
+        );
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_get_details_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut package_ids: *mut *const c_char = std::ptr::null_mut();
+    let format = CString::new("(^a&s)").pk_err(job);
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(gvariant_ptr, format.as_ptr(), &mut package_ids as *mut _);
+    }
+
+    let backend = get_moss_client();
+    let client = &backend.client;
+
+    let ids = c_char_array_to_vec(package_ids);
+
+    for id in ids {
+        let c_id = CString::new(id.clone()).pk_err(job);
+        if let Some(pkg) = moss_get_pkg_from_package_id(c_id.as_ptr(), client) {
+            let c_sum = CString::new(pkg.meta.summary).pk_err(job);
+            let c_lic = CString::new(pkg.meta.licenses.first().unwrap().to_string()).pk_err(job);
+            let c_desc = CString::new(pkg.meta.description).pk_err(job);
+            let c_url = CString::new(pkg.meta.homepage).pk_err(job);
+            unsafe {
+                pk_backend_job_details_full(
+                    job,
+                    c_id.as_ptr(),
+                    c_sum.as_ptr(),
+                    c_lic.as_ptr(),
+                    PkGroupEnum_PK_GROUP_ENUM_UNKNOWN,
+                    c_desc.as_ptr(),
+                    c_url.as_ptr(),
+                    u64::MAX, // FIXME: No way to get installed size of a package? NOTE: will print unknown once this lands https://github.com/PackageKit/PackageKit/pull/851
+                    pkg.meta.download_size.unwrap_or_else(|| u64::MAX),
+                );
+            }
+        } else {
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_PACKAGE_NOT_FOUND,
+                    CString::new(format!("Failed to find package {:?}", id))
+                        .pk_err(job)
+                        .as_ptr(),
+                );
+            }
+        }
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_get_details(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _package_ids: *const *const c_char,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(job, Some(backend_get_details_thread), ptr::null_mut(), None);
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_get_details_local_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut full_paths: *mut *const c_char = std::ptr::null_mut();
+    let format = CString::new("(^a&s)").unwrap();
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(gvariant_ptr, format.as_ptr(), &mut full_paths as *mut _);
+    }
+
+    let paths = c_char_array_to_vec(full_paths);
+
+    for path in paths {
+        let mut file = File::open(&path).unwrap();
+        let mut reader = stone::read(&mut file).unwrap();
+
+        let payloads = reader.payloads().unwrap();
+
+        let mut pkg_name: Option<String> = None;
+        let mut pkg_arch: Option<String> = None;
+        let mut pkg_ver: Option<String> = None;
+        let pkg_status = "local";
+        let mut pkg_summary: Option<String> = None;
+        let mut pkg_license: Option<String> = None;
+        let mut pkg_desc: Option<String> = None;
+        let mut pkg_homepage: Option<String> = None;
+        let mut pkg_dlsize: Option<u64> = None;
+
+        for payload in payloads.flatten() {
+            match payload {
+                PayloadKind::Meta(meta) => {
+                    for record in meta.body {
+                        match &record.tag {
+                            // HOLY MOTHER OF NESTING, BETTER WAY!?
+                            meta::Tag::Name => {
+                                let kind = record.kind.clone();
+                                match kind {
+                                    meta::Kind::String(s) => {
+                                        pkg_name = Some(s);
+                                    }
+                                    _ => {}
+                                }
+                            }
+                            meta::Tag::Version => {
+                                let kind = record.kind.clone();
+                                match kind {
+                                    meta::Kind::String(s) => {
+                                        pkg_arch = Some(s);
+                                    }
+                                    _ => {}
+                                }
+                            }
+                            meta::Tag::Architecture => {
+                                let kind = record.kind.clone();
+                                match kind {
+                                    meta::Kind::String(s) => {
+                                        pkg_ver = Some(s);
+                                    }
+                                    _ => {}
+                                }
+                            }
+                            meta::Tag::Summary => {
+                                let kind = record.kind.clone();
+                                match kind {
+                                    meta::Kind::String(s) => {
+                                        pkg_summary = Some(s);
+                                    }
+                                    _ => {}
+                                }
+                            }
+                            meta::Tag::License => {
+                                let kind = record.kind.clone();
+                                match kind {
+                                    meta::Kind::String(s) => {
+                                        pkg_license = Some(s);
+                                    }
+                                    _ => {}
+                                }
+                            }
+                            meta::Tag::Description => {
+                                let kind = record.kind.clone();
+                                match kind {
+                                    meta::Kind::String(s) => {
+                                        pkg_desc = Some(s);
+                                    }
+                                    _ => {}
+                                }
+                            }
+                            meta::Tag::Homepage => {
+                                let kind = record.kind.clone();
+                                match kind {
+                                    meta::Kind::String(s) => {
+                                        pkg_homepage = Some(s);
+                                    }
+                                    _ => {}
+                                }
+                            }
+                            meta::Tag::PackageSize => {
+                                let kind = record.kind.clone();
+                                match kind {
+                                    meta::Kind::Uint64(u) => {
+                                        pkg_dlsize = Some(u);
+                                    }
+                                    _ => {}
+                                }
+                            }
+                            _ => {}
+                        }
+                    }
+                }
+                _ => {}
+            }
+        }
+
+        let c_name = CString::new(pkg_name.unwrap().as_str()).pk_err(job);
+        let c_ver = CString::new(pkg_ver.unwrap().as_str()).pk_err(job);
+        let c_arch = CString::new(pkg_arch.unwrap().as_str()).pk_err(job);
+        let c_sum = CString::new(pkg_summary.unwrap().as_str()).pk_err(job);
+        let c_desc = CString::new(pkg_desc.unwrap().as_str()).pk_err(job);
+        let c_home = CString::new(pkg_homepage.unwrap().as_str()).pk_err(job);
+        let c_lic = CString::new(pkg_license.unwrap().as_str()).pk_err(job);
+
+        unsafe {
+            let id = pk_package_id_build(
+                c_name.as_ptr(),
+                c_ver.as_ptr(),
+                c_arch.as_ptr(),
+                CString::new(pkg_status).unwrap().as_ptr(),
+            );
+            pk_backend_job_details_full(
+                job,
+                id,
+                c_sum.as_ptr(),
+                c_lic.as_ptr(),
+                PkGroupEnum_PK_GROUP_ENUM_UNKNOWN,
+                c_desc.as_ptr(),
+                c_home.as_ptr(),
+                u64::MAX, // FIXME: No way to get installed size of a package? NOTE: will print unknown once this lands https://github.com/PackageKit/PackageKit/pull/851,
+                pkg_dlsize.unwrap_or(u64::MAX),
+            )
+        }
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_get_details_local(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _full_paths: *const *const c_char,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(
+            job,
+            Some(backend_get_details_local_thread),
+            ptr::null_mut(),
+            None,
+        );
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_get_packages_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut filters: PkBitfield = 0;
+    let format = CString::new("(t)").pk_err(job);
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(gvariant_ptr, format.as_ptr(), &mut filters as *mut _);
+    }
+
+    let backend = get_moss_client();
+    let client = &backend.client;
+
+    let flags = if pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_INSTALLED) {
+        package::Flags::new().with_installed()
+    } else if pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_NOT_INSTALLED) {
+        package::Flags::new().with_available()
+    } else {
+        package::Flags::default()
+    };
+
+    // TODO: ~newest filter how that does work? i think we get the latest version of a package from
+    //       all repos
+    let is_newest = pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_NEWEST)
+        || pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_NOT_NEWEST);
+
+    let mut pkgs_to_emit = Vec::new();
+
+    let mut seen = HashSet::new();
+    for pkg in client.registry.list(flags) {
+        // We have to filter out the remote versions of packages which are already installed :(
+        if is_newest || seen.insert(pkg.meta.name.to_string().clone()) {
+            pkgs_to_emit.push(pkg);
+        }
+    }
+
+    moss_emit_package_list(pkgs_to_emit, client, job);
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_get_packages(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _filters: PkBitfield,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(
+            job,
+            Some(backend_get_packages_thread),
+            ptr::null_mut(),
+            None,
+        );
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_resolve_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut search: *mut *const c_char = std::ptr::null_mut();
+    let mut filters: PkBitfield = 0;
+    let format = CString::new("(t^a&s)").pk_err(job);
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(
+            gvariant_ptr,
+            format.as_ptr(),
+            &mut filters as *mut _,
+            &mut search as *mut _,
+        );
+    }
+
+    let backend = get_moss_client();
+    let client = &backend.client;
+
+    let search_terms = c_char_array_to_vec(search);
+
+    let flags = if pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_INSTALLED) {
+        package::Flags::new().with_installed()
+    } else if pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_NOT_INSTALLED) {
+        package::Flags::new().with_available()
+    } else {
+        package::Flags::default()
+    };
+
+    // TODO: ~newest filter how that does work? i think we get the latest version of a package
+    //       from all repos, even if they're not the most up to date.
+    let is_newest = pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_NEWEST)
+        || pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_NOT_NEWEST);
+
+    let mut pkgs_to_emit = Vec::new();
+
+    let mut seen_installed = HashSet::new();
+    for keyword in &search_terms {
+        let matches: Vec<_> = client
+            .registry
+            .by_keyword(keyword, flags)
+            .filter(|pkg| pkg.meta.name.to_string() == *keyword)
+            .filter(|pkg| {
+                // newest filter operates on installed and available
+                // lists seperately so don't filter out duplicates
+                if is_newest {
+                    return true;
+                }
+                if pkg.flags.installed {
+                    seen_installed.insert(pkg.id.to_string());
+                    true
+                } else if pkg.flags.available {
+                    !seen_installed.contains(&pkg.id.to_string())
+                } else {
+                    true
+                }
+            })
+            .collect();
+
+        for pkg in matches {
+            pkgs_to_emit.push(pkg);
+        }
+    }
+
+    moss_emit_package_list(pkgs_to_emit, client, job);
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_resolve(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _filters: PkBitfield,
+    _search: *const *const c_char,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(job, Some(backend_resolve_thread), ptr::null_mut(), None);
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_get_files_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut package_ids: *mut *const c_char = std::ptr::null_mut();
+    let format = CString::new("(^a&s)").pk_err(job);
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(gvariant_ptr, format.as_ptr(), &mut package_ids as *mut _);
+    }
+
+    let backend = get_moss_client();
+    let client = &backend.client;
+
+    let ids = c_char_array_to_vec(package_ids);
+    for id in ids {
+        let c_id = CString::new(id.clone()).pk_err(job);
+        if let Some(pkg) = moss_get_pkg_from_package_id(c_id.as_ptr(), client) {
+            let vfs = client.vfs(&[pkg.id]).pk_err(job);
+            let files = vfs
+                .iter()
+                .filter_map(|file| {
+                    if matches!(file.kind(), vfs::tree::Kind::Directory) {
+                        return None;
+                    }
+                    let path = file.path();
+                    Some(path)
+                })
+                .collect::<Vec<_>>();
+
+            let mut files_ptr = OurCStringArray::from_vec(files);
+
+            unsafe {
+                pk_backend_job_files(job, c_id.as_ptr(), files_ptr.as_ptr());
+            }
+        } else {
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_PACKAGE_NOT_FOUND,
+                    CString::new(format!("Failed to find package {:?}", id))
+                        .pk_err(job)
+                        .as_ptr(),
+                );
+            }
+        }
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_get_files(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _package_ids: *const *const c_char,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(job, Some(backend_get_files_thread), ptr::null_mut(), None);
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_get_files_local_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut full_paths: *mut *const c_char = std::ptr::null_mut();
+    let format = CString::new("(^a&s)").pk_err(job);
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(gvariant_ptr, format.as_ptr(), &mut full_paths as *mut _);
+    }
+
+    let paths = c_char_array_to_vec(full_paths);
+
+    for path in paths {
+        let mut file = File::open(&path).unwrap();
+        let mut reader = stone::read(&mut file).unwrap();
+
+        let payloads = reader.payloads().unwrap();
+
+        let mut pkg_name: Option<String> = None;
+        let mut pkg_arch: Option<String> = None;
+        let mut pkg_ver: Option<String> = None;
+        let pkg_status = "local";
+
+        let mut layouts = vec![];
+
+        for payload in payloads.flatten() {
+            match payload {
+                PayloadKind::Layout(l) => layouts = l.body,
+                PayloadKind::Meta(meta) => {
+                    for record in meta.body {
+                        match &record.tag {
+                            // HOLY MOTHER OF NESTING, BETTER WAY!?
+                            meta::Tag::Name => {
+                                let kind = record.kind.clone();
+                                match kind {
+                                    meta::Kind::String(s) => {
+                                        pkg_name = Some(s);
+                                    }
+                                    _ => {}
+                                }
+                            }
+                            meta::Tag::Version => {
+                                let kind = record.kind.clone();
+                                match kind {
+                                    meta::Kind::String(s) => {
+                                        pkg_arch = Some(s);
+                                    }
+                                    _ => {}
+                                }
+                            }
+                            meta::Tag::Architecture => {
+                                let kind = record.kind.clone();
+                                match kind {
+                                    meta::Kind::String(s) => {
+                                        pkg_ver = Some(s);
+                                    }
+                                    _ => {}
+                                }
+                            }
+                            _ => {}
+                        }
+                    }
+                }
+                _ => {}
+            }
+        }
+
+        let c_name = CString::new(pkg_name.unwrap().as_str()).unwrap();
+        let c_ver = CString::new(pkg_ver.unwrap().as_str()).unwrap();
+        let c_arch = CString::new(pkg_arch.unwrap().as_str()).unwrap();
+
+        let files = layouts
+            .iter()
+            .filter_map(|file| match &file.entry {
+                layout::Entry::Regular(_, target)
+                | layout::Entry::Directory(target)
+                | layout::Entry::Symlink(_, target) => Some(format!("/usr/{}", target.clone())),
+                _ => None,
+            })
+            .collect::<Vec<_>>();
+
+        let mut files_ptr = OurCStringArray::from_vec(files);
+
+        unsafe {
+            let id = pk_package_id_build(
+                c_name.as_ptr(),
+                c_ver.as_ptr(),
+                c_arch.as_ptr(),
+                CString::new(pkg_status).unwrap().as_ptr(),
+            );
+            pk_backend_job_files(job, id, files_ptr.as_ptr());
+        }
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_get_files_local(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _full_paths: *const *const c_char,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(
+            job,
+            Some(backend_get_files_local_thread),
+            ptr::null_mut(),
+            None,
+        );
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_search_files_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut search: *mut *const c_char = std::ptr::null_mut();
+    let mut filters: PkBitfield = 0;
+    let format = CString::new("(t^a&s)").pk_err(job);
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(
+            gvariant_ptr,
+            format.as_ptr(),
+            &mut filters as *mut _,
+            &mut search as *mut _,
+        );
+    }
+
+    let backend = get_moss_client();
+    let client = &backend.client;
+
+    let search_terms = c_char_array_to_vec(search);
+
+    let layouts = client.layout_db.all().pk_err(job);
+
+    let mut pkgs_to_emit = Vec::new();
+
+    layouts
+        .into_iter()
+        .for_each(|(id, layout)| match layout.entry {
+            stone::payload::layout::Entry::Regular(_, file)
+            | stone::payload::layout::Entry::Symlink(_, file)
+            | stone::payload::layout::Entry::Directory(file) => {
+                for keyword in &search_terms {
+                    if file.contains(keyword) {
+                        if let Some(pkg) = client.registry.by_id(&id).next() {
+                            pkgs_to_emit.push(pkg);
+                        }
+                    }
+                }
+            }
+            _ => {}
+        });
+
+    moss_emit_package_list(pkgs_to_emit, client, job);
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_search_files(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _filters: PkBitfield,
+    _values: *const *const c_char,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(
+            job,
+            Some(backend_search_files_thread),
+            ptr::null_mut(),
+            None,
+        );
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_search_details_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut search: *mut *const c_char = std::ptr::null_mut();
+    let mut filters: PkBitfield = 0;
+    let format = CString::new("(t^a&s)").pk_err(job);
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(
+            gvariant_ptr,
+            format.as_ptr(),
+            &mut filters as *mut _,
+            &mut search as *mut _,
+        );
+    }
+
+    let backend = get_moss_client();
+    let client = &backend.client;
+
+    let search_terms = c_char_array_to_vec(search);
+
+    let flags = if pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_INSTALLED) {
+        package::Flags::new().with_installed()
+    } else if pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_NOT_INSTALLED) {
+        package::Flags::new().with_available()
+    } else {
+        package::Flags::default()
+    };
+
+    let mut pkgs_to_emit = Vec::new();
+
+    let mut seen = HashSet::new();
+    for keyword in &search_terms {
+        let matches: Vec<_> = client
+            .registry
+            .by_keyword(keyword, flags)
+            .filter(|pkg| {
+                pkg.meta.summary.contains(keyword) || pkg.meta.description.contains(keyword)
+            })
+            .collect();
+
+        // We have to filter out the remote versions of packages which are already installed :(
+        // however, for the newest filter we operate on available and installed lists separately
+        // TODO: ~newest filter how that does work?
+        let is_newest = pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_NEWEST)
+            || pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_NOT_NEWEST);
+        for pkg in matches {
+            if is_newest || seen.insert(pkg.meta.name.to_string().clone()) {
+                pkgs_to_emit.push(pkg);
+            }
+        }
+    }
+
+    moss_emit_package_list(pkgs_to_emit, client, job);
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_search_details(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _filters: PkBitfield,
+    _values: *const *const c_char,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(
+            job,
+            Some(backend_search_details_thread),
+            ptr::null_mut(),
+            None,
+        );
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_search_names_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut search: *mut *const c_char = std::ptr::null_mut();
+    let mut filters: PkBitfield = 0;
+    let format = CString::new("(t^a&s)").unwrap();
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(
+            gvariant_ptr,
+            format.as_ptr(),
+            &mut filters as *mut _,
+            &mut search as *mut _,
+        );
+    }
+
+    let backend = get_moss_client();
+    let client = &backend.client;
+
+    let search_terms = c_char_array_to_vec(search);
+
+    let flags = if pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_INSTALLED) {
+        package::Flags::new().with_installed()
+    } else if pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_NOT_INSTALLED) {
+        package::Flags::new().with_available()
+    } else {
+        package::Flags::default()
+    };
+
+    let mut pkgs_to_emit = Vec::new();
+
+    let mut seen = HashSet::new();
+    for keyword in &search_terms {
+        let matches: Vec<_> = client
+            .registry
+            .by_keyword(keyword, flags)
+            .filter(|pkg| pkg.meta.name.to_string().contains(keyword))
+            .collect();
+
+        // We have to filter out the remote versions of packages which
+        // are already installed :(
+        // however, for the newest filter we operate on available and installed lists separately
+        // TODO: ~newest filter how that does work? i think we get the latest version of a package from
+        //       all repos
+        let is_newest = pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_NEWEST)
+            || pk_bitfield_contain(filters, PkFilterEnum_PK_FILTER_ENUM_NOT_NEWEST);
+        for pkg in matches {
+            if is_newest || seen.insert(pkg.meta.name.to_string().clone()) {
+                pkgs_to_emit.push(pkg);
+            }
+        }
+    }
+
+    moss_emit_package_list(pkgs_to_emit, client, job);
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_search_names(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _filters: PkBitfield,
+    _values: *const *const c_char,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(
+            job,
+            Some(backend_search_names_thread),
+            ptr::null_mut(),
+            None,
+        );
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_remove_packages_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut package_ids: *mut *const c_char = std::ptr::null_mut();
+    let mut transaction_flags: PkBitfield = 0;
+    let mut allow_deps: i32 = 0;
+    let mut autoremove: i32 = 0;
+    let format = CString::new("(t^a&sbb)").pk_err(job);
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(
+            gvariant_ptr,
+            format.as_ptr(),
+            &mut transaction_flags as *mut _,
+            &mut package_ids as *mut _,
+            &mut allow_deps as *mut _,
+            &mut autoremove as *mut _,
+        );
+    }
+
+    let backend = get_moss_client();
+    let client = &backend.client;
+
+    let _guard = runtime::init();
+
+    unsafe {
+        pk_backend_job_set_status(job, PkStatusEnum_PK_STATUS_ENUM_DEP_RESOLVE);
+    }
+
+    let mut resolved: Vec<Id> = Vec::new();
+
+    let ids = c_char_array_to_vec(package_ids);
+
+    for id in ids {
+        let c_id = CString::new(id.clone()).pk_err(job);
+        if let Some(pkg) = moss_get_pkg_from_package_id(c_id.as_ptr(), client) {
+            resolved.push(pkg.id);
+        } else {
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_PACKAGE_NOT_FOUND,
+                    CString::new(format!("Failed to find package {:?}", id))
+                        .pk_err(job)
+                        .as_ptr(),
+                );
+            }
+        }
+    }
+
+    // Now, we'll create a moss transaction with our pkgs; this will pull in dependencies etc.
+    let mut tx = client
+        .registry
+        .transaction(transaction::Lookup::InstalledOnly)
+        .pk_err(job);
+
+    let installed = client
+        .registry
+        .list_installed(Flags::default())
+        .collect::<Vec<_>>();
+    let installed_ids = installed
+        .iter()
+        .map(|p| p.id.clone())
+        .collect::<BTreeSet<_>>();
+
+    tx.add(installed_ids.clone().into_iter().collect())
+        .pk_err(job);
+    tx.remove(resolved);
+    let finalized = tx.finalize().cloned().collect::<BTreeSet<_>>();
+    let removed = client
+        .resolve_packages(installed_ids.difference(&finalized))
+        .pk_err(job);
+
+    if pk_bitfield_contain(
+        transaction_flags,
+        PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_SIMULATE,
+    ) {
+        for pkg in removed {
+            let id = moss_build_package_id_from_registry(&pkg, &client).pk_err(job);
+            let c_summary = CString::new(pkg.meta.summary.clone()).pk_err(job);
+            unsafe {
+                pk_backend_job_package(job, PkInfoEnum_PK_INFO_ENUM_REMOVE, id, c_summary.as_ptr());
+            }
+        }
+        return;
+    }
+
+    unsafe {
+        pk_backend_job_set_status(job, PkStatusEnum_PK_STATUS_ENUM_REMOVE);
+    }
+
+    let new_state_pkgs = {
+        let previous_selections = match client.installation.active_state {
+            Some(id) => client.state_db.get(id).unwrap().selections,
+            None => vec![],
+        };
+
+        finalized
+            .into_iter()
+            .map(|id| {
+                previous_selections
+                    .iter()
+                    .find(|s| s.package == id)
+                    .cloned()
+                    // Should be unreachable since new state from removal
+                    // is always a subset of the previous state
+                    .unwrap_or_else(|| {
+                        eprintln!("Unreachable: previous selection not found during removal for package {id:?}, marking as not explicit");
+
+                        Selection {
+                            package: id,
+                            explicit: false,
+                            reason: None,
+                        }
+                    })
+            })
+            .collect::<Vec<_>>()
+    };
+
+    let job_atomic = Arc::new(AtomicPtr::new(job));
+    let job_clone = job_atomic.clone();
+
+    match client.new_state(
+        &new_state_pkgs,
+        "Remove",
+        Some(Arc::new(move |percentage, stage| {
+            let job_ptr = job_clone.load(Ordering::Relaxed);
+            let adjusted_percentage = match stage {
+                ProgressStage::Blit => scale_percentage(percentage, 0.0, 50.0),
+                ProgressStage::Transaction => scale_percentage(percentage, 50.0, 70.0),
+                ProgressStage::System => scale_percentage(percentage, 70.0, 100.0),
+            };
+            unsafe {
+                pk_backend_job_set_percentage(job_ptr, adjusted_percentage as u32);
+            }
+        })),
+    ) {
+        Ok(_) => {}
+        Err(e) => {
+            let c_err = e.to_string();
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_FAILED_FINALISE,
+                    CString::new(c_err).pk_err(job).as_ptr(),
+                );
+            }
+        }
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_remove_packages(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _transaction_flags: PkBitfield,
+    _package_ids: *const *const c_char,
+    _allow_deps: i32,
+    _autoremove: i32,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(
+            job,
+            Some(backend_remove_packages_thread),
+            ptr::null_mut(),
+            None,
+        );
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_install_packages_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut package_ids: *mut *const c_char = std::ptr::null_mut();
+    let mut transaction_flags: PkBitfield = 0;
+    let format = CString::new("(t^a&s)").pk_err(job);
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(
+            gvariant_ptr,
+            format.as_ptr(),
+            &mut transaction_flags as *mut _,
+            &mut package_ids as *mut _,
+        );
+    }
+
+    let backend = get_moss_client();
+    let client = &backend.client;
+
+    let _guard = runtime::init();
+
+    unsafe {
+        pk_backend_job_set_status(job, PkStatusEnum_PK_STATUS_ENUM_DEP_RESOLVE);
+    }
+
+    let mut resolved: Vec<Id> = Vec::new();
+
+    let ids = c_char_array_to_vec(package_ids);
+
+    for id in ids {
+        let c_id = CString::new(id.clone()).pk_err(job);
+        if let Some(pkg) = moss_get_pkg_from_package_id(c_id.as_ptr(), client) {
+            resolved.push(pkg.id);
+        } else {
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_PACKAGE_NOT_FOUND,
+                    CString::new(format!("Failed to find package {:?}", id))
+                        .pk_err(job)
+                        .as_ptr(),
+                );
+            }
+        }
+    }
+
+    // Now, we'll create a moss transaction with our pkgs; this will pull in dependencies etc.
+    let mut tx = client
+        .registry
+        .transaction(transaction::Lookup::PreferInstalled)
+        .pk_err(job);
+
+    tx.add(resolved.clone()).pk_err(job);
+    let tx_resolved = client.resolve_packages(tx.finalize()).pk_err(job);
+    let installed = client
+        .registry
+        .list_installed(Flags::default())
+        .collect::<Vec<_>>();
+    let is_installed = |p: &Package| installed.iter().any(|i| i.meta.name == p.meta.name);
+    let missing = tx_resolved
+        .iter()
+        .filter(|p| client.is_ephemeral() || !is_installed(p))
+        .collect::<Vec<_>>();
+    if missing.is_empty() {
+        unsafe {
+            pk_backend_job_error_code(
+                job,
+                PkErrorEnum_PK_ERROR_ENUM_PACKAGE_ALREADY_INSTALLED,
+                CString::new("Package(s) already installed")
+                    .pk_err(job)
+                    .as_ptr(),
+            );
+        }
+    }
+
+    if pk_bitfield_contain(
+        transaction_flags,
+        PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_SIMULATE,
+    ) {
+        for pkg in missing.clone() {
+            let id = moss_build_package_id_from_registry(&pkg, &client).pk_err(job);
+            let c_summary = CString::new(pkg.meta.summary.clone()).pk_err(job);
+            unsafe {
+                pk_backend_job_package(
+                    job,
+                    PkInfoEnum_PK_INFO_ENUM_INSTALL,
+                    id,
+                    c_summary.as_ptr(),
+                );
+            }
+        }
+        return;
+    }
+    unsafe {
+        pk_backend_job_set_status(job, PkStatusEnum_PK_STATUS_ENUM_DOWNLOAD);
+    }
+
+    let job_atomic = Arc::new(AtomicPtr::new(job));
+    let job_clone = job_atomic.clone();
+
+    // TODO: check for already downloaded packages as cache_packages will needlessly
+    // unpack cached packages and re-add cached packages to the install_db and layout_db
+    match runtime::block_on(async {
+        client
+            .cache_packages(
+                &missing,
+                Some(Arc::new(move |callback| match callback {
+                    DownloadCallback::DownloadOverall(percentage) => {
+                        let job_ptr = job_clone.load(Ordering::Relaxed);
+                        let global_pk_pct = (percentage * 100.0).floor();
+                        unsafe {
+                            pk_backend_job_set_percentage(job_ptr, global_pk_pct as u32);
+                        }
+                    }
+                })),
+            )
+            .await
+    }) {
+        Ok(_) => {}
+        Err(e) => {
+            let c_err = e.to_string();
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_PACKAGE_DOWNLOAD_FAILED,
+                    CString::new(c_err).pk_err(job).as_ptr(),
+                );
+            }
+        }
+    }
+
+    //let mut cached: Vec<(Package, UnpackedAsset)> = Vec::new();
+    //
+    //// TODO: concurrent downloads like in moss, percentage calculation will be a
+    ////       bit wierd but we can do it probably
+    //for (idx, pkg) in missing.iter().enumerate() {
+    //    let c_id = moss_build_package_id_from_registry(pkg, &backend).pk_err(job);
+    //    let id_len = missing.len().clone();
+    //    let package_id = c_id.clone();
+    //    match runtime::block_on(async {
+    //        client::cache::fetch(&pkg.meta, &backend.installation, {
+    //            //log_debug!("Attempting to download {:?}", full_pkg.meta.uri);
+    //            move |progress: moss::client::cache::Progress| {
+    //                let item_pct = progress.pct();
+    //                let pk_item_pct = (item_pct * 100.0).floor() as u32;
+    //
+    //                let global_pct = ((idx as f32) + item_pct) / (id_len as f32);
+    //                let pk_global_pct = (global_pct * 100.0).floor() as u32;
+    //
+    //                unsafe {
+    //                    pk_backend_job_set_item_progress(
+    //                        job,
+    //                        package_id,
+    //                        PkInfoEnum_PK_INFO_ENUM_DOWNLOADING,
+    //                        pk_item_pct,
+    //                    );
+    //                    pk_backend_job_set_percentage(job, pk_global_pct);
+    //                }
+    //            }
+    //        })
+    //        .await
+    //    }) {
+    //        Ok(download) => {
+    //            let unpacking_in_progress = moss::client::cache::UnpackingInProgress::default();
+    //            let unpacked = download
+    //                .unpack(unpacking_in_progress, |_: moss::client::cache::Progress| {
+    //                    //let pk_item_pct = (item_pct * 100.0).floor() as u32;
+    //                    //let item_pct = progress.pct();
+    //                    //
+    //                    //let global_pct = ((idx as f32) + item_pct) / (id_len as f32);
+    //                    //let pk_global_pct = (global_pct * 100.0).floor() as u32;
+    //                    //
+    //                    //unsafe {
+    //                    //    pk_backend_job_set_item_progress(
+    //                    //        job,
+    //                    //        package_id,
+    //                    //        PkInfoEnum_PK_INFO_ENUM_DECOMPRESSING,
+    //                    //        pk_item_pct,
+    //                    //    );
+    //                    //    pk_backend_job_set_percentage(job, pk_global_pct);
+    //                    //}
+    //                })
+    //                .pk_err(job);
+    //            let package = (*pkg).clone();
+    //            cached.push((package, unpacked));
+    //        }
+    //        Err(e) => {
+    //            let c_err = CString::new(e.to_string()).pk_err(job);
+    //            unsafe {
+    //                pk_backend_job_error_code(
+    //                    job,
+    //                    PkErrorEnum_PK_ERROR_ENUM_PACKAGE_DOWNLOAD_FAILED,
+    //                    c_err.as_ptr(),
+    //                );
+    //            }
+    //        }
+    //    }
+    //}
+    //
+    //client
+    //    .layout_db
+    //    .batch_add(cached.iter().flat_map(|(p, u)| {
+    //        u.payloads
+    //            .iter()
+    //            .flat_map(PayloadKind::layout)
+    //            .flat_map(|p| p.body.as_slice())
+    //            .map(|layout| (&p.id, layout))
+    //    }))
+    //    .pk_err(job);
+    //
+    //client
+    //    .install_db
+    //    .batch_add(cached.into_iter().map(|(p, _)| (p.id, p.meta)).collect())
+    //    .pk_err(job);
+
+    if pk_bitfield_contain(
+        transaction_flags,
+        PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD,
+    ) {
+        return;
+    }
+
+    unsafe {
+        pk_backend_job_set_status(job, PkStatusEnum_PK_STATUS_ENUM_INSTALL);
+    }
+
+    // Finally, Let's fucking install the thing
+    // TODO: it is possible to emit item_progress installing for each package?
+    let new_state_pkgs = {
+        // Only use previous state in stateful mode
+        let previous_selections = match client.installation.active_state {
+            Some(id) if !client.is_ephemeral() => client.state_db.get(id).pk_err(job).selections,
+            _ => vec![],
+        };
+        let missing_selections = missing.iter().map(|p| Selection {
+            package: p.id.clone(),
+            // Package is explicit if it was one of the input
+            // packages provided by the user
+            explicit: resolved.contains(&p.id),
+            reason: None,
+        });
+
+        missing_selections
+            .chain(previous_selections)
+            .collect::<Vec<_>>()
+    };
+
+    let job_atomic = Arc::new(AtomicPtr::new(job));
+    let job_clone = job_atomic.clone();
+
+    match client.new_state(
+        &new_state_pkgs,
+        "Install",
+        Some(Arc::new(move |percentage, stage| {
+            let job_ptr = job_clone.load(Ordering::Relaxed);
+            let adjusted_percentage = match stage {
+                ProgressStage::Blit => scale_percentage(percentage, 0.0, 50.0),
+                ProgressStage::Transaction => scale_percentage(percentage, 50.0, 70.0),
+                ProgressStage::System => scale_percentage(percentage, 70.0, 100.0),
+            };
+            unsafe {
+                pk_backend_job_set_percentage(job_ptr, adjusted_percentage as u32);
+            }
+        })),
+    ) {
+        Ok(_) => {}
+        Err(e) => {
+            let c_err = e.to_string();
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_FAILED_FINALISE,
+                    CString::new(c_err).pk_err(job).as_ptr(),
+                );
+            }
+        }
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_install_packages(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _transaction_flags: PkBitfield,
+    _package_ids: *const *const c_char,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(
+            job,
+            Some(backend_install_packages_thread),
+            ptr::null_mut(),
+            None,
+        );
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_update_packages_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut package_ids: *mut *const c_char = std::ptr::null_mut();
+    let mut transaction_flags: PkBitfield = 0;
+    let format = CString::new("(t^a&s)").pk_err(job);
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(
+            gvariant_ptr,
+            format.as_ptr(),
+            &mut transaction_flags as *mut _,
+            &mut package_ids as *mut _,
+        );
+    }
+
+    let backend = get_moss_client();
+    let client = &backend.client;
+
+    let _guard = runtime::init();
+
+    unsafe {
+        pk_backend_job_set_status(job, PkStatusEnum_PK_STATUS_ENUM_DEP_RESOLVE);
+    }
+
+    let mut resolved: Vec<Id> = Vec::new();
+
+    let ids = c_char_array_to_vec(package_ids);
+
+    for id in ids {
+        let c_id = CString::new(id.clone()).pk_err(job);
+        if let Some(pkg) = moss_get_pkg_from_package_id(c_id.as_ptr(), client) {
+            resolved.push(pkg.id);
+        } else {
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_PACKAGE_NOT_FOUND,
+                    CString::new(format!("Failed to find package {:?}", id))
+                        .pk_err(job)
+                        .as_ptr(),
+                );
+            }
+        }
+    }
+
+    let installed = client
+        .registry
+        .list_installed(package::Flags::default())
+        .collect::<Vec<_>>();
+    let all_ids = installed.iter().map(|p| &p.id).collect::<BTreeSet<_>>();
+
+    let finalized = installed
+        .iter()
+        .filter_map(|p| {
+            if !p.flags.explicit {
+                return None;
+            }
+            if let Some(lookup) = client
+                .registry
+                .by_name(&p.meta.name, package::Flags::new().with_available())
+                .next()
+            {
+                if !all_ids.contains(&lookup.id)
+                    && lookup.meta.source_release > p.meta.source_release
+                {
+                    return Some(lookup.id);
+                }
+            }
+            Some(p.id.clone())
+        })
+        .collect::<Vec<_>>();
+
+    let mut tx = client
+        .registry
+        .transaction(transaction::Lookup::PreferAvailable)
+        .unwrap();
+    tx.add(finalized).pk_err(job);
+    let synced = client.resolve_packages(tx.finalize()).pk_err(job);
+    let final_fucking_sync = synced
+        .iter()
+        .filter(|p| client.is_ephemeral() || !installed.iter().any(|i| i.id == p.id))
+        .collect::<Vec<_>>();
+
+    if pk_bitfield_contain(
+        transaction_flags,
+        PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_SIMULATE,
+    ) {
+        for pkg in final_fucking_sync.clone() {
+            unsafe {
+                let id = moss_build_package_id_from_registry(&pkg, &client).pk_err(job);
+                let c_summary = CString::new(pkg.meta.summary.clone()).unwrap();
+                pk_backend_job_package(
+                    job,
+                    PkInfoEnum_PK_INFO_ENUM_UPDATING,
+                    id,
+                    c_summary.as_ptr(),
+                );
+            }
+        }
+        return;
+    }
+
+    unsafe {
+        pk_backend_job_set_status(job, PkStatusEnum_PK_STATUS_ENUM_DOWNLOAD);
+    }
+
+    let job_atomic = Arc::new(AtomicPtr::new(job));
+    let job_clone = job_atomic.clone();
+
+    match runtime::block_on(async {
+        client
+            .cache_packages(
+                &final_fucking_sync,
+                Some(Arc::new(move |callback| match callback {
+                    DownloadCallback::DownloadOverall(op) => {
+                        let pk_global_pct = (op * 100.0).floor() as u32;
+                        let job_ptr = job_clone.load(Ordering::Relaxed);
+                        unsafe {
+                            pk_backend_job_set_percentage(job_ptr, pk_global_pct);
+                        }
+                    }
+                })),
+            )
+            .await
+    }) {
+        Ok(_) => {}
+        Err(e) => {
+            let c_err = e.to_string();
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_PACKAGE_DOWNLOAD_FAILED,
+                    CString::new(c_err).pk_err(job).as_ptr(),
+                );
+            }
+        }
+    }
+    let only_download = pk_bitfield_contain(
+        transaction_flags,
+        PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD,
+    );
+    if only_download {
+        return;
+    }
+
+    unsafe {
+        pk_backend_job_set_status(job, PkStatusEnum_PK_STATUS_ENUM_UPDATE);
+    }
+
+    let new_selections = {
+        let previous_selections = match client.installation.active_state {
+            Some(id) => client.state_db.get(id).pk_err(job).selections,
+            None => vec![],
+        };
+
+        synced
+            .into_iter()
+            .map(|p| {
+                // Use old version id to lookup previous selection
+                let lookup_id = installed
+                    .iter()
+                    .find_map(|i| (i.meta.name == p.meta.name).then_some(&i.id))
+                    .unwrap_or(&p.id);
+
+                previous_selections
+                    .iter()
+                    .find(|s| s.package == *lookup_id)
+                    .cloned()
+                    // Use prev reason / explicit flag & new id
+                    .map(|s| Selection {
+                        package: p.id.clone(),
+                        ..s
+                    })
+                    // Must be transitive
+                    .unwrap_or(Selection {
+                        package: p.id,
+                        explicit: false,
+                        reason: None,
+                    })
+            })
+            .collect::<Vec<_>>()
+    };
+
+    let job_atomic = Arc::new(AtomicPtr::new(job));
+    let job_clone = job_atomic.clone();
+
+    match client.new_state(
+        &new_selections,
+        "Sync",
+        Some(Arc::new(move |percentage, stage| {
+            let job_ptr = job_clone.load(Ordering::Relaxed);
+            let adjusted_percentage = match stage {
+                ProgressStage::Blit => scale_percentage(percentage, 0.0, 50.0),
+                ProgressStage::Transaction => scale_percentage(percentage, 50.0, 70.0),
+                ProgressStage::System => scale_percentage(percentage, 70.0, 100.0),
+            };
+            unsafe {
+                pk_backend_job_set_percentage(job_ptr, adjusted_percentage as u32);
+            }
+        })),
+    ) {
+        Ok(_) => {}
+        Err(e) => {
+            let c_err = e.to_string();
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_FAILED_FINALISE,
+                    CString::new(c_err).pk_err(job).as_ptr(),
+                );
+            }
+        }
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_update_packages(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _transaction_flags: PkBitfield,
+    _package_ids: *const *const c_char,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(
+            job,
+            Some(backend_update_packages_thread),
+            ptr::null_mut(),
+            None,
+        );
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_get_update_detail_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut package_ids: *mut *const c_char = std::ptr::null_mut();
+    let format = CString::new("(^a&s)").pk_err(job);
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(gvariant_ptr, format.as_ptr(), &mut package_ids as *mut _);
+    }
+
+    let backend = get_moss_client();
+    let client = &backend.client;
+
+    let ids = c_char_array_to_vec(package_ids);
+
+    for id in ids {
+        let c_id = CString::new(id.clone()).pk_err(job);
+        if let Some(_) = moss_get_pkg_from_package_id(c_id.as_ptr(), client) {
+            unsafe {
+                pk_backend_job_update_detail(
+                    job,
+                    c_id.as_ptr(),
+                    ptr::null_mut(),                                // updates
+                    ptr::null_mut(),                                // obsoletes
+                    ptr::null_mut(),                                // vendor urls
+                    ptr::null_mut(),                                // bugzilla urls
+                    ptr::null_mut(),                                // cve urls
+                    PkRestartEnum_PK_RESTART_ENUM_NONE,             // package warrants restart?
+                    ptr::null_mut(),                                // update text
+                    ptr::null_mut(),                                // changelog
+                    PkUpdateStateEnum_PK_UPDATE_STATE_ENUM_UNKNOWN, // update state
+                    ptr::null_mut(),                                // issued (date)
+                    ptr::null_mut(),                                // updated (date)
+                );
+            }
+        } else {
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_PACKAGE_NOT_FOUND,
+                    CString::new(format!("Failed to find package {:?}", id))
+                        .pk_err(job)
+                        .as_ptr(),
+                );
+            }
+        }
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_get_update_detail(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _package_ids: *const *const c_char,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(
+            job,
+            Some(backend_get_update_detail_thread),
+            ptr::null_mut(),
+            None,
+        );
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_get_updates_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut filters: PkBitfield = 0;
+    let format = CString::new("(t)").pk_err(job);
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(gvariant_ptr, format.as_ptr(), &mut filters as *mut _);
+    }
+
+    let backend = get_moss_client();
+    let client = &backend.client;
+
+    let pkgs_installed = client
+        .registry
+        .list(Flags::new().with_installed())
+        .collect::<Vec<_>>();
+    let pkgs_available = client
+        .registry
+        .list(Flags::new().with_available())
+        .collect::<Vec<_>>();
+
+    // NOTE: we doing moss list sync --upgrade-only here for now
+    //       for downgrades with higher priority we need to think about consequences in a front-end
+    //       application such as gnome-software e.g. outdated pkgs in local or community repo
+    //       which may not be ABI compatible
+    let mut set = pkgs_installed
+        .into_iter()
+        .filter_map(|p| {
+            pkgs_available
+                .iter()
+                .find(|u| u.meta.name == p.meta.name)
+                .filter(|u| u.meta.source_release > p.meta.source_release)
+        })
+        .collect::<Vec<_>>();
+    set.sort_by_key(|s| s.meta.name.clone());
+    set.dedup_by_key(|s| s.meta.name.clone());
+
+    for pkg in set {
+        unsafe {
+            let id = moss_build_package_id_from_registry(&pkg, &client).pk_err(job);
+            let c_summary = CString::new(pkg.meta.summary.clone()).pk_err(job);
+
+            // TODO: no way to determine pkgs which are security fixes, other enum types are also available
+            pk_backend_job_package(job, PkInfoEnum_PK_INFO_ENUM_NORMAL, id, c_summary.as_ptr());
+        }
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_get_updates(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _filters: PkBitfield,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(job, Some(backend_get_updates_thread), ptr::null_mut(), None);
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn backend_refresh_cache_thread(
+    job: *mut PkBackendJob,
+    params: *mut _GVariant,
+    _user_data: *mut c_void,
+) -> () {
+    let mut force: i32 = 0;
+    let format = CString::new("(b)").pk_err(job);
+    // Cast _GVariant to GVariant
+    let gvariant_ptr = params as *mut GVariant;
+    unsafe {
+        g_variant_get(gvariant_ptr, format.as_ptr(), &mut force as *mut _);
+    }
+
+    let backend = get_moss_client();
+    let config = config::Manager::system(&backend.installation.root, "moss");
+
+    unsafe {
+        pk_backend_job_set_status(job, PkStatusEnum_PK_STATUS_ENUM_REFRESH_CACHE);
+    }
+
+    let _guard = runtime::init();
+
+    match repository::Manager::system(config, backend.installation.clone()) {
+        Ok(manager) => {
+            let repo_len = manager.list().len();
+            for (idx, repo) in manager.list().enumerate() {
+                match runtime::block_on(async { manager.refresh(repo.0).await }) {
+                    Ok(_) => {
+                        let percentage = if idx > repo_len {
+                            100
+                        } else {
+                            (100 * idx) / repo_len
+                        } as u32;
+                        //log_debug!("refresh pct {}", percentage);
+                        unsafe {
+                            pk_backend_job_set_percentage(job, percentage);
+                        }
+                    }
+                    Err(e) => {
+                        let c_err = e.to_string();
+                        unsafe {
+                            pk_backend_job_error_code(
+                                job,
+                                PkErrorEnum_PK_ERROR_ENUM_REPO_CONFIGURATION_ERROR,
+                                CString::new(c_err).pk_err(job).as_ptr(),
+                            );
+                        }
+                    }
+                }
+            }
+        }
+        Err(e) => {
+            let c_err = e.to_string();
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_FAILED_INITIALIZATION,
+                    CString::new(c_err).pk_err(job).as_ptr(),
+                );
+            }
+        }
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_refresh_cache(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _force: i32,
+) -> () {
+    unsafe {
+        pk_backend_job_thread_create(
+            job,
+            Some(backend_refresh_cache_thread),
+            ptr::null_mut(),
+            None,
+        );
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_repo_enable(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    rid: *const c_char,
+    enabled: i32,
+) -> () {
+    let backend = get_moss_client();
+    let config = config::Manager::system(&backend.installation.root, "moss");
+
+    unsafe {
+        let c_str = CStr::from_ptr(rid);
+        let rid_str = match c_str.to_str() {
+            Ok(s) => s,
+            Err(_) => return,
+        };
+
+        let pk_id = repository::Id::new(&rid_str);
+        let enabled: bool = enabled != 0;
+
+        let _guard = runtime::init();
+
+        match repository::Manager::system(config, backend.installation.clone()) {
+            Ok(mut manager) => {
+                // NOTE: borrowing issues with mutable vs immutable manager
+                let repo_ids: Vec<_> = manager
+                    .list()
+                    .map(|(id, repo)| (id.clone(), repo.clone()))
+                    .collect();
+                let mut found_repo = false;
+                for (id, _repo) in repo_ids {
+                    if id.clone() == pk_id {
+                        found_repo = true;
+                        if enabled {
+                            match runtime::block_on(manager.enable(&id)) {
+                                Ok(_) => {}
+                                Err(e) => {
+                                    let c_err = e.to_string();
+                                    pk_backend_job_error_code(
+                                        job,
+                                        PkErrorEnum_PK_ERROR_ENUM_REPO_CONFIGURATION_ERROR,
+                                        CString::new(c_err).unwrap().as_ptr(),
+                                    );
+                                }
+                            }
+                        } else {
+                            match runtime::block_on(manager.disable(&id)) {
+                                Ok(_) => {}
+                                Err(e) => {
+                                    let c_err = e.to_string();
+                                    pk_backend_job_error_code(
+                                        job,
+                                        PkErrorEnum_PK_ERROR_ENUM_REPO_CONFIGURATION_ERROR,
+                                        CString::new(c_err).unwrap().as_ptr(),
+                                    );
+                                }
+                            }
+                        }
+                    }
+                }
+                if found_repo == false {
+                    let c_err = CString::new(format!("Failed to find repo: {}", pk_id)).unwrap();
+                    pk_backend_job_error_code(
+                        job,
+                        PkErrorEnum_PK_ERROR_ENUM_REPO_NOT_FOUND,
+                        c_err.as_ptr(),
+                    );
+                }
+            }
+            Err(e) => {
+                let c_err = e.to_string();
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_FAILED_INITIALIZATION,
+                    CString::new(c_err).unwrap().as_ptr(),
+                );
+            }
+        }
+    }
+    unsafe {
+        pk_backend_job_finished(job);
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_repo_set_data(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    repo_id: *const c_char,
+    parameter: *const c_char,
+    value: *const c_char,
+) -> () {
+    let backend = get_moss_client();
+    let config = config::Manager::system(&backend.installation.root, "moss");
+
+    match repository::Manager::system(config, backend.installation.clone()) {
+        Ok(mut manager) => {
+            unsafe {
+                let c_rid = CStr::from_ptr(repo_id);
+                let rid_str = match c_rid.to_str() {
+                    Ok(s) => s,
+                    Err(_) => return,
+                };
+                let c_param = CStr::from_ptr(parameter);
+                let param_str = match c_param.to_str() {
+                    Ok(s) => s,
+                    Err(_) => return,
+                };
+
+                let c_value = CStr::from_ptr(value);
+                let value_str = match c_value.to_str() {
+                    Ok(s) => s,
+                    Err(_) => return,
+                };
+
+                let pk_id = repository::Id::new(&rid_str);
+
+                match param_str {
+                    "add" => {
+                        let uri = Url::parse(value_str).unwrap();
+                        manager
+                            .add_repository(
+                                pk_id.clone(),
+                                Repository {
+                                    description: "...".to_string(),
+                                    uri,
+                                    priority: Priority::new(0),
+                                    active: true,
+                                },
+                            )
+                            .unwrap();
+                        // TODO: should we actually refresh the repo here or rely on refresh-cache?
+                        let _guard = runtime::init();
+                        match runtime::block_on(manager.refresh(&pk_id)) {
+                            Ok(_) => {}
+                            Err(e) => {
+                                let c_err = CString::new(e.to_string()).unwrap();
+                                pk_backend_job_error_code(
+                                    job,
+                                    PkErrorEnum_PK_ERROR_ENUM_REPO_NOT_FOUND,
+                                    c_err.as_ptr(),
+                                );
+                            }
+                        }
+                    }
+                    "remove" => match manager.remove(pk_id.clone()).unwrap() {
+                        repository::manager::Removal::NotFound => {
+                            let c_err =
+                                CString::new(format!("Repository id: {} was not found", pk_id))
+                                    .unwrap();
+                            pk_backend_job_error_code(
+                                job,
+                                PkErrorEnum_PK_ERROR_ENUM_REPO_NOT_FOUND,
+                                c_err.as_ptr(),
+                            );
+                        }
+                        repository::manager::Removal::ConfigDeleted(false) => {}
+                        repository::manager::Removal::ConfigDeleted(true) => {}
+                    },
+                    // TODO: modify priority and url of existing repos?
+                    _ => {
+                        let c_err =
+                            CString::new("Valid parameters for set_repo_data are: add and, remove")
+                                .unwrap();
+                        pk_backend_job_error_code(
+                            job,
+                            PkErrorEnum_PK_ERROR_ENUM_NOT_SUPPORTED,
+                            c_err.as_ptr(),
+                        );
+                    }
+                }
+            }
+        }
+        Err(e) => {
+            let c_err = e.to_string();
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_FAILED_INITIALIZATION,
+                    CString::new(c_err).unwrap().as_ptr(),
+                );
+            }
+        }
+    }
+    unsafe {
+        pk_backend_job_finished(job);
+    }
+}
+
+#[unsafe(no_mangle)]
+unsafe extern "C" fn pk_backend_get_repo_list(
+    _backend: *mut PkBackend,
+    job: *mut PkBackendJob,
+    _filters: PkBitfield,
+) -> () {
+    let backend = get_moss_client();
+    let config = config::Manager::system(&backend.installation.root, "moss");
+
+    match repository::Manager::system(config, backend.installation.clone()) {
+        Ok(manager) => {
+            let configured_repos = manager.list();
+            if configured_repos.len() == 0 {
+                // TODO, set pk_backend_job_error_code?
+                return;
+            }
+            for (id, repo) in
+                configured_repos.sorted_by(|(_, a), (_, b)| a.priority.cmp(&b.priority).reverse())
+            {
+                let c_id = CString::new(id.to_string()).unwrap();
+                let c_desc = CString::new(repo.description.clone()).unwrap();
+                let c_active = if repo.active { 1 } else { 0 };
+                unsafe {
+                    pk_backend_job_repo_detail(job, c_id.as_ptr(), c_desc.as_ptr(), c_active);
+                }
+            }
+        }
+        Err(e) => {
+            let c_err = e.to_string();
+            unsafe {
+                pk_backend_job_error_code(
+                    job,
+                    PkErrorEnum_PK_ERROR_ENUM_FAILED_INITIALIZATION,
+                    CString::new(c_err).unwrap().as_ptr(),
+                );
+            }
+        }
+    }
+    unsafe {
+        pk_backend_job_finished(job);
+    }
+}
+
+unsafe fn c_strings_to_vec_null_terminated(c_strings: *const *const c_char) -> Vec<String> {
+    if c_strings.is_null() {
+        return Vec::new();
+    }
+
+    let mut result = Vec::new();
+    let mut i = 0;
+
+    loop {
+        unsafe {
+            let c_str_ptr = *c_strings.add(i);
+            if c_str_ptr.is_null() {
+                break; // Found null terminator
+            }
+
+            let c_str = CStr::from_ptr(c_str_ptr);
+            if let Ok(rust_str) = c_str.to_str() {
+                result.push(rust_str.to_string());
+            }
+            i += 1;
+        }
+    }
+    result
+}
+
+// debugging
+unsafe fn print_c_char_array(ptr: *mut *const c_char) {
+    if ptr.is_null() {
+        println!("ptr is null");
+        return;
+    }
+
+    let mut i = 0;
+    unsafe {
+        loop {
+            let c_str_ptr = *ptr.add(i);
+            if c_str_ptr.is_null() {
+                break;
+            }
+
+            let cstr = CStr::from_ptr(c_str_ptr);
+            match cstr.to_str() {
+                Ok(s) => println!("Item {}: {}", i, s),
+                Err(e) => println!("Item {}: invalid UTF-8 ({})", i, e),
+            }
+
+            i += 1;
+        }
+    }
+}
+
+// LLM slop, lifetimes are an issue here so be careful and validate output
+// TODO: replace with ffi-convert crate
+pub struct OurCStringArray {
+    cstrings: Vec<CString>,
+    ptrs: Vec<*mut c_char>,
+}
+
+impl OurCStringArray {
+    /// Converts a Vec<String> to a CStringArray with null-terminated pointer array.
+    pub fn from_vec(strings: Vec<String>) -> Self {
+        let cstrings: Vec<CString> = strings
+            .into_iter()
+            .map(|s| CString::new(s).unwrap())
+            .collect();
+
+        // Create vector of raw pointers
+        let mut ptrs: Vec<*mut c_char> = cstrings
+            .iter()
+            .map(|cs| cs.as_ptr() as *mut c_char)
+            .collect();
+
+        ptrs.push(ptr::null_mut());
+
+        OurCStringArray { cstrings, ptrs }
+    }
+
+    /// Returns the pointer to the first pointer (char **)
+    pub fn as_ptr(&mut self) -> *mut *mut c_char {
+        self.ptrs.as_mut_ptr()
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::packagekit::{pk_get_distro_id, pk_package_id_build, pk_package_id_check};
+
+    #[test]
+    fn pk_distro() {
+        unsafe {
+            let distro = pk_get_distro_id();
+            println!("distro {}", *distro);
+        }
+    }
+
+    #[test]
+    fn packagekit_id_check() {
+        unsafe {
+            let id = pk_package_id_build(
+                std::ffi::CString::new("firefox").unwrap().as_ptr(),
+                std::ffi::CString::new("140.0.4-367").unwrap().as_ptr(),
+                std::ffi::CString::new("x86_64").unwrap().as_ptr(),
+                std::ffi::CString::new("installed:Unstable")
+                    .unwrap()
+                    .as_ptr(),
+            );
+
+            let id_ok = pk_package_id_check(id);
+            assert_eq!(1, id_ok);
+        }
+    }
+}
diff --git a/src/packagekit.rs b/src/packagekit.rs
new file mode 100644
index 000000000..e89712fbc
--- /dev/null
+++ b/src/packagekit.rs
@@ -0,0 +1,6 @@
+/* automatically generated by rust-bindgen 0.71.1 */
+#![allow(dead_code)]
+#![allow(unused_variables)]
+#![allow(unused_imports)]
+
+# [repr (C)] # [derive (Copy , Clone , Debug , Default , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct __BindgenBitfieldUnit < Storage > { storage : Storage , } impl < Storage > __BindgenBitfieldUnit < Storage > { # [inline] pub const fn new (storage : Storage) -> Self { Self { storage } } } impl < Storage > __BindgenBitfieldUnit < Storage > where Storage : AsRef < [u8] > + AsMut < [u8] >, { # [inline] fn extract_bit (byte : u8 , index : usize) -> bool { let bit_index = if cfg ! (target_endian = "big") { 7 - (index % 8) } else { index % 8 } ; let mask = 1 << bit_index ; byte & mask == mask } # [inline] pub fn get_bit (& self , index : usize) -> bool { debug_assert ! (index / 8 < self . storage . as_ref () . len ()) ; let byte_index = index / 8 ; let byte = self . storage . as_ref () [byte_index] ; Self :: extract_bit (byte , index) } # [inline] pub unsafe fn raw_get_bit (this : * const Self , index : usize) -> bool { debug_assert ! (index / 8 < core :: mem :: size_of ::< Storage > ()) ; let byte_index = index / 8 ; let byte = * (core :: ptr :: addr_of ! ((* this) . storage) as * const u8) . offset (byte_index as isize) ; Self :: extract_bit (byte , index) } # [inline] fn change_bit (byte : u8 , index : usize , val : bool) -> u8 { let bit_index = if cfg ! (target_endian = "big") { 7 - (index % 8) } else { index % 8 } ; let mask = 1 << bit_index ; if val { byte | mask } else { byte & ! mask } } # [inline] pub fn set_bit (& mut self , index : usize , val : bool) { debug_assert ! (index / 8 < self . storage . as_ref () . len ()) ; let byte_index = index / 8 ; let byte = & mut self . storage . as_mut () [byte_index] ; * byte = Self :: change_bit (* byte , index , val) ; } # [inline] pub unsafe fn raw_set_bit (this : * mut Self , index : usize , val : bool) { debug_assert ! (index / 8 < core :: mem :: size_of ::< Storage > ()) ; let byte_index = index / 8 ; let byte = (core :: ptr :: addr_of_mut ! ((* this) . storage) as * mut u8) . offset (byte_index as isize) ; * byte = Self :: change_bit (* byte , index , val) ; } # [inline] pub fn get (& self , bit_offset : usize , bit_width : u8) -> u64 { debug_assert ! (bit_width <= 64) ; debug_assert ! (bit_offset / 8 < self . storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width as usize)) / 8 <= self . storage . as_ref () . len ()) ; let mut val = 0 ; for i in 0 .. (bit_width as usize) { if self . get_bit (i + bit_offset) { let index = if cfg ! (target_endian = "big") { bit_width as usize - 1 - i } else { i } ; val |= 1 << index ; } } val } # [inline] pub unsafe fn raw_get (this : * const Self , bit_offset : usize , bit_width : u8 ,) -> u64 { debug_assert ! (bit_width <= 64) ; debug_assert ! (bit_offset / 8 < core :: mem :: size_of ::< Storage > ()) ; debug_assert ! ((bit_offset + (bit_width as usize)) / 8 <= core :: mem :: size_of ::< Storage > ()) ; let mut val = 0 ; for i in 0 .. (bit_width as usize) { if Self :: raw_get_bit (this , i + bit_offset) { let index = if cfg ! (target_endian = "big") { bit_width as usize - 1 - i } else { i } ; val |= 1 << index ; } } val } # [inline] pub fn set (& mut self , bit_offset : usize , bit_width : u8 , val : u64) { debug_assert ! (bit_width <= 64) ; debug_assert ! (bit_offset / 8 < self . storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width as usize)) / 8 <= self . storage . as_ref () . len ()) ; for i in 0 .. (bit_width as usize) { let mask = 1 << i ; let val_bit_is_set = val & mask == mask ; let index = if cfg ! (target_endian = "big") { bit_width as usize - 1 - i } else { i } ; self . set_bit (index + bit_offset , val_bit_is_set) ; } } # [inline] pub unsafe fn raw_set (this : * mut Self , bit_offset : usize , bit_width : u8 , val : u64 ,) { debug_assert ! (bit_width <= 64) ; debug_assert ! (bit_offset / 8 < core :: mem :: size_of ::< Storage > ()) ; debug_assert ! ((bit_offset + (bit_width as usize)) / 8 <= core :: mem :: size_of ::< Storage > ()) ; for i in 0 .. (bit_width as usize) { let mask = 1 << i ; let val_bit_is_set = val & mask == mask ; let index = if cfg ! (target_endian = "big") { bit_width as usize - 1 - i } else { i } ; Self :: raw_set_bit (this , index + bit_offset , val_bit_is_set) ; } } } # [derive (PartialEq , Copy , Clone , Hash , Debug , Default)] # [repr (C)] pub struct __BindgenComplex < T > { pub re : T , pub im : T } pub const __WORDSIZE : u32 = 64 ; pub const __WORDSIZE_TIME64_COMPAT32 : u32 = 1 ; pub const __SYSCALL_WORDSIZE : u32 = 64 ; pub const G_ANALYZER_ANALYZING : u32 = 0 ; pub const FALSE : u32 = 0 ; pub const G_HAVE_GNUC_VISIBILITY : u32 = 1 ; pub const _LIBC_LIMITS_H_ : u32 = 1 ; pub const _FEATURES_H : u32 = 1 ; pub const _DEFAULT_SOURCE : u32 = 1 ; pub const __GLIBC_USE_ISOC2Y : u32 = 0 ; pub const __GLIBC_USE_ISOC23 : u32 = 0 ; pub const __USE_ISOC11 : u32 = 1 ; pub const __USE_ISOC99 : u32 = 1 ; pub const __USE_ISOC95 : u32 = 1 ; pub const __USE_POSIX_IMPLICITLY : u32 = 1 ; pub const _POSIX_SOURCE : u32 = 1 ; pub const _POSIX_C_SOURCE : u32 = 200809 ; pub const __USE_POSIX : u32 = 1 ; pub const __USE_POSIX2 : u32 = 1 ; pub const __USE_POSIX199309 : u32 = 1 ; pub const __USE_POSIX199506 : u32 = 1 ; pub const __USE_XOPEN2K : u32 = 1 ; pub const __USE_XOPEN2K8 : u32 = 1 ; pub const _ATFILE_SOURCE : u32 = 1 ; pub const __TIMESIZE : u32 = 64 ; pub const __USE_TIME_BITS64 : u32 = 1 ; pub const __USE_MISC : u32 = 1 ; pub const __USE_ATFILE : u32 = 1 ; pub const __USE_FORTIFY_LEVEL : u32 = 0 ; pub const __GLIBC_USE_DEPRECATED_GETS : u32 = 0 ; pub const __GLIBC_USE_DEPRECATED_SCANF : u32 = 0 ; pub const __GLIBC_USE_C23_STRTOL : u32 = 0 ; pub const _STDC_PREDEF_H : u32 = 1 ; pub const __STDC_IEC_559__ : u32 = 1 ; pub const __STDC_IEC_60559_BFP__ : u32 = 201404 ; pub const __STDC_IEC_559_COMPLEX__ : u32 = 1 ; pub const __STDC_IEC_60559_COMPLEX__ : u32 = 201404 ; pub const __STDC_ISO_10646__ : u32 = 201706 ; pub const __GNU_LIBRARY__ : u32 = 6 ; pub const __GLIBC__ : u32 = 2 ; pub const __GLIBC_MINOR__ : u32 = 41 ; pub const _SYS_CDEFS_H : u32 = 1 ; pub const __glibc_c99_flexarr_available : u32 = 1 ; pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI : u32 = 0 ; pub const __HAVE_GENERIC_SELECTION : u32 = 1 ; pub const __GLIBC_USE_LIB_EXT2 : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_BFP_EXT : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23 : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_EXT : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_FUNCS_EXT : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_TYPES_EXT : u32 = 0 ; pub const MB_LEN_MAX : u32 = 16 ; pub const _BITS_POSIX1_LIM_H : u32 = 1 ; pub const _POSIX_AIO_LISTIO_MAX : u32 = 2 ; pub const _POSIX_AIO_MAX : u32 = 1 ; pub const _POSIX_ARG_MAX : u32 = 4096 ; pub const _POSIX_CHILD_MAX : u32 = 25 ; pub const _POSIX_DELAYTIMER_MAX : u32 = 32 ; pub const _POSIX_HOST_NAME_MAX : u32 = 255 ; pub const _POSIX_LINK_MAX : u32 = 8 ; pub const _POSIX_LOGIN_NAME_MAX : u32 = 9 ; pub const _POSIX_MAX_CANON : u32 = 255 ; pub const _POSIX_MAX_INPUT : u32 = 255 ; pub const _POSIX_MQ_OPEN_MAX : u32 = 8 ; pub const _POSIX_MQ_PRIO_MAX : u32 = 32 ; pub const _POSIX_NAME_MAX : u32 = 14 ; pub const _POSIX_NGROUPS_MAX : u32 = 8 ; pub const _POSIX_OPEN_MAX : u32 = 20 ; pub const _POSIX_PATH_MAX : u32 = 256 ; pub const _POSIX_PIPE_BUF : u32 = 512 ; pub const _POSIX_RE_DUP_MAX : u32 = 255 ; pub const _POSIX_RTSIG_MAX : u32 = 8 ; pub const _POSIX_SEM_NSEMS_MAX : u32 = 256 ; pub const _POSIX_SEM_VALUE_MAX : u32 = 32767 ; pub const _POSIX_SIGQUEUE_MAX : u32 = 32 ; pub const _POSIX_SSIZE_MAX : u32 = 32767 ; pub const _POSIX_STREAM_MAX : u32 = 8 ; pub const _POSIX_SYMLINK_MAX : u32 = 255 ; pub const _POSIX_SYMLOOP_MAX : u32 = 8 ; pub const _POSIX_TIMER_MAX : u32 = 32 ; pub const _POSIX_TTY_NAME_MAX : u32 = 9 ; pub const _POSIX_TZNAME_MAX : u32 = 6 ; pub const _POSIX_CLOCKRES_MIN : u32 = 20000000 ; pub const NR_OPEN : u32 = 1024 ; pub const NGROUPS_MAX : u32 = 65536 ; pub const ARG_MAX : u32 = 131072 ; pub const LINK_MAX : u32 = 127 ; pub const MAX_CANON : u32 = 255 ; pub const MAX_INPUT : u32 = 255 ; pub const NAME_MAX : u32 = 255 ; pub const PATH_MAX : u32 = 4096 ; pub const PIPE_BUF : u32 = 4096 ; pub const XATTR_NAME_MAX : u32 = 255 ; pub const XATTR_SIZE_MAX : u32 = 65536 ; pub const XATTR_LIST_MAX : u32 = 65536 ; pub const RTSIG_MAX : u32 = 32 ; pub const _POSIX_THREAD_KEYS_MAX : u32 = 128 ; pub const PTHREAD_KEYS_MAX : u32 = 1024 ; pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS : u32 = 4 ; pub const PTHREAD_DESTRUCTOR_ITERATIONS : u32 = 4 ; pub const _POSIX_THREAD_THREADS_MAX : u32 = 64 ; pub const AIO_PRIO_DELTA_MAX : u32 = 20 ; pub const PTHREAD_STACK_MIN : u32 = 16384 ; pub const DELAYTIMER_MAX : u32 = 2147483647 ; pub const TTY_NAME_MAX : u32 = 32 ; pub const LOGIN_NAME_MAX : u32 = 256 ; pub const HOST_NAME_MAX : u32 = 64 ; pub const MQ_PRIO_MAX : u32 = 32768 ; pub const SEM_VALUE_MAX : u32 = 2147483647 ; pub const _BITS_POSIX2_LIM_H : u32 = 1 ; pub const _POSIX2_BC_BASE_MAX : u32 = 99 ; pub const _POSIX2_BC_DIM_MAX : u32 = 2048 ; pub const _POSIX2_BC_SCALE_MAX : u32 = 99 ; pub const _POSIX2_BC_STRING_MAX : u32 = 1000 ; pub const _POSIX2_COLL_WEIGHTS_MAX : u32 = 2 ; pub const _POSIX2_EXPR_NEST_MAX : u32 = 32 ; pub const _POSIX2_LINE_MAX : u32 = 2048 ; pub const _POSIX2_RE_DUP_MAX : u32 = 255 ; pub const _POSIX2_CHARCLASS_NAME_MAX : u32 = 14 ; pub const BC_BASE_MAX : u32 = 99 ; pub const BC_DIM_MAX : u32 = 2048 ; pub const BC_SCALE_MAX : u32 = 99 ; pub const BC_STRING_MAX : u32 = 1000 ; pub const COLL_WEIGHTS_MAX : u32 = 255 ; pub const EXPR_NEST_MAX : u32 = 32 ; pub const LINE_MAX : u32 = 2048 ; pub const CHARCLASS_NAME_MAX : u32 = 2048 ; pub const RE_DUP_MAX : u32 = 32767 ; pub const G_GINT16_MODIFIER : & [u8 ; 2] = b"h\0" ; pub const G_GINT16_FORMAT : & [u8 ; 3] = b"hi\0" ; pub const G_GUINT16_FORMAT : & [u8 ; 3] = b"hu\0" ; pub const G_GINT32_MODIFIER : & [u8 ; 1] = b"\0" ; pub const G_GINT32_FORMAT : & [u8 ; 2] = b"i\0" ; pub const G_GUINT32_FORMAT : & [u8 ; 2] = b"u\0" ; pub const G_HAVE_GINT64 : u32 = 1 ; pub const G_GINT64_MODIFIER : & [u8 ; 2] = b"l\0" ; pub const G_GINT64_FORMAT : & [u8 ; 3] = b"li\0" ; pub const G_GUINT64_FORMAT : & [u8 ; 3] = b"lu\0" ; pub const GLIB_SIZEOF_VOID_P : u32 = 8 ; pub const GLIB_SIZEOF_LONG : u32 = 8 ; pub const GLIB_SIZEOF_SIZE_T : u32 = 8 ; pub const GLIB_SIZEOF_SSIZE_T : u32 = 8 ; pub const G_GSIZE_MODIFIER : & [u8 ; 2] = b"l\0" ; pub const G_GSSIZE_MODIFIER : & [u8 ; 2] = b"l\0" ; pub const G_GSIZE_FORMAT : & [u8 ; 3] = b"lu\0" ; pub const G_GSSIZE_FORMAT : & [u8 ; 3] = b"li\0" ; pub const G_GOFFSET_MODIFIER : & [u8 ; 2] = b"l\0" ; pub const G_GOFFSET_FORMAT : & [u8 ; 3] = b"li\0" ; pub const G_POLLFD_FORMAT : & [u8 ; 3] = b"%d\0" ; pub const G_GINTPTR_MODIFIER : & [u8 ; 2] = b"l\0" ; pub const G_GINTPTR_FORMAT : & [u8 ; 3] = b"li\0" ; pub const G_GUINTPTR_FORMAT : & [u8 ; 3] = b"lu\0" ; pub const GLIB_MAJOR_VERSION : u32 = 2 ; pub const GLIB_MINOR_VERSION : u32 = 84 ; pub const GLIB_MICRO_VERSION : u32 = 3 ; pub const G_VA_COPY_AS_ARRAY : u32 = 1 ; pub const G_HAVE_ISO_VARARGS : u32 = 1 ; pub const G_HAVE_GROWING_STACK : u32 = 0 ; pub const G_HAVE_GNUC_VARARGS : u32 = 1 ; pub const G_MODULE_SUFFIX : & [u8 ; 3] = b"so\0" ; pub const G_PID_FORMAT : & [u8 ; 2] = b"i\0" ; pub const GLIB_SYSDEF_AF_UNIX : u32 = 1 ; pub const GLIB_SYSDEF_AF_INET : u32 = 2 ; pub const GLIB_SYSDEF_AF_INET6 : u32 = 10 ; pub const GLIB_SYSDEF_MSG_OOB : u32 = 1 ; pub const GLIB_SYSDEF_MSG_PEEK : u32 = 2 ; pub const GLIB_SYSDEF_MSG_DONTROUTE : u32 = 4 ; pub const G_DIR_SEPARATOR : u8 = 47u8 ; pub const G_DIR_SEPARATOR_S : & [u8 ; 2] = b"/\0" ; pub const G_SEARCHPATH_SEPARATOR : u8 = 58u8 ; pub const G_SEARCHPATH_SEPARATOR_S : & [u8 ; 2] = b":\0" ; pub const _TIME_H : u32 = 1 ; pub const _BITS_TIME_H : u32 = 1 ; pub const _BITS_TYPES_H : u32 = 1 ; pub const _BITS_TYPESIZES_H : u32 = 1 ; pub const __OFF_T_MATCHES_OFF64_T : u32 = 1 ; pub const __INO_T_MATCHES_INO64_T : u32 = 1 ; pub const __RLIM_T_MATCHES_RLIM64_T : u32 = 1 ; pub const __STATFS_MATCHES_STATFS64 : u32 = 1 ; pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 : u32 = 1 ; pub const __FD_SETSIZE : u32 = 1024 ; pub const _BITS_TIME64_H : u32 = 1 ; pub const CLOCK_REALTIME : u32 = 0 ; pub const CLOCK_MONOTONIC : u32 = 1 ; pub const CLOCK_PROCESS_CPUTIME_ID : u32 = 2 ; pub const CLOCK_THREAD_CPUTIME_ID : u32 = 3 ; pub const CLOCK_MONOTONIC_RAW : u32 = 4 ; pub const CLOCK_REALTIME_COARSE : u32 = 5 ; pub const CLOCK_MONOTONIC_COARSE : u32 = 6 ; pub const CLOCK_BOOTTIME : u32 = 7 ; pub const CLOCK_REALTIME_ALARM : u32 = 8 ; pub const CLOCK_BOOTTIME_ALARM : u32 = 9 ; pub const CLOCK_TAI : u32 = 11 ; pub const TIMER_ABSTIME : u32 = 1 ; pub const __clock_t_defined : u32 = 1 ; pub const __time_t_defined : u32 = 1 ; pub const __struct_tm_defined : u32 = 1 ; pub const _STRUCT_TIMESPEC : u32 = 1 ; pub const _BITS_ENDIAN_H : u32 = 1 ; pub const __LITTLE_ENDIAN : u32 = 1234 ; pub const __BIG_ENDIAN : u32 = 4321 ; pub const __PDP_ENDIAN : u32 = 3412 ; pub const _BITS_ENDIANNESS_H : u32 = 1 ; pub const __BYTE_ORDER : u32 = 1234 ; pub const __FLOAT_WORD_ORDER : u32 = 1234 ; pub const __clockid_t_defined : u32 = 1 ; pub const __timer_t_defined : u32 = 1 ; pub const __itimerspec_defined : u32 = 1 ; pub const _BITS_TYPES_LOCALE_T_H : u32 = 1 ; pub const _BITS_TYPES___LOCALE_T_H : u32 = 1 ; pub const TIME_UTC : u32 = 1 ; pub const G_E : f64 = 2.718281828459045 ; pub const G_LN2 : f64 = 0.6931471805599453 ; pub const G_LN10 : f64 = 2.302585092994046 ; pub const G_PI : f64 = 3.141592653589793 ; pub const G_PI_2 : f64 = 1.5707963267948966 ; pub const G_PI_4 : f64 = 0.7853981633974483 ; pub const G_SQRT2 : f64 = 1.4142135623730951 ; pub const G_LITTLE_ENDIAN : u32 = 1234 ; pub const G_BIG_ENDIAN : u32 = 4321 ; pub const G_PDP_ENDIAN : u32 = 3412 ; pub const G_IEEE754_FLOAT_BIAS : u32 = 127 ; pub const G_IEEE754_DOUBLE_BIAS : u32 = 1023 ; pub const G_LOG_2_BASE_10 : f64 = 0.3010299956639812 ; pub const _STRING_H : u32 = 1 ; pub const _STRINGS_H : u32 = 1 ; pub const _STDLIB_H : u32 = 1 ; pub const WNOHANG : u32 = 1 ; pub const WUNTRACED : u32 = 2 ; pub const WSTOPPED : u32 = 2 ; pub const WEXITED : u32 = 4 ; pub const WCONTINUED : u32 = 8 ; pub const WNOWAIT : u32 = 16777216 ; pub const __WNOTHREAD : u32 = 536870912 ; pub const __WALL : u32 = 1073741824 ; pub const __WCLONE : u32 = 2147483648 ; pub const __W_CONTINUED : u32 = 65535 ; pub const __WCOREFLAG : u32 = 128 ; pub const __HAVE_FLOAT128 : u32 = 1 ; pub const __HAVE_DISTINCT_FLOAT128 : u32 = 1 ; pub const __HAVE_FLOAT64X : u32 = 1 ; pub const __HAVE_FLOAT64X_LONG_DOUBLE : u32 = 1 ; pub const __HAVE_FLOAT16 : u32 = 0 ; pub const __HAVE_FLOAT32 : u32 = 1 ; pub const __HAVE_FLOAT64 : u32 = 1 ; pub const __HAVE_FLOAT32X : u32 = 1 ; pub const __HAVE_FLOAT128X : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT16 : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT32 : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT64 : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT32X : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT64X : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT128X : u32 = 0 ; pub const __HAVE_FLOATN_NOT_TYPEDEF : u32 = 0 ; pub const __ldiv_t_defined : u32 = 1 ; pub const __lldiv_t_defined : u32 = 1 ; pub const RAND_MAX : u32 = 2147483647 ; pub const EXIT_FAILURE : u32 = 1 ; pub const EXIT_SUCCESS : u32 = 0 ; pub const _SYS_TYPES_H : u32 = 1 ; pub const _BITS_STDINT_INTN_H : u32 = 1 ; pub const __BIT_TYPES_DEFINED__ : u32 = 1 ; pub const _ENDIAN_H : u32 = 1 ; pub const LITTLE_ENDIAN : u32 = 1234 ; pub const BIG_ENDIAN : u32 = 4321 ; pub const PDP_ENDIAN : u32 = 3412 ; pub const BYTE_ORDER : u32 = 1234 ; pub const _BITS_BYTESWAP_H : u32 = 1 ; pub const _BITS_UINTN_IDENTITY_H : u32 = 1 ; pub const _SYS_SELECT_H : u32 = 1 ; pub const __sigset_t_defined : u32 = 1 ; pub const __timeval_defined : u32 = 1 ; pub const FD_SETSIZE : u32 = 1024 ; pub const _BITS_PTHREADTYPES_COMMON_H : u32 = 1 ; pub const _THREAD_SHARED_TYPES_H : u32 = 1 ; pub const _BITS_PTHREADTYPES_ARCH_H : u32 = 1 ; pub const __SIZEOF_PTHREAD_MUTEX_T : u32 = 40 ; pub const __SIZEOF_PTHREAD_ATTR_T : u32 = 56 ; pub const __SIZEOF_PTHREAD_RWLOCK_T : u32 = 56 ; pub const __SIZEOF_PTHREAD_BARRIER_T : u32 = 32 ; pub const __SIZEOF_PTHREAD_MUTEXATTR_T : u32 = 4 ; pub const __SIZEOF_PTHREAD_COND_T : u32 = 48 ; pub const __SIZEOF_PTHREAD_CONDATTR_T : u32 = 4 ; pub const __SIZEOF_PTHREAD_RWLOCKATTR_T : u32 = 8 ; pub const __SIZEOF_PTHREAD_BARRIERATTR_T : u32 = 4 ; pub const _THREAD_MUTEX_INTERNAL_H : u32 = 1 ; pub const __PTHREAD_MUTEX_HAVE_PREV : u32 = 1 ; pub const __have_pthread_attr_t : u32 = 1 ; pub const _ALLOCA_H : u32 = 1 ; pub const _BITS_SIGNUM_GENERIC_H : u32 = 1 ; pub const SIGINT : u32 = 2 ; pub const SIGILL : u32 = 4 ; pub const SIGABRT : u32 = 6 ; pub const SIGFPE : u32 = 8 ; pub const SIGSEGV : u32 = 11 ; pub const SIGTERM : u32 = 15 ; pub const SIGHUP : u32 = 1 ; pub const SIGQUIT : u32 = 3 ; pub const SIGTRAP : u32 = 5 ; pub const SIGKILL : u32 = 9 ; pub const SIGPIPE : u32 = 13 ; pub const SIGALRM : u32 = 14 ; pub const SIGIOT : u32 = 6 ; pub const _BITS_SIGNUM_ARCH_H : u32 = 1 ; pub const SIGSTKFLT : u32 = 16 ; pub const SIGPWR : u32 = 30 ; pub const SIGBUS : u32 = 7 ; pub const SIGSYS : u32 = 31 ; pub const SIGURG : u32 = 23 ; pub const SIGSTOP : u32 = 19 ; pub const SIGTSTP : u32 = 20 ; pub const SIGCONT : u32 = 18 ; pub const SIGCHLD : u32 = 17 ; pub const SIGTTIN : u32 = 21 ; pub const SIGTTOU : u32 = 22 ; pub const SIGPOLL : u32 = 29 ; pub const SIGXFSZ : u32 = 25 ; pub const SIGXCPU : u32 = 24 ; pub const SIGVTALRM : u32 = 26 ; pub const SIGPROF : u32 = 27 ; pub const SIGUSR1 : u32 = 10 ; pub const SIGUSR2 : u32 = 12 ; pub const SIGWINCH : u32 = 28 ; pub const SIGIO : u32 = 29 ; pub const SIGCLD : u32 = 17 ; pub const __SIGRTMIN : u32 = 32 ; pub const __SIGRTMAX : u32 = 64 ; pub const _NSIG : u32 = 65 ; pub const __sig_atomic_t_defined : u32 = 1 ; pub const __siginfo_t_defined : u32 = 1 ; pub const __SI_MAX_SIZE : u32 = 128 ; pub const _BITS_SIGINFO_ARCH_H : u32 = 1 ; pub const __SI_ERRNO_THEN_CODE : u32 = 1 ; pub const __SI_HAVE_SIGSYS : u32 = 1 ; pub const _BITS_SIGINFO_CONSTS_H : u32 = 1 ; pub const __SI_ASYNCIO_AFTER_SIGIO : u32 = 1 ; pub const __sigevent_t_defined : u32 = 1 ; pub const __SIGEV_MAX_SIZE : u32 = 64 ; pub const _BITS_SIGEVENT_CONSTS_H : u32 = 1 ; pub const NSIG : u32 = 65 ; pub const _BITS_SIGACTION_H : u32 = 1 ; pub const SA_NOCLDSTOP : u32 = 1 ; pub const SA_NOCLDWAIT : u32 = 2 ; pub const SA_SIGINFO : u32 = 4 ; pub const SA_ONSTACK : u32 = 134217728 ; pub const SA_RESTART : u32 = 268435456 ; pub const SA_NODEFER : u32 = 1073741824 ; pub const SA_RESETHAND : u32 = 2147483648 ; pub const SA_INTERRUPT : u32 = 536870912 ; pub const SA_NOMASK : u32 = 1073741824 ; pub const SA_ONESHOT : u32 = 2147483648 ; pub const SA_STACK : u32 = 134217728 ; pub const SIG_BLOCK : u32 = 0 ; pub const SIG_UNBLOCK : u32 = 1 ; pub const SIG_SETMASK : u32 = 2 ; pub const _BITS_SIGCONTEXT_H : u32 = 1 ; pub const FP_XSTATE_MAGIC1 : u32 = 1179670611 ; pub const FP_XSTATE_MAGIC2 : u32 = 1179670597 ; pub const __stack_t_defined : u32 = 1 ; pub const _SYS_UCONTEXT_H : u32 = 1 ; pub const __NGREG : u32 = 23 ; pub const NGREG : u32 = 23 ; pub const _BITS_SIGSTACK_H : u32 = 1 ; pub const MINSIGSTKSZ : u32 = 2048 ; pub const SIGSTKSZ : u32 = 8192 ; pub const _BITS_SS_FLAGS_H : u32 = 1 ; pub const __sigstack_defined : u32 = 1 ; pub const _BITS_SIGTHREAD_H : u32 = 1 ; pub const G_DATALIST_FLAGS_MASK : u32 = 3 ; pub const G_DATE_BAD_JULIAN : u32 = 0 ; pub const G_DATE_BAD_DAY : u32 = 0 ; pub const G_DATE_BAD_YEAR : u32 = 0 ; pub const _DIRENT_H : u32 = 1 ; pub const _DIRENT_MATCHES_DIRENT64 : u32 = 1 ; pub const MAXNAMLEN : u32 = 255 ; pub const G_MEM_ALIGN : u32 = 8 ; pub const G_HOOK_FLAG_USER_SHIFT : u32 = 4 ; pub const G_PRIORITY_HIGH : i32 = - 100 ; pub const G_PRIORITY_DEFAULT : u32 = 0 ; pub const G_PRIORITY_HIGH_IDLE : u32 = 100 ; pub const G_PRIORITY_DEFAULT_IDLE : u32 = 200 ; pub const G_PRIORITY_LOW : u32 = 300 ; pub const G_SOURCE_REMOVE : u32 = 0 ; pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH : u32 = 18 ; pub const G_STR_DELIMITERS : & [u8 ; 8] = b"_-|> <.\0" ; pub const G_ASCII_DTOSTR_BUF_SIZE : u32 = 39 ; pub const G_KEY_FILE_DESKTOP_GROUP : & [u8 ; 14] = b"Desktop Entry\0" ; pub const G_KEY_FILE_DESKTOP_KEY_TYPE : & [u8 ; 5] = b"Type\0" ; pub const G_KEY_FILE_DESKTOP_KEY_VERSION : & [u8 ; 8] = b"Version\0" ; pub const G_KEY_FILE_DESKTOP_KEY_NAME : & [u8 ; 5] = b"Name\0" ; pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME : & [u8 ; 12] = b"GenericName\0" ; pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY : & [u8 ; 10] = b"NoDisplay\0" ; pub const G_KEY_FILE_DESKTOP_KEY_COMMENT : & [u8 ; 8] = b"Comment\0" ; pub const G_KEY_FILE_DESKTOP_KEY_ICON : & [u8 ; 5] = b"Icon\0" ; pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN : & [u8 ; 7] = b"Hidden\0" ; pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN : & [u8 ; 11] = b"OnlyShowIn\0" ; pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN : & [u8 ; 10] = b"NotShowIn\0" ; pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC : & [u8 ; 8] = b"TryExec\0" ; pub const G_KEY_FILE_DESKTOP_KEY_EXEC : & [u8 ; 5] = b"Exec\0" ; pub const G_KEY_FILE_DESKTOP_KEY_PATH : & [u8 ; 5] = b"Path\0" ; pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL : & [u8 ; 9] = b"Terminal\0" ; pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE : & [u8 ; 9] = b"MimeType\0" ; pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES : & [u8 ; 11] = b"Categories\0" ; pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY : & [u8 ; 14] = b"StartupNotify\0" ; pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS : & [u8 ; 15] = b"StartupWMClass\0" ; pub const G_KEY_FILE_DESKTOP_KEY_URL : & [u8 ; 4] = b"URL\0" ; pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE : & [u8 ; 16] = b"DBusActivatable\0" ; pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS : & [u8 ; 8] = b"Actions\0" ; pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION : & [u8 ; 12] = b"Application\0" ; pub const G_KEY_FILE_DESKTOP_TYPE_LINK : & [u8 ; 5] = b"Link\0" ; pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY : & [u8 ; 10] = b"Directory\0" ; pub const G_LOG_LEVEL_USER_SHIFT : u32 = 8 ; pub const G_OPTION_REMAINING : & [u8 ; 1] = b"\0" ; pub const G_CSET_A_2_Z : & [u8 ; 27] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0" ; pub const G_CSET_a_2_z : & [u8 ; 27] = b"abcdefghijklmnopqrstuvwxyz\0" ; pub const G_CSET_DIGITS : & [u8 ; 11] = b"0123456789\0" ; pub const G_CSET_LATINC : & [u8 ; 31] = b"\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD8\xD9\xDA\xDB\xDC\xDD\xDE\0" ; pub const G_CSET_LATINS : & [u8 ; 33] = b"\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF\0" ; pub const _ERRNO_H : u32 = 1 ; pub const _BITS_ERRNO_H : u32 = 1 ; pub const EPERM : u32 = 1 ; pub const ENOENT : u32 = 2 ; pub const ESRCH : u32 = 3 ; pub const EINTR : u32 = 4 ; pub const EIO : u32 = 5 ; pub const ENXIO : u32 = 6 ; pub const E2BIG : u32 = 7 ; pub const ENOEXEC : u32 = 8 ; pub const EBADF : u32 = 9 ; pub const ECHILD : u32 = 10 ; pub const EAGAIN : u32 = 11 ; pub const ENOMEM : u32 = 12 ; pub const EACCES : u32 = 13 ; pub const EFAULT : u32 = 14 ; pub const ENOTBLK : u32 = 15 ; pub const EBUSY : u32 = 16 ; pub const EEXIST : u32 = 17 ; pub const EXDEV : u32 = 18 ; pub const ENODEV : u32 = 19 ; pub const ENOTDIR : u32 = 20 ; pub const EISDIR : u32 = 21 ; pub const EINVAL : u32 = 22 ; pub const ENFILE : u32 = 23 ; pub const EMFILE : u32 = 24 ; pub const ENOTTY : u32 = 25 ; pub const ETXTBSY : u32 = 26 ; pub const EFBIG : u32 = 27 ; pub const ENOSPC : u32 = 28 ; pub const ESPIPE : u32 = 29 ; pub const EROFS : u32 = 30 ; pub const EMLINK : u32 = 31 ; pub const EPIPE : u32 = 32 ; pub const EDOM : u32 = 33 ; pub const ERANGE : u32 = 34 ; pub const EDEADLK : u32 = 35 ; pub const ENAMETOOLONG : u32 = 36 ; pub const ENOLCK : u32 = 37 ; pub const ENOSYS : u32 = 38 ; pub const ENOTEMPTY : u32 = 39 ; pub const ELOOP : u32 = 40 ; pub const EWOULDBLOCK : u32 = 11 ; pub const ENOMSG : u32 = 42 ; pub const EIDRM : u32 = 43 ; pub const ECHRNG : u32 = 44 ; pub const EL2NSYNC : u32 = 45 ; pub const EL3HLT : u32 = 46 ; pub const EL3RST : u32 = 47 ; pub const ELNRNG : u32 = 48 ; pub const EUNATCH : u32 = 49 ; pub const ENOCSI : u32 = 50 ; pub const EL2HLT : u32 = 51 ; pub const EBADE : u32 = 52 ; pub const EBADR : u32 = 53 ; pub const EXFULL : u32 = 54 ; pub const ENOANO : u32 = 55 ; pub const EBADRQC : u32 = 56 ; pub const EBADSLT : u32 = 57 ; pub const EDEADLOCK : u32 = 35 ; pub const EBFONT : u32 = 59 ; pub const ENOSTR : u32 = 60 ; pub const ENODATA : u32 = 61 ; pub const ETIME : u32 = 62 ; pub const ENOSR : u32 = 63 ; pub const ENONET : u32 = 64 ; pub const ENOPKG : u32 = 65 ; pub const EREMOTE : u32 = 66 ; pub const ENOLINK : u32 = 67 ; pub const EADV : u32 = 68 ; pub const ESRMNT : u32 = 69 ; pub const ECOMM : u32 = 70 ; pub const EPROTO : u32 = 71 ; pub const EMULTIHOP : u32 = 72 ; pub const EDOTDOT : u32 = 73 ; pub const EBADMSG : u32 = 74 ; pub const EOVERFLOW : u32 = 75 ; pub const ENOTUNIQ : u32 = 76 ; pub const EBADFD : u32 = 77 ; pub const EREMCHG : u32 = 78 ; pub const ELIBACC : u32 = 79 ; pub const ELIBBAD : u32 = 80 ; pub const ELIBSCN : u32 = 81 ; pub const ELIBMAX : u32 = 82 ; pub const ELIBEXEC : u32 = 83 ; pub const EILSEQ : u32 = 84 ; pub const ERESTART : u32 = 85 ; pub const ESTRPIPE : u32 = 86 ; pub const EUSERS : u32 = 87 ; pub const ENOTSOCK : u32 = 88 ; pub const EDESTADDRREQ : u32 = 89 ; pub const EMSGSIZE : u32 = 90 ; pub const EPROTOTYPE : u32 = 91 ; pub const ENOPROTOOPT : u32 = 92 ; pub const EPROTONOSUPPORT : u32 = 93 ; pub const ESOCKTNOSUPPORT : u32 = 94 ; pub const EOPNOTSUPP : u32 = 95 ; pub const EPFNOSUPPORT : u32 = 96 ; pub const EAFNOSUPPORT : u32 = 97 ; pub const EADDRINUSE : u32 = 98 ; pub const EADDRNOTAVAIL : u32 = 99 ; pub const ENETDOWN : u32 = 100 ; pub const ENETUNREACH : u32 = 101 ; pub const ENETRESET : u32 = 102 ; pub const ECONNABORTED : u32 = 103 ; pub const ECONNRESET : u32 = 104 ; pub const ENOBUFS : u32 = 105 ; pub const EISCONN : u32 = 106 ; pub const ENOTCONN : u32 = 107 ; pub const ESHUTDOWN : u32 = 108 ; pub const ETOOMANYREFS : u32 = 109 ; pub const ETIMEDOUT : u32 = 110 ; pub const ECONNREFUSED : u32 = 111 ; pub const EHOSTDOWN : u32 = 112 ; pub const EHOSTUNREACH : u32 = 113 ; pub const EALREADY : u32 = 114 ; pub const EINPROGRESS : u32 = 115 ; pub const ESTALE : u32 = 116 ; pub const EUCLEAN : u32 = 117 ; pub const ENOTNAM : u32 = 118 ; pub const ENAVAIL : u32 = 119 ; pub const EISNAM : u32 = 120 ; pub const EREMOTEIO : u32 = 121 ; pub const EDQUOT : u32 = 122 ; pub const ENOMEDIUM : u32 = 123 ; pub const EMEDIUMTYPE : u32 = 124 ; pub const ECANCELED : u32 = 125 ; pub const ENOKEY : u32 = 126 ; pub const EKEYEXPIRED : u32 = 127 ; pub const EKEYREVOKED : u32 = 128 ; pub const EKEYREJECTED : u32 = 129 ; pub const EOWNERDEAD : u32 = 130 ; pub const ENOTRECOVERABLE : u32 = 131 ; pub const ERFKILL : u32 = 132 ; pub const EHWPOISON : u32 = 133 ; pub const ENOTSUP : u32 = 95 ; pub const G_TEST_OPTION_ISOLATE_DIRS : & [u8 ; 13] = b"isolate_dirs\0" ; pub const G_TEST_OPTION_NO_PRGNAME : & [u8 ; 17] = b"no_g_set_prgname\0" ; pub const G_TEST_OPTION_NONFATAL_ASSERTIONS : & [u8 ; 20] = b"nonfatal-assertions\0" ; pub const G_USEC_PER_SEC : u32 = 1000000 ; pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS : & [u8 ; 8] = b":/?#[]@\0" ; pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS : & [u8 ; 12] = b"!$&'()*+,;=\0" ; pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT : & [u8 ; 14] = b"!$&'()*+,;=:@\0" ; pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH : & [u8 ; 15] = b"!$&'()*+,;=:@/\0" ; pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO : & [u8 ; 13] = b"!$&'()*+,;=:\0" ; pub const G_ALLOC_ONLY : u32 = 1 ; pub const G_ALLOC_AND_FREE : u32 = 2 ; pub const G_ALLOCATOR_LIST : u32 = 1 ; pub const G_ALLOCATOR_SLIST : u32 = 2 ; pub const G_ALLOCATOR_NODE : u32 = 3 ; pub const _PTHREAD_H : u32 = 1 ; pub const _SCHED_H : u32 = 1 ; pub const _BITS_SCHED_H : u32 = 1 ; pub const SCHED_OTHER : u32 = 0 ; pub const SCHED_FIFO : u32 = 1 ; pub const SCHED_RR : u32 = 2 ; pub const _BITS_TYPES_STRUCT_SCHED_PARAM : u32 = 1 ; pub const _BITS_CPU_SET_H : u32 = 1 ; pub const __CPU_SETSIZE : u32 = 1024 ; pub const _BITS_SETJMP_H : u32 = 1 ; pub const __jmp_buf_tag_defined : u32 = 1 ; pub const PTHREAD_ONCE_INIT : u32 = 0 ; pub const PTHREAD_BARRIER_SERIAL_THREAD : i32 = - 1 ; pub const G_TYPE_FUNDAMENTAL_SHIFT : u32 = 2 ; pub const G_TYPE_FUNDAMENTAL_MAX : u32 = 1020 ; pub const G_TYPE_RESERVED_GLIB_FIRST : u32 = 22 ; pub const G_TYPE_RESERVED_GLIB_LAST : u32 = 31 ; pub const G_TYPE_RESERVED_BSE_FIRST : u32 = 32 ; pub const G_TYPE_RESERVED_BSE_LAST : u32 = 48 ; pub const G_TYPE_RESERVED_USER_FIRST : u32 = 49 ; pub const G_VALUE_NOCOPY_CONTENTS : u32 = 134217728 ; pub const G_PARAM_MASK : u32 = 255 ; pub const G_PARAM_USER_SHIFT : u32 = 8 ; pub const G_SIGNAL_FLAGS_MASK : u32 = 511 ; pub const G_SIGNAL_MATCH_MASK : u32 = 63 ; pub const _UNISTD_H : u32 = 1 ; pub const _POSIX_VERSION : u32 = 200809 ; pub const __POSIX2_THIS_VERSION : u32 = 200809 ; pub const _POSIX2_VERSION : u32 = 200809 ; pub const _POSIX2_C_VERSION : u32 = 200809 ; pub const _POSIX2_C_BIND : u32 = 200809 ; pub const _POSIX2_C_DEV : u32 = 200809 ; pub const _POSIX2_SW_DEV : u32 = 200809 ; pub const _POSIX2_LOCALEDEF : u32 = 200809 ; pub const _XOPEN_VERSION : u32 = 700 ; pub const _XOPEN_XCU_VERSION : u32 = 4 ; pub const _XOPEN_XPG2 : u32 = 1 ; pub const _XOPEN_XPG3 : u32 = 1 ; pub const _XOPEN_XPG4 : u32 = 1 ; pub const _XOPEN_UNIX : u32 = 1 ; pub const _XOPEN_ENH_I18N : u32 = 1 ; pub const _XOPEN_LEGACY : u32 = 1 ; pub const _BITS_POSIX_OPT_H : u32 = 1 ; pub const _POSIX_JOB_CONTROL : u32 = 1 ; pub const _POSIX_SAVED_IDS : u32 = 1 ; pub const _POSIX_PRIORITY_SCHEDULING : u32 = 200809 ; pub const _POSIX_SYNCHRONIZED_IO : u32 = 200809 ; pub const _POSIX_FSYNC : u32 = 200809 ; pub const _POSIX_MAPPED_FILES : u32 = 200809 ; pub const _POSIX_MEMLOCK : u32 = 200809 ; pub const _POSIX_MEMLOCK_RANGE : u32 = 200809 ; pub const _POSIX_MEMORY_PROTECTION : u32 = 200809 ; pub const _POSIX_CHOWN_RESTRICTED : u32 = 0 ; pub const _POSIX_VDISABLE : u8 = 0u8 ; pub const _POSIX_NO_TRUNC : u32 = 1 ; pub const _XOPEN_REALTIME : u32 = 1 ; pub const _XOPEN_REALTIME_THREADS : u32 = 1 ; pub const _XOPEN_SHM : u32 = 1 ; pub const _POSIX_THREADS : u32 = 200809 ; pub const _POSIX_REENTRANT_FUNCTIONS : u32 = 1 ; pub const _POSIX_THREAD_SAFE_FUNCTIONS : u32 = 200809 ; pub const _POSIX_THREAD_PRIORITY_SCHEDULING : u32 = 200809 ; pub const _POSIX_THREAD_ATTR_STACKSIZE : u32 = 200809 ; pub const _POSIX_THREAD_ATTR_STACKADDR : u32 = 200809 ; pub const _POSIX_THREAD_PRIO_INHERIT : u32 = 200809 ; pub const _POSIX_THREAD_PRIO_PROTECT : u32 = 200809 ; pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT : u32 = 200809 ; pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT : i32 = - 1 ; pub const _POSIX_SEMAPHORES : u32 = 200809 ; pub const _POSIX_REALTIME_SIGNALS : u32 = 200809 ; pub const _POSIX_ASYNCHRONOUS_IO : u32 = 200809 ; pub const _POSIX_ASYNC_IO : u32 = 1 ; pub const _LFS_ASYNCHRONOUS_IO : u32 = 1 ; pub const _POSIX_PRIORITIZED_IO : u32 = 200809 ; pub const _LFS64_ASYNCHRONOUS_IO : u32 = 1 ; pub const _LFS_LARGEFILE : u32 = 1 ; pub const _LFS64_LARGEFILE : u32 = 1 ; pub const _LFS64_STDIO : u32 = 1 ; pub const _POSIX_SHARED_MEMORY_OBJECTS : u32 = 200809 ; pub const _POSIX_CPUTIME : u32 = 0 ; pub const _POSIX_THREAD_CPUTIME : u32 = 0 ; pub const _POSIX_REGEXP : u32 = 1 ; pub const _POSIX_READER_WRITER_LOCKS : u32 = 200809 ; pub const _POSIX_SHELL : u32 = 1 ; pub const _POSIX_TIMEOUTS : u32 = 200809 ; pub const _POSIX_SPIN_LOCKS : u32 = 200809 ; pub const _POSIX_SPAWN : u32 = 200809 ; pub const _POSIX_TIMERS : u32 = 200809 ; pub const _POSIX_BARRIERS : u32 = 200809 ; pub const _POSIX_MESSAGE_PASSING : u32 = 200809 ; pub const _POSIX_THREAD_PROCESS_SHARED : u32 = 200809 ; pub const _POSIX_MONOTONIC_CLOCK : u32 = 0 ; pub const _POSIX_CLOCK_SELECTION : u32 = 200809 ; pub const _POSIX_ADVISORY_INFO : u32 = 200809 ; pub const _POSIX_IPV6 : u32 = 200809 ; pub const _POSIX_RAW_SOCKETS : u32 = 200809 ; pub const _POSIX2_CHAR_TERM : u32 = 200809 ; pub const _POSIX_SPORADIC_SERVER : i32 = - 1 ; pub const _POSIX_THREAD_SPORADIC_SERVER : i32 = - 1 ; pub const _POSIX_TRACE : i32 = - 1 ; pub const _POSIX_TRACE_EVENT_FILTER : i32 = - 1 ; pub const _POSIX_TRACE_INHERIT : i32 = - 1 ; pub const _POSIX_TRACE_LOG : i32 = - 1 ; pub const _POSIX_TYPED_MEMORY_OBJECTS : i32 = - 1 ; pub const _POSIX_V7_LPBIG_OFFBIG : i32 = - 1 ; pub const _POSIX_V6_LPBIG_OFFBIG : i32 = - 1 ; pub const _XBS5_LPBIG_OFFBIG : i32 = - 1 ; pub const _POSIX_V7_LP64_OFF64 : u32 = 1 ; pub const _POSIX_V6_LP64_OFF64 : u32 = 1 ; pub const _XBS5_LP64_OFF64 : u32 = 1 ; pub const __ILP32_OFF32_CFLAGS : & [u8 ; 5] = b"-m32\0" ; pub const __ILP32_OFF32_LDFLAGS : & [u8 ; 5] = b"-m32\0" ; pub const __ILP32_OFFBIG_CFLAGS : & [u8 ; 48] = b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0" ; pub const __ILP32_OFFBIG_LDFLAGS : & [u8 ; 5] = b"-m32\0" ; pub const __LP64_OFF64_CFLAGS : & [u8 ; 5] = b"-m64\0" ; pub const __LP64_OFF64_LDFLAGS : & [u8 ; 5] = b"-m64\0" ; pub const STDIN_FILENO : u32 = 0 ; pub const STDOUT_FILENO : u32 = 1 ; pub const STDERR_FILENO : u32 = 2 ; pub const R_OK : u32 = 4 ; pub const W_OK : u32 = 2 ; pub const X_OK : u32 = 1 ; pub const F_OK : u32 = 0 ; pub const SEEK_SET : u32 = 0 ; pub const SEEK_CUR : u32 = 1 ; pub const SEEK_END : u32 = 2 ; pub const L_SET : u32 = 0 ; pub const L_INCR : u32 = 1 ; pub const L_XTND : u32 = 2 ; pub const _GETOPT_POSIX_H : u32 = 1 ; pub const _GETOPT_CORE_H : u32 = 1 ; pub const F_ULOCK : u32 = 0 ; pub const F_LOCK : u32 = 1 ; pub const F_TLOCK : u32 = 2 ; pub const F_TEST : u32 = 3 ; pub const G_DEBUG_CONTROLLER_EXTENSION_POINT_NAME : & [u8 ; 21] = b"gio-debug-controller\0" ; pub const G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE : & [u8 ; 12] = b"unix-device\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_TYPE : & [u8 ; 15] = b"standard::type\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN : & [u8 ; 20] = b"standard::is-hidden\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP : & [u8 ; 20] = b"standard::is-backup\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK : & [u8 ; 21] = b"standard::is-symlink\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL : & [u8 ; 21] = b"standard::is-virtual\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE : & [u8 ; 22] = b"standard::is-volatile\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_NAME : & [u8 ; 15] = b"standard::name\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME : & [u8 ; 23] = b"standard::display-name\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME : & [u8 ; 20] = b"standard::edit-name\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_COPY_NAME : & [u8 ; 20] = b"standard::copy-name\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION : & [u8 ; 22] = b"standard::description\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_ICON : & [u8 ; 15] = b"standard::icon\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON : & [u8 ; 24] = b"standard::symbolic-icon\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE : & [u8 ; 23] = b"standard::content-type\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE : & [u8 ; 28] = b"standard::fast-content-type\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_SIZE : & [u8 ; 15] = b"standard::size\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE : & [u8 ; 25] = b"standard::allocated-size\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET : & [u8 ; 25] = b"standard::symlink-target\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_TARGET_URI : & [u8 ; 21] = b"standard::target-uri\0" ; pub const G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER : & [u8 ; 21] = b"standard::sort-order\0" ; pub const G_FILE_ATTRIBUTE_ETAG_VALUE : & [u8 ; 12] = b"etag::value\0" ; pub const G_FILE_ATTRIBUTE_ID_FILE : & [u8 ; 9] = b"id::file\0" ; pub const G_FILE_ATTRIBUTE_ID_FILESYSTEM : & [u8 ; 15] = b"id::filesystem\0" ; pub const G_FILE_ATTRIBUTE_ACCESS_CAN_READ : & [u8 ; 17] = b"access::can-read\0" ; pub const G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE : & [u8 ; 18] = b"access::can-write\0" ; pub const G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE : & [u8 ; 20] = b"access::can-execute\0" ; pub const G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE : & [u8 ; 19] = b"access::can-delete\0" ; pub const G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH : & [u8 ; 18] = b"access::can-trash\0" ; pub const G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME : & [u8 ; 19] = b"access::can-rename\0" ; pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT : & [u8 ; 21] = b"mountable::can-mount\0" ; pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT : & [u8 ; 23] = b"mountable::can-unmount\0" ; pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT : & [u8 ; 21] = b"mountable::can-eject\0" ; pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE : & [u8 ; 23] = b"mountable::unix-device\0" ; pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE : & [u8 ; 28] = b"mountable::unix-device-file\0" ; pub const G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI : & [u8 ; 19] = b"mountable::hal-udi\0" ; pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START : & [u8 ; 21] = b"mountable::can-start\0" ; pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED : & [u8 ; 30] = b"mountable::can-start-degraded\0" ; pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP : & [u8 ; 20] = b"mountable::can-stop\0" ; pub const G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE : & [u8 ; 27] = b"mountable::start-stop-type\0" ; pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL : & [u8 ; 20] = b"mountable::can-poll\0" ; pub const G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC : & [u8 ; 36] = b"mountable::is-media-check-automatic\0" ; pub const G_FILE_ATTRIBUTE_TIME_MODIFIED : & [u8 ; 15] = b"time::modified\0" ; pub const G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC : & [u8 ; 20] = b"time::modified-usec\0" ; pub const G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC : & [u8 ; 20] = b"time::modified-nsec\0" ; pub const G_FILE_ATTRIBUTE_TIME_ACCESS : & [u8 ; 13] = b"time::access\0" ; pub const G_FILE_ATTRIBUTE_TIME_ACCESS_USEC : & [u8 ; 18] = b"time::access-usec\0" ; pub const G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC : & [u8 ; 18] = b"time::access-nsec\0" ; pub const G_FILE_ATTRIBUTE_TIME_CHANGED : & [u8 ; 14] = b"time::changed\0" ; pub const G_FILE_ATTRIBUTE_TIME_CHANGED_USEC : & [u8 ; 19] = b"time::changed-usec\0" ; pub const G_FILE_ATTRIBUTE_TIME_CHANGED_NSEC : & [u8 ; 19] = b"time::changed-nsec\0" ; pub const G_FILE_ATTRIBUTE_TIME_CREATED : & [u8 ; 14] = b"time::created\0" ; pub const G_FILE_ATTRIBUTE_TIME_CREATED_USEC : & [u8 ; 19] = b"time::created-usec\0" ; pub const G_FILE_ATTRIBUTE_TIME_CREATED_NSEC : & [u8 ; 19] = b"time::created-nsec\0" ; pub const G_FILE_ATTRIBUTE_UNIX_DEVICE : & [u8 ; 13] = b"unix::device\0" ; pub const G_FILE_ATTRIBUTE_UNIX_INODE : & [u8 ; 12] = b"unix::inode\0" ; pub const G_FILE_ATTRIBUTE_UNIX_MODE : & [u8 ; 11] = b"unix::mode\0" ; pub const G_FILE_ATTRIBUTE_UNIX_NLINK : & [u8 ; 12] = b"unix::nlink\0" ; pub const G_FILE_ATTRIBUTE_UNIX_UID : & [u8 ; 10] = b"unix::uid\0" ; pub const G_FILE_ATTRIBUTE_UNIX_GID : & [u8 ; 10] = b"unix::gid\0" ; pub const G_FILE_ATTRIBUTE_UNIX_RDEV : & [u8 ; 11] = b"unix::rdev\0" ; pub const G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE : & [u8 ; 17] = b"unix::block-size\0" ; pub const G_FILE_ATTRIBUTE_UNIX_BLOCKS : & [u8 ; 13] = b"unix::blocks\0" ; pub const G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT : & [u8 ; 20] = b"unix::is-mountpoint\0" ; pub const G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE : & [u8 ; 16] = b"dos::is-archive\0" ; pub const G_FILE_ATTRIBUTE_DOS_IS_SYSTEM : & [u8 ; 15] = b"dos::is-system\0" ; pub const G_FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT : & [u8 ; 19] = b"dos::is-mountpoint\0" ; pub const G_FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG : & [u8 ; 23] = b"dos::reparse-point-tag\0" ; pub const G_FILE_ATTRIBUTE_OWNER_USER : & [u8 ; 12] = b"owner::user\0" ; pub const G_FILE_ATTRIBUTE_OWNER_USER_REAL : & [u8 ; 17] = b"owner::user-real\0" ; pub const G_FILE_ATTRIBUTE_OWNER_GROUP : & [u8 ; 13] = b"owner::group\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH : & [u8 ; 16] = b"thumbnail::path\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED : & [u8 ; 18] = b"thumbnail::failed\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID : & [u8 ; 20] = b"thumbnail::is-valid\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_NORMAL : & [u8 ; 23] = b"thumbnail::path-normal\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL : & [u8 ; 25] = b"thumbnail::failed-normal\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_NORMAL : & [u8 ; 27] = b"thumbnail::is-valid-normal\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_LARGE : & [u8 ; 22] = b"thumbnail::path-large\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE : & [u8 ; 24] = b"thumbnail::failed-large\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_LARGE : & [u8 ; 26] = b"thumbnail::is-valid-large\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_XLARGE : & [u8 ; 23] = b"thumbnail::path-xlarge\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE : & [u8 ; 25] = b"thumbnail::failed-xlarge\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XLARGE : & [u8 ; 27] = b"thumbnail::is-valid-xlarge\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_XXLARGE : & [u8 ; 24] = b"thumbnail::path-xxlarge\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE : & [u8 ; 26] = b"thumbnail::failed-xxlarge\0" ; pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XXLARGE : & [u8 ; 28] = b"thumbnail::is-valid-xxlarge\0" ; pub const G_FILE_ATTRIBUTE_PREVIEW_ICON : & [u8 ; 14] = b"preview::icon\0" ; pub const G_FILE_ATTRIBUTE_FILESYSTEM_SIZE : & [u8 ; 17] = b"filesystem::size\0" ; pub const G_FILE_ATTRIBUTE_FILESYSTEM_FREE : & [u8 ; 17] = b"filesystem::free\0" ; pub const G_FILE_ATTRIBUTE_FILESYSTEM_USED : & [u8 ; 17] = b"filesystem::used\0" ; pub const G_FILE_ATTRIBUTE_FILESYSTEM_TYPE : & [u8 ; 17] = b"filesystem::type\0" ; pub const G_FILE_ATTRIBUTE_FILESYSTEM_READONLY : & [u8 ; 21] = b"filesystem::readonly\0" ; pub const G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW : & [u8 ; 24] = b"filesystem::use-preview\0" ; pub const G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE : & [u8 ; 19] = b"filesystem::remote\0" ; pub const G_FILE_ATTRIBUTE_GVFS_BACKEND : & [u8 ; 14] = b"gvfs::backend\0" ; pub const G_FILE_ATTRIBUTE_SELINUX_CONTEXT : & [u8 ; 17] = b"selinux::context\0" ; pub const G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT : & [u8 ; 18] = b"trash::item-count\0" ; pub const G_FILE_ATTRIBUTE_TRASH_ORIG_PATH : & [u8 ; 17] = b"trash::orig-path\0" ; pub const G_FILE_ATTRIBUTE_TRASH_DELETION_DATE : & [u8 ; 21] = b"trash::deletion-date\0" ; pub const G_FILE_ATTRIBUTE_RECENT_MODIFIED : & [u8 ; 17] = b"recent::modified\0" ; pub const G_MEMORY_MONITOR_EXTENSION_POINT_NAME : & [u8 ; 19] = b"gio-memory-monitor\0" ; pub const G_MENU_ATTRIBUTE_ACTION : & [u8 ; 7] = b"action\0" ; pub const G_MENU_ATTRIBUTE_ACTION_NAMESPACE : & [u8 ; 17] = b"action-namespace\0" ; pub const G_MENU_ATTRIBUTE_TARGET : & [u8 ; 7] = b"target\0" ; pub const G_MENU_ATTRIBUTE_LABEL : & [u8 ; 6] = b"label\0" ; pub const G_MENU_ATTRIBUTE_ICON : & [u8 ; 5] = b"icon\0" ; pub const G_MENU_LINK_SUBMENU : & [u8 ; 8] = b"submenu\0" ; pub const G_MENU_LINK_SECTION : & [u8 ; 8] = b"section\0" ; pub const G_VOLUME_MONITOR_EXTENSION_POINT_NAME : & [u8 ; 19] = b"gio-volume-monitor\0" ; pub const G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME : & [u8 ; 26] = b"gio-native-volume-monitor\0" ; pub const G_NETWORK_MONITOR_EXTENSION_POINT_NAME : & [u8 ; 20] = b"gio-network-monitor\0" ; pub const G_POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME : & [u8 ; 26] = b"gio-power-profile-monitor\0" ; pub const G_PROXY_EXTENSION_POINT_NAME : & [u8 ; 10] = b"gio-proxy\0" ; pub const G_PROXY_RESOLVER_EXTENSION_POINT_NAME : & [u8 ; 19] = b"gio-proxy-resolver\0" ; pub const G_TLS_BACKEND_EXTENSION_POINT_NAME : & [u8 ; 16] = b"gio-tls-backend\0" ; pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER : & [u8 ; 18] = b"1.3.6.1.5.5.7.3.1\0" ; pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT : & [u8 ; 18] = b"1.3.6.1.5.5.7.3.2\0" ; pub const G_VFS_EXTENSION_POINT_NAME : & [u8 ; 8] = b"gio-vfs\0" ; pub const G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE : & [u8 ; 12] = b"unix-device\0" ; pub const G_VOLUME_IDENTIFIER_KIND_LABEL : & [u8 ; 6] = b"label\0" ; pub const G_VOLUME_IDENTIFIER_KIND_UUID : & [u8 ; 5] = b"uuid\0" ; pub const G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT : & [u8 ; 10] = b"nfs-mount\0" ; pub const G_VOLUME_IDENTIFIER_KIND_CLASS : & [u8 ; 6] = b"class\0" ; pub const PK_BITFIELD_FORMAT : & [u8 ; 3] = b"lu\0" ; pub const PK_DBUS_SERVICE : & [u8 ; 27] = b"org.freedesktop.PackageKit\0" ; pub const PK_DBUS_PATH : & [u8 ; 28] = b"/org/freedesktop/PackageKit\0" ; pub const PK_DBUS_INTERFACE : & [u8 ; 27] = b"org.freedesktop.PackageKit\0" ; pub const PK_DBUS_INTERFACE_TRANSACTION : & [u8 ; 39] = b"org.freedesktop.PackageKit.Transaction\0" ; pub const PK_DBUS_INTERFACE_OFFLINE : & [u8 ; 35] = b"org.freedesktop.PackageKit.Offline\0" ; pub const PK_SYSTEM_PACKAGE_LIST_FILENAME : & [u8 ; 40] = b"/var/lib/PackageKit/system.package-list\0" ; pub const PK_SYSTEM_PACKAGE_CACHE_FILENAME : & [u8 ; 37] = b"/var/lib/PackageKit/package-cache.db\0" ; pub const PK_DESKTOP_DEFAULT_APPLICATION_DIR : & [u8 ; 24] = b"/usr/share/applications\0" ; pub const PK_PACKAGE_ID_NAME : u32 = 0 ; pub const PK_PACKAGE_ID_VERSION : u32 = 1 ; pub const PK_PACKAGE_ID_ARCH : u32 = 2 ; pub const PK_PACKAGE_ID_DATA : u32 = 3 ; pub const PK_PACKAGE_IDS_DELIM : & [u8 ; 2] = b"&\0" ; pub const PK_MAJOR_VERSION : u32 = 1 ; pub const PK_MINOR_VERSION : u32 = 3 ; pub const PK_MICRO_VERSION : u32 = 2 ; pub const PK_BACKEND_SPAWN_FILENAME_DELIM : & [u8 ; 2] = b"|\0" ; pub const PK_BACKEND_PERCENTAGE_INVALID : u32 = 101 ; pub type wchar_t = :: std :: os :: raw :: c_int ; # [repr (C)] # [repr (align (16))] # [derive (Debug , Copy , Clone)] pub struct max_align_t { pub __clang_max_align_nonce1 : :: std :: os :: raw :: c_longlong , pub __bindgen_padding_0 : u64 , pub __clang_max_align_nonce2 : u128 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of max_align_t"] [:: std :: mem :: size_of :: < max_align_t > () - 32usize] ; ["Alignment of max_align_t"] [:: std :: mem :: align_of :: < max_align_t > () - 16usize] ; ["Offset of field: max_align_t::__clang_max_align_nonce1"] [:: std :: mem :: offset_of ! (max_align_t , __clang_max_align_nonce1) - 0usize] ; ["Offset of field: max_align_t::__clang_max_align_nonce2"] [:: std :: mem :: offset_of ! (max_align_t , __clang_max_align_nonce2) - 16usize] ; } ; pub type gint8 = :: std :: os :: raw :: c_schar ; pub type guint8 = :: std :: os :: raw :: c_uchar ; pub type gint16 = :: std :: os :: raw :: c_short ; pub type guint16 = :: std :: os :: raw :: c_ushort ; pub type gint32 = :: std :: os :: raw :: c_int ; pub type guint32 = :: std :: os :: raw :: c_uint ; pub type gint64 = :: std :: os :: raw :: c_long ; pub type guint64 = :: std :: os :: raw :: c_ulong ; pub type gssize = :: std :: os :: raw :: c_long ; pub type gsize = :: std :: os :: raw :: c_ulong ; pub type goffset = gint64 ; pub type gintptr = :: std :: os :: raw :: c_long ; pub type guintptr = :: std :: os :: raw :: c_ulong ; pub type GPid = :: std :: os :: raw :: c_int ; pub type __u_char = :: std :: os :: raw :: c_uchar ; pub type __u_short = :: std :: os :: raw :: c_ushort ; pub type __u_int = :: std :: os :: raw :: c_uint ; pub type __u_long = :: std :: os :: raw :: c_ulong ; pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __int16_t = :: std :: os :: raw :: c_short ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub type __int_least8_t = __int8_t ; pub type __uint_least8_t = __uint8_t ; pub type __int_least16_t = __int16_t ; pub type __uint_least16_t = __uint16_t ; pub type __int_least32_t = __int32_t ; pub type __uint_least32_t = __uint32_t ; pub type __int_least64_t = __int64_t ; pub type __uint_least64_t = __uint64_t ; pub type __quad_t = :: std :: os :: raw :: c_long ; pub type __u_quad_t = :: std :: os :: raw :: c_ulong ; pub type __intmax_t = :: std :: os :: raw :: c_long ; pub type __uintmax_t = :: std :: os :: raw :: c_ulong ; pub type __dev_t = :: std :: os :: raw :: c_ulong ; pub type __uid_t = :: std :: os :: raw :: c_uint ; pub type __gid_t = :: std :: os :: raw :: c_uint ; pub type __ino_t = :: std :: os :: raw :: c_ulong ; pub type __ino64_t = :: std :: os :: raw :: c_ulong ; pub type __mode_t = :: std :: os :: raw :: c_uint ; pub type __nlink_t = :: std :: os :: raw :: c_ulong ; pub type __off_t = :: std :: os :: raw :: c_long ; pub type __off64_t = :: std :: os :: raw :: c_long ; pub type __pid_t = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __fsid_t { pub __val : [:: std :: os :: raw :: c_int ; 2usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __fsid_t"] [:: std :: mem :: size_of :: < __fsid_t > () - 8usize] ; ["Alignment of __fsid_t"] [:: std :: mem :: align_of :: < __fsid_t > () - 4usize] ; ["Offset of field: __fsid_t::__val"] [:: std :: mem :: offset_of ! (__fsid_t , __val) - 0usize] ; } ; pub type __clock_t = :: std :: os :: raw :: c_long ; pub type __rlim_t = :: std :: os :: raw :: c_ulong ; pub type __rlim64_t = :: std :: os :: raw :: c_ulong ; pub type __id_t = :: std :: os :: raw :: c_uint ; pub type __time_t = :: std :: os :: raw :: c_long ; pub type __useconds_t = :: std :: os :: raw :: c_uint ; pub type __suseconds_t = :: std :: os :: raw :: c_long ; pub type __suseconds64_t = :: std :: os :: raw :: c_long ; pub type __daddr_t = :: std :: os :: raw :: c_int ; pub type __key_t = :: std :: os :: raw :: c_int ; pub type __clockid_t = :: std :: os :: raw :: c_int ; pub type __timer_t = * mut :: std :: os :: raw :: c_void ; pub type __blksize_t = :: std :: os :: raw :: c_long ; pub type __blkcnt_t = :: std :: os :: raw :: c_long ; pub type __blkcnt64_t = :: std :: os :: raw :: c_long ; pub type __fsblkcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsblkcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsword_t = :: std :: os :: raw :: c_long ; pub type __ssize_t = :: std :: os :: raw :: c_long ; pub type __syscall_slong_t = :: std :: os :: raw :: c_long ; pub type __syscall_ulong_t = :: std :: os :: raw :: c_ulong ; pub type __loff_t = __off64_t ; pub type __caddr_t = * mut :: std :: os :: raw :: c_char ; pub type __intptr_t = :: std :: os :: raw :: c_long ; pub type __socklen_t = :: std :: os :: raw :: c_uint ; pub type __sig_atomic_t = :: std :: os :: raw :: c_int ; pub type clock_t = __clock_t ; pub type time_t = __time_t ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct tm { pub tm_sec : :: std :: os :: raw :: c_int , pub tm_min : :: std :: os :: raw :: c_int , pub tm_hour : :: std :: os :: raw :: c_int , pub tm_mday : :: std :: os :: raw :: c_int , pub tm_mon : :: std :: os :: raw :: c_int , pub tm_year : :: std :: os :: raw :: c_int , pub tm_wday : :: std :: os :: raw :: c_int , pub tm_yday : :: std :: os :: raw :: c_int , pub tm_isdst : :: std :: os :: raw :: c_int , pub tm_gmtoff : :: std :: os :: raw :: c_long , pub tm_zone : * const :: std :: os :: raw :: c_char , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of tm"] [:: std :: mem :: size_of :: < tm > () - 56usize] ; ["Alignment of tm"] [:: std :: mem :: align_of :: < tm > () - 8usize] ; ["Offset of field: tm::tm_sec"] [:: std :: mem :: offset_of ! (tm , tm_sec) - 0usize] ; ["Offset of field: tm::tm_min"] [:: std :: mem :: offset_of ! (tm , tm_min) - 4usize] ; ["Offset of field: tm::tm_hour"] [:: std :: mem :: offset_of ! (tm , tm_hour) - 8usize] ; ["Offset of field: tm::tm_mday"] [:: std :: mem :: offset_of ! (tm , tm_mday) - 12usize] ; ["Offset of field: tm::tm_mon"] [:: std :: mem :: offset_of ! (tm , tm_mon) - 16usize] ; ["Offset of field: tm::tm_year"] [:: std :: mem :: offset_of ! (tm , tm_year) - 20usize] ; ["Offset of field: tm::tm_wday"] [:: std :: mem :: offset_of ! (tm , tm_wday) - 24usize] ; ["Offset of field: tm::tm_yday"] [:: std :: mem :: offset_of ! (tm , tm_yday) - 28usize] ; ["Offset of field: tm::tm_isdst"] [:: std :: mem :: offset_of ! (tm , tm_isdst) - 32usize] ; ["Offset of field: tm::tm_gmtoff"] [:: std :: mem :: offset_of ! (tm , tm_gmtoff) - 40usize] ; ["Offset of field: tm::tm_zone"] [:: std :: mem :: offset_of ! (tm , tm_zone) - 48usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct timespec { pub tv_sec : __time_t , pub tv_nsec : __syscall_slong_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of timespec"] [:: std :: mem :: size_of :: < timespec > () - 16usize] ; ["Alignment of timespec"] [:: std :: mem :: align_of :: < timespec > () - 8usize] ; ["Offset of field: timespec::tv_sec"] [:: std :: mem :: offset_of ! (timespec , tv_sec) - 0usize] ; ["Offset of field: timespec::tv_nsec"] [:: std :: mem :: offset_of ! (timespec , tv_nsec) - 8usize] ; } ; pub type clockid_t = __clockid_t ; pub type timer_t = __timer_t ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct itimerspec { pub it_interval : timespec , pub it_value : timespec , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of itimerspec"] [:: std :: mem :: size_of :: < itimerspec > () - 32usize] ; ["Alignment of itimerspec"] [:: std :: mem :: align_of :: < itimerspec > () - 8usize] ; ["Offset of field: itimerspec::it_interval"] [:: std :: mem :: offset_of ! (itimerspec , it_interval) - 0usize] ; ["Offset of field: itimerspec::it_value"] [:: std :: mem :: offset_of ! (itimerspec , it_value) - 16usize] ; } ; pub type pid_t = __pid_t ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __locale_struct { pub __locales : [* mut __locale_data ; 13usize] , pub __ctype_b : * const :: std :: os :: raw :: c_ushort , pub __ctype_tolower : * const :: std :: os :: raw :: c_int , pub __ctype_toupper : * const :: std :: os :: raw :: c_int , pub __names : [* const :: std :: os :: raw :: c_char ; 13usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __locale_struct"] [:: std :: mem :: size_of :: < __locale_struct > () - 232usize] ; ["Alignment of __locale_struct"] [:: std :: mem :: align_of :: < __locale_struct > () - 8usize] ; ["Offset of field: __locale_struct::__locales"] [:: std :: mem :: offset_of ! (__locale_struct , __locales) - 0usize] ; ["Offset of field: __locale_struct::__ctype_b"] [:: std :: mem :: offset_of ! (__locale_struct , __ctype_b) - 104usize] ; ["Offset of field: __locale_struct::__ctype_tolower"] [:: std :: mem :: offset_of ! (__locale_struct , __ctype_tolower) - 112usize] ; ["Offset of field: __locale_struct::__ctype_toupper"] [:: std :: mem :: offset_of ! (__locale_struct , __ctype_toupper) - 120usize] ; ["Offset of field: __locale_struct::__names"] [:: std :: mem :: offset_of ! (__locale_struct , __names) - 128usize] ; } ; pub type __locale_t = * mut __locale_struct ; pub type locale_t = __locale_t ; unsafe extern "C" { pub fn clock () -> clock_t ; } unsafe extern "C" { pub fn time (__timer : * mut time_t) -> time_t ; } unsafe extern "C" { pub fn difftime (__time1 : time_t , __time0 : time_t) -> f64 ; } unsafe extern "C" { pub fn mktime (__tp : * mut tm) -> time_t ; } unsafe extern "C" { pub fn strftime (__s : * mut :: std :: os :: raw :: c_char , __maxsize : usize , __format : * const :: std :: os :: raw :: c_char , __tp : * const tm) -> usize ; } unsafe extern "C" { pub fn strftime_l (__s : * mut :: std :: os :: raw :: c_char , __maxsize : usize , __format : * const :: std :: os :: raw :: c_char , __tp : * const tm , __loc : locale_t) -> usize ; } unsafe extern "C" { pub fn gmtime (__timer : * const time_t) -> * mut tm ; } unsafe extern "C" { pub fn localtime (__timer : * const time_t) -> * mut tm ; } unsafe extern "C" { pub fn gmtime_r (__timer : * const time_t , __tp : * mut tm) -> * mut tm ; } unsafe extern "C" { pub fn localtime_r (__timer : * const time_t , __tp : * mut tm) -> * mut tm ; } unsafe extern "C" { pub fn asctime (__tp : * const tm) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ctime (__timer : * const time_t) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn asctime_r (__tp : * const tm , __buf : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ctime_r (__timer : * const time_t , __buf : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub static mut __tzname : [* mut :: std :: os :: raw :: c_char ; 2usize] ; } unsafe extern "C" { pub static mut __daylight : :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub static mut __timezone : :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub static mut tzname : [* mut :: std :: os :: raw :: c_char ; 2usize] ; } unsafe extern "C" { pub fn tzset () ; } unsafe extern "C" { pub static mut daylight : :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub static mut timezone : :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn timegm (__tp : * mut tm) -> time_t ; } unsafe extern "C" { pub fn timelocal (__tp : * mut tm) -> time_t ; } unsafe extern "C" { pub fn dysize (__year : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn nanosleep (__requested_time : * const timespec , __remaining : * mut timespec) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn clock_getres (__clock_id : clockid_t , __res : * mut timespec) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn clock_gettime (__clock_id : clockid_t , __tp : * mut timespec) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn clock_settime (__clock_id : clockid_t , __tp : * const timespec) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn clock_nanosleep (__clock_id : clockid_t , __flags : :: std :: os :: raw :: c_int , __req : * const timespec , __rem : * mut timespec) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn clock_getcpuclockid (__pid : pid_t , __clock_id : * mut clockid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn timer_create (__clock_id : clockid_t , __evp : * mut sigevent , __timerid : * mut timer_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn timer_delete (__timerid : timer_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn timer_settime (__timerid : timer_t , __flags : :: std :: os :: raw :: c_int , __value : * const itimerspec , __ovalue : * mut itimerspec) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn timer_gettime (__timerid : timer_t , __value : * mut itimerspec) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn timer_getoverrun (__timerid : timer_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn timespec_get (__ts : * mut timespec , __base : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } pub type gchar = :: std :: os :: raw :: c_char ; pub type gshort = :: std :: os :: raw :: c_short ; pub type glong = :: std :: os :: raw :: c_long ; pub type gint = :: std :: os :: raw :: c_int ; pub type gboolean = gint ; pub type guchar = :: std :: os :: raw :: c_uchar ; pub type gushort = :: std :: os :: raw :: c_ushort ; pub type gulong = :: std :: os :: raw :: c_ulong ; pub type guint = :: std :: os :: raw :: c_uint ; pub type gfloat = f32 ; pub type gdouble = f64 ; pub type gpointer = * mut :: std :: os :: raw :: c_void ; pub type gconstpointer = * const :: std :: os :: raw :: c_void ; pub type GCompareFunc = :: std :: option :: Option < unsafe extern "C" fn (a : gconstpointer , b : gconstpointer) -> gint > ; pub type GCompareDataFunc = :: std :: option :: Option < unsafe extern "C" fn (a : gconstpointer , b : gconstpointer , user_data : gpointer) -> gint > ; pub type GEqualFunc = :: std :: option :: Option < unsafe extern "C" fn (a : gconstpointer , b : gconstpointer) -> gboolean > ; pub type GEqualFuncFull = :: std :: option :: Option < unsafe extern "C" fn (a : gconstpointer , b : gconstpointer , user_data : gpointer) -> gboolean > ; pub type GDestroyNotify = :: std :: option :: Option < unsafe extern "C" fn (data : gpointer) > ; pub type GFunc = :: std :: option :: Option < unsafe extern "C" fn (data : gpointer , user_data : gpointer) > ; pub type GHashFunc = :: std :: option :: Option < unsafe extern "C" fn (key : gconstpointer) -> guint > ; pub type GHFunc = :: std :: option :: Option < unsafe extern "C" fn (key : gpointer , value : gpointer , user_data : gpointer) > ; pub type GCopyFunc = :: std :: option :: Option < unsafe extern "C" fn (src : gconstpointer , data : gpointer) -> gpointer > ; pub type GFreeFunc = :: std :: option :: Option < unsafe extern "C" fn (data : gpointer) > ; pub type GTranslateFunc = :: std :: option :: Option < unsafe extern "C" fn (str_ : * const gchar , data : gpointer) -> * const gchar > ; pub type GDoubleIEEE754 = _GDoubleIEEE754 ; pub type GFloatIEEE754 = _GFloatIEEE754 ; # [repr (C)] # [derive (Copy , Clone)] pub union _GFloatIEEE754 { pub v_float : gfloat , pub mpn : _GFloatIEEE754__bindgen_ty_1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFloatIEEE754__bindgen_ty_1 { pub _bitfield_align_1 : [u32 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 4usize] > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFloatIEEE754__bindgen_ty_1"] [:: std :: mem :: size_of :: < _GFloatIEEE754__bindgen_ty_1 > () - 4usize] ; ["Alignment of _GFloatIEEE754__bindgen_ty_1"] [:: std :: mem :: align_of :: < _GFloatIEEE754__bindgen_ty_1 > () - 4usize] ; } ; impl _GFloatIEEE754__bindgen_ty_1 { # [inline] pub fn mantissa (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 23u8) as u32) } } # [inline] pub fn set_mantissa (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 23u8 , val as u64) } } # [inline] pub unsafe fn mantissa_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 0usize , 23u8 ,) as u32) } } # [inline] pub unsafe fn set_mantissa_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 0usize , 23u8 , val as u64 ,) } } # [inline] pub fn biased_exponent (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (23usize , 8u8) as u32) } } # [inline] pub fn set_biased_exponent (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (23usize , 8u8 , val as u64) } } # [inline] pub unsafe fn biased_exponent_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 23usize , 8u8 ,) as u32) } } # [inline] pub unsafe fn set_biased_exponent_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 23usize , 8u8 , val as u64 ,) } } # [inline] pub fn sign (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (31usize , 1u8) as u32) } } # [inline] pub fn set_sign (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (31usize , 1u8 , val as u64) } } # [inline] pub unsafe fn sign_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 31usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_sign_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 31usize , 1u8 , val as u64 ,) } } # [inline] pub fn new_bitfield_1 (mantissa : guint , biased_exponent : guint , sign : guint) -> __BindgenBitfieldUnit < [u8 ; 4usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 4usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 23u8 , { let mantissa : u32 = unsafe { :: std :: mem :: transmute (mantissa) } ; mantissa as u64 }) ; __bindgen_bitfield_unit . set (23usize , 8u8 , { let biased_exponent : u32 = unsafe { :: std :: mem :: transmute (biased_exponent) } ; biased_exponent as u64 }) ; __bindgen_bitfield_unit . set (31usize , 1u8 , { let sign : u32 = unsafe { :: std :: mem :: transmute (sign) } ; sign as u64 }) ; __bindgen_bitfield_unit } } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFloatIEEE754"] [:: std :: mem :: size_of :: < _GFloatIEEE754 > () - 4usize] ; ["Alignment of _GFloatIEEE754"] [:: std :: mem :: align_of :: < _GFloatIEEE754 > () - 4usize] ; ["Offset of field: _GFloatIEEE754::v_float"] [:: std :: mem :: offset_of ! (_GFloatIEEE754 , v_float) - 0usize] ; ["Offset of field: _GFloatIEEE754::mpn"] [:: std :: mem :: offset_of ! (_GFloatIEEE754 , mpn) - 0usize] ; } ; # [repr (C)] # [derive (Copy , Clone)] pub union _GDoubleIEEE754 { pub v_double : gdouble , pub mpn : _GDoubleIEEE754__bindgen_ty_1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDoubleIEEE754__bindgen_ty_1 { pub _bitfield_align_1 : [u32 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 8usize] > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDoubleIEEE754__bindgen_ty_1"] [:: std :: mem :: size_of :: < _GDoubleIEEE754__bindgen_ty_1 > () - 8usize] ; ["Alignment of _GDoubleIEEE754__bindgen_ty_1"] [:: std :: mem :: align_of :: < _GDoubleIEEE754__bindgen_ty_1 > () - 4usize] ; } ; impl _GDoubleIEEE754__bindgen_ty_1 { # [inline] pub fn mantissa_low (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 32u8) as u32) } } # [inline] pub fn set_mantissa_low (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 32u8 , val as u64) } } # [inline] pub unsafe fn mantissa_low_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 0usize , 32u8 ,) as u32) } } # [inline] pub unsafe fn set_mantissa_low_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 0usize , 32u8 , val as u64 ,) } } # [inline] pub fn mantissa_high (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (32usize , 20u8) as u32) } } # [inline] pub fn set_mantissa_high (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (32usize , 20u8 , val as u64) } } # [inline] pub unsafe fn mantissa_high_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 32usize , 20u8 ,) as u32) } } # [inline] pub unsafe fn set_mantissa_high_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 32usize , 20u8 , val as u64 ,) } } # [inline] pub fn biased_exponent (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (52usize , 11u8) as u32) } } # [inline] pub fn set_biased_exponent (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (52usize , 11u8 , val as u64) } } # [inline] pub unsafe fn biased_exponent_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 52usize , 11u8 ,) as u32) } } # [inline] pub unsafe fn set_biased_exponent_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 52usize , 11u8 , val as u64 ,) } } # [inline] pub fn sign (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (63usize , 1u8) as u32) } } # [inline] pub fn set_sign (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (63usize , 1u8 , val as u64) } } # [inline] pub unsafe fn sign_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 63usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_sign_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 63usize , 1u8 , val as u64 ,) } } # [inline] pub fn new_bitfield_1 (mantissa_low : guint , mantissa_high : guint , biased_exponent : guint , sign : guint) -> __BindgenBitfieldUnit < [u8 ; 8usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 8usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 32u8 , { let mantissa_low : u32 = unsafe { :: std :: mem :: transmute (mantissa_low) } ; mantissa_low as u64 }) ; __bindgen_bitfield_unit . set (32usize , 20u8 , { let mantissa_high : u32 = unsafe { :: std :: mem :: transmute (mantissa_high) } ; mantissa_high as u64 }) ; __bindgen_bitfield_unit . set (52usize , 11u8 , { let biased_exponent : u32 = unsafe { :: std :: mem :: transmute (biased_exponent) } ; biased_exponent as u64 }) ; __bindgen_bitfield_unit . set (63usize , 1u8 , { let sign : u32 = unsafe { :: std :: mem :: transmute (sign) } ; sign as u64 }) ; __bindgen_bitfield_unit } } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDoubleIEEE754"] [:: std :: mem :: size_of :: < _GDoubleIEEE754 > () - 8usize] ; ["Alignment of _GDoubleIEEE754"] [:: std :: mem :: align_of :: < _GDoubleIEEE754 > () - 8usize] ; ["Offset of field: _GDoubleIEEE754::v_double"] [:: std :: mem :: offset_of ! (_GDoubleIEEE754 , v_double) - 0usize] ; ["Offset of field: _GDoubleIEEE754::mpn"] [:: std :: mem :: offset_of ! (_GDoubleIEEE754 , mpn) - 0usize] ; } ; pub type GTimeVal = _GTimeVal ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTimeVal { pub tv_sec : glong , pub tv_usec : glong , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTimeVal"] [:: std :: mem :: size_of :: < _GTimeVal > () - 16usize] ; ["Alignment of _GTimeVal"] [:: std :: mem :: align_of :: < _GTimeVal > () - 8usize] ; ["Offset of field: _GTimeVal::tv_sec"] [:: std :: mem :: offset_of ! (_GTimeVal , tv_sec) - 0usize] ; ["Offset of field: _GTimeVal::tv_usec"] [:: std :: mem :: offset_of ! (_GTimeVal , tv_usec) - 8usize] ; } ; pub type grefcount = gint ; pub type gatomicrefcount = gint ; unsafe extern "C" { pub fn memcpy (__dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn memmove (__dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn memccpy (__dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn memset (__s : * mut :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn memcmp (__s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn __memcmpeq (__s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn memchr (__s : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn strcpy (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strncpy (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strcat (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strncat (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strcmp (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn strncmp (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn strcoll (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn strxfrm (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_ulong ; } unsafe extern "C" { pub fn strcoll_l (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __l : locale_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn strxfrm_l (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize , __l : locale_t) -> usize ; } unsafe extern "C" { pub fn strdup (__s : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strndup (__string : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strchr (__s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strrchr (__s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strchrnul (__s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strcspn (__s : * const :: std :: os :: raw :: c_char , __reject : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_ulong ; } unsafe extern "C" { pub fn strspn (__s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_ulong ; } unsafe extern "C" { pub fn strpbrk (__s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strstr (__haystack : * const :: std :: os :: raw :: c_char , __needle : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strtok (__s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn __strtok_r (__s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strtok_r (__s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strcasestr (__haystack : * const :: std :: os :: raw :: c_char , __needle : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn memmem (__haystack : * const :: std :: os :: raw :: c_void , __haystacklen : usize , __needle : * const :: std :: os :: raw :: c_void , __needlelen : usize) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn __mempcpy (__dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : usize) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn mempcpy (__dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn strlen (__s : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_ulong ; } unsafe extern "C" { pub fn strnlen (__string : * const :: std :: os :: raw :: c_char , __maxlen : usize) -> usize ; } unsafe extern "C" { pub fn strerror (__errnum : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { # [link_name = "\u{1}__xpg_strerror_r"] pub fn strerror_r (__errnum : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn strerror_l (__errnum : :: std :: os :: raw :: c_int , __l : locale_t) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn bcmp (__s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn bcopy (__src : * const :: std :: os :: raw :: c_void , __dest : * mut :: std :: os :: raw :: c_void , __n : :: std :: os :: raw :: c_ulong) ; } unsafe extern "C" { pub fn bzero (__s : * mut :: std :: os :: raw :: c_void , __n : :: std :: os :: raw :: c_ulong) ; } unsafe extern "C" { pub fn index (__s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn rindex (__s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ffs (__i : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ffsl (__l : :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ffsll (__ll : :: std :: os :: raw :: c_longlong) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn strcasecmp (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn strncasecmp (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn strcasecmp_l (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __loc : locale_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn strncasecmp_l (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize , __loc : locale_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn explicit_bzero (__s : * mut :: std :: os :: raw :: c_void , __n : usize) ; } unsafe extern "C" { pub fn strsep (__stringp : * mut * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strsignal (__sig : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn __stpcpy (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn stpcpy (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn __stpncpy (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn stpncpy (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn strlcpy (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_ulong ; } unsafe extern "C" { pub fn strlcat (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_ulong ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GBytes { _unused : [u8 ; 0] , } pub type GBytes = _GBytes ; pub type GArray = _GArray ; pub type GByteArray = _GByteArray ; pub type GPtrArray = _GPtrArray ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GArray { pub data : * mut gchar , pub len : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GArray"] [:: std :: mem :: size_of :: < _GArray > () - 16usize] ; ["Alignment of _GArray"] [:: std :: mem :: align_of :: < _GArray > () - 8usize] ; ["Offset of field: _GArray::data"] [:: std :: mem :: offset_of ! (_GArray , data) - 0usize] ; ["Offset of field: _GArray::len"] [:: std :: mem :: offset_of ! (_GArray , len) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GByteArray { pub data : * mut guint8 , pub len : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GByteArray"] [:: std :: mem :: size_of :: < _GByteArray > () - 16usize] ; ["Alignment of _GByteArray"] [:: std :: mem :: align_of :: < _GByteArray > () - 8usize] ; ["Offset of field: _GByteArray::data"] [:: std :: mem :: offset_of ! (_GByteArray , data) - 0usize] ; ["Offset of field: _GByteArray::len"] [:: std :: mem :: offset_of ! (_GByteArray , len) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPtrArray { pub pdata : * mut gpointer , pub len : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GPtrArray"] [:: std :: mem :: size_of :: < _GPtrArray > () - 16usize] ; ["Alignment of _GPtrArray"] [:: std :: mem :: align_of :: < _GPtrArray > () - 8usize] ; ["Offset of field: _GPtrArray::pdata"] [:: std :: mem :: offset_of ! (_GPtrArray , pdata) - 0usize] ; ["Offset of field: _GPtrArray::len"] [:: std :: mem :: offset_of ! (_GPtrArray , len) - 8usize] ; } ; unsafe extern "C" { pub fn g_array_new (zero_terminated : gboolean , clear_ : gboolean , element_size : guint) -> * mut GArray ; } unsafe extern "C" { pub fn g_array_new_take (data : gpointer , len : gsize , clear : gboolean , element_size : gsize) -> * mut GArray ; } unsafe extern "C" { pub fn g_array_new_take_zero_terminated (data : gpointer , clear : gboolean , element_size : gsize) -> * mut GArray ; } unsafe extern "C" { pub fn g_array_steal (array : * mut GArray , len : * mut gsize) -> gpointer ; } unsafe extern "C" { pub fn g_array_sized_new (zero_terminated : gboolean , clear_ : gboolean , element_size : guint , reserved_size : guint) -> * mut GArray ; } unsafe extern "C" { pub fn g_array_copy (array : * mut GArray) -> * mut GArray ; } unsafe extern "C" { pub fn g_array_free (array : * mut GArray , free_segment : gboolean) -> * mut gchar ; } unsafe extern "C" { pub fn g_array_ref (array : * mut GArray) -> * mut GArray ; } unsafe extern "C" { pub fn g_array_unref (array : * mut GArray) ; } unsafe extern "C" { pub fn g_array_get_element_size (array : * mut GArray) -> guint ; } unsafe extern "C" { pub fn g_array_append_vals (array : * mut GArray , data : gconstpointer , len : guint) -> * mut GArray ; } unsafe extern "C" { pub fn g_array_prepend_vals (array : * mut GArray , data : gconstpointer , len : guint) -> * mut GArray ; } unsafe extern "C" { pub fn g_array_insert_vals (array : * mut GArray , index_ : guint , data : gconstpointer , len : guint) -> * mut GArray ; } unsafe extern "C" { pub fn g_array_set_size (array : * mut GArray , length : guint) -> * mut GArray ; } unsafe extern "C" { pub fn g_array_remove_index (array : * mut GArray , index_ : guint) -> * mut GArray ; } unsafe extern "C" { pub fn g_array_remove_index_fast (array : * mut GArray , index_ : guint) -> * mut GArray ; } unsafe extern "C" { pub fn g_array_remove_range (array : * mut GArray , index_ : guint , length : guint) -> * mut GArray ; } unsafe extern "C" { pub fn g_array_sort (array : * mut GArray , compare_func : GCompareFunc) ; } unsafe extern "C" { pub fn g_array_sort_with_data (array : * mut GArray , compare_func : GCompareDataFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_array_binary_search (array : * mut GArray , target : gconstpointer , compare_func : GCompareFunc , out_match_index : * mut guint) -> gboolean ; } unsafe extern "C" { pub fn g_array_set_clear_func (array : * mut GArray , clear_func : GDestroyNotify) ; } unsafe extern "C" { pub fn g_ptr_array_new () -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_ptr_array_new_with_free_func (element_free_func : GDestroyNotify) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_ptr_array_new_take (data : * mut gpointer , len : gsize , element_free_func : GDestroyNotify) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_ptr_array_new_from_array (data : * mut gpointer , len : gsize , copy_func : GCopyFunc , copy_func_user_data : gpointer , element_free_func : GDestroyNotify) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_ptr_array_steal (array : * mut GPtrArray , len : * mut gsize) -> * mut gpointer ; } unsafe extern "C" { pub fn g_ptr_array_copy (array : * mut GPtrArray , func : GCopyFunc , user_data : gpointer) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_ptr_array_sized_new (reserved_size : guint) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_ptr_array_new_full (reserved_size : guint , element_free_func : GDestroyNotify) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_ptr_array_new_null_terminated (reserved_size : guint , element_free_func : GDestroyNotify , null_terminated : gboolean) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_ptr_array_new_take_null_terminated (data : * mut gpointer , element_free_func : GDestroyNotify) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_ptr_array_new_from_null_terminated_array (data : * mut gpointer , copy_func : GCopyFunc , copy_func_user_data : gpointer , element_free_func : GDestroyNotify) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_ptr_array_free (array : * mut GPtrArray , free_segment : gboolean) -> * mut gpointer ; } unsafe extern "C" { pub fn g_ptr_array_ref (array : * mut GPtrArray) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_ptr_array_unref (array : * mut GPtrArray) ; } unsafe extern "C" { pub fn g_ptr_array_set_free_func (array : * mut GPtrArray , element_free_func : GDestroyNotify) ; } unsafe extern "C" { pub fn g_ptr_array_set_size (array : * mut GPtrArray , length : gint) ; } unsafe extern "C" { pub fn g_ptr_array_remove_index (array : * mut GPtrArray , index_ : guint) -> gpointer ; } unsafe extern "C" { pub fn g_ptr_array_remove_index_fast (array : * mut GPtrArray , index_ : guint) -> gpointer ; } unsafe extern "C" { pub fn g_ptr_array_steal_index (array : * mut GPtrArray , index_ : guint) -> gpointer ; } unsafe extern "C" { pub fn g_ptr_array_steal_index_fast (array : * mut GPtrArray , index_ : guint) -> gpointer ; } unsafe extern "C" { pub fn g_ptr_array_remove (array : * mut GPtrArray , data : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_ptr_array_remove_fast (array : * mut GPtrArray , data : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_ptr_array_remove_range (array : * mut GPtrArray , index_ : guint , length : guint) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_ptr_array_add (array : * mut GPtrArray , data : gpointer) ; } unsafe extern "C" { pub fn g_ptr_array_extend (array_to_extend : * mut GPtrArray , array : * mut GPtrArray , func : GCopyFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_ptr_array_extend_and_steal (array_to_extend : * mut GPtrArray , array : * mut GPtrArray) ; } unsafe extern "C" { pub fn g_ptr_array_insert (array : * mut GPtrArray , index_ : gint , data : gpointer) ; } unsafe extern "C" { pub fn g_ptr_array_sort (array : * mut GPtrArray , compare_func : GCompareFunc) ; } unsafe extern "C" { pub fn g_ptr_array_sort_with_data (array : * mut GPtrArray , compare_func : GCompareDataFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_ptr_array_sort_values (array : * mut GPtrArray , compare_func : GCompareFunc) ; } unsafe extern "C" { pub fn g_ptr_array_sort_values_with_data (array : * mut GPtrArray , compare_func : GCompareDataFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_ptr_array_foreach (array : * mut GPtrArray , func : GFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_ptr_array_find (haystack : * mut GPtrArray , needle : gconstpointer , index_ : * mut guint) -> gboolean ; } unsafe extern "C" { pub fn g_ptr_array_find_with_equal_func (haystack : * mut GPtrArray , needle : gconstpointer , equal_func : GEqualFunc , index_ : * mut guint) -> gboolean ; } unsafe extern "C" { pub fn g_ptr_array_is_null_terminated (array : * mut GPtrArray) -> gboolean ; } unsafe extern "C" { pub fn g_byte_array_new () -> * mut GByteArray ; } unsafe extern "C" { pub fn g_byte_array_new_take (data : * mut guint8 , len : gsize) -> * mut GByteArray ; } unsafe extern "C" { pub fn g_byte_array_steal (array : * mut GByteArray , len : * mut gsize) -> * mut guint8 ; } unsafe extern "C" { pub fn g_byte_array_sized_new (reserved_size : guint) -> * mut GByteArray ; } unsafe extern "C" { pub fn g_byte_array_free (array : * mut GByteArray , free_segment : gboolean) -> * mut guint8 ; } unsafe extern "C" { pub fn g_byte_array_free_to_bytes (array : * mut GByteArray) -> * mut GBytes ; } unsafe extern "C" { pub fn g_byte_array_ref (array : * mut GByteArray) -> * mut GByteArray ; } unsafe extern "C" { pub fn g_byte_array_unref (array : * mut GByteArray) ; } unsafe extern "C" { pub fn g_byte_array_append (array : * mut GByteArray , data : * const guint8 , len : guint) -> * mut GByteArray ; } unsafe extern "C" { pub fn g_byte_array_prepend (array : * mut GByteArray , data : * const guint8 , len : guint) -> * mut GByteArray ; } unsafe extern "C" { pub fn g_byte_array_set_size (array : * mut GByteArray , length : guint) -> * mut GByteArray ; } unsafe extern "C" { pub fn g_byte_array_remove_index (array : * mut GByteArray , index_ : guint) -> * mut GByteArray ; } unsafe extern "C" { pub fn g_byte_array_remove_index_fast (array : * mut GByteArray , index_ : guint) -> * mut GByteArray ; } unsafe extern "C" { pub fn g_byte_array_remove_range (array : * mut GByteArray , index_ : guint , length : guint) -> * mut GByteArray ; } unsafe extern "C" { pub fn g_byte_array_sort (array : * mut GByteArray , compare_func : GCompareFunc) ; } unsafe extern "C" { pub fn g_byte_array_sort_with_data (array : * mut GByteArray , compare_func : GCompareDataFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_atomic_int_get (atomic : * const gint) -> gint ; } unsafe extern "C" { pub fn g_atomic_int_set (atomic : * mut gint , newval : gint) ; } unsafe extern "C" { pub fn g_atomic_int_inc (atomic : * mut gint) ; } unsafe extern "C" { pub fn g_atomic_int_dec_and_test (atomic : * mut gint) -> gboolean ; } unsafe extern "C" { pub fn g_atomic_int_compare_and_exchange (atomic : * mut gint , oldval : gint , newval : gint) -> gboolean ; } unsafe extern "C" { pub fn g_atomic_int_compare_and_exchange_full (atomic : * mut gint , oldval : gint , newval : gint , preval : * mut gint) -> gboolean ; } unsafe extern "C" { pub fn g_atomic_int_exchange (atomic : * mut gint , newval : gint) -> gint ; } unsafe extern "C" { pub fn g_atomic_int_add (atomic : * mut gint , val : gint) -> gint ; } unsafe extern "C" { pub fn g_atomic_int_and (atomic : * mut guint , val : guint) -> guint ; } unsafe extern "C" { pub fn g_atomic_int_or (atomic : * mut guint , val : guint) -> guint ; } unsafe extern "C" { pub fn g_atomic_int_xor (atomic : * mut guint , val : guint) -> guint ; } unsafe extern "C" { pub fn g_atomic_pointer_get (atomic : * const :: std :: os :: raw :: c_void) -> gpointer ; } unsafe extern "C" { pub fn g_atomic_pointer_set (atomic : * mut :: std :: os :: raw :: c_void , newval : gpointer) ; } unsafe extern "C" { pub fn g_atomic_pointer_compare_and_exchange (atomic : * mut :: std :: os :: raw :: c_void , oldval : gpointer , newval : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_atomic_pointer_compare_and_exchange_full (atomic : * mut :: std :: os :: raw :: c_void , oldval : gpointer , newval : gpointer , preval : * mut :: std :: os :: raw :: c_void) -> gboolean ; } unsafe extern "C" { pub fn g_atomic_pointer_exchange (atomic : * mut :: std :: os :: raw :: c_void , newval : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_atomic_pointer_add (atomic : * mut :: std :: os :: raw :: c_void , val : gssize) -> gintptr ; } unsafe extern "C" { pub fn g_atomic_pointer_and (atomic : * mut :: std :: os :: raw :: c_void , val : gsize) -> guintptr ; } unsafe extern "C" { pub fn g_atomic_pointer_or (atomic : * mut :: std :: os :: raw :: c_void , val : gsize) -> guintptr ; } unsafe extern "C" { pub fn g_atomic_pointer_xor (atomic : * mut :: std :: os :: raw :: c_void , val : gsize) -> guintptr ; } unsafe extern "C" { pub fn g_atomic_int_exchange_and_add (atomic : * mut gint , val : gint) -> gint ; } pub type __gnuc_va_list = __builtin_va_list ; pub type va_list = __builtin_va_list ; pub type GQuark = guint32 ; unsafe extern "C" { pub fn g_quark_try_string (string : * const gchar) -> GQuark ; } unsafe extern "C" { pub fn g_quark_from_static_string (string : * const gchar) -> GQuark ; } unsafe extern "C" { pub fn g_quark_from_string (string : * const gchar) -> GQuark ; } unsafe extern "C" { pub fn g_quark_to_string (quark : GQuark) -> * const gchar ; } unsafe extern "C" { pub fn g_intern_string (string : * const gchar) -> * const gchar ; } unsafe extern "C" { pub fn g_intern_static_string (string : * const gchar) -> * const gchar ; } pub type GError = _GError ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GError { pub domain : GQuark , pub code : gint , pub message : * mut gchar , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GError"] [:: std :: mem :: size_of :: < _GError > () - 16usize] ; ["Alignment of _GError"] [:: std :: mem :: align_of :: < _GError > () - 8usize] ; ["Offset of field: _GError::domain"] [:: std :: mem :: offset_of ! (_GError , domain) - 0usize] ; ["Offset of field: _GError::code"] [:: std :: mem :: offset_of ! (_GError , code) - 4usize] ; ["Offset of field: _GError::message"] [:: std :: mem :: offset_of ! (_GError , message) - 8usize] ; } ; pub type GErrorInitFunc = :: std :: option :: Option < unsafe extern "C" fn (error : * mut GError) > ; pub type GErrorCopyFunc = :: std :: option :: Option < unsafe extern "C" fn (src_error : * const GError , dest_error : * mut GError) > ; pub type GErrorClearFunc = :: std :: option :: Option < unsafe extern "C" fn (error : * mut GError) > ; unsafe extern "C" { pub fn g_error_domain_register_static (error_type_name : * const :: std :: os :: raw :: c_char , error_type_private_size : gsize , error_type_init : GErrorInitFunc , error_type_copy : GErrorCopyFunc , error_type_clear : GErrorClearFunc) -> GQuark ; } unsafe extern "C" { pub fn g_error_domain_register (error_type_name : * const :: std :: os :: raw :: c_char , error_type_private_size : gsize , error_type_init : GErrorInitFunc , error_type_copy : GErrorCopyFunc , error_type_clear : GErrorClearFunc) -> GQuark ; } unsafe extern "C" { pub fn g_error_new (domain : GQuark , code : gint , format : * const gchar , ...) -> * mut GError ; } unsafe extern "C" { pub fn g_error_new_literal (domain : GQuark , code : gint , message : * const gchar) -> * mut GError ; } unsafe extern "C" { pub fn g_error_new_valist (domain : GQuark , code : gint , format : * const gchar , args : * mut __va_list_tag) -> * mut GError ; } unsafe extern "C" { pub fn g_error_free (error : * mut GError) ; } unsafe extern "C" { pub fn g_error_copy (error : * const GError) -> * mut GError ; } unsafe extern "C" { pub fn g_error_matches (error : * const GError , domain : GQuark , code : gint) -> gboolean ; } unsafe extern "C" { pub fn g_set_error (err : * mut * mut GError , domain : GQuark , code : gint , format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_set_error_literal (err : * mut * mut GError , domain : GQuark , code : gint , message : * const gchar) ; } unsafe extern "C" { pub fn g_propagate_error (dest : * mut * mut GError , src : * mut GError) ; } unsafe extern "C" { pub fn g_clear_error (err : * mut * mut GError) ; } unsafe extern "C" { pub fn g_prefix_error (err : * mut * mut GError , format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_prefix_error_literal (err : * mut * mut GError , prefix : * const gchar) ; } unsafe extern "C" { pub fn g_propagate_prefixed_error (dest : * mut * mut GError , src : * mut GError , format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_get_user_name () -> * const gchar ; } unsafe extern "C" { pub fn g_get_real_name () -> * const gchar ; } unsafe extern "C" { pub fn g_get_home_dir () -> * const gchar ; } unsafe extern "C" { pub fn g_get_tmp_dir () -> * const gchar ; } unsafe extern "C" { pub fn g_get_host_name () -> * const gchar ; } unsafe extern "C" { pub fn g_get_prgname () -> * const gchar ; } unsafe extern "C" { pub fn g_set_prgname (prgname : * const gchar) ; } unsafe extern "C" { pub fn g_get_application_name () -> * const gchar ; } unsafe extern "C" { pub fn g_set_application_name (application_name : * const gchar) ; } unsafe extern "C" { pub fn g_get_os_info (key_name : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_reload_user_special_dirs_cache () ; } unsafe extern "C" { pub fn g_get_user_data_dir () -> * const gchar ; } unsafe extern "C" { pub fn g_get_user_config_dir () -> * const gchar ; } unsafe extern "C" { pub fn g_get_user_cache_dir () -> * const gchar ; } unsafe extern "C" { pub fn g_get_user_state_dir () -> * const gchar ; } unsafe extern "C" { pub fn g_get_system_data_dirs () -> * const * const gchar ; } unsafe extern "C" { pub fn g_get_system_config_dirs () -> * const * const gchar ; } unsafe extern "C" { pub fn g_get_user_runtime_dir () -> * const gchar ; } pub const GUserDirectory_G_USER_DIRECTORY_DESKTOP : GUserDirectory = 0 ; pub const GUserDirectory_G_USER_DIRECTORY_DOCUMENTS : GUserDirectory = 1 ; pub const GUserDirectory_G_USER_DIRECTORY_DOWNLOAD : GUserDirectory = 2 ; pub const GUserDirectory_G_USER_DIRECTORY_MUSIC : GUserDirectory = 3 ; pub const GUserDirectory_G_USER_DIRECTORY_PICTURES : GUserDirectory = 4 ; pub const GUserDirectory_G_USER_DIRECTORY_PUBLIC_SHARE : GUserDirectory = 5 ; pub const GUserDirectory_G_USER_DIRECTORY_TEMPLATES : GUserDirectory = 6 ; pub const GUserDirectory_G_USER_DIRECTORY_VIDEOS : GUserDirectory = 7 ; pub const GUserDirectory_G_USER_N_DIRECTORIES : GUserDirectory = 8 ; pub type GUserDirectory = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_get_user_special_dir (directory : GUserDirectory) -> * const gchar ; } pub type GDebugKey = _GDebugKey ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDebugKey { pub key : * const gchar , pub value : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDebugKey"] [:: std :: mem :: size_of :: < _GDebugKey > () - 16usize] ; ["Alignment of _GDebugKey"] [:: std :: mem :: align_of :: < _GDebugKey > () - 8usize] ; ["Offset of field: _GDebugKey::key"] [:: std :: mem :: offset_of ! (_GDebugKey , key) - 0usize] ; ["Offset of field: _GDebugKey::value"] [:: std :: mem :: offset_of ! (_GDebugKey , value) - 8usize] ; } ; unsafe extern "C" { pub fn g_parse_debug_string (string : * const gchar , keys : * const GDebugKey , nkeys : guint) -> guint ; } unsafe extern "C" { pub fn g_snprintf (string : * mut gchar , n : gulong , format : * const gchar , ...) -> gint ; } unsafe extern "C" { pub fn g_vsnprintf (string : * mut gchar , n : gulong , format : * const gchar , args : * mut __va_list_tag) -> gint ; } unsafe extern "C" { pub fn g_nullify_pointer (nullify_location : * mut gpointer) ; } pub const GFormatSizeFlags_G_FORMAT_SIZE_DEFAULT : GFormatSizeFlags = 0 ; pub const GFormatSizeFlags_G_FORMAT_SIZE_LONG_FORMAT : GFormatSizeFlags = 1 ; pub const GFormatSizeFlags_G_FORMAT_SIZE_IEC_UNITS : GFormatSizeFlags = 2 ; pub const GFormatSizeFlags_G_FORMAT_SIZE_BITS : GFormatSizeFlags = 4 ; pub const GFormatSizeFlags_G_FORMAT_SIZE_ONLY_VALUE : GFormatSizeFlags = 8 ; pub const GFormatSizeFlags_G_FORMAT_SIZE_ONLY_UNIT : GFormatSizeFlags = 16 ; pub type GFormatSizeFlags = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_format_size_full (size : guint64 , flags : GFormatSizeFlags) -> * mut gchar ; } unsafe extern "C" { pub fn g_format_size (size : guint64) -> * mut gchar ; } unsafe extern "C" { pub fn g_format_size_for_display (size : goffset) -> * mut gchar ; } pub type GVoidFunc = :: std :: option :: Option < unsafe extern "C" fn () > ; unsafe extern "C" { pub fn g_atexit (func : GVoidFunc) ; } unsafe extern "C" { pub fn g_find_program_in_path (program : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_bit_nth_lsf (mask : gulong , nth_bit : gint) -> gint ; } unsafe extern "C" { pub fn g_bit_nth_msf (mask : gulong , nth_bit : gint) -> gint ; } unsafe extern "C" { pub fn g_bit_storage (number : gulong) -> guint ; } pub type __cfloat128 = __BindgenComplex < u128 > ; pub type _Float128 = u128 ; pub type _Float32 = f32 ; pub type _Float64 = f64 ; pub type _Float32x = f64 ; pub type _Float64x = u128 ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct div_t { pub quot : :: std :: os :: raw :: c_int , pub rem : :: std :: os :: raw :: c_int , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of div_t"] [:: std :: mem :: size_of :: < div_t > () - 8usize] ; ["Alignment of div_t"] [:: std :: mem :: align_of :: < div_t > () - 4usize] ; ["Offset of field: div_t::quot"] [:: std :: mem :: offset_of ! (div_t , quot) - 0usize] ; ["Offset of field: div_t::rem"] [:: std :: mem :: offset_of ! (div_t , rem) - 4usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ldiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ldiv_t"] [:: std :: mem :: size_of :: < ldiv_t > () - 16usize] ; ["Alignment of ldiv_t"] [:: std :: mem :: align_of :: < ldiv_t > () - 8usize] ; ["Offset of field: ldiv_t::quot"] [:: std :: mem :: offset_of ! (ldiv_t , quot) - 0usize] ; ["Offset of field: ldiv_t::rem"] [:: std :: mem :: offset_of ! (ldiv_t , rem) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct lldiv_t { pub quot : :: std :: os :: raw :: c_longlong , pub rem : :: std :: os :: raw :: c_longlong , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of lldiv_t"] [:: std :: mem :: size_of :: < lldiv_t > () - 16usize] ; ["Alignment of lldiv_t"] [:: std :: mem :: align_of :: < lldiv_t > () - 8usize] ; ["Offset of field: lldiv_t::quot"] [:: std :: mem :: offset_of ! (lldiv_t , quot) - 0usize] ; ["Offset of field: lldiv_t::rem"] [:: std :: mem :: offset_of ! (lldiv_t , rem) - 8usize] ; } ; unsafe extern "C" { pub fn __ctype_get_mb_cur_max () -> usize ; } unsafe extern "C" { pub fn atof (__nptr : * const :: std :: os :: raw :: c_char) -> f64 ; } unsafe extern "C" { pub fn atoi (__nptr : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn atol (__nptr : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn atoll (__nptr : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_longlong ; } unsafe extern "C" { pub fn strtod (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char) -> f64 ; } unsafe extern "C" { pub fn strtof (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char) -> f32 ; } unsafe extern "C" { pub fn strtold (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char) -> u128 ; } unsafe extern "C" { pub fn strtol (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn strtoul (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulong ; } unsafe extern "C" { pub fn strtoq (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_longlong ; } unsafe extern "C" { pub fn strtouq (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong ; } unsafe extern "C" { pub fn strtoll (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_longlong ; } unsafe extern "C" { pub fn strtoull (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong ; } unsafe extern "C" { pub fn l64a (__n : :: std :: os :: raw :: c_long) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn a64l (__s : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_long ; } pub type u_char = __u_char ; pub type u_short = __u_short ; pub type u_int = __u_int ; pub type u_long = __u_long ; pub type quad_t = __quad_t ; pub type u_quad_t = __u_quad_t ; pub type fsid_t = __fsid_t ; pub type loff_t = __loff_t ; pub type ino_t = __ino_t ; pub type dev_t = __dev_t ; pub type gid_t = __gid_t ; pub type mode_t = __mode_t ; pub type nlink_t = __nlink_t ; pub type uid_t = __uid_t ; pub type off_t = __off_t ; pub type id_t = __id_t ; pub type daddr_t = __daddr_t ; pub type caddr_t = __caddr_t ; pub type key_t = __key_t ; pub type ulong = :: std :: os :: raw :: c_ulong ; pub type ushort = :: std :: os :: raw :: c_ushort ; pub type uint = :: std :: os :: raw :: c_uint ; pub type u_int8_t = __uint8_t ; pub type u_int16_t = __uint16_t ; pub type u_int32_t = __uint32_t ; pub type u_int64_t = __uint64_t ; pub type register_t = :: std :: os :: raw :: c_long ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __sigset_t { pub __val : [:: std :: os :: raw :: c_ulong ; 16usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __sigset_t"] [:: std :: mem :: size_of :: < __sigset_t > () - 128usize] ; ["Alignment of __sigset_t"] [:: std :: mem :: align_of :: < __sigset_t > () - 8usize] ; ["Offset of field: __sigset_t::__val"] [:: std :: mem :: offset_of ! (__sigset_t , __val) - 0usize] ; } ; pub type sigset_t = __sigset_t ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct timeval { pub tv_sec : __time_t , pub tv_usec : __suseconds_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of timeval"] [:: std :: mem :: size_of :: < timeval > () - 16usize] ; ["Alignment of timeval"] [:: std :: mem :: align_of :: < timeval > () - 8usize] ; ["Offset of field: timeval::tv_sec"] [:: std :: mem :: offset_of ! (timeval , tv_sec) - 0usize] ; ["Offset of field: timeval::tv_usec"] [:: std :: mem :: offset_of ! (timeval , tv_usec) - 8usize] ; } ; pub type suseconds_t = __suseconds_t ; pub type __fd_mask = :: std :: os :: raw :: c_long ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct fd_set { pub __fds_bits : [__fd_mask ; 16usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of fd_set"] [:: std :: mem :: size_of :: < fd_set > () - 128usize] ; ["Alignment of fd_set"] [:: std :: mem :: align_of :: < fd_set > () - 8usize] ; ["Offset of field: fd_set::__fds_bits"] [:: std :: mem :: offset_of ! (fd_set , __fds_bits) - 0usize] ; } ; pub type fd_mask = __fd_mask ; unsafe extern "C" { pub fn select (__nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * mut timeval) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pselect (__nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * const timespec , __sigmask : * const __sigset_t) -> :: std :: os :: raw :: c_int ; } pub type blksize_t = __blksize_t ; pub type blkcnt_t = __blkcnt_t ; pub type fsblkcnt_t = __fsblkcnt_t ; pub type fsfilcnt_t = __fsfilcnt_t ; # [repr (C)] # [derive (Copy , Clone)] pub union __atomic_wide_counter { pub __value64 : :: std :: os :: raw :: c_ulonglong , pub __value32 : __atomic_wide_counter__bindgen_ty_1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __atomic_wide_counter__bindgen_ty_1 { pub __low : :: std :: os :: raw :: c_uint , pub __high : :: std :: os :: raw :: c_uint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __atomic_wide_counter__bindgen_ty_1"] [:: std :: mem :: size_of :: < __atomic_wide_counter__bindgen_ty_1 > () - 8usize] ; ["Alignment of __atomic_wide_counter__bindgen_ty_1"] [:: std :: mem :: align_of :: < __atomic_wide_counter__bindgen_ty_1 > () - 4usize] ; ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"] [:: std :: mem :: offset_of ! (__atomic_wide_counter__bindgen_ty_1 , __low) - 0usize] ; ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"] [:: std :: mem :: offset_of ! (__atomic_wide_counter__bindgen_ty_1 , __high) - 4usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __atomic_wide_counter"] [:: std :: mem :: size_of :: < __atomic_wide_counter > () - 8usize] ; ["Alignment of __atomic_wide_counter"] [:: std :: mem :: align_of :: < __atomic_wide_counter > () - 8usize] ; ["Offset of field: __atomic_wide_counter::__value64"] [:: std :: mem :: offset_of ! (__atomic_wide_counter , __value64) - 0usize] ; ["Offset of field: __atomic_wide_counter::__value32"] [:: std :: mem :: offset_of ! (__atomic_wide_counter , __value32) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __pthread_internal_list { pub __prev : * mut __pthread_internal_list , pub __next : * mut __pthread_internal_list , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __pthread_internal_list"] [:: std :: mem :: size_of :: < __pthread_internal_list > () - 16usize] ; ["Alignment of __pthread_internal_list"] [:: std :: mem :: align_of :: < __pthread_internal_list > () - 8usize] ; ["Offset of field: __pthread_internal_list::__prev"] [:: std :: mem :: offset_of ! (__pthread_internal_list , __prev) - 0usize] ; ["Offset of field: __pthread_internal_list::__next"] [:: std :: mem :: offset_of ! (__pthread_internal_list , __next) - 8usize] ; } ; pub type __pthread_list_t = __pthread_internal_list ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __pthread_internal_slist { pub __next : * mut __pthread_internal_slist , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __pthread_internal_slist"] [:: std :: mem :: size_of :: < __pthread_internal_slist > () - 8usize] ; ["Alignment of __pthread_internal_slist"] [:: std :: mem :: align_of :: < __pthread_internal_slist > () - 8usize] ; ["Offset of field: __pthread_internal_slist::__next"] [:: std :: mem :: offset_of ! (__pthread_internal_slist , __next) - 0usize] ; } ; pub type __pthread_slist_t = __pthread_internal_slist ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __pthread_mutex_s { pub __lock : :: std :: os :: raw :: c_int , pub __count : :: std :: os :: raw :: c_uint , pub __owner : :: std :: os :: raw :: c_int , pub __nusers : :: std :: os :: raw :: c_uint , pub __kind : :: std :: os :: raw :: c_int , pub __spins : :: std :: os :: raw :: c_short , pub __elision : :: std :: os :: raw :: c_short , pub __list : __pthread_list_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __pthread_mutex_s"] [:: std :: mem :: size_of :: < __pthread_mutex_s > () - 40usize] ; ["Alignment of __pthread_mutex_s"] [:: std :: mem :: align_of :: < __pthread_mutex_s > () - 8usize] ; ["Offset of field: __pthread_mutex_s::__lock"] [:: std :: mem :: offset_of ! (__pthread_mutex_s , __lock) - 0usize] ; ["Offset of field: __pthread_mutex_s::__count"] [:: std :: mem :: offset_of ! (__pthread_mutex_s , __count) - 4usize] ; ["Offset of field: __pthread_mutex_s::__owner"] [:: std :: mem :: offset_of ! (__pthread_mutex_s , __owner) - 8usize] ; ["Offset of field: __pthread_mutex_s::__nusers"] [:: std :: mem :: offset_of ! (__pthread_mutex_s , __nusers) - 12usize] ; ["Offset of field: __pthread_mutex_s::__kind"] [:: std :: mem :: offset_of ! (__pthread_mutex_s , __kind) - 16usize] ; ["Offset of field: __pthread_mutex_s::__spins"] [:: std :: mem :: offset_of ! (__pthread_mutex_s , __spins) - 20usize] ; ["Offset of field: __pthread_mutex_s::__elision"] [:: std :: mem :: offset_of ! (__pthread_mutex_s , __elision) - 22usize] ; ["Offset of field: __pthread_mutex_s::__list"] [:: std :: mem :: offset_of ! (__pthread_mutex_s , __list) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __pthread_rwlock_arch_t { pub __readers : :: std :: os :: raw :: c_uint , pub __writers : :: std :: os :: raw :: c_uint , pub __wrphase_futex : :: std :: os :: raw :: c_uint , pub __writers_futex : :: std :: os :: raw :: c_uint , pub __pad3 : :: std :: os :: raw :: c_uint , pub __pad4 : :: std :: os :: raw :: c_uint , pub __cur_writer : :: std :: os :: raw :: c_int , pub __shared : :: std :: os :: raw :: c_int , pub __rwelision : :: std :: os :: raw :: c_schar , pub __pad1 : [:: std :: os :: raw :: c_uchar ; 7usize] , pub __pad2 : :: std :: os :: raw :: c_ulong , pub __flags : :: std :: os :: raw :: c_uint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __pthread_rwlock_arch_t"] [:: std :: mem :: size_of :: < __pthread_rwlock_arch_t > () - 56usize] ; ["Alignment of __pthread_rwlock_arch_t"] [:: std :: mem :: align_of :: < __pthread_rwlock_arch_t > () - 8usize] ; ["Offset of field: __pthread_rwlock_arch_t::__readers"] [:: std :: mem :: offset_of ! (__pthread_rwlock_arch_t , __readers) - 0usize] ; ["Offset of field: __pthread_rwlock_arch_t::__writers"] [:: std :: mem :: offset_of ! (__pthread_rwlock_arch_t , __writers) - 4usize] ; ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"] [:: std :: mem :: offset_of ! (__pthread_rwlock_arch_t , __wrphase_futex) - 8usize] ; ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"] [:: std :: mem :: offset_of ! (__pthread_rwlock_arch_t , __writers_futex) - 12usize] ; ["Offset of field: __pthread_rwlock_arch_t::__pad3"] [:: std :: mem :: offset_of ! (__pthread_rwlock_arch_t , __pad3) - 16usize] ; ["Offset of field: __pthread_rwlock_arch_t::__pad4"] [:: std :: mem :: offset_of ! (__pthread_rwlock_arch_t , __pad4) - 20usize] ; ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"] [:: std :: mem :: offset_of ! (__pthread_rwlock_arch_t , __cur_writer) - 24usize] ; ["Offset of field: __pthread_rwlock_arch_t::__shared"] [:: std :: mem :: offset_of ! (__pthread_rwlock_arch_t , __shared) - 28usize] ; ["Offset of field: __pthread_rwlock_arch_t::__rwelision"] [:: std :: mem :: offset_of ! (__pthread_rwlock_arch_t , __rwelision) - 32usize] ; ["Offset of field: __pthread_rwlock_arch_t::__pad1"] [:: std :: mem :: offset_of ! (__pthread_rwlock_arch_t , __pad1) - 33usize] ; ["Offset of field: __pthread_rwlock_arch_t::__pad2"] [:: std :: mem :: offset_of ! (__pthread_rwlock_arch_t , __pad2) - 40usize] ; ["Offset of field: __pthread_rwlock_arch_t::__flags"] [:: std :: mem :: offset_of ! (__pthread_rwlock_arch_t , __flags) - 48usize] ; } ; # [repr (C)] # [derive (Copy , Clone)] pub struct __pthread_cond_s { pub __wseq : __atomic_wide_counter , pub __g1_start : __atomic_wide_counter , pub __g_size : [:: std :: os :: raw :: c_uint ; 2usize] , pub __g1_orig_size : :: std :: os :: raw :: c_uint , pub __wrefs : :: std :: os :: raw :: c_uint , pub __g_signals : [:: std :: os :: raw :: c_uint ; 2usize] , pub __unused_initialized_1 : :: std :: os :: raw :: c_uint , pub __unused_initialized_2 : :: std :: os :: raw :: c_uint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __pthread_cond_s"] [:: std :: mem :: size_of :: < __pthread_cond_s > () - 48usize] ; ["Alignment of __pthread_cond_s"] [:: std :: mem :: align_of :: < __pthread_cond_s > () - 8usize] ; ["Offset of field: __pthread_cond_s::__wseq"] [:: std :: mem :: offset_of ! (__pthread_cond_s , __wseq) - 0usize] ; ["Offset of field: __pthread_cond_s::__g1_start"] [:: std :: mem :: offset_of ! (__pthread_cond_s , __g1_start) - 8usize] ; ["Offset of field: __pthread_cond_s::__g_size"] [:: std :: mem :: offset_of ! (__pthread_cond_s , __g_size) - 16usize] ; ["Offset of field: __pthread_cond_s::__g1_orig_size"] [:: std :: mem :: offset_of ! (__pthread_cond_s , __g1_orig_size) - 24usize] ; ["Offset of field: __pthread_cond_s::__wrefs"] [:: std :: mem :: offset_of ! (__pthread_cond_s , __wrefs) - 28usize] ; ["Offset of field: __pthread_cond_s::__g_signals"] [:: std :: mem :: offset_of ! (__pthread_cond_s , __g_signals) - 32usize] ; ["Offset of field: __pthread_cond_s::__unused_initialized_1"] [:: std :: mem :: offset_of ! (__pthread_cond_s , __unused_initialized_1) - 40usize] ; ["Offset of field: __pthread_cond_s::__unused_initialized_2"] [:: std :: mem :: offset_of ! (__pthread_cond_s , __unused_initialized_2) - 44usize] ; } ; pub type __tss_t = :: std :: os :: raw :: c_uint ; pub type __thrd_t = :: std :: os :: raw :: c_ulong ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __once_flag { pub __data : :: std :: os :: raw :: c_int , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __once_flag"] [:: std :: mem :: size_of :: < __once_flag > () - 4usize] ; ["Alignment of __once_flag"] [:: std :: mem :: align_of :: < __once_flag > () - 4usize] ; ["Offset of field: __once_flag::__data"] [:: std :: mem :: offset_of ! (__once_flag , __data) - 0usize] ; } ; pub type pthread_t = :: std :: os :: raw :: c_ulong ; # [repr (C)] # [derive (Copy , Clone)] pub union pthread_mutexattr_t { pub __size : [:: std :: os :: raw :: c_char ; 4usize] , pub __align : :: std :: os :: raw :: c_int , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of pthread_mutexattr_t"] [:: std :: mem :: size_of :: < pthread_mutexattr_t > () - 4usize] ; ["Alignment of pthread_mutexattr_t"] [:: std :: mem :: align_of :: < pthread_mutexattr_t > () - 4usize] ; ["Offset of field: pthread_mutexattr_t::__size"] [:: std :: mem :: offset_of ! (pthread_mutexattr_t , __size) - 0usize] ; ["Offset of field: pthread_mutexattr_t::__align"] [:: std :: mem :: offset_of ! (pthread_mutexattr_t , __align) - 0usize] ; } ; # [repr (C)] # [derive (Copy , Clone)] pub union pthread_condattr_t { pub __size : [:: std :: os :: raw :: c_char ; 4usize] , pub __align : :: std :: os :: raw :: c_int , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of pthread_condattr_t"] [:: std :: mem :: size_of :: < pthread_condattr_t > () - 4usize] ; ["Alignment of pthread_condattr_t"] [:: std :: mem :: align_of :: < pthread_condattr_t > () - 4usize] ; ["Offset of field: pthread_condattr_t::__size"] [:: std :: mem :: offset_of ! (pthread_condattr_t , __size) - 0usize] ; ["Offset of field: pthread_condattr_t::__align"] [:: std :: mem :: offset_of ! (pthread_condattr_t , __align) - 0usize] ; } ; pub type pthread_key_t = :: std :: os :: raw :: c_uint ; pub type pthread_once_t = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Copy , Clone)] pub union pthread_attr_t { pub __size : [:: std :: os :: raw :: c_char ; 56usize] , pub __align : :: std :: os :: raw :: c_long , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of pthread_attr_t"] [:: std :: mem :: size_of :: < pthread_attr_t > () - 56usize] ; ["Alignment of pthread_attr_t"] [:: std :: mem :: align_of :: < pthread_attr_t > () - 8usize] ; ["Offset of field: pthread_attr_t::__size"] [:: std :: mem :: offset_of ! (pthread_attr_t , __size) - 0usize] ; ["Offset of field: pthread_attr_t::__align"] [:: std :: mem :: offset_of ! (pthread_attr_t , __align) - 0usize] ; } ; # [repr (C)] # [derive (Copy , Clone)] pub union pthread_mutex_t { pub __data : __pthread_mutex_s , pub __size : [:: std :: os :: raw :: c_char ; 40usize] , pub __align : :: std :: os :: raw :: c_long , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of pthread_mutex_t"] [:: std :: mem :: size_of :: < pthread_mutex_t > () - 40usize] ; ["Alignment of pthread_mutex_t"] [:: std :: mem :: align_of :: < pthread_mutex_t > () - 8usize] ; ["Offset of field: pthread_mutex_t::__data"] [:: std :: mem :: offset_of ! (pthread_mutex_t , __data) - 0usize] ; ["Offset of field: pthread_mutex_t::__size"] [:: std :: mem :: offset_of ! (pthread_mutex_t , __size) - 0usize] ; ["Offset of field: pthread_mutex_t::__align"] [:: std :: mem :: offset_of ! (pthread_mutex_t , __align) - 0usize] ; } ; # [repr (C)] # [derive (Copy , Clone)] pub union pthread_cond_t { pub __data : __pthread_cond_s , pub __size : [:: std :: os :: raw :: c_char ; 48usize] , pub __align : :: std :: os :: raw :: c_longlong , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of pthread_cond_t"] [:: std :: mem :: size_of :: < pthread_cond_t > () - 48usize] ; ["Alignment of pthread_cond_t"] [:: std :: mem :: align_of :: < pthread_cond_t > () - 8usize] ; ["Offset of field: pthread_cond_t::__data"] [:: std :: mem :: offset_of ! (pthread_cond_t , __data) - 0usize] ; ["Offset of field: pthread_cond_t::__size"] [:: std :: mem :: offset_of ! (pthread_cond_t , __size) - 0usize] ; ["Offset of field: pthread_cond_t::__align"] [:: std :: mem :: offset_of ! (pthread_cond_t , __align) - 0usize] ; } ; # [repr (C)] # [derive (Copy , Clone)] pub union pthread_rwlock_t { pub __data : __pthread_rwlock_arch_t , pub __size : [:: std :: os :: raw :: c_char ; 56usize] , pub __align : :: std :: os :: raw :: c_long , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of pthread_rwlock_t"] [:: std :: mem :: size_of :: < pthread_rwlock_t > () - 56usize] ; ["Alignment of pthread_rwlock_t"] [:: std :: mem :: align_of :: < pthread_rwlock_t > () - 8usize] ; ["Offset of field: pthread_rwlock_t::__data"] [:: std :: mem :: offset_of ! (pthread_rwlock_t , __data) - 0usize] ; ["Offset of field: pthread_rwlock_t::__size"] [:: std :: mem :: offset_of ! (pthread_rwlock_t , __size) - 0usize] ; ["Offset of field: pthread_rwlock_t::__align"] [:: std :: mem :: offset_of ! (pthread_rwlock_t , __align) - 0usize] ; } ; # [repr (C)] # [derive (Copy , Clone)] pub union pthread_rwlockattr_t { pub __size : [:: std :: os :: raw :: c_char ; 8usize] , pub __align : :: std :: os :: raw :: c_long , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of pthread_rwlockattr_t"] [:: std :: mem :: size_of :: < pthread_rwlockattr_t > () - 8usize] ; ["Alignment of pthread_rwlockattr_t"] [:: std :: mem :: align_of :: < pthread_rwlockattr_t > () - 8usize] ; ["Offset of field: pthread_rwlockattr_t::__size"] [:: std :: mem :: offset_of ! (pthread_rwlockattr_t , __size) - 0usize] ; ["Offset of field: pthread_rwlockattr_t::__align"] [:: std :: mem :: offset_of ! (pthread_rwlockattr_t , __align) - 0usize] ; } ; pub type pthread_spinlock_t = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Copy , Clone)] pub union pthread_barrier_t { pub __size : [:: std :: os :: raw :: c_char ; 32usize] , pub __align : :: std :: os :: raw :: c_long , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of pthread_barrier_t"] [:: std :: mem :: size_of :: < pthread_barrier_t > () - 32usize] ; ["Alignment of pthread_barrier_t"] [:: std :: mem :: align_of :: < pthread_barrier_t > () - 8usize] ; ["Offset of field: pthread_barrier_t::__size"] [:: std :: mem :: offset_of ! (pthread_barrier_t , __size) - 0usize] ; ["Offset of field: pthread_barrier_t::__align"] [:: std :: mem :: offset_of ! (pthread_barrier_t , __align) - 0usize] ; } ; # [repr (C)] # [derive (Copy , Clone)] pub union pthread_barrierattr_t { pub __size : [:: std :: os :: raw :: c_char ; 4usize] , pub __align : :: std :: os :: raw :: c_int , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of pthread_barrierattr_t"] [:: std :: mem :: size_of :: < pthread_barrierattr_t > () - 4usize] ; ["Alignment of pthread_barrierattr_t"] [:: std :: mem :: align_of :: < pthread_barrierattr_t > () - 4usize] ; ["Offset of field: pthread_barrierattr_t::__size"] [:: std :: mem :: offset_of ! (pthread_barrierattr_t , __size) - 0usize] ; ["Offset of field: pthread_barrierattr_t::__align"] [:: std :: mem :: offset_of ! (pthread_barrierattr_t , __align) - 0usize] ; } ; unsafe extern "C" { pub fn random () -> :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn srandom (__seed : :: std :: os :: raw :: c_uint) ; } unsafe extern "C" { pub fn initstate (__seed : :: std :: os :: raw :: c_uint , __statebuf : * mut :: std :: os :: raw :: c_char , __statelen : usize) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn setstate (__statebuf : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct random_data { pub fptr : * mut i32 , pub rptr : * mut i32 , pub state : * mut i32 , pub rand_type : :: std :: os :: raw :: c_int , pub rand_deg : :: std :: os :: raw :: c_int , pub rand_sep : :: std :: os :: raw :: c_int , pub end_ptr : * mut i32 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of random_data"] [:: std :: mem :: size_of :: < random_data > () - 48usize] ; ["Alignment of random_data"] [:: std :: mem :: align_of :: < random_data > () - 8usize] ; ["Offset of field: random_data::fptr"] [:: std :: mem :: offset_of ! (random_data , fptr) - 0usize] ; ["Offset of field: random_data::rptr"] [:: std :: mem :: offset_of ! (random_data , rptr) - 8usize] ; ["Offset of field: random_data::state"] [:: std :: mem :: offset_of ! (random_data , state) - 16usize] ; ["Offset of field: random_data::rand_type"] [:: std :: mem :: offset_of ! (random_data , rand_type) - 24usize] ; ["Offset of field: random_data::rand_deg"] [:: std :: mem :: offset_of ! (random_data , rand_deg) - 28usize] ; ["Offset of field: random_data::rand_sep"] [:: std :: mem :: offset_of ! (random_data , rand_sep) - 32usize] ; ["Offset of field: random_data::end_ptr"] [:: std :: mem :: offset_of ! (random_data , end_ptr) - 40usize] ; } ; unsafe extern "C" { pub fn random_r (__buf : * mut random_data , __result : * mut i32) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn srandom_r (__seed : :: std :: os :: raw :: c_uint , __buf : * mut random_data) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn initstate_r (__seed : :: std :: os :: raw :: c_uint , __statebuf : * mut :: std :: os :: raw :: c_char , __statelen : usize , __buf : * mut random_data) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn setstate_r (__statebuf : * mut :: std :: os :: raw :: c_char , __buf : * mut random_data) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn rand () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn srand (__seed : :: std :: os :: raw :: c_uint) ; } unsafe extern "C" { pub fn rand_r (__seed : * mut :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn drand48 () -> f64 ; } unsafe extern "C" { pub fn erand48 (__xsubi : * mut :: std :: os :: raw :: c_ushort) -> f64 ; } unsafe extern "C" { pub fn lrand48 () -> :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn nrand48 (__xsubi : * mut :: std :: os :: raw :: c_ushort) -> :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn mrand48 () -> :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn jrand48 (__xsubi : * mut :: std :: os :: raw :: c_ushort) -> :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn srand48 (__seedval : :: std :: os :: raw :: c_long) ; } unsafe extern "C" { pub fn seed48 (__seed16v : * mut :: std :: os :: raw :: c_ushort) -> * mut :: std :: os :: raw :: c_ushort ; } unsafe extern "C" { pub fn lcong48 (__param : * mut :: std :: os :: raw :: c_ushort) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct drand48_data { pub __x : [:: std :: os :: raw :: c_ushort ; 3usize] , pub __old_x : [:: std :: os :: raw :: c_ushort ; 3usize] , pub __c : :: std :: os :: raw :: c_ushort , pub __init : :: std :: os :: raw :: c_ushort , pub __a : :: std :: os :: raw :: c_ulonglong , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of drand48_data"] [:: std :: mem :: size_of :: < drand48_data > () - 24usize] ; ["Alignment of drand48_data"] [:: std :: mem :: align_of :: < drand48_data > () - 8usize] ; ["Offset of field: drand48_data::__x"] [:: std :: mem :: offset_of ! (drand48_data , __x) - 0usize] ; ["Offset of field: drand48_data::__old_x"] [:: std :: mem :: offset_of ! (drand48_data , __old_x) - 6usize] ; ["Offset of field: drand48_data::__c"] [:: std :: mem :: offset_of ! (drand48_data , __c) - 12usize] ; ["Offset of field: drand48_data::__init"] [:: std :: mem :: offset_of ! (drand48_data , __init) - 14usize] ; ["Offset of field: drand48_data::__a"] [:: std :: mem :: offset_of ! (drand48_data , __a) - 16usize] ; } ; unsafe extern "C" { pub fn drand48_r (__buffer : * mut drand48_data , __result : * mut f64) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn erand48_r (__xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut f64) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn lrand48_r (__buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn nrand48_r (__xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn mrand48_r (__buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn jrand48_r (__xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn srand48_r (__seedval : :: std :: os :: raw :: c_long , __buffer : * mut drand48_data) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn seed48_r (__seed16v : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn lcong48_r (__param : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn arc4random () -> __uint32_t ; } unsafe extern "C" { pub fn arc4random_buf (__buf : * mut :: std :: os :: raw :: c_void , __size : usize) ; } unsafe extern "C" { pub fn arc4random_uniform (__upper_bound : __uint32_t) -> __uint32_t ; } unsafe extern "C" { pub fn malloc (__size : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn calloc (__nmemb : :: std :: os :: raw :: c_ulong , __size : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn realloc (__ptr : * mut :: std :: os :: raw :: c_void , __size : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn free (__ptr : * mut :: std :: os :: raw :: c_void) ; } unsafe extern "C" { pub fn reallocarray (__ptr : * mut :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn alloca (__size : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn valloc (__size : usize) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn posix_memalign (__memptr : * mut * mut :: std :: os :: raw :: c_void , __alignment : usize , __size : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn aligned_alloc (__alignment : :: std :: os :: raw :: c_ulong , __size : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn abort () -> ! ; } unsafe extern "C" { pub fn atexit (__func : :: std :: option :: Option < unsafe extern "C" fn () >) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn at_quick_exit (__func : :: std :: option :: Option < unsafe extern "C" fn () >) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn on_exit (__func : :: std :: option :: Option < unsafe extern "C" fn (__status : :: std :: os :: raw :: c_int , __arg : * mut :: std :: os :: raw :: c_void) > , __arg : * mut :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn exit (__status : :: std :: os :: raw :: c_int) -> ! ; } unsafe extern "C" { pub fn quick_exit (__status : :: std :: os :: raw :: c_int) -> ! ; } unsafe extern "C" { pub fn _Exit (__status : :: std :: os :: raw :: c_int) -> ! ; } unsafe extern "C" { pub fn getenv (__name : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn putenv (__string : * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn setenv (__name : * const :: std :: os :: raw :: c_char , __value : * const :: std :: os :: raw :: c_char , __replace : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn unsetenv (__name : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn clearenv () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn mktemp (__template : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn mkstemp (__template : * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn mkstemps (__template : * mut :: std :: os :: raw :: c_char , __suffixlen : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn mkdtemp (__template : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn system (__command : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn realpath (__name : * const :: std :: os :: raw :: c_char , __resolved : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } pub type __compar_fn_t = :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int > ; unsafe extern "C" { pub fn bsearch (__key : * const :: std :: os :: raw :: c_void , __base : * const :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn qsort (__base : * mut :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t) ; } unsafe extern "C" { pub fn abs (__x : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn labs (__x : :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn llabs (__x : :: std :: os :: raw :: c_longlong) -> :: std :: os :: raw :: c_longlong ; } unsafe extern "C" { pub fn div (__numer : :: std :: os :: raw :: c_int , __denom : :: std :: os :: raw :: c_int) -> div_t ; } unsafe extern "C" { pub fn ldiv (__numer : :: std :: os :: raw :: c_long , __denom : :: std :: os :: raw :: c_long) -> ldiv_t ; } unsafe extern "C" { pub fn lldiv (__numer : :: std :: os :: raw :: c_longlong , __denom : :: std :: os :: raw :: c_longlong) -> lldiv_t ; } unsafe extern "C" { pub fn ecvt (__value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn fcvt (__value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn gcvt (__value : f64 , __ndigit : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn qecvt (__value : u128 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn qfcvt (__value : u128 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn qgcvt (__value : u128 , __ndigit : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ecvt_r (__value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn fcvt_r (__value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn qecvt_r (__value : u128 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn qfcvt_r (__value : u128 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn mblen (__s : * const :: std :: os :: raw :: c_char , __n : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn mbtowc (__pwc : * mut wchar_t , __s : * const :: std :: os :: raw :: c_char , __n : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn wctomb (__s : * mut :: std :: os :: raw :: c_char , __wchar : wchar_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn mbstowcs (__pwcs : * mut wchar_t , __s : * const :: std :: os :: raw :: c_char , __n : usize) -> usize ; } unsafe extern "C" { pub fn wcstombs (__s : * mut :: std :: os :: raw :: c_char , __pwcs : * const wchar_t , __n : usize) -> usize ; } unsafe extern "C" { pub fn rpmatch (__response : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn getsubopt (__optionp : * mut * mut :: std :: os :: raw :: c_char , __tokens : * const * mut :: std :: os :: raw :: c_char , __valuep : * mut * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn getloadavg (__loadavg : * mut f64 , __nelem : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn g_thread_error_quark () -> GQuark ; } pub const GThreadError_G_THREAD_ERROR_AGAIN : GThreadError = 0 ; pub type GThreadError = :: std :: os :: raw :: c_uint ; pub type GThreadFunc = :: std :: option :: Option < unsafe extern "C" fn (data : gpointer) -> gpointer > ; pub type GThread = _GThread ; pub type GMutex = _GMutex ; pub type GRecMutex = _GRecMutex ; pub type GRWLock = _GRWLock ; pub type GCond = _GCond ; pub type GPrivate = _GPrivate ; pub type GOnce = _GOnce ; # [repr (C)] # [derive (Copy , Clone)] pub union _GMutex { pub p : gpointer , pub i : [guint ; 2usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMutex"] [:: std :: mem :: size_of :: < _GMutex > () - 8usize] ; ["Alignment of _GMutex"] [:: std :: mem :: align_of :: < _GMutex > () - 8usize] ; ["Offset of field: _GMutex::p"] [:: std :: mem :: offset_of ! (_GMutex , p) - 0usize] ; ["Offset of field: _GMutex::i"] [:: std :: mem :: offset_of ! (_GMutex , i) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GRWLock { pub p : gpointer , pub i : [guint ; 2usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GRWLock"] [:: std :: mem :: size_of :: < _GRWLock > () - 16usize] ; ["Alignment of _GRWLock"] [:: std :: mem :: align_of :: < _GRWLock > () - 8usize] ; ["Offset of field: _GRWLock::p"] [:: std :: mem :: offset_of ! (_GRWLock , p) - 0usize] ; ["Offset of field: _GRWLock::i"] [:: std :: mem :: offset_of ! (_GRWLock , i) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GCond { pub p : gpointer , pub i : [guint ; 2usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GCond"] [:: std :: mem :: size_of :: < _GCond > () - 16usize] ; ["Alignment of _GCond"] [:: std :: mem :: align_of :: < _GCond > () - 8usize] ; ["Offset of field: _GCond::p"] [:: std :: mem :: offset_of ! (_GCond , p) - 0usize] ; ["Offset of field: _GCond::i"] [:: std :: mem :: offset_of ! (_GCond , i) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GRecMutex { pub p : gpointer , pub i : [guint ; 2usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GRecMutex"] [:: std :: mem :: size_of :: < _GRecMutex > () - 16usize] ; ["Alignment of _GRecMutex"] [:: std :: mem :: align_of :: < _GRecMutex > () - 8usize] ; ["Offset of field: _GRecMutex::p"] [:: std :: mem :: offset_of ! (_GRecMutex , p) - 0usize] ; ["Offset of field: _GRecMutex::i"] [:: std :: mem :: offset_of ! (_GRecMutex , i) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPrivate { pub p : gpointer , pub notify : GDestroyNotify , pub future : [gpointer ; 2usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GPrivate"] [:: std :: mem :: size_of :: < _GPrivate > () - 32usize] ; ["Alignment of _GPrivate"] [:: std :: mem :: align_of :: < _GPrivate > () - 8usize] ; ["Offset of field: _GPrivate::p"] [:: std :: mem :: offset_of ! (_GPrivate , p) - 0usize] ; ["Offset of field: _GPrivate::notify"] [:: std :: mem :: offset_of ! (_GPrivate , notify) - 8usize] ; ["Offset of field: _GPrivate::future"] [:: std :: mem :: offset_of ! (_GPrivate , future) - 16usize] ; } ; pub const GOnceStatus_G_ONCE_STATUS_NOTCALLED : GOnceStatus = 0 ; pub const GOnceStatus_G_ONCE_STATUS_PROGRESS : GOnceStatus = 1 ; pub const GOnceStatus_G_ONCE_STATUS_READY : GOnceStatus = 2 ; pub type GOnceStatus = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GOnce { pub status : GOnceStatus , pub retval : gpointer , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GOnce"] [:: std :: mem :: size_of :: < _GOnce > () - 16usize] ; ["Alignment of _GOnce"] [:: std :: mem :: align_of :: < _GOnce > () - 8usize] ; ["Offset of field: _GOnce::status"] [:: std :: mem :: offset_of ! (_GOnce , status) - 0usize] ; ["Offset of field: _GOnce::retval"] [:: std :: mem :: offset_of ! (_GOnce , retval) - 8usize] ; } ; unsafe extern "C" { pub fn g_thread_ref (thread : * mut GThread) -> * mut GThread ; } unsafe extern "C" { pub fn g_thread_unref (thread : * mut GThread) ; } unsafe extern "C" { pub fn g_thread_new (name : * const gchar , func : GThreadFunc , data : gpointer) -> * mut GThread ; } unsafe extern "C" { pub fn g_thread_try_new (name : * const gchar , func : GThreadFunc , data : gpointer , error : * mut * mut GError) -> * mut GThread ; } unsafe extern "C" { pub fn g_thread_self () -> * mut GThread ; } unsafe extern "C" { pub fn g_thread_exit (retval : gpointer) -> ! ; } unsafe extern "C" { pub fn g_thread_join (thread : * mut GThread) -> gpointer ; } unsafe extern "C" { pub fn g_thread_yield () ; } unsafe extern "C" { pub fn g_thread_get_name (thread : * mut GThread) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_mutex_init (mutex : * mut GMutex) ; } unsafe extern "C" { pub fn g_mutex_clear (mutex : * mut GMutex) ; } unsafe extern "C" { pub fn g_mutex_lock (mutex : * mut GMutex) ; } unsafe extern "C" { pub fn g_mutex_trylock (mutex : * mut GMutex) -> gboolean ; } unsafe extern "C" { pub fn g_mutex_unlock (mutex : * mut GMutex) ; } unsafe extern "C" { pub fn g_rw_lock_init (rw_lock : * mut GRWLock) ; } unsafe extern "C" { pub fn g_rw_lock_clear (rw_lock : * mut GRWLock) ; } unsafe extern "C" { pub fn g_rw_lock_writer_lock (rw_lock : * mut GRWLock) ; } unsafe extern "C" { pub fn g_rw_lock_writer_trylock (rw_lock : * mut GRWLock) -> gboolean ; } unsafe extern "C" { pub fn g_rw_lock_writer_unlock (rw_lock : * mut GRWLock) ; } unsafe extern "C" { pub fn g_rw_lock_reader_lock (rw_lock : * mut GRWLock) ; } unsafe extern "C" { pub fn g_rw_lock_reader_trylock (rw_lock : * mut GRWLock) -> gboolean ; } unsafe extern "C" { pub fn g_rw_lock_reader_unlock (rw_lock : * mut GRWLock) ; } unsafe extern "C" { pub fn g_rec_mutex_init (rec_mutex : * mut GRecMutex) ; } unsafe extern "C" { pub fn g_rec_mutex_clear (rec_mutex : * mut GRecMutex) ; } unsafe extern "C" { pub fn g_rec_mutex_lock (rec_mutex : * mut GRecMutex) ; } unsafe extern "C" { pub fn g_rec_mutex_trylock (rec_mutex : * mut GRecMutex) -> gboolean ; } unsafe extern "C" { pub fn g_rec_mutex_unlock (rec_mutex : * mut GRecMutex) ; } unsafe extern "C" { pub fn g_cond_init (cond : * mut GCond) ; } unsafe extern "C" { pub fn g_cond_clear (cond : * mut GCond) ; } unsafe extern "C" { pub fn g_cond_wait (cond : * mut GCond , mutex : * mut GMutex) ; } unsafe extern "C" { pub fn g_cond_signal (cond : * mut GCond) ; } unsafe extern "C" { pub fn g_cond_broadcast (cond : * mut GCond) ; } unsafe extern "C" { pub fn g_cond_wait_until (cond : * mut GCond , mutex : * mut GMutex , end_time : gint64) -> gboolean ; } unsafe extern "C" { pub fn g_private_get (key : * mut GPrivate) -> gpointer ; } unsafe extern "C" { pub fn g_private_set (key : * mut GPrivate , value : gpointer) ; } unsafe extern "C" { pub fn g_private_replace (key : * mut GPrivate , value : gpointer) ; } unsafe extern "C" { pub fn g_once_impl (once : * mut GOnce , func : GThreadFunc , arg : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_once_init_enter (location : * mut :: std :: os :: raw :: c_void) -> gboolean ; } unsafe extern "C" { pub fn g_once_init_leave (location : * mut :: std :: os :: raw :: c_void , result : gsize) ; } unsafe extern "C" { pub fn g_once_init_enter_pointer (location : * mut :: std :: os :: raw :: c_void) -> gboolean ; } unsafe extern "C" { pub fn g_once_init_leave_pointer (location : * mut :: std :: os :: raw :: c_void , result : gpointer) ; } unsafe extern "C" { pub fn g_get_num_processors () -> guint ; } pub type GMutexLocker = :: std :: os :: raw :: c_void ; pub type GRecMutexLocker = :: std :: os :: raw :: c_void ; pub type GRWLockWriterLocker = :: std :: os :: raw :: c_void ; pub type GRWLockReaderLocker = :: std :: os :: raw :: c_void ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GAsyncQueue { _unused : [u8 ; 0] , } pub type GAsyncQueue = _GAsyncQueue ; unsafe extern "C" { pub fn g_async_queue_new () -> * mut GAsyncQueue ; } unsafe extern "C" { pub fn g_async_queue_new_full (item_free_func : GDestroyNotify) -> * mut GAsyncQueue ; } unsafe extern "C" { pub fn g_async_queue_lock (queue : * mut GAsyncQueue) ; } unsafe extern "C" { pub fn g_async_queue_unlock (queue : * mut GAsyncQueue) ; } unsafe extern "C" { pub fn g_async_queue_ref (queue : * mut GAsyncQueue) -> * mut GAsyncQueue ; } unsafe extern "C" { pub fn g_async_queue_unref (queue : * mut GAsyncQueue) ; } unsafe extern "C" { pub fn g_async_queue_ref_unlocked (queue : * mut GAsyncQueue) ; } unsafe extern "C" { pub fn g_async_queue_unref_and_unlock (queue : * mut GAsyncQueue) ; } unsafe extern "C" { pub fn g_async_queue_push (queue : * mut GAsyncQueue , data : gpointer) ; } unsafe extern "C" { pub fn g_async_queue_push_unlocked (queue : * mut GAsyncQueue , data : gpointer) ; } unsafe extern "C" { pub fn g_async_queue_push_sorted (queue : * mut GAsyncQueue , data : gpointer , func : GCompareDataFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_async_queue_push_sorted_unlocked (queue : * mut GAsyncQueue , data : gpointer , func : GCompareDataFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_async_queue_pop (queue : * mut GAsyncQueue) -> gpointer ; } unsafe extern "C" { pub fn g_async_queue_pop_unlocked (queue : * mut GAsyncQueue) -> gpointer ; } unsafe extern "C" { pub fn g_async_queue_try_pop (queue : * mut GAsyncQueue) -> gpointer ; } unsafe extern "C" { pub fn g_async_queue_try_pop_unlocked (queue : * mut GAsyncQueue) -> gpointer ; } unsafe extern "C" { pub fn g_async_queue_timeout_pop (queue : * mut GAsyncQueue , timeout : guint64) -> gpointer ; } unsafe extern "C" { pub fn g_async_queue_timeout_pop_unlocked (queue : * mut GAsyncQueue , timeout : guint64) -> gpointer ; } unsafe extern "C" { pub fn g_async_queue_length (queue : * mut GAsyncQueue) -> gint ; } unsafe extern "C" { pub fn g_async_queue_length_unlocked (queue : * mut GAsyncQueue) -> gint ; } unsafe extern "C" { pub fn g_async_queue_sort (queue : * mut GAsyncQueue , func : GCompareDataFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_async_queue_sort_unlocked (queue : * mut GAsyncQueue , func : GCompareDataFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_async_queue_remove (queue : * mut GAsyncQueue , item : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_async_queue_remove_unlocked (queue : * mut GAsyncQueue , item : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_async_queue_push_front (queue : * mut GAsyncQueue , item : gpointer) ; } unsafe extern "C" { pub fn g_async_queue_push_front_unlocked (queue : * mut GAsyncQueue , item : gpointer) ; } unsafe extern "C" { pub fn g_async_queue_timed_pop (queue : * mut GAsyncQueue , end_time : * mut GTimeVal) -> gpointer ; } unsafe extern "C" { pub fn g_async_queue_timed_pop_unlocked (queue : * mut GAsyncQueue , end_time : * mut GTimeVal) -> gpointer ; } pub type sig_atomic_t = __sig_atomic_t ; # [repr (C)] # [derive (Copy , Clone)] pub union sigval { pub sival_int : :: std :: os :: raw :: c_int , pub sival_ptr : * mut :: std :: os :: raw :: c_void , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of sigval"] [:: std :: mem :: size_of :: < sigval > () - 8usize] ; ["Alignment of sigval"] [:: std :: mem :: align_of :: < sigval > () - 8usize] ; ["Offset of field: sigval::sival_int"] [:: std :: mem :: offset_of ! (sigval , sival_int) - 0usize] ; ["Offset of field: sigval::sival_ptr"] [:: std :: mem :: offset_of ! (sigval , sival_ptr) - 0usize] ; } ; pub type __sigval_t = sigval ; # [repr (C)] # [derive (Copy , Clone)] pub struct siginfo_t { pub si_signo : :: std :: os :: raw :: c_int , pub si_errno : :: std :: os :: raw :: c_int , pub si_code : :: std :: os :: raw :: c_int , pub __pad0 : :: std :: os :: raw :: c_int , pub _sifields : siginfo_t__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union siginfo_t__bindgen_ty_1 { pub _pad : [:: std :: os :: raw :: c_int ; 28usize] , pub _kill : siginfo_t__bindgen_ty_1__bindgen_ty_1 , pub _timer : siginfo_t__bindgen_ty_1__bindgen_ty_2 , pub _rt : siginfo_t__bindgen_ty_1__bindgen_ty_3 , pub _sigchld : siginfo_t__bindgen_ty_1__bindgen_ty_4 , pub _sigfault : siginfo_t__bindgen_ty_1__bindgen_ty_5 , pub _sigpoll : siginfo_t__bindgen_ty_1__bindgen_ty_6 , pub _sigsys : siginfo_t__bindgen_ty_1__bindgen_ty_7 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 { pub si_pid : __pid_t , pub si_uid : __uid_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_1"] [:: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_1 > () - 8usize] ; ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_1"] [:: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_1 > () - 4usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_1::si_pid"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_1 , si_pid) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_1::si_uid"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_1 , si_uid) - 4usize] ; } ; # [repr (C)] # [derive (Copy , Clone)] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 { pub si_tid : :: std :: os :: raw :: c_int , pub si_overrun : :: std :: os :: raw :: c_int , pub si_sigval : __sigval_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_2"] [:: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_2 > () - 16usize] ; ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_2"] [:: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_2 > () - 8usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_tid"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_2 , si_tid) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_overrun"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_2 , si_overrun) - 4usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_sigval"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_2 , si_sigval) - 8usize] ; } ; # [repr (C)] # [derive (Copy , Clone)] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 { pub si_pid : __pid_t , pub si_uid : __uid_t , pub si_sigval : __sigval_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_3"] [:: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_3 > () - 16usize] ; ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_3"] [:: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_3 > () - 8usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_pid"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_3 , si_pid) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_uid"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_3 , si_uid) - 4usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_sigval"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_3 , si_sigval) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 { pub si_pid : __pid_t , pub si_uid : __uid_t , pub si_status : :: std :: os :: raw :: c_int , pub si_utime : __clock_t , pub si_stime : __clock_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_4"] [:: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_4 > () - 32usize] ; ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_4"] [:: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_4 > () - 8usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_pid"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_4 , si_pid) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_uid"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_4 , si_uid) - 4usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_status"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_4 , si_status) - 8usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_utime"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_4 , si_utime) - 16usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_stime"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_4 , si_stime) - 24usize] ; } ; # [repr (C)] # [derive (Copy , Clone)] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 { pub si_addr : * mut :: std :: os :: raw :: c_void , pub si_addr_lsb : :: std :: os :: raw :: c_short , pub _bounds : siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 { pub _addr_bnd : siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 , pub _pkey : __uint32_t , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 { pub _lower : * mut :: std :: os :: raw :: c_void , pub _upper : * mut :: std :: os :: raw :: c_void , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1"] [:: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 > () - 16usize] ; ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1"] [:: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 > () - 8usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1::_lower"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 , _lower) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1::_upper"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 , _upper) - 8usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1"] [:: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 > () - 16usize] ; ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1"] [:: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 > () - 8usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1::_addr_bnd"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 , _addr_bnd) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1::_pkey"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 , _pkey) - 0usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5"] [:: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5 > () - 32usize] ; ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5"] [:: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5 > () - 8usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::si_addr"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5 , si_addr) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::si_addr_lsb"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5 , si_addr_lsb) - 8usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::_bounds"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5 , _bounds) - 16usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 { pub si_band : :: std :: os :: raw :: c_long , pub si_fd : :: std :: os :: raw :: c_int , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_6"] [:: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_6 > () - 16usize] ; ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_6"] [:: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_6 > () - 8usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_6::si_band"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_6 , si_band) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_6::si_fd"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_6 , si_fd) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 { pub _call_addr : * mut :: std :: os :: raw :: c_void , pub _syscall : :: std :: os :: raw :: c_int , pub _arch : :: std :: os :: raw :: c_uint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_7"] [:: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_7 > () - 16usize] ; ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_7"] [:: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_7 > () - 8usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_call_addr"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_7 , _call_addr) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_syscall"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_7 , _syscall) - 8usize] ; ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_arch"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_7 , _arch) - 12usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of siginfo_t__bindgen_ty_1"] [:: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1 > () - 112usize] ; ["Alignment of siginfo_t__bindgen_ty_1"] [:: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1 > () - 8usize] ; ["Offset of field: siginfo_t__bindgen_ty_1::_pad"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1 , _pad) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1::_kill"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1 , _kill) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1::_timer"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1 , _timer) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1::_rt"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1 , _rt) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1::_sigchld"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1 , _sigchld) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1::_sigfault"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1 , _sigfault) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1::_sigpoll"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1 , _sigpoll) - 0usize] ; ["Offset of field: siginfo_t__bindgen_ty_1::_sigsys"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1 , _sigsys) - 0usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of siginfo_t"] [:: std :: mem :: size_of :: < siginfo_t > () - 128usize] ; ["Alignment of siginfo_t"] [:: std :: mem :: align_of :: < siginfo_t > () - 8usize] ; ["Offset of field: siginfo_t::si_signo"] [:: std :: mem :: offset_of ! (siginfo_t , si_signo) - 0usize] ; ["Offset of field: siginfo_t::si_errno"] [:: std :: mem :: offset_of ! (siginfo_t , si_errno) - 4usize] ; ["Offset of field: siginfo_t::si_code"] [:: std :: mem :: offset_of ! (siginfo_t , si_code) - 8usize] ; ["Offset of field: siginfo_t::__pad0"] [:: std :: mem :: offset_of ! (siginfo_t , __pad0) - 12usize] ; ["Offset of field: siginfo_t::_sifields"] [:: std :: mem :: offset_of ! (siginfo_t , _sifields) - 16usize] ; } ; pub const SI_ASYNCNL : _bindgen_ty_1 = - 60 ; pub const SI_DETHREAD : _bindgen_ty_1 = - 7 ; pub const SI_TKILL : _bindgen_ty_1 = - 6 ; pub const SI_SIGIO : _bindgen_ty_1 = - 5 ; pub const SI_ASYNCIO : _bindgen_ty_1 = - 4 ; pub const SI_MESGQ : _bindgen_ty_1 = - 3 ; pub const SI_TIMER : _bindgen_ty_1 = - 2 ; pub const SI_QUEUE : _bindgen_ty_1 = - 1 ; pub const SI_USER : _bindgen_ty_1 = 0 ; pub const SI_KERNEL : _bindgen_ty_1 = 128 ; pub type _bindgen_ty_1 = :: std :: os :: raw :: c_int ; pub const ILL_ILLOPC : _bindgen_ty_2 = 1 ; pub const ILL_ILLOPN : _bindgen_ty_2 = 2 ; pub const ILL_ILLADR : _bindgen_ty_2 = 3 ; pub const ILL_ILLTRP : _bindgen_ty_2 = 4 ; pub const ILL_PRVOPC : _bindgen_ty_2 = 5 ; pub const ILL_PRVREG : _bindgen_ty_2 = 6 ; pub const ILL_COPROC : _bindgen_ty_2 = 7 ; pub const ILL_BADSTK : _bindgen_ty_2 = 8 ; pub const ILL_BADIADDR : _bindgen_ty_2 = 9 ; pub type _bindgen_ty_2 = :: std :: os :: raw :: c_uint ; pub const FPE_INTDIV : _bindgen_ty_3 = 1 ; pub const FPE_INTOVF : _bindgen_ty_3 = 2 ; pub const FPE_FLTDIV : _bindgen_ty_3 = 3 ; pub const FPE_FLTOVF : _bindgen_ty_3 = 4 ; pub const FPE_FLTUND : _bindgen_ty_3 = 5 ; pub const FPE_FLTRES : _bindgen_ty_3 = 6 ; pub const FPE_FLTINV : _bindgen_ty_3 = 7 ; pub const FPE_FLTSUB : _bindgen_ty_3 = 8 ; pub const FPE_FLTUNK : _bindgen_ty_3 = 14 ; pub const FPE_CONDTRAP : _bindgen_ty_3 = 15 ; pub type _bindgen_ty_3 = :: std :: os :: raw :: c_uint ; pub const SEGV_MAPERR : _bindgen_ty_4 = 1 ; pub const SEGV_ACCERR : _bindgen_ty_4 = 2 ; pub const SEGV_BNDERR : _bindgen_ty_4 = 3 ; pub const SEGV_PKUERR : _bindgen_ty_4 = 4 ; pub const SEGV_ACCADI : _bindgen_ty_4 = 5 ; pub const SEGV_ADIDERR : _bindgen_ty_4 = 6 ; pub const SEGV_ADIPERR : _bindgen_ty_4 = 7 ; pub const SEGV_MTEAERR : _bindgen_ty_4 = 8 ; pub const SEGV_MTESERR : _bindgen_ty_4 = 9 ; pub const SEGV_CPERR : _bindgen_ty_4 = 10 ; pub type _bindgen_ty_4 = :: std :: os :: raw :: c_uint ; pub const BUS_ADRALN : _bindgen_ty_5 = 1 ; pub const BUS_ADRERR : _bindgen_ty_5 = 2 ; pub const BUS_OBJERR : _bindgen_ty_5 = 3 ; pub const BUS_MCEERR_AR : _bindgen_ty_5 = 4 ; pub const BUS_MCEERR_AO : _bindgen_ty_5 = 5 ; pub type _bindgen_ty_5 = :: std :: os :: raw :: c_uint ; pub const CLD_EXITED : _bindgen_ty_6 = 1 ; pub const CLD_KILLED : _bindgen_ty_6 = 2 ; pub const CLD_DUMPED : _bindgen_ty_6 = 3 ; pub const CLD_TRAPPED : _bindgen_ty_6 = 4 ; pub const CLD_STOPPED : _bindgen_ty_6 = 5 ; pub const CLD_CONTINUED : _bindgen_ty_6 = 6 ; pub type _bindgen_ty_6 = :: std :: os :: raw :: c_uint ; pub const POLL_IN : _bindgen_ty_7 = 1 ; pub const POLL_OUT : _bindgen_ty_7 = 2 ; pub const POLL_MSG : _bindgen_ty_7 = 3 ; pub const POLL_ERR : _bindgen_ty_7 = 4 ; pub const POLL_PRI : _bindgen_ty_7 = 5 ; pub const POLL_HUP : _bindgen_ty_7 = 6 ; pub type _bindgen_ty_7 = :: std :: os :: raw :: c_uint ; pub type sigval_t = __sigval_t ; # [repr (C)] # [derive (Copy , Clone)] pub struct sigevent { pub sigev_value : __sigval_t , pub sigev_signo : :: std :: os :: raw :: c_int , pub sigev_notify : :: std :: os :: raw :: c_int , pub _sigev_un : sigevent__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union sigevent__bindgen_ty_1 { pub _pad : [:: std :: os :: raw :: c_int ; 12usize] , pub _tid : __pid_t , pub _sigev_thread : sigevent__bindgen_ty_1__bindgen_ty_1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct sigevent__bindgen_ty_1__bindgen_ty_1 { pub _function : :: std :: option :: Option < unsafe extern "C" fn (arg1 : __sigval_t) > , pub _attribute : * mut pthread_attr_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of sigevent__bindgen_ty_1__bindgen_ty_1"] [:: std :: mem :: size_of :: < sigevent__bindgen_ty_1__bindgen_ty_1 > () - 16usize] ; ["Alignment of sigevent__bindgen_ty_1__bindgen_ty_1"] [:: std :: mem :: align_of :: < sigevent__bindgen_ty_1__bindgen_ty_1 > () - 8usize] ; ["Offset of field: sigevent__bindgen_ty_1__bindgen_ty_1::_function"] [:: std :: mem :: offset_of ! (sigevent__bindgen_ty_1__bindgen_ty_1 , _function) - 0usize] ; ["Offset of field: sigevent__bindgen_ty_1__bindgen_ty_1::_attribute"] [:: std :: mem :: offset_of ! (sigevent__bindgen_ty_1__bindgen_ty_1 , _attribute) - 8usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of sigevent__bindgen_ty_1"] [:: std :: mem :: size_of :: < sigevent__bindgen_ty_1 > () - 48usize] ; ["Alignment of sigevent__bindgen_ty_1"] [:: std :: mem :: align_of :: < sigevent__bindgen_ty_1 > () - 8usize] ; ["Offset of field: sigevent__bindgen_ty_1::_pad"] [:: std :: mem :: offset_of ! (sigevent__bindgen_ty_1 , _pad) - 0usize] ; ["Offset of field: sigevent__bindgen_ty_1::_tid"] [:: std :: mem :: offset_of ! (sigevent__bindgen_ty_1 , _tid) - 0usize] ; ["Offset of field: sigevent__bindgen_ty_1::_sigev_thread"] [:: std :: mem :: offset_of ! (sigevent__bindgen_ty_1 , _sigev_thread) - 0usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of sigevent"] [:: std :: mem :: size_of :: < sigevent > () - 64usize] ; ["Alignment of sigevent"] [:: std :: mem :: align_of :: < sigevent > () - 8usize] ; ["Offset of field: sigevent::sigev_value"] [:: std :: mem :: offset_of ! (sigevent , sigev_value) - 0usize] ; ["Offset of field: sigevent::sigev_signo"] [:: std :: mem :: offset_of ! (sigevent , sigev_signo) - 8usize] ; ["Offset of field: sigevent::sigev_notify"] [:: std :: mem :: offset_of ! (sigevent , sigev_notify) - 12usize] ; ["Offset of field: sigevent::_sigev_un"] [:: std :: mem :: offset_of ! (sigevent , _sigev_un) - 16usize] ; } ; pub type sigevent_t = sigevent ; pub const SIGEV_SIGNAL : _bindgen_ty_8 = 0 ; pub const SIGEV_NONE : _bindgen_ty_8 = 1 ; pub const SIGEV_THREAD : _bindgen_ty_8 = 2 ; pub const SIGEV_THREAD_ID : _bindgen_ty_8 = 4 ; pub type _bindgen_ty_8 = :: std :: os :: raw :: c_uint ; pub type __sighandler_t = :: std :: option :: Option < unsafe extern "C" fn (arg1 : :: std :: os :: raw :: c_int) > ; unsafe extern "C" { pub fn __sysv_signal (__sig : :: std :: os :: raw :: c_int , __handler : __sighandler_t) -> __sighandler_t ; } unsafe extern "C" { pub fn signal (__sig : :: std :: os :: raw :: c_int , __handler : __sighandler_t) -> __sighandler_t ; } unsafe extern "C" { pub fn kill (__pid : __pid_t , __sig : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn killpg (__pgrp : __pid_t , __sig : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn raise (__sig : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ssignal (__sig : :: std :: os :: raw :: c_int , __handler : __sighandler_t) -> __sighandler_t ; } unsafe extern "C" { pub fn gsignal (__sig : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn psignal (__sig : :: std :: os :: raw :: c_int , __s : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn psiginfo (__pinfo : * const siginfo_t , __s : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn sigblock (__mask : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sigsetmask (__mask : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn siggetmask () -> :: std :: os :: raw :: c_int ; } pub type sig_t = __sighandler_t ; unsafe extern "C" { pub fn sigemptyset (__set : * mut sigset_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sigfillset (__set : * mut sigset_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sigaddset (__set : * mut sigset_t , __signo : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sigdelset (__set : * mut sigset_t , __signo : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sigismember (__set : * const sigset_t , __signo : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct sigaction { pub __sigaction_handler : sigaction__bindgen_ty_1 , pub sa_mask : __sigset_t , pub sa_flags : :: std :: os :: raw :: c_int , pub sa_restorer : :: std :: option :: Option < unsafe extern "C" fn () > , } # [repr (C)] # [derive (Copy , Clone)] pub union sigaction__bindgen_ty_1 { pub sa_handler : __sighandler_t , pub sa_sigaction : :: std :: option :: Option < unsafe extern "C" fn (arg1 : :: std :: os :: raw :: c_int , arg2 : * mut siginfo_t , arg3 : * mut :: std :: os :: raw :: c_void) > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of sigaction__bindgen_ty_1"] [:: std :: mem :: size_of :: < sigaction__bindgen_ty_1 > () - 8usize] ; ["Alignment of sigaction__bindgen_ty_1"] [:: std :: mem :: align_of :: < sigaction__bindgen_ty_1 > () - 8usize] ; ["Offset of field: sigaction__bindgen_ty_1::sa_handler"] [:: std :: mem :: offset_of ! (sigaction__bindgen_ty_1 , sa_handler) - 0usize] ; ["Offset of field: sigaction__bindgen_ty_1::sa_sigaction"] [:: std :: mem :: offset_of ! (sigaction__bindgen_ty_1 , sa_sigaction) - 0usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of sigaction"] [:: std :: mem :: size_of :: < sigaction > () - 152usize] ; ["Alignment of sigaction"] [:: std :: mem :: align_of :: < sigaction > () - 8usize] ; ["Offset of field: sigaction::__sigaction_handler"] [:: std :: mem :: offset_of ! (sigaction , __sigaction_handler) - 0usize] ; ["Offset of field: sigaction::sa_mask"] [:: std :: mem :: offset_of ! (sigaction , sa_mask) - 8usize] ; ["Offset of field: sigaction::sa_flags"] [:: std :: mem :: offset_of ! (sigaction , sa_flags) - 136usize] ; ["Offset of field: sigaction::sa_restorer"] [:: std :: mem :: offset_of ! (sigaction , sa_restorer) - 144usize] ; } ; unsafe extern "C" { pub fn sigprocmask (__how : :: std :: os :: raw :: c_int , __set : * const sigset_t , __oset : * mut sigset_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sigsuspend (__set : * const sigset_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sigaction (__sig : :: std :: os :: raw :: c_int , __act : * const sigaction , __oact : * mut sigaction) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sigpending (__set : * mut sigset_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sigwait (__set : * const sigset_t , __sig : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sigwaitinfo (__set : * const sigset_t , __info : * mut siginfo_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sigtimedwait (__set : * const sigset_t , __info : * mut siginfo_t , __timeout : * const timespec) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sigqueue (__pid : __pid_t , __sig : :: std :: os :: raw :: c_int , __val : sigval) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _fpx_sw_bytes { pub magic1 : __uint32_t , pub extended_size : __uint32_t , pub xstate_bv : __uint64_t , pub xstate_size : __uint32_t , pub __glibc_reserved1 : [__uint32_t ; 7usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _fpx_sw_bytes"] [:: std :: mem :: size_of :: < _fpx_sw_bytes > () - 48usize] ; ["Alignment of _fpx_sw_bytes"] [:: std :: mem :: align_of :: < _fpx_sw_bytes > () - 8usize] ; ["Offset of field: _fpx_sw_bytes::magic1"] [:: std :: mem :: offset_of ! (_fpx_sw_bytes , magic1) - 0usize] ; ["Offset of field: _fpx_sw_bytes::extended_size"] [:: std :: mem :: offset_of ! (_fpx_sw_bytes , extended_size) - 4usize] ; ["Offset of field: _fpx_sw_bytes::xstate_bv"] [:: std :: mem :: offset_of ! (_fpx_sw_bytes , xstate_bv) - 8usize] ; ["Offset of field: _fpx_sw_bytes::xstate_size"] [:: std :: mem :: offset_of ! (_fpx_sw_bytes , xstate_size) - 16usize] ; ["Offset of field: _fpx_sw_bytes::__glibc_reserved1"] [:: std :: mem :: offset_of ! (_fpx_sw_bytes , __glibc_reserved1) - 20usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _fpreg { pub significand : [:: std :: os :: raw :: c_ushort ; 4usize] , pub exponent : :: std :: os :: raw :: c_ushort , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _fpreg"] [:: std :: mem :: size_of :: < _fpreg > () - 10usize] ; ["Alignment of _fpreg"] [:: std :: mem :: align_of :: < _fpreg > () - 2usize] ; ["Offset of field: _fpreg::significand"] [:: std :: mem :: offset_of ! (_fpreg , significand) - 0usize] ; ["Offset of field: _fpreg::exponent"] [:: std :: mem :: offset_of ! (_fpreg , exponent) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _fpxreg { pub significand : [:: std :: os :: raw :: c_ushort ; 4usize] , pub exponent : :: std :: os :: raw :: c_ushort , pub __glibc_reserved1 : [:: std :: os :: raw :: c_ushort ; 3usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _fpxreg"] [:: std :: mem :: size_of :: < _fpxreg > () - 16usize] ; ["Alignment of _fpxreg"] [:: std :: mem :: align_of :: < _fpxreg > () - 2usize] ; ["Offset of field: _fpxreg::significand"] [:: std :: mem :: offset_of ! (_fpxreg , significand) - 0usize] ; ["Offset of field: _fpxreg::exponent"] [:: std :: mem :: offset_of ! (_fpxreg , exponent) - 8usize] ; ["Offset of field: _fpxreg::__glibc_reserved1"] [:: std :: mem :: offset_of ! (_fpxreg , __glibc_reserved1) - 10usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _xmmreg { pub element : [__uint32_t ; 4usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _xmmreg"] [:: std :: mem :: size_of :: < _xmmreg > () - 16usize] ; ["Alignment of _xmmreg"] [:: std :: mem :: align_of :: < _xmmreg > () - 4usize] ; ["Offset of field: _xmmreg::element"] [:: std :: mem :: offset_of ! (_xmmreg , element) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _fpstate { pub cwd : __uint16_t , pub swd : __uint16_t , pub ftw : __uint16_t , pub fop : __uint16_t , pub rip : __uint64_t , pub rdp : __uint64_t , pub mxcsr : __uint32_t , pub mxcr_mask : __uint32_t , pub _st : [_fpxreg ; 8usize] , pub _xmm : [_xmmreg ; 16usize] , pub __glibc_reserved1 : [__uint32_t ; 24usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _fpstate"] [:: std :: mem :: size_of :: < _fpstate > () - 512usize] ; ["Alignment of _fpstate"] [:: std :: mem :: align_of :: < _fpstate > () - 8usize] ; ["Offset of field: _fpstate::cwd"] [:: std :: mem :: offset_of ! (_fpstate , cwd) - 0usize] ; ["Offset of field: _fpstate::swd"] [:: std :: mem :: offset_of ! (_fpstate , swd) - 2usize] ; ["Offset of field: _fpstate::ftw"] [:: std :: mem :: offset_of ! (_fpstate , ftw) - 4usize] ; ["Offset of field: _fpstate::fop"] [:: std :: mem :: offset_of ! (_fpstate , fop) - 6usize] ; ["Offset of field: _fpstate::rip"] [:: std :: mem :: offset_of ! (_fpstate , rip) - 8usize] ; ["Offset of field: _fpstate::rdp"] [:: std :: mem :: offset_of ! (_fpstate , rdp) - 16usize] ; ["Offset of field: _fpstate::mxcsr"] [:: std :: mem :: offset_of ! (_fpstate , mxcsr) - 24usize] ; ["Offset of field: _fpstate::mxcr_mask"] [:: std :: mem :: offset_of ! (_fpstate , mxcr_mask) - 28usize] ; ["Offset of field: _fpstate::_st"] [:: std :: mem :: offset_of ! (_fpstate , _st) - 32usize] ; ["Offset of field: _fpstate::_xmm"] [:: std :: mem :: offset_of ! (_fpstate , _xmm) - 160usize] ; ["Offset of field: _fpstate::__glibc_reserved1"] [:: std :: mem :: offset_of ! (_fpstate , __glibc_reserved1) - 416usize] ; } ; # [repr (C)] # [derive (Copy , Clone)] pub struct sigcontext { pub r8 : __uint64_t , pub r9 : __uint64_t , pub r10 : __uint64_t , pub r11 : __uint64_t , pub r12 : __uint64_t , pub r13 : __uint64_t , pub r14 : __uint64_t , pub r15 : __uint64_t , pub rdi : __uint64_t , pub rsi : __uint64_t , pub rbp : __uint64_t , pub rbx : __uint64_t , pub rdx : __uint64_t , pub rax : __uint64_t , pub rcx : __uint64_t , pub rsp : __uint64_t , pub rip : __uint64_t , pub eflags : __uint64_t , pub cs : :: std :: os :: raw :: c_ushort , pub gs : :: std :: os :: raw :: c_ushort , pub fs : :: std :: os :: raw :: c_ushort , pub __pad0 : :: std :: os :: raw :: c_ushort , pub err : __uint64_t , pub trapno : __uint64_t , pub oldmask : __uint64_t , pub cr2 : __uint64_t , pub __bindgen_anon_1 : sigcontext__bindgen_ty_1 , pub __reserved1 : [__uint64_t ; 8usize] , } # [repr (C)] # [derive (Copy , Clone)] pub union sigcontext__bindgen_ty_1 { pub fpstate : * mut _fpstate , pub __fpstate_word : __uint64_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of sigcontext__bindgen_ty_1"] [:: std :: mem :: size_of :: < sigcontext__bindgen_ty_1 > () - 8usize] ; ["Alignment of sigcontext__bindgen_ty_1"] [:: std :: mem :: align_of :: < sigcontext__bindgen_ty_1 > () - 8usize] ; ["Offset of field: sigcontext__bindgen_ty_1::fpstate"] [:: std :: mem :: offset_of ! (sigcontext__bindgen_ty_1 , fpstate) - 0usize] ; ["Offset of field: sigcontext__bindgen_ty_1::__fpstate_word"] [:: std :: mem :: offset_of ! (sigcontext__bindgen_ty_1 , __fpstate_word) - 0usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of sigcontext"] [:: std :: mem :: size_of :: < sigcontext > () - 256usize] ; ["Alignment of sigcontext"] [:: std :: mem :: align_of :: < sigcontext > () - 8usize] ; ["Offset of field: sigcontext::r8"] [:: std :: mem :: offset_of ! (sigcontext , r8) - 0usize] ; ["Offset of field: sigcontext::r9"] [:: std :: mem :: offset_of ! (sigcontext , r9) - 8usize] ; ["Offset of field: sigcontext::r10"] [:: std :: mem :: offset_of ! (sigcontext , r10) - 16usize] ; ["Offset of field: sigcontext::r11"] [:: std :: mem :: offset_of ! (sigcontext , r11) - 24usize] ; ["Offset of field: sigcontext::r12"] [:: std :: mem :: offset_of ! (sigcontext , r12) - 32usize] ; ["Offset of field: sigcontext::r13"] [:: std :: mem :: offset_of ! (sigcontext , r13) - 40usize] ; ["Offset of field: sigcontext::r14"] [:: std :: mem :: offset_of ! (sigcontext , r14) - 48usize] ; ["Offset of field: sigcontext::r15"] [:: std :: mem :: offset_of ! (sigcontext , r15) - 56usize] ; ["Offset of field: sigcontext::rdi"] [:: std :: mem :: offset_of ! (sigcontext , rdi) - 64usize] ; ["Offset of field: sigcontext::rsi"] [:: std :: mem :: offset_of ! (sigcontext , rsi) - 72usize] ; ["Offset of field: sigcontext::rbp"] [:: std :: mem :: offset_of ! (sigcontext , rbp) - 80usize] ; ["Offset of field: sigcontext::rbx"] [:: std :: mem :: offset_of ! (sigcontext , rbx) - 88usize] ; ["Offset of field: sigcontext::rdx"] [:: std :: mem :: offset_of ! (sigcontext , rdx) - 96usize] ; ["Offset of field: sigcontext::rax"] [:: std :: mem :: offset_of ! (sigcontext , rax) - 104usize] ; ["Offset of field: sigcontext::rcx"] [:: std :: mem :: offset_of ! (sigcontext , rcx) - 112usize] ; ["Offset of field: sigcontext::rsp"] [:: std :: mem :: offset_of ! (sigcontext , rsp) - 120usize] ; ["Offset of field: sigcontext::rip"] [:: std :: mem :: offset_of ! (sigcontext , rip) - 128usize] ; ["Offset of field: sigcontext::eflags"] [:: std :: mem :: offset_of ! (sigcontext , eflags) - 136usize] ; ["Offset of field: sigcontext::cs"] [:: std :: mem :: offset_of ! (sigcontext , cs) - 144usize] ; ["Offset of field: sigcontext::gs"] [:: std :: mem :: offset_of ! (sigcontext , gs) - 146usize] ; ["Offset of field: sigcontext::fs"] [:: std :: mem :: offset_of ! (sigcontext , fs) - 148usize] ; ["Offset of field: sigcontext::__pad0"] [:: std :: mem :: offset_of ! (sigcontext , __pad0) - 150usize] ; ["Offset of field: sigcontext::err"] [:: std :: mem :: offset_of ! (sigcontext , err) - 152usize] ; ["Offset of field: sigcontext::trapno"] [:: std :: mem :: offset_of ! (sigcontext , trapno) - 160usize] ; ["Offset of field: sigcontext::oldmask"] [:: std :: mem :: offset_of ! (sigcontext , oldmask) - 168usize] ; ["Offset of field: sigcontext::cr2"] [:: std :: mem :: offset_of ! (sigcontext , cr2) - 176usize] ; ["Offset of field: sigcontext::__reserved1"] [:: std :: mem :: offset_of ! (sigcontext , __reserved1) - 192usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _xsave_hdr { pub xstate_bv : __uint64_t , pub __glibc_reserved1 : [__uint64_t ; 2usize] , pub __glibc_reserved2 : [__uint64_t ; 5usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _xsave_hdr"] [:: std :: mem :: size_of :: < _xsave_hdr > () - 64usize] ; ["Alignment of _xsave_hdr"] [:: std :: mem :: align_of :: < _xsave_hdr > () - 8usize] ; ["Offset of field: _xsave_hdr::xstate_bv"] [:: std :: mem :: offset_of ! (_xsave_hdr , xstate_bv) - 0usize] ; ["Offset of field: _xsave_hdr::__glibc_reserved1"] [:: std :: mem :: offset_of ! (_xsave_hdr , __glibc_reserved1) - 8usize] ; ["Offset of field: _xsave_hdr::__glibc_reserved2"] [:: std :: mem :: offset_of ! (_xsave_hdr , __glibc_reserved2) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _ymmh_state { pub ymmh_space : [__uint32_t ; 64usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _ymmh_state"] [:: std :: mem :: size_of :: < _ymmh_state > () - 256usize] ; ["Alignment of _ymmh_state"] [:: std :: mem :: align_of :: < _ymmh_state > () - 4usize] ; ["Offset of field: _ymmh_state::ymmh_space"] [:: std :: mem :: offset_of ! (_ymmh_state , ymmh_space) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _xstate { pub fpstate : _fpstate , pub xstate_hdr : _xsave_hdr , pub ymmh : _ymmh_state , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _xstate"] [:: std :: mem :: size_of :: < _xstate > () - 832usize] ; ["Alignment of _xstate"] [:: std :: mem :: align_of :: < _xstate > () - 8usize] ; ["Offset of field: _xstate::fpstate"] [:: std :: mem :: offset_of ! (_xstate , fpstate) - 0usize] ; ["Offset of field: _xstate::xstate_hdr"] [:: std :: mem :: offset_of ! (_xstate , xstate_hdr) - 512usize] ; ["Offset of field: _xstate::ymmh"] [:: std :: mem :: offset_of ! (_xstate , ymmh) - 576usize] ; } ; unsafe extern "C" { pub fn sigreturn (__scp : * mut sigcontext) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct stack_t { pub ss_sp : * mut :: std :: os :: raw :: c_void , pub ss_flags : :: std :: os :: raw :: c_int , pub ss_size : usize , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of stack_t"] [:: std :: mem :: size_of :: < stack_t > () - 24usize] ; ["Alignment of stack_t"] [:: std :: mem :: align_of :: < stack_t > () - 8usize] ; ["Offset of field: stack_t::ss_sp"] [:: std :: mem :: offset_of ! (stack_t , ss_sp) - 0usize] ; ["Offset of field: stack_t::ss_flags"] [:: std :: mem :: offset_of ! (stack_t , ss_flags) - 8usize] ; ["Offset of field: stack_t::ss_size"] [:: std :: mem :: offset_of ! (stack_t , ss_size) - 16usize] ; } ; pub type greg_t = :: std :: os :: raw :: c_longlong ; pub type gregset_t = [greg_t ; 23usize] ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _libc_fpxreg { pub significand : [:: std :: os :: raw :: c_ushort ; 4usize] , pub exponent : :: std :: os :: raw :: c_ushort , pub __glibc_reserved1 : [:: std :: os :: raw :: c_ushort ; 3usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _libc_fpxreg"] [:: std :: mem :: size_of :: < _libc_fpxreg > () - 16usize] ; ["Alignment of _libc_fpxreg"] [:: std :: mem :: align_of :: < _libc_fpxreg > () - 2usize] ; ["Offset of field: _libc_fpxreg::significand"] [:: std :: mem :: offset_of ! (_libc_fpxreg , significand) - 0usize] ; ["Offset of field: _libc_fpxreg::exponent"] [:: std :: mem :: offset_of ! (_libc_fpxreg , exponent) - 8usize] ; ["Offset of field: _libc_fpxreg::__glibc_reserved1"] [:: std :: mem :: offset_of ! (_libc_fpxreg , __glibc_reserved1) - 10usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _libc_xmmreg { pub element : [__uint32_t ; 4usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _libc_xmmreg"] [:: std :: mem :: size_of :: < _libc_xmmreg > () - 16usize] ; ["Alignment of _libc_xmmreg"] [:: std :: mem :: align_of :: < _libc_xmmreg > () - 4usize] ; ["Offset of field: _libc_xmmreg::element"] [:: std :: mem :: offset_of ! (_libc_xmmreg , element) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _libc_fpstate { pub cwd : __uint16_t , pub swd : __uint16_t , pub ftw : __uint16_t , pub fop : __uint16_t , pub rip : __uint64_t , pub rdp : __uint64_t , pub mxcsr : __uint32_t , pub mxcr_mask : __uint32_t , pub _st : [_libc_fpxreg ; 8usize] , pub _xmm : [_libc_xmmreg ; 16usize] , pub __glibc_reserved1 : [__uint32_t ; 24usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _libc_fpstate"] [:: std :: mem :: size_of :: < _libc_fpstate > () - 512usize] ; ["Alignment of _libc_fpstate"] [:: std :: mem :: align_of :: < _libc_fpstate > () - 8usize] ; ["Offset of field: _libc_fpstate::cwd"] [:: std :: mem :: offset_of ! (_libc_fpstate , cwd) - 0usize] ; ["Offset of field: _libc_fpstate::swd"] [:: std :: mem :: offset_of ! (_libc_fpstate , swd) - 2usize] ; ["Offset of field: _libc_fpstate::ftw"] [:: std :: mem :: offset_of ! (_libc_fpstate , ftw) - 4usize] ; ["Offset of field: _libc_fpstate::fop"] [:: std :: mem :: offset_of ! (_libc_fpstate , fop) - 6usize] ; ["Offset of field: _libc_fpstate::rip"] [:: std :: mem :: offset_of ! (_libc_fpstate , rip) - 8usize] ; ["Offset of field: _libc_fpstate::rdp"] [:: std :: mem :: offset_of ! (_libc_fpstate , rdp) - 16usize] ; ["Offset of field: _libc_fpstate::mxcsr"] [:: std :: mem :: offset_of ! (_libc_fpstate , mxcsr) - 24usize] ; ["Offset of field: _libc_fpstate::mxcr_mask"] [:: std :: mem :: offset_of ! (_libc_fpstate , mxcr_mask) - 28usize] ; ["Offset of field: _libc_fpstate::_st"] [:: std :: mem :: offset_of ! (_libc_fpstate , _st) - 32usize] ; ["Offset of field: _libc_fpstate::_xmm"] [:: std :: mem :: offset_of ! (_libc_fpstate , _xmm) - 160usize] ; ["Offset of field: _libc_fpstate::__glibc_reserved1"] [:: std :: mem :: offset_of ! (_libc_fpstate , __glibc_reserved1) - 416usize] ; } ; pub type fpregset_t = * mut _libc_fpstate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct mcontext_t { pub gregs : gregset_t , pub fpregs : fpregset_t , pub __reserved1 : [:: std :: os :: raw :: c_ulonglong ; 8usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of mcontext_t"] [:: std :: mem :: size_of :: < mcontext_t > () - 256usize] ; ["Alignment of mcontext_t"] [:: std :: mem :: align_of :: < mcontext_t > () - 8usize] ; ["Offset of field: mcontext_t::gregs"] [:: std :: mem :: offset_of ! (mcontext_t , gregs) - 0usize] ; ["Offset of field: mcontext_t::fpregs"] [:: std :: mem :: offset_of ! (mcontext_t , fpregs) - 184usize] ; ["Offset of field: mcontext_t::__reserved1"] [:: std :: mem :: offset_of ! (mcontext_t , __reserved1) - 192usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ucontext_t { pub uc_flags : :: std :: os :: raw :: c_ulong , pub uc_link : * mut ucontext_t , pub uc_stack : stack_t , pub uc_mcontext : mcontext_t , pub uc_sigmask : sigset_t , pub __fpregs_mem : _libc_fpstate , pub __ssp : [:: std :: os :: raw :: c_ulonglong ; 4usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ucontext_t"] [:: std :: mem :: size_of :: < ucontext_t > () - 968usize] ; ["Alignment of ucontext_t"] [:: std :: mem :: align_of :: < ucontext_t > () - 8usize] ; ["Offset of field: ucontext_t::uc_flags"] [:: std :: mem :: offset_of ! (ucontext_t , uc_flags) - 0usize] ; ["Offset of field: ucontext_t::uc_link"] [:: std :: mem :: offset_of ! (ucontext_t , uc_link) - 8usize] ; ["Offset of field: ucontext_t::uc_stack"] [:: std :: mem :: offset_of ! (ucontext_t , uc_stack) - 16usize] ; ["Offset of field: ucontext_t::uc_mcontext"] [:: std :: mem :: offset_of ! (ucontext_t , uc_mcontext) - 40usize] ; ["Offset of field: ucontext_t::uc_sigmask"] [:: std :: mem :: offset_of ! (ucontext_t , uc_sigmask) - 296usize] ; ["Offset of field: ucontext_t::__fpregs_mem"] [:: std :: mem :: offset_of ! (ucontext_t , __fpregs_mem) - 424usize] ; ["Offset of field: ucontext_t::__ssp"] [:: std :: mem :: offset_of ! (ucontext_t , __ssp) - 936usize] ; } ; unsafe extern "C" { pub fn siginterrupt (__sig : :: std :: os :: raw :: c_int , __interrupt : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } pub const SS_ONSTACK : _bindgen_ty_9 = 1 ; pub const SS_DISABLE : _bindgen_ty_9 = 2 ; pub type _bindgen_ty_9 = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn sigaltstack (__ss : * const stack_t , __oss : * mut stack_t) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct sigstack { pub ss_sp : * mut :: std :: os :: raw :: c_void , pub ss_onstack : :: std :: os :: raw :: c_int , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of sigstack"] [:: std :: mem :: size_of :: < sigstack > () - 16usize] ; ["Alignment of sigstack"] [:: std :: mem :: align_of :: < sigstack > () - 8usize] ; ["Offset of field: sigstack::ss_sp"] [:: std :: mem :: offset_of ! (sigstack , ss_sp) - 0usize] ; ["Offset of field: sigstack::ss_onstack"] [:: std :: mem :: offset_of ! (sigstack , ss_onstack) - 8usize] ; } ; unsafe extern "C" { pub fn sigstack (__ss : * mut sigstack , __oss : * mut sigstack) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_sigmask (__how : :: std :: os :: raw :: c_int , __newmask : * const __sigset_t , __oldmask : * mut __sigset_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_kill (__threadid : pthread_t , __signo : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn __libc_current_sigrtmin () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn __libc_current_sigrtmax () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn g_on_error_query (prg_name : * const gchar) ; } unsafe extern "C" { pub fn g_on_error_stack_trace (prg_name : * const gchar) ; } unsafe extern "C" { pub fn g_base64_encode_step (in_ : * const guchar , len : gsize , break_lines : gboolean , out : * mut gchar , state : * mut gint , save : * mut gint) -> gsize ; } unsafe extern "C" { pub fn g_base64_encode_close (break_lines : gboolean , out : * mut gchar , state : * mut gint , save : * mut gint) -> gsize ; } unsafe extern "C" { pub fn g_base64_encode (data : * const guchar , len : gsize) -> * mut gchar ; } unsafe extern "C" { pub fn g_base64_decode_step (in_ : * const gchar , len : gsize , out : * mut guchar , state : * mut gint , save : * mut guint) -> gsize ; } unsafe extern "C" { pub fn g_base64_decode (text : * const gchar , out_len : * mut gsize) -> * mut guchar ; } unsafe extern "C" { pub fn g_base64_decode_inplace (text : * mut gchar , out_len : * mut gsize) -> * mut guchar ; } unsafe extern "C" { pub fn g_bit_lock (address : * mut gint , lock_bit : gint) ; } unsafe extern "C" { pub fn g_bit_trylock (address : * mut gint , lock_bit : gint) -> gboolean ; } unsafe extern "C" { pub fn g_bit_unlock (address : * mut gint , lock_bit : gint) ; } unsafe extern "C" { pub fn g_pointer_bit_lock (address : * mut :: std :: os :: raw :: c_void , lock_bit : gint) ; } unsafe extern "C" { pub fn g_pointer_bit_lock_and_get (address : gpointer , lock_bit : guint , out_ptr : * mut guintptr) ; } unsafe extern "C" { pub fn g_pointer_bit_trylock (address : * mut :: std :: os :: raw :: c_void , lock_bit : gint) -> gboolean ; } unsafe extern "C" { pub fn g_pointer_bit_unlock (address : * mut :: std :: os :: raw :: c_void , lock_bit : gint) ; } unsafe extern "C" { pub fn g_pointer_bit_lock_mask_ptr (ptr : gpointer , lock_bit : guint , set : gboolean , preserve_mask : guintptr , preserve_ptr : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_pointer_bit_unlock_and_set (address : * mut :: std :: os :: raw :: c_void , lock_bit : guint , ptr : gpointer , preserve_mask : guintptr) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTimeZone { _unused : [u8 ; 0] , } pub type GTimeZone = _GTimeZone ; pub const GTimeType_G_TIME_TYPE_STANDARD : GTimeType = 0 ; pub const GTimeType_G_TIME_TYPE_DAYLIGHT : GTimeType = 1 ; pub const GTimeType_G_TIME_TYPE_UNIVERSAL : GTimeType = 2 ; pub type GTimeType = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_time_zone_new (identifier : * const gchar) -> * mut GTimeZone ; } unsafe extern "C" { pub fn g_time_zone_new_identifier (identifier : * const gchar) -> * mut GTimeZone ; } unsafe extern "C" { pub fn g_time_zone_new_utc () -> * mut GTimeZone ; } unsafe extern "C" { pub fn g_time_zone_new_local () -> * mut GTimeZone ; } unsafe extern "C" { pub fn g_time_zone_new_offset (seconds : gint32) -> * mut GTimeZone ; } unsafe extern "C" { pub fn g_time_zone_ref (tz : * mut GTimeZone) -> * mut GTimeZone ; } unsafe extern "C" { pub fn g_time_zone_unref (tz : * mut GTimeZone) ; } unsafe extern "C" { pub fn g_time_zone_find_interval (tz : * mut GTimeZone , type_ : GTimeType , time_ : gint64) -> gint ; } unsafe extern "C" { pub fn g_time_zone_adjust_time (tz : * mut GTimeZone , type_ : GTimeType , time_ : * mut gint64) -> gint ; } unsafe extern "C" { pub fn g_time_zone_get_abbreviation (tz : * mut GTimeZone , interval : gint) -> * const gchar ; } unsafe extern "C" { pub fn g_time_zone_get_offset (tz : * mut GTimeZone , interval : gint) -> gint32 ; } unsafe extern "C" { pub fn g_time_zone_is_dst (tz : * mut GTimeZone , interval : gint) -> gboolean ; } unsafe extern "C" { pub fn g_time_zone_get_identifier (tz : * mut GTimeZone) -> * const gchar ; } pub type GTimeSpan = gint64 ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDateTime { _unused : [u8 ; 0] , } pub type GDateTime = _GDateTime ; unsafe extern "C" { pub fn g_date_time_unref (datetime : * mut GDateTime) ; } unsafe extern "C" { pub fn g_date_time_ref (datetime : * mut GDateTime) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_new_now (tz : * mut GTimeZone) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_new_now_local () -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_new_now_utc () -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_new_from_unix_local (t : gint64) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_new_from_unix_utc (t : gint64) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_new_from_unix_local_usec (usecs : gint64) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_new_from_unix_utc_usec (usecs : gint64) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_new_from_timeval_local (tv : * const GTimeVal) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_new_from_timeval_utc (tv : * const GTimeVal) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_new_from_iso8601 (text : * const gchar , default_tz : * mut GTimeZone) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_new (tz : * mut GTimeZone , year : gint , month : gint , day : gint , hour : gint , minute : gint , seconds : gdouble) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_new_local (year : gint , month : gint , day : gint , hour : gint , minute : gint , seconds : gdouble) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_new_utc (year : gint , month : gint , day : gint , hour : gint , minute : gint , seconds : gdouble) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_add (datetime : * mut GDateTime , timespan : GTimeSpan) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_add_years (datetime : * mut GDateTime , years : gint) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_add_months (datetime : * mut GDateTime , months : gint) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_add_weeks (datetime : * mut GDateTime , weeks : gint) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_add_days (datetime : * mut GDateTime , days : gint) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_add_hours (datetime : * mut GDateTime , hours : gint) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_add_minutes (datetime : * mut GDateTime , minutes : gint) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_add_seconds (datetime : * mut GDateTime , seconds : gdouble) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_add_full (datetime : * mut GDateTime , years : gint , months : gint , days : gint , hours : gint , minutes : gint , seconds : gdouble) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_compare (dt1 : gconstpointer , dt2 : gconstpointer) -> gint ; } unsafe extern "C" { pub fn g_date_time_difference (end : * mut GDateTime , begin : * mut GDateTime) -> GTimeSpan ; } unsafe extern "C" { pub fn g_date_time_hash (datetime : gconstpointer) -> guint ; } unsafe extern "C" { pub fn g_date_time_equal (dt1 : gconstpointer , dt2 : gconstpointer) -> gboolean ; } unsafe extern "C" { pub fn g_date_time_get_ymd (datetime : * mut GDateTime , year : * mut gint , month : * mut gint , day : * mut gint) ; } unsafe extern "C" { pub fn g_date_time_get_year (datetime : * mut GDateTime) -> gint ; } unsafe extern "C" { pub fn g_date_time_get_month (datetime : * mut GDateTime) -> gint ; } unsafe extern "C" { pub fn g_date_time_get_day_of_month (datetime : * mut GDateTime) -> gint ; } unsafe extern "C" { pub fn g_date_time_get_week_numbering_year (datetime : * mut GDateTime) -> gint ; } unsafe extern "C" { pub fn g_date_time_get_week_of_year (datetime : * mut GDateTime) -> gint ; } unsafe extern "C" { pub fn g_date_time_get_day_of_week (datetime : * mut GDateTime) -> gint ; } unsafe extern "C" { pub fn g_date_time_get_day_of_year (datetime : * mut GDateTime) -> gint ; } unsafe extern "C" { pub fn g_date_time_get_hour (datetime : * mut GDateTime) -> gint ; } unsafe extern "C" { pub fn g_date_time_get_minute (datetime : * mut GDateTime) -> gint ; } unsafe extern "C" { pub fn g_date_time_get_second (datetime : * mut GDateTime) -> gint ; } unsafe extern "C" { pub fn g_date_time_get_microsecond (datetime : * mut GDateTime) -> gint ; } unsafe extern "C" { pub fn g_date_time_get_seconds (datetime : * mut GDateTime) -> gdouble ; } unsafe extern "C" { pub fn g_date_time_to_unix (datetime : * mut GDateTime) -> gint64 ; } unsafe extern "C" { pub fn g_date_time_to_unix_usec (datetime : * mut GDateTime) -> gint64 ; } unsafe extern "C" { pub fn g_date_time_to_timeval (datetime : * mut GDateTime , tv : * mut GTimeVal) -> gboolean ; } unsafe extern "C" { pub fn g_date_time_get_utc_offset (datetime : * mut GDateTime) -> GTimeSpan ; } unsafe extern "C" { pub fn g_date_time_get_timezone (datetime : * mut GDateTime) -> * mut GTimeZone ; } unsafe extern "C" { pub fn g_date_time_get_timezone_abbreviation (datetime : * mut GDateTime) -> * const gchar ; } unsafe extern "C" { pub fn g_date_time_is_daylight_savings (datetime : * mut GDateTime) -> gboolean ; } unsafe extern "C" { pub fn g_date_time_to_timezone (datetime : * mut GDateTime , tz : * mut GTimeZone) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_to_local (datetime : * mut GDateTime) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_to_utc (datetime : * mut GDateTime) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_date_time_format (datetime : * mut GDateTime , format : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_date_time_format_iso8601 (datetime : * mut GDateTime) -> * mut gchar ; } pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_URI : GBookmarkFileError = 0 ; pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_VALUE : GBookmarkFileError = 1 ; pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED : GBookmarkFileError = 2 ; pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND : GBookmarkFileError = 3 ; pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_READ : GBookmarkFileError = 4 ; pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING : GBookmarkFileError = 5 ; pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_WRITE : GBookmarkFileError = 6 ; pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND : GBookmarkFileError = 7 ; pub type GBookmarkFileError = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_bookmark_file_error_quark () -> GQuark ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GBookmarkFile { _unused : [u8 ; 0] , } pub type GBookmarkFile = _GBookmarkFile ; unsafe extern "C" { pub fn g_bookmark_file_new () -> * mut GBookmarkFile ; } unsafe extern "C" { pub fn g_bookmark_file_free (bookmark : * mut GBookmarkFile) ; } unsafe extern "C" { pub fn g_bookmark_file_copy (bookmark : * mut GBookmarkFile) -> * mut GBookmarkFile ; } unsafe extern "C" { pub fn g_bookmark_file_load_from_file (bookmark : * mut GBookmarkFile , filename : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_load_from_data (bookmark : * mut GBookmarkFile , data : * const gchar , length : gsize , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_load_from_data_dirs (bookmark : * mut GBookmarkFile , file : * const gchar , full_path : * mut * mut gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_to_data (bookmark : * mut GBookmarkFile , length : * mut gsize , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_bookmark_file_to_file (bookmark : * mut GBookmarkFile , filename : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_set_title (bookmark : * mut GBookmarkFile , uri : * const gchar , title : * const gchar) ; } unsafe extern "C" { pub fn g_bookmark_file_get_title (bookmark : * mut GBookmarkFile , uri : * const gchar , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_bookmark_file_set_description (bookmark : * mut GBookmarkFile , uri : * const gchar , description : * const gchar) ; } unsafe extern "C" { pub fn g_bookmark_file_get_description (bookmark : * mut GBookmarkFile , uri : * const gchar , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_bookmark_file_set_mime_type (bookmark : * mut GBookmarkFile , uri : * const gchar , mime_type : * const gchar) ; } unsafe extern "C" { pub fn g_bookmark_file_get_mime_type (bookmark : * mut GBookmarkFile , uri : * const gchar , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_bookmark_file_set_groups (bookmark : * mut GBookmarkFile , uri : * const gchar , groups : * mut * const gchar , length : gsize) ; } unsafe extern "C" { pub fn g_bookmark_file_add_group (bookmark : * mut GBookmarkFile , uri : * const gchar , group : * const gchar) ; } unsafe extern "C" { pub fn g_bookmark_file_has_group (bookmark : * mut GBookmarkFile , uri : * const gchar , group : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_get_groups (bookmark : * mut GBookmarkFile , uri : * const gchar , length : * mut gsize , error : * mut * mut GError) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_bookmark_file_add_application (bookmark : * mut GBookmarkFile , uri : * const gchar , name : * const gchar , exec : * const gchar) ; } unsafe extern "C" { pub fn g_bookmark_file_has_application (bookmark : * mut GBookmarkFile , uri : * const gchar , name : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_get_applications (bookmark : * mut GBookmarkFile , uri : * const gchar , length : * mut gsize , error : * mut * mut GError) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_bookmark_file_set_app_info (bookmark : * mut GBookmarkFile , uri : * const gchar , name : * const gchar , exec : * const gchar , count : gint , stamp : time_t , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_set_application_info (bookmark : * mut GBookmarkFile , uri : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , exec : * const :: std :: os :: raw :: c_char , count : :: std :: os :: raw :: c_int , stamp : * mut GDateTime , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_get_app_info (bookmark : * mut GBookmarkFile , uri : * const gchar , name : * const gchar , exec : * mut * mut gchar , count : * mut guint , stamp : * mut time_t , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_get_application_info (bookmark : * mut GBookmarkFile , uri : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , exec : * mut * mut :: std :: os :: raw :: c_char , count : * mut :: std :: os :: raw :: c_uint , stamp : * mut * mut GDateTime , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_set_is_private (bookmark : * mut GBookmarkFile , uri : * const gchar , is_private : gboolean) ; } unsafe extern "C" { pub fn g_bookmark_file_get_is_private (bookmark : * mut GBookmarkFile , uri : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_set_icon (bookmark : * mut GBookmarkFile , uri : * const gchar , href : * const gchar , mime_type : * const gchar) ; } unsafe extern "C" { pub fn g_bookmark_file_get_icon (bookmark : * mut GBookmarkFile , uri : * const gchar , href : * mut * mut gchar , mime_type : * mut * mut gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_set_added (bookmark : * mut GBookmarkFile , uri : * const gchar , added : time_t) ; } unsafe extern "C" { pub fn g_bookmark_file_set_added_date_time (bookmark : * mut GBookmarkFile , uri : * const :: std :: os :: raw :: c_char , added : * mut GDateTime) ; } unsafe extern "C" { pub fn g_bookmark_file_get_added (bookmark : * mut GBookmarkFile , uri : * const gchar , error : * mut * mut GError) -> time_t ; } unsafe extern "C" { pub fn g_bookmark_file_get_added_date_time (bookmark : * mut GBookmarkFile , uri : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_bookmark_file_set_modified (bookmark : * mut GBookmarkFile , uri : * const gchar , modified : time_t) ; } unsafe extern "C" { pub fn g_bookmark_file_set_modified_date_time (bookmark : * mut GBookmarkFile , uri : * const :: std :: os :: raw :: c_char , modified : * mut GDateTime) ; } unsafe extern "C" { pub fn g_bookmark_file_get_modified (bookmark : * mut GBookmarkFile , uri : * const gchar , error : * mut * mut GError) -> time_t ; } unsafe extern "C" { pub fn g_bookmark_file_get_modified_date_time (bookmark : * mut GBookmarkFile , uri : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_bookmark_file_set_visited (bookmark : * mut GBookmarkFile , uri : * const gchar , visited : time_t) ; } unsafe extern "C" { pub fn g_bookmark_file_set_visited_date_time (bookmark : * mut GBookmarkFile , uri : * const :: std :: os :: raw :: c_char , visited : * mut GDateTime) ; } unsafe extern "C" { pub fn g_bookmark_file_get_visited (bookmark : * mut GBookmarkFile , uri : * const gchar , error : * mut * mut GError) -> time_t ; } unsafe extern "C" { pub fn g_bookmark_file_get_visited_date_time (bookmark : * mut GBookmarkFile , uri : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_bookmark_file_has_item (bookmark : * mut GBookmarkFile , uri : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_get_size (bookmark : * mut GBookmarkFile) -> gint ; } unsafe extern "C" { pub fn g_bookmark_file_get_uris (bookmark : * mut GBookmarkFile , length : * mut gsize) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_bookmark_file_remove_group (bookmark : * mut GBookmarkFile , uri : * const gchar , group : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_remove_application (bookmark : * mut GBookmarkFile , uri : * const gchar , name : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_remove_item (bookmark : * mut GBookmarkFile , uri : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bookmark_file_move_item (bookmark : * mut GBookmarkFile , old_uri : * const gchar , new_uri : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_bytes_new (data : gconstpointer , size : gsize) -> * mut GBytes ; } unsafe extern "C" { pub fn g_bytes_new_take (data : gpointer , size : gsize) -> * mut GBytes ; } unsafe extern "C" { pub fn g_bytes_new_static (data : gconstpointer , size : gsize) -> * mut GBytes ; } unsafe extern "C" { pub fn g_bytes_new_with_free_func (data : gconstpointer , size : gsize , free_func : GDestroyNotify , user_data : gpointer) -> * mut GBytes ; } unsafe extern "C" { pub fn g_bytes_new_from_bytes (bytes : * mut GBytes , offset : gsize , length : gsize) -> * mut GBytes ; } unsafe extern "C" { pub fn g_bytes_get_data (bytes : * mut GBytes , size : * mut gsize) -> gconstpointer ; } unsafe extern "C" { pub fn g_bytes_get_size (bytes : * mut GBytes) -> gsize ; } unsafe extern "C" { pub fn g_bytes_ref (bytes : * mut GBytes) -> * mut GBytes ; } unsafe extern "C" { pub fn g_bytes_unref (bytes : * mut GBytes) ; } unsafe extern "C" { pub fn g_bytes_unref_to_data (bytes : * mut GBytes , size : * mut gsize) -> gpointer ; } unsafe extern "C" { pub fn g_bytes_unref_to_array (bytes : * mut GBytes) -> * mut GByteArray ; } unsafe extern "C" { pub fn g_bytes_hash (bytes : gconstpointer) -> guint ; } unsafe extern "C" { pub fn g_bytes_equal (bytes1 : gconstpointer , bytes2 : gconstpointer) -> gboolean ; } unsafe extern "C" { pub fn g_bytes_compare (bytes1 : gconstpointer , bytes2 : gconstpointer) -> gint ; } unsafe extern "C" { pub fn g_bytes_get_region (bytes : * mut GBytes , element_size : gsize , offset : gsize , n_elements : gsize) -> gconstpointer ; } unsafe extern "C" { pub fn g_get_charset (charset : * mut * const :: std :: os :: raw :: c_char) -> gboolean ; } unsafe extern "C" { pub fn g_get_codeset () -> * mut gchar ; } unsafe extern "C" { pub fn g_get_console_charset (charset : * mut * const :: std :: os :: raw :: c_char) -> gboolean ; } unsafe extern "C" { pub fn g_get_language_names () -> * const * const gchar ; } unsafe extern "C" { pub fn g_get_language_names_with_category (category_name : * const gchar) -> * const * const gchar ; } unsafe extern "C" { pub fn g_get_locale_variants (locale : * const gchar) -> * mut * mut gchar ; } pub const GChecksumType_G_CHECKSUM_MD5 : GChecksumType = 0 ; pub const GChecksumType_G_CHECKSUM_SHA1 : GChecksumType = 1 ; pub const GChecksumType_G_CHECKSUM_SHA256 : GChecksumType = 2 ; pub const GChecksumType_G_CHECKSUM_SHA512 : GChecksumType = 3 ; pub const GChecksumType_G_CHECKSUM_SHA384 : GChecksumType = 4 ; pub type GChecksumType = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GChecksum { _unused : [u8 ; 0] , } pub type GChecksum = _GChecksum ; unsafe extern "C" { pub fn g_checksum_type_get_length (checksum_type : GChecksumType) -> gssize ; } unsafe extern "C" { pub fn g_checksum_new (checksum_type : GChecksumType) -> * mut GChecksum ; } unsafe extern "C" { pub fn g_checksum_reset (checksum : * mut GChecksum) ; } unsafe extern "C" { pub fn g_checksum_copy (checksum : * const GChecksum) -> * mut GChecksum ; } unsafe extern "C" { pub fn g_checksum_free (checksum : * mut GChecksum) ; } unsafe extern "C" { pub fn g_checksum_update (checksum : * mut GChecksum , data : * const guchar , length : gssize) ; } unsafe extern "C" { pub fn g_checksum_get_string (checksum : * mut GChecksum) -> * const gchar ; } unsafe extern "C" { pub fn g_checksum_get_digest (checksum : * mut GChecksum , buffer : * mut guint8 , digest_len : * mut gsize) ; } unsafe extern "C" { pub fn g_compute_checksum_for_data (checksum_type : GChecksumType , data : * const guchar , length : gsize) -> * mut gchar ; } unsafe extern "C" { pub fn g_compute_checksum_for_string (checksum_type : GChecksumType , str_ : * const gchar , length : gssize) -> * mut gchar ; } unsafe extern "C" { pub fn g_compute_checksum_for_bytes (checksum_type : GChecksumType , data : * mut GBytes) -> * mut gchar ; } pub const GConvertError_G_CONVERT_ERROR_NO_CONVERSION : GConvertError = 0 ; pub const GConvertError_G_CONVERT_ERROR_ILLEGAL_SEQUENCE : GConvertError = 1 ; pub const GConvertError_G_CONVERT_ERROR_FAILED : GConvertError = 2 ; pub const GConvertError_G_CONVERT_ERROR_PARTIAL_INPUT : GConvertError = 3 ; pub const GConvertError_G_CONVERT_ERROR_BAD_URI : GConvertError = 4 ; pub const GConvertError_G_CONVERT_ERROR_NOT_ABSOLUTE_PATH : GConvertError = 5 ; pub const GConvertError_G_CONVERT_ERROR_NO_MEMORY : GConvertError = 6 ; pub const GConvertError_G_CONVERT_ERROR_EMBEDDED_NUL : GConvertError = 7 ; pub type GConvertError = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_convert_error_quark () -> GQuark ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIConv { _unused : [u8 ; 0] , } pub type GIConv = * mut _GIConv ; unsafe extern "C" { pub fn g_iconv_open (to_codeset : * const gchar , from_codeset : * const gchar) -> GIConv ; } unsafe extern "C" { pub fn g_iconv (converter : GIConv , inbuf : * mut * mut gchar , inbytes_left : * mut gsize , outbuf : * mut * mut gchar , outbytes_left : * mut gsize) -> gsize ; } unsafe extern "C" { pub fn g_iconv_close (converter : GIConv) -> gint ; } unsafe extern "C" { pub fn g_convert (str_ : * const gchar , len : gssize , to_codeset : * const gchar , from_codeset : * const gchar , bytes_read : * mut gsize , bytes_written : * mut gsize , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_convert_with_iconv (str_ : * const gchar , len : gssize , converter : GIConv , bytes_read : * mut gsize , bytes_written : * mut gsize , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_convert_with_fallback (str_ : * const gchar , len : gssize , to_codeset : * const gchar , from_codeset : * const gchar , fallback : * const gchar , bytes_read : * mut gsize , bytes_written : * mut gsize , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_locale_to_utf8 (opsysstring : * const gchar , len : gssize , bytes_read : * mut gsize , bytes_written : * mut gsize , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_locale_from_utf8 (utf8string : * const gchar , len : gssize , bytes_read : * mut gsize , bytes_written : * mut gsize , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_filename_to_utf8 (opsysstring : * const gchar , len : gssize , bytes_read : * mut gsize , bytes_written : * mut gsize , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_filename_from_utf8 (utf8string : * const gchar , len : gssize , bytes_read : * mut gsize , bytes_written : * mut gsize , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_filename_from_uri (uri : * const gchar , hostname : * mut * mut gchar , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_filename_to_uri (filename : * const gchar , hostname : * const gchar , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_filename_display_name (filename : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_get_filename_charsets (filename_charsets : * mut * mut * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_filename_display_basename (filename : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_uri_list_extract_uris (uri_list : * const gchar) -> * mut * mut gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GData { _unused : [u8 ; 0] , } pub type GData = _GData ; pub type GDataForeachFunc = :: std :: option :: Option < unsafe extern "C" fn (key_id : GQuark , data : gpointer , user_data : gpointer) > ; unsafe extern "C" { pub fn g_datalist_init (datalist : * mut * mut GData) ; } unsafe extern "C" { pub fn g_datalist_clear (datalist : * mut * mut GData) ; } unsafe extern "C" { pub fn g_datalist_id_get_data (datalist : * mut * mut GData , key_id : GQuark) -> gpointer ; } unsafe extern "C" { pub fn g_datalist_id_set_data_full (datalist : * mut * mut GData , key_id : GQuark , data : gpointer , destroy_func : GDestroyNotify) ; } unsafe extern "C" { pub fn g_datalist_id_remove_multiple (datalist : * mut * mut GData , keys : * mut GQuark , n_keys : gsize) ; } pub type GDuplicateFunc = :: std :: option :: Option < unsafe extern "C" fn (data : gpointer , user_data : gpointer) -> gpointer > ; unsafe extern "C" { pub fn g_datalist_id_dup_data (datalist : * mut * mut GData , key_id : GQuark , dup_func : GDuplicateFunc , user_data : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_datalist_id_replace_data (datalist : * mut * mut GData , key_id : GQuark , oldval : gpointer , newval : gpointer , destroy : GDestroyNotify , old_destroy : * mut GDestroyNotify) -> gboolean ; } unsafe extern "C" { pub fn g_datalist_id_remove_no_notify (datalist : * mut * mut GData , key_id : GQuark) -> gpointer ; } unsafe extern "C" { pub fn g_datalist_foreach (datalist : * mut * mut GData , func : GDataForeachFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_datalist_set_flags (datalist : * mut * mut GData , flags : guint) ; } unsafe extern "C" { pub fn g_datalist_unset_flags (datalist : * mut * mut GData , flags : guint) ; } unsafe extern "C" { pub fn g_datalist_get_flags (datalist : * mut * mut GData) -> guint ; } unsafe extern "C" { pub fn g_dataset_destroy (dataset_location : gconstpointer) ; } unsafe extern "C" { pub fn g_dataset_id_get_data (dataset_location : gconstpointer , key_id : GQuark) -> gpointer ; } unsafe extern "C" { pub fn g_datalist_get_data (datalist : * mut * mut GData , key : * const gchar) -> gpointer ; } unsafe extern "C" { pub fn g_dataset_id_set_data_full (dataset_location : gconstpointer , key_id : GQuark , data : gpointer , destroy_func : GDestroyNotify) ; } unsafe extern "C" { pub fn g_dataset_id_remove_no_notify (dataset_location : gconstpointer , key_id : GQuark) -> gpointer ; } unsafe extern "C" { pub fn g_dataset_foreach (dataset_location : gconstpointer , func : GDataForeachFunc , user_data : gpointer) ; } pub type GTime = gint32 ; pub type GDateYear = guint16 ; pub type GDateDay = guint8 ; pub type GDate = _GDate ; pub const GDateDMY_G_DATE_DAY : GDateDMY = 0 ; pub const GDateDMY_G_DATE_MONTH : GDateDMY = 1 ; pub const GDateDMY_G_DATE_YEAR : GDateDMY = 2 ; pub type GDateDMY = :: std :: os :: raw :: c_uint ; pub const GDateWeekday_G_DATE_BAD_WEEKDAY : GDateWeekday = 0 ; pub const GDateWeekday_G_DATE_MONDAY : GDateWeekday = 1 ; pub const GDateWeekday_G_DATE_TUESDAY : GDateWeekday = 2 ; pub const GDateWeekday_G_DATE_WEDNESDAY : GDateWeekday = 3 ; pub const GDateWeekday_G_DATE_THURSDAY : GDateWeekday = 4 ; pub const GDateWeekday_G_DATE_FRIDAY : GDateWeekday = 5 ; pub const GDateWeekday_G_DATE_SATURDAY : GDateWeekday = 6 ; pub const GDateWeekday_G_DATE_SUNDAY : GDateWeekday = 7 ; pub type GDateWeekday = :: std :: os :: raw :: c_uint ; pub const GDateMonth_G_DATE_BAD_MONTH : GDateMonth = 0 ; pub const GDateMonth_G_DATE_JANUARY : GDateMonth = 1 ; pub const GDateMonth_G_DATE_FEBRUARY : GDateMonth = 2 ; pub const GDateMonth_G_DATE_MARCH : GDateMonth = 3 ; pub const GDateMonth_G_DATE_APRIL : GDateMonth = 4 ; pub const GDateMonth_G_DATE_MAY : GDateMonth = 5 ; pub const GDateMonth_G_DATE_JUNE : GDateMonth = 6 ; pub const GDateMonth_G_DATE_JULY : GDateMonth = 7 ; pub const GDateMonth_G_DATE_AUGUST : GDateMonth = 8 ; pub const GDateMonth_G_DATE_SEPTEMBER : GDateMonth = 9 ; pub const GDateMonth_G_DATE_OCTOBER : GDateMonth = 10 ; pub const GDateMonth_G_DATE_NOVEMBER : GDateMonth = 11 ; pub const GDateMonth_G_DATE_DECEMBER : GDateMonth = 12 ; pub type GDateMonth = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDate { pub _bitfield_align_1 : [u32 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 8usize] > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDate"] [:: std :: mem :: size_of :: < _GDate > () - 8usize] ; ["Alignment of _GDate"] [:: std :: mem :: align_of :: < _GDate > () - 4usize] ; } ; impl _GDate { # [inline] pub fn julian_days (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 32u8) as u32) } } # [inline] pub fn set_julian_days (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 32u8 , val as u64) } } # [inline] pub unsafe fn julian_days_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 0usize , 32u8 ,) as u32) } } # [inline] pub unsafe fn set_julian_days_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 0usize , 32u8 , val as u64 ,) } } # [inline] pub fn julian (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (32usize , 1u8) as u32) } } # [inline] pub fn set_julian (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (32usize , 1u8 , val as u64) } } # [inline] pub unsafe fn julian_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 32usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_julian_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 32usize , 1u8 , val as u64 ,) } } # [inline] pub fn dmy (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (33usize , 1u8) as u32) } } # [inline] pub fn set_dmy (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (33usize , 1u8 , val as u64) } } # [inline] pub unsafe fn dmy_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 33usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_dmy_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 33usize , 1u8 , val as u64 ,) } } # [inline] pub fn day (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (34usize , 6u8) as u32) } } # [inline] pub fn set_day (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (34usize , 6u8 , val as u64) } } # [inline] pub unsafe fn day_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 34usize , 6u8 ,) as u32) } } # [inline] pub unsafe fn set_day_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 34usize , 6u8 , val as u64 ,) } } # [inline] pub fn month (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (40usize , 4u8) as u32) } } # [inline] pub fn set_month (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (40usize , 4u8 , val as u64) } } # [inline] pub unsafe fn month_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 40usize , 4u8 ,) as u32) } } # [inline] pub unsafe fn set_month_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 40usize , 4u8 , val as u64 ,) } } # [inline] pub fn year (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (44usize , 16u8) as u32) } } # [inline] pub fn set_year (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (44usize , 16u8 , val as u64) } } # [inline] pub unsafe fn year_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 44usize , 16u8 ,) as u32) } } # [inline] pub unsafe fn set_year_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 8usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 44usize , 16u8 , val as u64 ,) } } # [inline] pub fn new_bitfield_1 (julian_days : guint , julian : guint , dmy : guint , day : guint , month : guint , year : guint) -> __BindgenBitfieldUnit < [u8 ; 8usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 8usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 32u8 , { let julian_days : u32 = unsafe { :: std :: mem :: transmute (julian_days) } ; julian_days as u64 }) ; __bindgen_bitfield_unit . set (32usize , 1u8 , { let julian : u32 = unsafe { :: std :: mem :: transmute (julian) } ; julian as u64 }) ; __bindgen_bitfield_unit . set (33usize , 1u8 , { let dmy : u32 = unsafe { :: std :: mem :: transmute (dmy) } ; dmy as u64 }) ; __bindgen_bitfield_unit . set (34usize , 6u8 , { let day : u32 = unsafe { :: std :: mem :: transmute (day) } ; day as u64 }) ; __bindgen_bitfield_unit . set (40usize , 4u8 , { let month : u32 = unsafe { :: std :: mem :: transmute (month) } ; month as u64 }) ; __bindgen_bitfield_unit . set (44usize , 16u8 , { let year : u32 = unsafe { :: std :: mem :: transmute (year) } ; year as u64 }) ; __bindgen_bitfield_unit } } unsafe extern "C" { pub fn g_date_new () -> * mut GDate ; } unsafe extern "C" { pub fn g_date_new_dmy (day : GDateDay , month : GDateMonth , year : GDateYear) -> * mut GDate ; } unsafe extern "C" { pub fn g_date_new_julian (julian_day : guint32) -> * mut GDate ; } unsafe extern "C" { pub fn g_date_free (date : * mut GDate) ; } unsafe extern "C" { pub fn g_date_copy (date : * const GDate) -> * mut GDate ; } unsafe extern "C" { pub fn g_date_valid (date : * const GDate) -> gboolean ; } unsafe extern "C" { pub fn g_date_valid_day (day : GDateDay) -> gboolean ; } unsafe extern "C" { pub fn g_date_valid_month (month : GDateMonth) -> gboolean ; } unsafe extern "C" { pub fn g_date_valid_year (year : GDateYear) -> gboolean ; } unsafe extern "C" { pub fn g_date_valid_weekday (weekday : GDateWeekday) -> gboolean ; } unsafe extern "C" { pub fn g_date_valid_julian (julian_date : guint32) -> gboolean ; } unsafe extern "C" { pub fn g_date_valid_dmy (day : GDateDay , month : GDateMonth , year : GDateYear) -> gboolean ; } unsafe extern "C" { pub fn g_date_get_weekday (date : * const GDate) -> GDateWeekday ; } unsafe extern "C" { pub fn g_date_get_month (date : * const GDate) -> GDateMonth ; } unsafe extern "C" { pub fn g_date_get_year (date : * const GDate) -> GDateYear ; } unsafe extern "C" { pub fn g_date_get_day (date : * const GDate) -> GDateDay ; } unsafe extern "C" { pub fn g_date_get_julian (date : * const GDate) -> guint32 ; } unsafe extern "C" { pub fn g_date_get_day_of_year (date : * const GDate) -> guint ; } unsafe extern "C" { pub fn g_date_get_monday_week_of_year (date : * const GDate) -> guint ; } unsafe extern "C" { pub fn g_date_get_sunday_week_of_year (date : * const GDate) -> guint ; } unsafe extern "C" { pub fn g_date_get_iso8601_week_of_year (date : * const GDate) -> guint ; } unsafe extern "C" { pub fn g_date_clear (date : * mut GDate , n_dates : guint) ; } unsafe extern "C" { pub fn g_date_set_parse (date : * mut GDate , str_ : * const gchar) ; } unsafe extern "C" { pub fn g_date_set_time_t (date : * mut GDate , timet : time_t) ; } unsafe extern "C" { pub fn g_date_set_time_val (date : * mut GDate , timeval : * mut GTimeVal) ; } unsafe extern "C" { pub fn g_date_set_time (date : * mut GDate , time_ : GTime) ; } unsafe extern "C" { pub fn g_date_set_month (date : * mut GDate , month : GDateMonth) ; } unsafe extern "C" { pub fn g_date_set_day (date : * mut GDate , day : GDateDay) ; } unsafe extern "C" { pub fn g_date_set_year (date : * mut GDate , year : GDateYear) ; } unsafe extern "C" { pub fn g_date_set_dmy (date : * mut GDate , day : GDateDay , month : GDateMonth , y : GDateYear) ; } unsafe extern "C" { pub fn g_date_set_julian (date : * mut GDate , julian_date : guint32) ; } unsafe extern "C" { pub fn g_date_is_first_of_month (date : * const GDate) -> gboolean ; } unsafe extern "C" { pub fn g_date_is_last_of_month (date : * const GDate) -> gboolean ; } unsafe extern "C" { pub fn g_date_add_days (date : * mut GDate , n_days : guint) ; } unsafe extern "C" { pub fn g_date_subtract_days (date : * mut GDate , n_days : guint) ; } unsafe extern "C" { pub fn g_date_add_months (date : * mut GDate , n_months : guint) ; } unsafe extern "C" { pub fn g_date_subtract_months (date : * mut GDate , n_months : guint) ; } unsafe extern "C" { pub fn g_date_add_years (date : * mut GDate , n_years : guint) ; } unsafe extern "C" { pub fn g_date_subtract_years (date : * mut GDate , n_years : guint) ; } unsafe extern "C" { pub fn g_date_is_leap_year (year : GDateYear) -> gboolean ; } unsafe extern "C" { pub fn g_date_get_days_in_month (month : GDateMonth , year : GDateYear) -> guint8 ; } unsafe extern "C" { pub fn g_date_get_monday_weeks_in_year (year : GDateYear) -> guint8 ; } unsafe extern "C" { pub fn g_date_get_sunday_weeks_in_year (year : GDateYear) -> guint8 ; } unsafe extern "C" { pub fn g_date_days_between (date1 : * const GDate , date2 : * const GDate) -> gint ; } unsafe extern "C" { pub fn g_date_compare (lhs : * const GDate , rhs : * const GDate) -> gint ; } unsafe extern "C" { pub fn g_date_to_struct_tm (date : * const GDate , tm : * mut tm) ; } unsafe extern "C" { pub fn g_date_clamp (date : * mut GDate , min_date : * const GDate , max_date : * const GDate) ; } unsafe extern "C" { pub fn g_date_order (date1 : * mut GDate , date2 : * mut GDate) ; } unsafe extern "C" { pub fn g_date_strftime (s : * mut gchar , slen : gsize , format : * const gchar , date : * const GDate) -> gsize ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct dirent { pub d_ino : __ino_t , pub d_off : __off_t , pub d_reclen : :: std :: os :: raw :: c_ushort , pub d_type : :: std :: os :: raw :: c_uchar , pub d_name : [:: std :: os :: raw :: c_char ; 256usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of dirent"] [:: std :: mem :: size_of :: < dirent > () - 280usize] ; ["Alignment of dirent"] [:: std :: mem :: align_of :: < dirent > () - 8usize] ; ["Offset of field: dirent::d_ino"] [:: std :: mem :: offset_of ! (dirent , d_ino) - 0usize] ; ["Offset of field: dirent::d_off"] [:: std :: mem :: offset_of ! (dirent , d_off) - 8usize] ; ["Offset of field: dirent::d_reclen"] [:: std :: mem :: offset_of ! (dirent , d_reclen) - 16usize] ; ["Offset of field: dirent::d_type"] [:: std :: mem :: offset_of ! (dirent , d_type) - 18usize] ; ["Offset of field: dirent::d_name"] [:: std :: mem :: offset_of ! (dirent , d_name) - 19usize] ; } ; pub const DT_UNKNOWN : _bindgen_ty_10 = 0 ; pub const DT_FIFO : _bindgen_ty_10 = 1 ; pub const DT_CHR : _bindgen_ty_10 = 2 ; pub const DT_DIR : _bindgen_ty_10 = 4 ; pub const DT_BLK : _bindgen_ty_10 = 6 ; pub const DT_REG : _bindgen_ty_10 = 8 ; pub const DT_LNK : _bindgen_ty_10 = 10 ; pub const DT_SOCK : _bindgen_ty_10 = 12 ; pub const DT_WHT : _bindgen_ty_10 = 14 ; pub type _bindgen_ty_10 = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __dirstream { _unused : [u8 ; 0] , } pub type DIR = __dirstream ; unsafe extern "C" { pub fn closedir (__dirp : * mut DIR) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn opendir (__name : * const :: std :: os :: raw :: c_char) -> * mut DIR ; } unsafe extern "C" { pub fn fdopendir (__fd : :: std :: os :: raw :: c_int) -> * mut DIR ; } unsafe extern "C" { pub fn readdir (__dirp : * mut DIR) -> * mut dirent ; } unsafe extern "C" { pub fn readdir_r (__dirp : * mut DIR , __entry : * mut dirent , __result : * mut * mut dirent) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn rewinddir (__dirp : * mut DIR) ; } unsafe extern "C" { pub fn seekdir (__dirp : * mut DIR , __pos : :: std :: os :: raw :: c_long) ; } unsafe extern "C" { pub fn telldir (__dirp : * mut DIR) -> :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn dirfd (__dirp : * mut DIR) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn scandir (__dir : * const :: std :: os :: raw :: c_char , __namelist : * mut * mut * mut dirent , __selector : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const dirent) -> :: std :: os :: raw :: c_int > , __cmp : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut * const dirent , arg2 : * mut * const dirent) -> :: std :: os :: raw :: c_int >) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn alphasort (__e1 : * mut * const dirent , __e2 : * mut * const dirent) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn getdirentries (__fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __nbytes : usize , __basep : * mut __off_t) -> __ssize_t ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDir { _unused : [u8 ; 0] , } pub type GDir = _GDir ; unsafe extern "C" { pub fn g_dir_open (path : * const gchar , flags : guint , error : * mut * mut GError) -> * mut GDir ; } unsafe extern "C" { pub fn g_dir_read_name (dir : * mut GDir) -> * const gchar ; } unsafe extern "C" { pub fn g_dir_rewind (dir : * mut GDir) ; } unsafe extern "C" { pub fn g_dir_close (dir : * mut GDir) ; } unsafe extern "C" { pub fn g_dir_ref (dir : * mut GDir) -> * mut GDir ; } unsafe extern "C" { pub fn g_dir_unref (dir : * mut GDir) ; } unsafe extern "C" { pub fn g_getenv (variable : * const gchar) -> * const gchar ; } unsafe extern "C" { pub fn g_setenv (variable : * const gchar , value : * const gchar , overwrite : gboolean) -> gboolean ; } unsafe extern "C" { pub fn g_unsetenv (variable : * const gchar) ; } unsafe extern "C" { pub fn g_listenv () -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_get_environ () -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_environ_getenv (envp : * mut * mut gchar , variable : * const gchar) -> * const gchar ; } unsafe extern "C" { pub fn g_environ_setenv (envp : * mut * mut gchar , variable : * const gchar , value : * const gchar , overwrite : gboolean) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_environ_unsetenv (envp : * mut * mut gchar , variable : * const gchar) -> * mut * mut gchar ; } pub const GFileError_G_FILE_ERROR_EXIST : GFileError = 0 ; pub const GFileError_G_FILE_ERROR_ISDIR : GFileError = 1 ; pub const GFileError_G_FILE_ERROR_ACCES : GFileError = 2 ; pub const GFileError_G_FILE_ERROR_NAMETOOLONG : GFileError = 3 ; pub const GFileError_G_FILE_ERROR_NOENT : GFileError = 4 ; pub const GFileError_G_FILE_ERROR_NOTDIR : GFileError = 5 ; pub const GFileError_G_FILE_ERROR_NXIO : GFileError = 6 ; pub const GFileError_G_FILE_ERROR_NODEV : GFileError = 7 ; pub const GFileError_G_FILE_ERROR_ROFS : GFileError = 8 ; pub const GFileError_G_FILE_ERROR_TXTBSY : GFileError = 9 ; pub const GFileError_G_FILE_ERROR_FAULT : GFileError = 10 ; pub const GFileError_G_FILE_ERROR_LOOP : GFileError = 11 ; pub const GFileError_G_FILE_ERROR_NOSPC : GFileError = 12 ; pub const GFileError_G_FILE_ERROR_NOMEM : GFileError = 13 ; pub const GFileError_G_FILE_ERROR_MFILE : GFileError = 14 ; pub const GFileError_G_FILE_ERROR_NFILE : GFileError = 15 ; pub const GFileError_G_FILE_ERROR_BADF : GFileError = 16 ; pub const GFileError_G_FILE_ERROR_INVAL : GFileError = 17 ; pub const GFileError_G_FILE_ERROR_PIPE : GFileError = 18 ; pub const GFileError_G_FILE_ERROR_AGAIN : GFileError = 19 ; pub const GFileError_G_FILE_ERROR_INTR : GFileError = 20 ; pub const GFileError_G_FILE_ERROR_IO : GFileError = 21 ; pub const GFileError_G_FILE_ERROR_PERM : GFileError = 22 ; pub const GFileError_G_FILE_ERROR_NOSYS : GFileError = 23 ; pub const GFileError_G_FILE_ERROR_FAILED : GFileError = 24 ; pub type GFileError = :: std :: os :: raw :: c_uint ; pub const GFileTest_G_FILE_TEST_IS_REGULAR : GFileTest = 1 ; pub const GFileTest_G_FILE_TEST_IS_SYMLINK : GFileTest = 2 ; pub const GFileTest_G_FILE_TEST_IS_DIR : GFileTest = 4 ; pub const GFileTest_G_FILE_TEST_IS_EXECUTABLE : GFileTest = 8 ; pub const GFileTest_G_FILE_TEST_EXISTS : GFileTest = 16 ; pub type GFileTest = :: std :: os :: raw :: c_uint ; pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_NONE : GFileSetContentsFlags = 0 ; pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_CONSISTENT : GFileSetContentsFlags = 1 ; pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_DURABLE : GFileSetContentsFlags = 2 ; pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_ONLY_EXISTING : GFileSetContentsFlags = 4 ; pub type GFileSetContentsFlags = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_file_error_quark () -> GQuark ; } unsafe extern "C" { pub fn g_file_error_from_errno (err_no : gint) -> GFileError ; } unsafe extern "C" { pub fn g_file_test (filename : * const gchar , test : GFileTest) -> gboolean ; } unsafe extern "C" { pub fn g_file_get_contents (filename : * const gchar , contents : * mut * mut gchar , length : * mut gsize , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_set_contents (filename : * const gchar , contents : * const gchar , length : gssize , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_set_contents_full (filename : * const gchar , contents : * const gchar , length : gssize , flags : GFileSetContentsFlags , mode : :: std :: os :: raw :: c_int , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_read_link (filename : * const gchar , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_mkdtemp (tmpl : * mut gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_mkdtemp_full (tmpl : * mut gchar , mode : gint) -> * mut gchar ; } unsafe extern "C" { pub fn g_mkstemp (tmpl : * mut gchar) -> gint ; } unsafe extern "C" { pub fn g_mkstemp_full (tmpl : * mut gchar , flags : gint , mode : gint) -> gint ; } unsafe extern "C" { pub fn g_file_open_tmp (tmpl : * const gchar , name_used : * mut * mut gchar , error : * mut * mut GError) -> gint ; } unsafe extern "C" { pub fn g_dir_make_tmp (tmpl : * const gchar , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_build_path (separator : * const gchar , first_element : * const gchar , ...) -> * mut gchar ; } unsafe extern "C" { pub fn g_build_pathv (separator : * const gchar , args : * mut * mut gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_build_filename (first_element : * const gchar , ...) -> * mut gchar ; } unsafe extern "C" { pub fn g_build_filenamev (args : * mut * mut gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_build_filename_valist (first_element : * const gchar , args : * mut va_list) -> * mut gchar ; } unsafe extern "C" { pub fn g_mkdir_with_parents (pathname : * const gchar , mode : gint) -> gint ; } unsafe extern "C" { pub fn g_path_is_absolute (file_name : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_path_skip_root (file_name : * const gchar) -> * const gchar ; } unsafe extern "C" { pub fn g_basename (file_name : * const gchar) -> * const gchar ; } unsafe extern "C" { pub fn g_get_current_dir () -> * mut gchar ; } unsafe extern "C" { pub fn g_path_get_basename (file_name : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_path_get_dirname (file_name : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_canonicalize_filename (filename : * const gchar , relative_to : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_strip_context (msgid : * const gchar , msgval : * const gchar) -> * const gchar ; } unsafe extern "C" { pub fn g_dgettext (domain : * const gchar , msgid : * const gchar) -> * const gchar ; } unsafe extern "C" { pub fn g_dcgettext (domain : * const gchar , msgid : * const gchar , category : gint) -> * const gchar ; } unsafe extern "C" { pub fn g_dngettext (domain : * const gchar , msgid : * const gchar , msgid_plural : * const gchar , n : gulong) -> * const gchar ; } unsafe extern "C" { pub fn g_dpgettext (domain : * const gchar , msgctxtid : * const gchar , msgidoffset : gsize) -> * const gchar ; } unsafe extern "C" { pub fn g_dpgettext2 (domain : * const gchar , context : * const gchar , msgid : * const gchar) -> * const gchar ; } pub type GMemVTable = _GMemVTable ; unsafe extern "C" { pub fn g_free (mem : gpointer) ; } unsafe extern "C" { pub fn g_free_sized (mem : gpointer , size : usize) ; } unsafe extern "C" { pub fn g_clear_pointer (pp : * mut gpointer , destroy : GDestroyNotify) ; } unsafe extern "C" { pub fn g_malloc (n_bytes : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_malloc0 (n_bytes : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_realloc (mem : gpointer , n_bytes : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_try_malloc (n_bytes : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_try_malloc0 (n_bytes : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_try_realloc (mem : gpointer , n_bytes : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_malloc_n (n_blocks : gsize , n_block_bytes : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_malloc0_n (n_blocks : gsize , n_block_bytes : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_realloc_n (mem : gpointer , n_blocks : gsize , n_block_bytes : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_try_malloc_n (n_blocks : gsize , n_block_bytes : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_try_malloc0_n (n_blocks : gsize , n_block_bytes : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_try_realloc_n (mem : gpointer , n_blocks : gsize , n_block_bytes : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_aligned_alloc (n_blocks : gsize , n_block_bytes : gsize , alignment : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_aligned_alloc0 (n_blocks : gsize , n_block_bytes : gsize , alignment : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_aligned_free (mem : gpointer) ; } unsafe extern "C" { pub fn g_aligned_free_sized (mem : gpointer , alignment : usize , size : usize) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMemVTable { pub malloc : :: std :: option :: Option < unsafe extern "C" fn (n_bytes : gsize) -> gpointer > , pub realloc : :: std :: option :: Option < unsafe extern "C" fn (mem : gpointer , n_bytes : gsize) -> gpointer > , pub free : :: std :: option :: Option < unsafe extern "C" fn (mem : gpointer) > , pub calloc : :: std :: option :: Option < unsafe extern "C" fn (n_blocks : gsize , n_block_bytes : gsize) -> gpointer > , pub try_malloc : :: std :: option :: Option < unsafe extern "C" fn (n_bytes : gsize) -> gpointer > , pub try_realloc : :: std :: option :: Option < unsafe extern "C" fn (mem : gpointer , n_bytes : gsize) -> gpointer > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMemVTable"] [:: std :: mem :: size_of :: < _GMemVTable > () - 48usize] ; ["Alignment of _GMemVTable"] [:: std :: mem :: align_of :: < _GMemVTable > () - 8usize] ; ["Offset of field: _GMemVTable::malloc"] [:: std :: mem :: offset_of ! (_GMemVTable , malloc) - 0usize] ; ["Offset of field: _GMemVTable::realloc"] [:: std :: mem :: offset_of ! (_GMemVTable , realloc) - 8usize] ; ["Offset of field: _GMemVTable::free"] [:: std :: mem :: offset_of ! (_GMemVTable , free) - 16usize] ; ["Offset of field: _GMemVTable::calloc"] [:: std :: mem :: offset_of ! (_GMemVTable , calloc) - 24usize] ; ["Offset of field: _GMemVTable::try_malloc"] [:: std :: mem :: offset_of ! (_GMemVTable , try_malloc) - 32usize] ; ["Offset of field: _GMemVTable::try_realloc"] [:: std :: mem :: offset_of ! (_GMemVTable , try_realloc) - 40usize] ; } ; unsafe extern "C" { pub fn g_mem_set_vtable (vtable : * mut GMemVTable) ; } unsafe extern "C" { pub fn g_mem_is_system_malloc () -> gboolean ; } unsafe extern "C" { pub static mut g_mem_gc_friendly : gboolean ; } unsafe extern "C" { pub static mut glib_mem_profiler_table : * mut GMemVTable ; } unsafe extern "C" { pub fn g_mem_profile () ; } pub type GNode = _GNode ; pub const GTraverseFlags_G_TRAVERSE_LEAVES : GTraverseFlags = 1 ; pub const GTraverseFlags_G_TRAVERSE_NON_LEAVES : GTraverseFlags = 2 ; pub const GTraverseFlags_G_TRAVERSE_ALL : GTraverseFlags = 3 ; pub const GTraverseFlags_G_TRAVERSE_MASK : GTraverseFlags = 3 ; pub const GTraverseFlags_G_TRAVERSE_LEAFS : GTraverseFlags = 1 ; pub const GTraverseFlags_G_TRAVERSE_NON_LEAFS : GTraverseFlags = 2 ; pub type GTraverseFlags = :: std :: os :: raw :: c_uint ; pub const GTraverseType_G_IN_ORDER : GTraverseType = 0 ; pub const GTraverseType_G_PRE_ORDER : GTraverseType = 1 ; pub const GTraverseType_G_POST_ORDER : GTraverseType = 2 ; pub const GTraverseType_G_LEVEL_ORDER : GTraverseType = 3 ; pub type GTraverseType = :: std :: os :: raw :: c_uint ; pub type GNodeTraverseFunc = :: std :: option :: Option < unsafe extern "C" fn (node : * mut GNode , data : gpointer) -> gboolean > ; pub type GNodeForeachFunc = :: std :: option :: Option < unsafe extern "C" fn (node : * mut GNode , data : gpointer) > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNode { pub data : gpointer , pub next : * mut GNode , pub prev : * mut GNode , pub parent : * mut GNode , pub children : * mut GNode , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GNode"] [:: std :: mem :: size_of :: < _GNode > () - 40usize] ; ["Alignment of _GNode"] [:: std :: mem :: align_of :: < _GNode > () - 8usize] ; ["Offset of field: _GNode::data"] [:: std :: mem :: offset_of ! (_GNode , data) - 0usize] ; ["Offset of field: _GNode::next"] [:: std :: mem :: offset_of ! (_GNode , next) - 8usize] ; ["Offset of field: _GNode::prev"] [:: std :: mem :: offset_of ! (_GNode , prev) - 16usize] ; ["Offset of field: _GNode::parent"] [:: std :: mem :: offset_of ! (_GNode , parent) - 24usize] ; ["Offset of field: _GNode::children"] [:: std :: mem :: offset_of ! (_GNode , children) - 32usize] ; } ; unsafe extern "C" { pub fn g_node_new (data : gpointer) -> * mut GNode ; } unsafe extern "C" { pub fn g_node_destroy (root : * mut GNode) ; } unsafe extern "C" { pub fn g_node_unlink (node : * mut GNode) ; } unsafe extern "C" { pub fn g_node_copy_deep (node : * mut GNode , copy_func : GCopyFunc , data : gpointer) -> * mut GNode ; } unsafe extern "C" { pub fn g_node_copy (node : * mut GNode) -> * mut GNode ; } unsafe extern "C" { pub fn g_node_insert (parent : * mut GNode , position : gint , node : * mut GNode) -> * mut GNode ; } unsafe extern "C" { pub fn g_node_insert_before (parent : * mut GNode , sibling : * mut GNode , node : * mut GNode) -> * mut GNode ; } unsafe extern "C" { pub fn g_node_insert_after (parent : * mut GNode , sibling : * mut GNode , node : * mut GNode) -> * mut GNode ; } unsafe extern "C" { pub fn g_node_prepend (parent : * mut GNode , node : * mut GNode) -> * mut GNode ; } unsafe extern "C" { pub fn g_node_n_nodes (root : * mut GNode , flags : GTraverseFlags) -> guint ; } unsafe extern "C" { pub fn g_node_get_root (node : * mut GNode) -> * mut GNode ; } unsafe extern "C" { pub fn g_node_is_ancestor (node : * mut GNode , descendant : * mut GNode) -> gboolean ; } unsafe extern "C" { pub fn g_node_depth (node : * mut GNode) -> guint ; } unsafe extern "C" { pub fn g_node_find (root : * mut GNode , order : GTraverseType , flags : GTraverseFlags , data : gpointer) -> * mut GNode ; } unsafe extern "C" { pub fn g_node_traverse (root : * mut GNode , order : GTraverseType , flags : GTraverseFlags , max_depth : gint , func : GNodeTraverseFunc , data : gpointer) ; } unsafe extern "C" { pub fn g_node_max_height (root : * mut GNode) -> guint ; } unsafe extern "C" { pub fn g_node_children_foreach (node : * mut GNode , flags : GTraverseFlags , func : GNodeForeachFunc , data : gpointer) ; } unsafe extern "C" { pub fn g_node_reverse_children (node : * mut GNode) ; } unsafe extern "C" { pub fn g_node_n_children (node : * mut GNode) -> guint ; } unsafe extern "C" { pub fn g_node_nth_child (node : * mut GNode , n : guint) -> * mut GNode ; } unsafe extern "C" { pub fn g_node_last_child (node : * mut GNode) -> * mut GNode ; } unsafe extern "C" { pub fn g_node_find_child (node : * mut GNode , flags : GTraverseFlags , data : gpointer) -> * mut GNode ; } unsafe extern "C" { pub fn g_node_child_position (node : * mut GNode , child : * mut GNode) -> gint ; } unsafe extern "C" { pub fn g_node_child_index (node : * mut GNode , data : gpointer) -> gint ; } unsafe extern "C" { pub fn g_node_first_sibling (node : * mut GNode) -> * mut GNode ; } unsafe extern "C" { pub fn g_node_last_sibling (node : * mut GNode) -> * mut GNode ; } pub type GList = _GList ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GList { pub data : gpointer , pub next : * mut GList , pub prev : * mut GList , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GList"] [:: std :: mem :: size_of :: < _GList > () - 24usize] ; ["Alignment of _GList"] [:: std :: mem :: align_of :: < _GList > () - 8usize] ; ["Offset of field: _GList::data"] [:: std :: mem :: offset_of ! (_GList , data) - 0usize] ; ["Offset of field: _GList::next"] [:: std :: mem :: offset_of ! (_GList , next) - 8usize] ; ["Offset of field: _GList::prev"] [:: std :: mem :: offset_of ! (_GList , prev) - 16usize] ; } ; unsafe extern "C" { pub fn g_list_alloc () -> * mut GList ; } unsafe extern "C" { pub fn g_list_free (list : * mut GList) ; } unsafe extern "C" { pub fn g_list_free_1 (list : * mut GList) ; } unsafe extern "C" { pub fn g_list_free_full (list : * mut GList , free_func : GDestroyNotify) ; } unsafe extern "C" { pub fn g_list_append (list : * mut GList , data : gpointer) -> * mut GList ; } unsafe extern "C" { pub fn g_list_prepend (list : * mut GList , data : gpointer) -> * mut GList ; } unsafe extern "C" { pub fn g_list_insert (list : * mut GList , data : gpointer , position : gint) -> * mut GList ; } unsafe extern "C" { pub fn g_list_insert_sorted (list : * mut GList , data : gpointer , func : GCompareFunc) -> * mut GList ; } unsafe extern "C" { pub fn g_list_insert_sorted_with_data (list : * mut GList , data : gpointer , func : GCompareDataFunc , user_data : gpointer) -> * mut GList ; } unsafe extern "C" { pub fn g_list_insert_before (list : * mut GList , sibling : * mut GList , data : gpointer) -> * mut GList ; } unsafe extern "C" { pub fn g_list_insert_before_link (list : * mut GList , sibling : * mut GList , link_ : * mut GList) -> * mut GList ; } unsafe extern "C" { pub fn g_list_concat (list1 : * mut GList , list2 : * mut GList) -> * mut GList ; } unsafe extern "C" { pub fn g_list_remove (list : * mut GList , data : gconstpointer) -> * mut GList ; } unsafe extern "C" { pub fn g_list_remove_all (list : * mut GList , data : gconstpointer) -> * mut GList ; } unsafe extern "C" { pub fn g_list_remove_link (list : * mut GList , llink : * mut GList) -> * mut GList ; } unsafe extern "C" { pub fn g_list_delete_link (list : * mut GList , link_ : * mut GList) -> * mut GList ; } unsafe extern "C" { pub fn g_list_reverse (list : * mut GList) -> * mut GList ; } unsafe extern "C" { pub fn g_list_copy (list : * mut GList) -> * mut GList ; } unsafe extern "C" { pub fn g_list_copy_deep (list : * mut GList , func : GCopyFunc , user_data : gpointer) -> * mut GList ; } unsafe extern "C" { pub fn g_list_nth (list : * mut GList , n : guint) -> * mut GList ; } unsafe extern "C" { pub fn g_list_nth_prev (list : * mut GList , n : guint) -> * mut GList ; } unsafe extern "C" { pub fn g_list_find (list : * mut GList , data : gconstpointer) -> * mut GList ; } unsafe extern "C" { pub fn g_list_find_custom (list : * mut GList , data : gconstpointer , func : GCompareFunc) -> * mut GList ; } unsafe extern "C" { pub fn g_list_position (list : * mut GList , llink : * mut GList) -> gint ; } unsafe extern "C" { pub fn g_list_index (list : * mut GList , data : gconstpointer) -> gint ; } unsafe extern "C" { pub fn g_list_last (list : * mut GList) -> * mut GList ; } unsafe extern "C" { pub fn g_list_first (list : * mut GList) -> * mut GList ; } unsafe extern "C" { pub fn g_list_length (list : * mut GList) -> guint ; } unsafe extern "C" { pub fn g_list_foreach (list : * mut GList , func : GFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_list_sort (list : * mut GList , compare_func : GCompareFunc) -> * mut GList ; } unsafe extern "C" { pub fn g_list_sort_with_data (list : * mut GList , compare_func : GCompareDataFunc , user_data : gpointer) -> * mut GList ; } unsafe extern "C" { pub fn g_list_nth_data (list : * mut GList , n : guint) -> gpointer ; } unsafe extern "C" { pub fn g_clear_list (list_ptr : * mut * mut GList , destroy : GDestroyNotify) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GHashTable { _unused : [u8 ; 0] , } pub type GHashTable = _GHashTable ; pub type GHRFunc = :: std :: option :: Option < unsafe extern "C" fn (key : gpointer , value : gpointer , user_data : gpointer) -> gboolean > ; pub type GHashTableIter = _GHashTableIter ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GHashTableIter { pub dummy1 : gpointer , pub dummy2 : gpointer , pub dummy3 : gpointer , pub dummy4 : :: std :: os :: raw :: c_int , pub dummy5 : gboolean , pub dummy6 : gpointer , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GHashTableIter"] [:: std :: mem :: size_of :: < _GHashTableIter > () - 40usize] ; ["Alignment of _GHashTableIter"] [:: std :: mem :: align_of :: < _GHashTableIter > () - 8usize] ; ["Offset of field: _GHashTableIter::dummy1"] [:: std :: mem :: offset_of ! (_GHashTableIter , dummy1) - 0usize] ; ["Offset of field: _GHashTableIter::dummy2"] [:: std :: mem :: offset_of ! (_GHashTableIter , dummy2) - 8usize] ; ["Offset of field: _GHashTableIter::dummy3"] [:: std :: mem :: offset_of ! (_GHashTableIter , dummy3) - 16usize] ; ["Offset of field: _GHashTableIter::dummy4"] [:: std :: mem :: offset_of ! (_GHashTableIter , dummy4) - 24usize] ; ["Offset of field: _GHashTableIter::dummy5"] [:: std :: mem :: offset_of ! (_GHashTableIter , dummy5) - 28usize] ; ["Offset of field: _GHashTableIter::dummy6"] [:: std :: mem :: offset_of ! (_GHashTableIter , dummy6) - 32usize] ; } ; unsafe extern "C" { pub fn g_hash_table_new (hash_func : GHashFunc , key_equal_func : GEqualFunc) -> * mut GHashTable ; } unsafe extern "C" { pub fn g_hash_table_new_full (hash_func : GHashFunc , key_equal_func : GEqualFunc , key_destroy_func : GDestroyNotify , value_destroy_func : GDestroyNotify) -> * mut GHashTable ; } unsafe extern "C" { pub fn g_hash_table_new_similar (other_hash_table : * mut GHashTable) -> * mut GHashTable ; } unsafe extern "C" { pub fn g_hash_table_destroy (hash_table : * mut GHashTable) ; } unsafe extern "C" { pub fn g_hash_table_insert (hash_table : * mut GHashTable , key : gpointer , value : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_hash_table_replace (hash_table : * mut GHashTable , key : gpointer , value : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_hash_table_add (hash_table : * mut GHashTable , key : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_hash_table_remove (hash_table : * mut GHashTable , key : gconstpointer) -> gboolean ; } unsafe extern "C" { pub fn g_hash_table_remove_all (hash_table : * mut GHashTable) ; } unsafe extern "C" { pub fn g_hash_table_steal (hash_table : * mut GHashTable , key : gconstpointer) -> gboolean ; } unsafe extern "C" { pub fn g_hash_table_steal_extended (hash_table : * mut GHashTable , lookup_key : gconstpointer , stolen_key : * mut gpointer , stolen_value : * mut gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_hash_table_steal_all (hash_table : * mut GHashTable) ; } unsafe extern "C" { pub fn g_hash_table_steal_all_keys (hash_table : * mut GHashTable) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_hash_table_steal_all_values (hash_table : * mut GHashTable) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_hash_table_lookup (hash_table : * mut GHashTable , key : gconstpointer) -> gpointer ; } unsafe extern "C" { pub fn g_hash_table_contains (hash_table : * mut GHashTable , key : gconstpointer) -> gboolean ; } unsafe extern "C" { pub fn g_hash_table_lookup_extended (hash_table : * mut GHashTable , lookup_key : gconstpointer , orig_key : * mut gpointer , value : * mut gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_hash_table_foreach (hash_table : * mut GHashTable , func : GHFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_hash_table_find (hash_table : * mut GHashTable , predicate : GHRFunc , user_data : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_hash_table_foreach_remove (hash_table : * mut GHashTable , func : GHRFunc , user_data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_hash_table_foreach_steal (hash_table : * mut GHashTable , func : GHRFunc , user_data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_hash_table_size (hash_table : * mut GHashTable) -> guint ; } unsafe extern "C" { pub fn g_hash_table_get_keys (hash_table : * mut GHashTable) -> * mut GList ; } unsafe extern "C" { pub fn g_hash_table_get_values (hash_table : * mut GHashTable) -> * mut GList ; } unsafe extern "C" { pub fn g_hash_table_get_keys_as_array (hash_table : * mut GHashTable , length : * mut guint) -> * mut gpointer ; } unsafe extern "C" { pub fn g_hash_table_get_keys_as_ptr_array (hash_table : * mut GHashTable) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_hash_table_get_values_as_ptr_array (hash_table : * mut GHashTable) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_hash_table_iter_init (iter : * mut GHashTableIter , hash_table : * mut GHashTable) ; } unsafe extern "C" { pub fn g_hash_table_iter_next (iter : * mut GHashTableIter , key : * mut gpointer , value : * mut gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_hash_table_iter_get_hash_table (iter : * mut GHashTableIter) -> * mut GHashTable ; } unsafe extern "C" { pub fn g_hash_table_iter_remove (iter : * mut GHashTableIter) ; } unsafe extern "C" { pub fn g_hash_table_iter_replace (iter : * mut GHashTableIter , value : gpointer) ; } unsafe extern "C" { pub fn g_hash_table_iter_steal (iter : * mut GHashTableIter) ; } unsafe extern "C" { pub fn g_hash_table_ref (hash_table : * mut GHashTable) -> * mut GHashTable ; } unsafe extern "C" { pub fn g_hash_table_unref (hash_table : * mut GHashTable) ; } unsafe extern "C" { pub fn g_str_equal (v1 : gconstpointer , v2 : gconstpointer) -> gboolean ; } unsafe extern "C" { pub fn g_str_hash (v : gconstpointer) -> guint ; } unsafe extern "C" { pub fn g_int_equal (v1 : gconstpointer , v2 : gconstpointer) -> gboolean ; } unsafe extern "C" { pub fn g_int_hash (v : gconstpointer) -> guint ; } unsafe extern "C" { pub fn g_int64_equal (v1 : gconstpointer , v2 : gconstpointer) -> gboolean ; } unsafe extern "C" { pub fn g_int64_hash (v : gconstpointer) -> guint ; } unsafe extern "C" { pub fn g_double_equal (v1 : gconstpointer , v2 : gconstpointer) -> gboolean ; } unsafe extern "C" { pub fn g_double_hash (v : gconstpointer) -> guint ; } unsafe extern "C" { pub fn g_direct_hash (v : gconstpointer) -> guint ; } unsafe extern "C" { pub fn g_direct_equal (v1 : gconstpointer , v2 : gconstpointer) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GHmac { _unused : [u8 ; 0] , } pub type GHmac = _GHmac ; unsafe extern "C" { pub fn g_hmac_new (digest_type : GChecksumType , key : * const guchar , key_len : gsize) -> * mut GHmac ; } unsafe extern "C" { pub fn g_hmac_copy (hmac : * const GHmac) -> * mut GHmac ; } unsafe extern "C" { pub fn g_hmac_ref (hmac : * mut GHmac) -> * mut GHmac ; } unsafe extern "C" { pub fn g_hmac_unref (hmac : * mut GHmac) ; } unsafe extern "C" { pub fn g_hmac_update (hmac : * mut GHmac , data : * const guchar , length : gssize) ; } unsafe extern "C" { pub fn g_hmac_get_string (hmac : * mut GHmac) -> * const gchar ; } unsafe extern "C" { pub fn g_hmac_get_digest (hmac : * mut GHmac , buffer : * mut guint8 , digest_len : * mut gsize) ; } unsafe extern "C" { pub fn g_compute_hmac_for_data (digest_type : GChecksumType , key : * const guchar , key_len : gsize , data : * const guchar , length : gsize) -> * mut gchar ; } unsafe extern "C" { pub fn g_compute_hmac_for_string (digest_type : GChecksumType , key : * const guchar , key_len : gsize , str_ : * const gchar , length : gssize) -> * mut gchar ; } unsafe extern "C" { pub fn g_compute_hmac_for_bytes (digest_type : GChecksumType , key : * mut GBytes , data : * mut GBytes) -> * mut gchar ; } pub type GHook = _GHook ; pub type GHookList = _GHookList ; pub type GHookCompareFunc = :: std :: option :: Option < unsafe extern "C" fn (new_hook : * mut GHook , sibling : * mut GHook) -> gint > ; pub type GHookFindFunc = :: std :: option :: Option < unsafe extern "C" fn (hook : * mut GHook , data : gpointer) -> gboolean > ; pub type GHookMarshaller = :: std :: option :: Option < unsafe extern "C" fn (hook : * mut GHook , marshal_data : gpointer) > ; pub type GHookCheckMarshaller = :: std :: option :: Option < unsafe extern "C" fn (hook : * mut GHook , marshal_data : gpointer) -> gboolean > ; pub type GHookFunc = :: std :: option :: Option < unsafe extern "C" fn (data : gpointer) > ; pub type GHookCheckFunc = :: std :: option :: Option < unsafe extern "C" fn (data : gpointer) -> gboolean > ; pub type GHookFinalizeFunc = :: std :: option :: Option < unsafe extern "C" fn (hook_list : * mut GHookList , hook : * mut GHook) > ; pub const GHookFlagMask_G_HOOK_FLAG_ACTIVE : GHookFlagMask = 1 ; pub const GHookFlagMask_G_HOOK_FLAG_IN_CALL : GHookFlagMask = 2 ; pub const GHookFlagMask_G_HOOK_FLAG_MASK : GHookFlagMask = 15 ; pub type GHookFlagMask = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GHookList { pub seq_id : gulong , pub _bitfield_align_1 : [u16 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 3usize] > , pub hooks : * mut GHook , pub dummy3 : gpointer , pub finalize_hook : GHookFinalizeFunc , pub dummy : [gpointer ; 2usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GHookList"] [:: std :: mem :: size_of :: < _GHookList > () - 56usize] ; ["Alignment of _GHookList"] [:: std :: mem :: align_of :: < _GHookList > () - 8usize] ; ["Offset of field: _GHookList::seq_id"] [:: std :: mem :: offset_of ! (_GHookList , seq_id) - 0usize] ; ["Offset of field: _GHookList::hooks"] [:: std :: mem :: offset_of ! (_GHookList , hooks) - 16usize] ; ["Offset of field: _GHookList::dummy3"] [:: std :: mem :: offset_of ! (_GHookList , dummy3) - 24usize] ; ["Offset of field: _GHookList::finalize_hook"] [:: std :: mem :: offset_of ! (_GHookList , finalize_hook) - 32usize] ; ["Offset of field: _GHookList::dummy"] [:: std :: mem :: offset_of ! (_GHookList , dummy) - 40usize] ; } ; impl _GHookList { # [inline] pub fn hook_size (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 16u8) as u32) } } # [inline] pub fn set_hook_size (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 16u8 , val as u64) } } # [inline] pub unsafe fn hook_size_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 0usize , 16u8 ,) as u32) } } # [inline] pub unsafe fn set_hook_size_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 0usize , 16u8 , val as u64 ,) } } # [inline] pub fn is_setup (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (16usize , 1u8) as u32) } } # [inline] pub fn set_is_setup (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (16usize , 1u8 , val as u64) } } # [inline] pub unsafe fn is_setup_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 16usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_is_setup_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 16usize , 1u8 , val as u64 ,) } } # [inline] pub fn new_bitfield_1 (hook_size : guint , is_setup : guint) -> __BindgenBitfieldUnit < [u8 ; 3usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 3usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 16u8 , { let hook_size : u32 = unsafe { :: std :: mem :: transmute (hook_size) } ; hook_size as u64 }) ; __bindgen_bitfield_unit . set (16usize , 1u8 , { let is_setup : u32 = unsafe { :: std :: mem :: transmute (is_setup) } ; is_setup as u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GHook { pub data : gpointer , pub next : * mut GHook , pub prev : * mut GHook , pub ref_count : guint , pub hook_id : gulong , pub flags : guint , pub func : gpointer , pub destroy : GDestroyNotify , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GHook"] [:: std :: mem :: size_of :: < _GHook > () - 64usize] ; ["Alignment of _GHook"] [:: std :: mem :: align_of :: < _GHook > () - 8usize] ; ["Offset of field: _GHook::data"] [:: std :: mem :: offset_of ! (_GHook , data) - 0usize] ; ["Offset of field: _GHook::next"] [:: std :: mem :: offset_of ! (_GHook , next) - 8usize] ; ["Offset of field: _GHook::prev"] [:: std :: mem :: offset_of ! (_GHook , prev) - 16usize] ; ["Offset of field: _GHook::ref_count"] [:: std :: mem :: offset_of ! (_GHook , ref_count) - 24usize] ; ["Offset of field: _GHook::hook_id"] [:: std :: mem :: offset_of ! (_GHook , hook_id) - 32usize] ; ["Offset of field: _GHook::flags"] [:: std :: mem :: offset_of ! (_GHook , flags) - 40usize] ; ["Offset of field: _GHook::func"] [:: std :: mem :: offset_of ! (_GHook , func) - 48usize] ; ["Offset of field: _GHook::destroy"] [:: std :: mem :: offset_of ! (_GHook , destroy) - 56usize] ; } ; unsafe extern "C" { pub fn g_hook_list_init (hook_list : * mut GHookList , hook_size : guint) ; } unsafe extern "C" { pub fn g_hook_list_clear (hook_list : * mut GHookList) ; } unsafe extern "C" { pub fn g_hook_alloc (hook_list : * mut GHookList) -> * mut GHook ; } unsafe extern "C" { pub fn g_hook_free (hook_list : * mut GHookList , hook : * mut GHook) ; } unsafe extern "C" { pub fn g_hook_ref (hook_list : * mut GHookList , hook : * mut GHook) -> * mut GHook ; } unsafe extern "C" { pub fn g_hook_unref (hook_list : * mut GHookList , hook : * mut GHook) ; } unsafe extern "C" { pub fn g_hook_destroy (hook_list : * mut GHookList , hook_id : gulong) -> gboolean ; } unsafe extern "C" { pub fn g_hook_destroy_link (hook_list : * mut GHookList , hook : * mut GHook) ; } unsafe extern "C" { pub fn g_hook_prepend (hook_list : * mut GHookList , hook : * mut GHook) ; } unsafe extern "C" { pub fn g_hook_insert_before (hook_list : * mut GHookList , sibling : * mut GHook , hook : * mut GHook) ; } unsafe extern "C" { pub fn g_hook_insert_sorted (hook_list : * mut GHookList , hook : * mut GHook , func : GHookCompareFunc) ; } unsafe extern "C" { pub fn g_hook_get (hook_list : * mut GHookList , hook_id : gulong) -> * mut GHook ; } unsafe extern "C" { pub fn g_hook_find (hook_list : * mut GHookList , need_valids : gboolean , func : GHookFindFunc , data : gpointer) -> * mut GHook ; } unsafe extern "C" { pub fn g_hook_find_data (hook_list : * mut GHookList , need_valids : gboolean , data : gpointer) -> * mut GHook ; } unsafe extern "C" { pub fn g_hook_find_func (hook_list : * mut GHookList , need_valids : gboolean , func : gpointer) -> * mut GHook ; } unsafe extern "C" { pub fn g_hook_find_func_data (hook_list : * mut GHookList , need_valids : gboolean , func : gpointer , data : gpointer) -> * mut GHook ; } unsafe extern "C" { pub fn g_hook_first_valid (hook_list : * mut GHookList , may_be_in_call : gboolean) -> * mut GHook ; } unsafe extern "C" { pub fn g_hook_next_valid (hook_list : * mut GHookList , hook : * mut GHook , may_be_in_call : gboolean) -> * mut GHook ; } unsafe extern "C" { pub fn g_hook_compare_ids (new_hook : * mut GHook , sibling : * mut GHook) -> gint ; } unsafe extern "C" { pub fn g_hook_list_invoke (hook_list : * mut GHookList , may_recurse : gboolean) ; } unsafe extern "C" { pub fn g_hook_list_invoke_check (hook_list : * mut GHookList , may_recurse : gboolean) ; } unsafe extern "C" { pub fn g_hook_list_marshal (hook_list : * mut GHookList , may_recurse : gboolean , marshaller : GHookMarshaller , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_hook_list_marshal_check (hook_list : * mut GHookList , may_recurse : gboolean , marshaller : GHookCheckMarshaller , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_hostname_is_non_ascii (hostname : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_hostname_is_ascii_encoded (hostname : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_hostname_is_ip_address (hostname : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_hostname_to_ascii (hostname : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_hostname_to_unicode (hostname : * const gchar) -> * mut gchar ; } pub type GPollFD = _GPollFD ; pub type GPollFunc = :: std :: option :: Option < unsafe extern "C" fn (ufds : * mut GPollFD , nfsd : guint , timeout_ : gint) -> gint > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPollFD { pub fd : gint , pub events : gushort , pub revents : gushort , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GPollFD"] [:: std :: mem :: size_of :: < _GPollFD > () - 8usize] ; ["Alignment of _GPollFD"] [:: std :: mem :: align_of :: < _GPollFD > () - 4usize] ; ["Offset of field: _GPollFD::fd"] [:: std :: mem :: offset_of ! (_GPollFD , fd) - 0usize] ; ["Offset of field: _GPollFD::events"] [:: std :: mem :: offset_of ! (_GPollFD , events) - 4usize] ; ["Offset of field: _GPollFD::revents"] [:: std :: mem :: offset_of ! (_GPollFD , revents) - 6usize] ; } ; unsafe extern "C" { pub fn g_poll (fds : * mut GPollFD , nfds : guint , timeout : gint) -> gint ; } pub type GSList = _GSList ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSList { pub data : gpointer , pub next : * mut GSList , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSList"] [:: std :: mem :: size_of :: < _GSList > () - 16usize] ; ["Alignment of _GSList"] [:: std :: mem :: align_of :: < _GSList > () - 8usize] ; ["Offset of field: _GSList::data"] [:: std :: mem :: offset_of ! (_GSList , data) - 0usize] ; ["Offset of field: _GSList::next"] [:: std :: mem :: offset_of ! (_GSList , next) - 8usize] ; } ; unsafe extern "C" { pub fn g_slist_alloc () -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_free (list : * mut GSList) ; } unsafe extern "C" { pub fn g_slist_free_1 (list : * mut GSList) ; } unsafe extern "C" { pub fn g_slist_free_full (list : * mut GSList , free_func : GDestroyNotify) ; } unsafe extern "C" { pub fn g_slist_append (list : * mut GSList , data : gpointer) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_prepend (list : * mut GSList , data : gpointer) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_insert (list : * mut GSList , data : gpointer , position : gint) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_insert_sorted (list : * mut GSList , data : gpointer , func : GCompareFunc) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_insert_sorted_with_data (list : * mut GSList , data : gpointer , func : GCompareDataFunc , user_data : gpointer) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_insert_before (slist : * mut GSList , sibling : * mut GSList , data : gpointer) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_concat (list1 : * mut GSList , list2 : * mut GSList) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_remove (list : * mut GSList , data : gconstpointer) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_remove_all (list : * mut GSList , data : gconstpointer) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_remove_link (list : * mut GSList , link_ : * mut GSList) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_delete_link (list : * mut GSList , link_ : * mut GSList) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_reverse (list : * mut GSList) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_copy (list : * mut GSList) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_copy_deep (list : * mut GSList , func : GCopyFunc , user_data : gpointer) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_nth (list : * mut GSList , n : guint) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_find (list : * mut GSList , data : gconstpointer) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_find_custom (list : * mut GSList , data : gconstpointer , func : GCompareFunc) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_position (list : * mut GSList , llink : * mut GSList) -> gint ; } unsafe extern "C" { pub fn g_slist_index (list : * mut GSList , data : gconstpointer) -> gint ; } unsafe extern "C" { pub fn g_slist_last (list : * mut GSList) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_length (list : * mut GSList) -> guint ; } unsafe extern "C" { pub fn g_slist_foreach (list : * mut GSList , func : GFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_slist_sort (list : * mut GSList , compare_func : GCompareFunc) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_sort_with_data (list : * mut GSList , compare_func : GCompareDataFunc , user_data : gpointer) -> * mut GSList ; } unsafe extern "C" { pub fn g_slist_nth_data (list : * mut GSList , n : guint) -> gpointer ; } unsafe extern "C" { pub fn g_clear_slist (slist_ptr : * mut * mut GSList , destroy : GDestroyNotify) ; } pub const GIOCondition_G_IO_IN : GIOCondition = 1 ; pub const GIOCondition_G_IO_OUT : GIOCondition = 4 ; pub const GIOCondition_G_IO_PRI : GIOCondition = 2 ; pub const GIOCondition_G_IO_ERR : GIOCondition = 8 ; pub const GIOCondition_G_IO_HUP : GIOCondition = 16 ; pub const GIOCondition_G_IO_NVAL : GIOCondition = 32 ; pub type GIOCondition = :: std :: os :: raw :: c_uint ; pub const GMainContextFlags_G_MAIN_CONTEXT_FLAGS_NONE : GMainContextFlags = 0 ; pub const GMainContextFlags_G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING : GMainContextFlags = 1 ; pub type GMainContextFlags = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMainContext { _unused : [u8 ; 0] , } pub type GMainContext = _GMainContext ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMainLoop { _unused : [u8 ; 0] , } pub type GMainLoop = _GMainLoop ; pub type GSource = _GSource ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSourcePrivate { _unused : [u8 ; 0] , } pub type GSourcePrivate = _GSourcePrivate ; pub type GSourceCallbackFuncs = _GSourceCallbackFuncs ; pub type GSourceFuncs = _GSourceFuncs ; pub type GSourceFunc = :: std :: option :: Option < unsafe extern "C" fn (user_data : gpointer) -> gboolean > ; pub type GSourceOnceFunc = :: std :: option :: Option < unsafe extern "C" fn (user_data : gpointer) > ; pub type GChildWatchFunc = :: std :: option :: Option < unsafe extern "C" fn (pid : GPid , wait_status : gint , user_data : gpointer) > ; pub type GSourceDisposeFunc = :: std :: option :: Option < unsafe extern "C" fn (source : * mut GSource) > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSource { pub callback_data : gpointer , pub callback_funcs : * mut GSourceCallbackFuncs , pub source_funcs : * const GSourceFuncs , pub ref_count : guint , pub context : * mut GMainContext , pub priority : gint , pub flags : guint , pub source_id : guint , pub poll_fds : * mut GSList , pub prev : * mut GSource , pub next : * mut GSource , pub name : * mut :: std :: os :: raw :: c_char , pub priv_ : * mut GSourcePrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSource"] [:: std :: mem :: size_of :: < _GSource > () - 96usize] ; ["Alignment of _GSource"] [:: std :: mem :: align_of :: < _GSource > () - 8usize] ; ["Offset of field: _GSource::callback_data"] [:: std :: mem :: offset_of ! (_GSource , callback_data) - 0usize] ; ["Offset of field: _GSource::callback_funcs"] [:: std :: mem :: offset_of ! (_GSource , callback_funcs) - 8usize] ; ["Offset of field: _GSource::source_funcs"] [:: std :: mem :: offset_of ! (_GSource , source_funcs) - 16usize] ; ["Offset of field: _GSource::ref_count"] [:: std :: mem :: offset_of ! (_GSource , ref_count) - 24usize] ; ["Offset of field: _GSource::context"] [:: std :: mem :: offset_of ! (_GSource , context) - 32usize] ; ["Offset of field: _GSource::priority"] [:: std :: mem :: offset_of ! (_GSource , priority) - 40usize] ; ["Offset of field: _GSource::flags"] [:: std :: mem :: offset_of ! (_GSource , flags) - 44usize] ; ["Offset of field: _GSource::source_id"] [:: std :: mem :: offset_of ! (_GSource , source_id) - 48usize] ; ["Offset of field: _GSource::poll_fds"] [:: std :: mem :: offset_of ! (_GSource , poll_fds) - 56usize] ; ["Offset of field: _GSource::prev"] [:: std :: mem :: offset_of ! (_GSource , prev) - 64usize] ; ["Offset of field: _GSource::next"] [:: std :: mem :: offset_of ! (_GSource , next) - 72usize] ; ["Offset of field: _GSource::name"] [:: std :: mem :: offset_of ! (_GSource , name) - 80usize] ; ["Offset of field: _GSource::priv_"] [:: std :: mem :: offset_of ! (_GSource , priv_) - 88usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSourceCallbackFuncs { pub ref_ : :: std :: option :: Option < unsafe extern "C" fn (cb_data : gpointer) > , pub unref : :: std :: option :: Option < unsafe extern "C" fn (cb_data : gpointer) > , pub get : :: std :: option :: Option < unsafe extern "C" fn (cb_data : gpointer , source : * mut GSource , func : * mut GSourceFunc , data : * mut gpointer) > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSourceCallbackFuncs"] [:: std :: mem :: size_of :: < _GSourceCallbackFuncs > () - 24usize] ; ["Alignment of _GSourceCallbackFuncs"] [:: std :: mem :: align_of :: < _GSourceCallbackFuncs > () - 8usize] ; ["Offset of field: _GSourceCallbackFuncs::ref_"] [:: std :: mem :: offset_of ! (_GSourceCallbackFuncs , ref_) - 0usize] ; ["Offset of field: _GSourceCallbackFuncs::unref"] [:: std :: mem :: offset_of ! (_GSourceCallbackFuncs , unref) - 8usize] ; ["Offset of field: _GSourceCallbackFuncs::get"] [:: std :: mem :: offset_of ! (_GSourceCallbackFuncs , get) - 16usize] ; } ; pub type GSourceDummyMarshal = :: std :: option :: Option < unsafe extern "C" fn () > ; pub type GSourceFuncsPrepareFunc = :: std :: option :: Option < unsafe extern "C" fn (source : * mut GSource , timeout_ : * mut gint) -> gboolean > ; pub type GSourceFuncsCheckFunc = :: std :: option :: Option < unsafe extern "C" fn (source : * mut GSource) -> gboolean > ; pub type GSourceFuncsDispatchFunc = :: std :: option :: Option < unsafe extern "C" fn (source : * mut GSource , callback : GSourceFunc , user_data : gpointer) -> gboolean > ; pub type GSourceFuncsFinalizeFunc = :: std :: option :: Option < unsafe extern "C" fn (source : * mut GSource) > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSourceFuncs { pub prepare : GSourceFuncsPrepareFunc , pub check : GSourceFuncsCheckFunc , pub dispatch : GSourceFuncsDispatchFunc , pub finalize : GSourceFuncsFinalizeFunc , pub closure_callback : GSourceFunc , pub closure_marshal : GSourceDummyMarshal , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSourceFuncs"] [:: std :: mem :: size_of :: < _GSourceFuncs > () - 48usize] ; ["Alignment of _GSourceFuncs"] [:: std :: mem :: align_of :: < _GSourceFuncs > () - 8usize] ; ["Offset of field: _GSourceFuncs::prepare"] [:: std :: mem :: offset_of ! (_GSourceFuncs , prepare) - 0usize] ; ["Offset of field: _GSourceFuncs::check"] [:: std :: mem :: offset_of ! (_GSourceFuncs , check) - 8usize] ; ["Offset of field: _GSourceFuncs::dispatch"] [:: std :: mem :: offset_of ! (_GSourceFuncs , dispatch) - 16usize] ; ["Offset of field: _GSourceFuncs::finalize"] [:: std :: mem :: offset_of ! (_GSourceFuncs , finalize) - 24usize] ; ["Offset of field: _GSourceFuncs::closure_callback"] [:: std :: mem :: offset_of ! (_GSourceFuncs , closure_callback) - 32usize] ; ["Offset of field: _GSourceFuncs::closure_marshal"] [:: std :: mem :: offset_of ! (_GSourceFuncs , closure_marshal) - 40usize] ; } ; unsafe extern "C" { pub fn g_main_context_new () -> * mut GMainContext ; } unsafe extern "C" { pub fn g_main_context_new_with_flags (flags : GMainContextFlags) -> * mut GMainContext ; } unsafe extern "C" { pub fn g_main_context_ref (context : * mut GMainContext) -> * mut GMainContext ; } unsafe extern "C" { pub fn g_main_context_unref (context : * mut GMainContext) ; } unsafe extern "C" { pub fn g_main_context_default () -> * mut GMainContext ; } unsafe extern "C" { pub fn g_main_context_iteration (context : * mut GMainContext , may_block : gboolean) -> gboolean ; } unsafe extern "C" { pub fn g_main_context_pending (context : * mut GMainContext) -> gboolean ; } unsafe extern "C" { pub fn g_main_context_find_source_by_id (context : * mut GMainContext , source_id : guint) -> * mut GSource ; } unsafe extern "C" { pub fn g_main_context_find_source_by_user_data (context : * mut GMainContext , user_data : gpointer) -> * mut GSource ; } unsafe extern "C" { pub fn g_main_context_find_source_by_funcs_user_data (context : * mut GMainContext , funcs : * mut GSourceFuncs , user_data : gpointer) -> * mut GSource ; } unsafe extern "C" { pub fn g_main_context_wakeup (context : * mut GMainContext) ; } unsafe extern "C" { pub fn g_main_context_acquire (context : * mut GMainContext) -> gboolean ; } unsafe extern "C" { pub fn g_main_context_release (context : * mut GMainContext) ; } unsafe extern "C" { pub fn g_main_context_is_owner (context : * mut GMainContext) -> gboolean ; } unsafe extern "C" { pub fn g_main_context_wait (context : * mut GMainContext , cond : * mut GCond , mutex : * mut GMutex) -> gboolean ; } unsafe extern "C" { pub fn g_main_context_prepare (context : * mut GMainContext , priority : * mut gint) -> gboolean ; } unsafe extern "C" { pub fn g_main_context_query (context : * mut GMainContext , max_priority : gint , timeout_ : * mut gint , fds : * mut GPollFD , n_fds : gint) -> gint ; } unsafe extern "C" { pub fn g_main_context_check (context : * mut GMainContext , max_priority : gint , fds : * mut GPollFD , n_fds : gint) -> gboolean ; } unsafe extern "C" { pub fn g_main_context_dispatch (context : * mut GMainContext) ; } unsafe extern "C" { pub fn g_main_context_set_poll_func (context : * mut GMainContext , func : GPollFunc) ; } unsafe extern "C" { pub fn g_main_context_get_poll_func (context : * mut GMainContext) -> GPollFunc ; } unsafe extern "C" { pub fn g_main_context_add_poll (context : * mut GMainContext , fd : * mut GPollFD , priority : gint) ; } unsafe extern "C" { pub fn g_main_context_remove_poll (context : * mut GMainContext , fd : * mut GPollFD) ; } unsafe extern "C" { pub fn g_main_depth () -> gint ; } unsafe extern "C" { pub fn g_main_current_source () -> * mut GSource ; } unsafe extern "C" { pub fn g_main_context_push_thread_default (context : * mut GMainContext) ; } unsafe extern "C" { pub fn g_main_context_pop_thread_default (context : * mut GMainContext) ; } unsafe extern "C" { pub fn g_main_context_get_thread_default () -> * mut GMainContext ; } unsafe extern "C" { pub fn g_main_context_ref_thread_default () -> * mut GMainContext ; } pub type GMainContextPusher = :: std :: os :: raw :: c_void ; unsafe extern "C" { pub fn g_main_loop_new (context : * mut GMainContext , is_running : gboolean) -> * mut GMainLoop ; } unsafe extern "C" { pub fn g_main_loop_run (loop_ : * mut GMainLoop) ; } unsafe extern "C" { pub fn g_main_loop_quit (loop_ : * mut GMainLoop) ; } unsafe extern "C" { pub fn g_main_loop_ref (loop_ : * mut GMainLoop) -> * mut GMainLoop ; } unsafe extern "C" { pub fn g_main_loop_unref (loop_ : * mut GMainLoop) ; } unsafe extern "C" { pub fn g_main_loop_is_running (loop_ : * mut GMainLoop) -> gboolean ; } unsafe extern "C" { pub fn g_main_loop_get_context (loop_ : * mut GMainLoop) -> * mut GMainContext ; } unsafe extern "C" { pub fn g_source_new (source_funcs : * mut GSourceFuncs , struct_size : guint) -> * mut GSource ; } unsafe extern "C" { pub fn g_source_set_dispose_function (source : * mut GSource , dispose : GSourceDisposeFunc) ; } unsafe extern "C" { pub fn g_source_ref (source : * mut GSource) -> * mut GSource ; } unsafe extern "C" { pub fn g_source_unref (source : * mut GSource) ; } unsafe extern "C" { pub fn g_source_attach (source : * mut GSource , context : * mut GMainContext) -> guint ; } unsafe extern "C" { pub fn g_source_destroy (source : * mut GSource) ; } unsafe extern "C" { pub fn g_source_set_priority (source : * mut GSource , priority : gint) ; } unsafe extern "C" { pub fn g_source_get_priority (source : * mut GSource) -> gint ; } unsafe extern "C" { pub fn g_source_set_can_recurse (source : * mut GSource , can_recurse : gboolean) ; } unsafe extern "C" { pub fn g_source_get_can_recurse (source : * mut GSource) -> gboolean ; } unsafe extern "C" { pub fn g_source_get_id (source : * mut GSource) -> guint ; } unsafe extern "C" { pub fn g_source_get_context (source : * mut GSource) -> * mut GMainContext ; } unsafe extern "C" { pub fn g_source_set_callback (source : * mut GSource , func : GSourceFunc , data : gpointer , notify : GDestroyNotify) ; } unsafe extern "C" { pub fn g_source_set_funcs (source : * mut GSource , funcs : * mut GSourceFuncs) ; } unsafe extern "C" { pub fn g_source_is_destroyed (source : * mut GSource) -> gboolean ; } unsafe extern "C" { pub fn g_source_set_name (source : * mut GSource , name : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_source_set_static_name (source : * mut GSource , name : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_source_get_name (source : * mut GSource) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_source_set_name_by_id (tag : guint , name : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_source_set_ready_time (source : * mut GSource , ready_time : gint64) ; } unsafe extern "C" { pub fn g_source_get_ready_time (source : * mut GSource) -> gint64 ; } unsafe extern "C" { pub fn g_source_add_unix_fd (source : * mut GSource , fd : gint , events : GIOCondition) -> gpointer ; } unsafe extern "C" { pub fn g_source_modify_unix_fd (source : * mut GSource , tag : gpointer , new_events : GIOCondition) ; } unsafe extern "C" { pub fn g_source_remove_unix_fd (source : * mut GSource , tag : gpointer) ; } unsafe extern "C" { pub fn g_source_query_unix_fd (source : * mut GSource , tag : gpointer) -> GIOCondition ; } unsafe extern "C" { pub fn g_source_set_callback_indirect (source : * mut GSource , callback_data : gpointer , callback_funcs : * mut GSourceCallbackFuncs) ; } unsafe extern "C" { pub fn g_source_add_poll (source : * mut GSource , fd : * mut GPollFD) ; } unsafe extern "C" { pub fn g_source_remove_poll (source : * mut GSource , fd : * mut GPollFD) ; } unsafe extern "C" { pub fn g_source_add_child_source (source : * mut GSource , child_source : * mut GSource) ; } unsafe extern "C" { pub fn g_source_remove_child_source (source : * mut GSource , child_source : * mut GSource) ; } unsafe extern "C" { pub fn g_source_get_current_time (source : * mut GSource , timeval : * mut GTimeVal) ; } unsafe extern "C" { pub fn g_source_get_time (source : * mut GSource) -> gint64 ; } unsafe extern "C" { pub fn g_idle_source_new () -> * mut GSource ; } unsafe extern "C" { pub fn g_child_watch_source_new (pid : GPid) -> * mut GSource ; } unsafe extern "C" { pub fn g_timeout_source_new (interval : guint) -> * mut GSource ; } unsafe extern "C" { pub fn g_timeout_source_new_seconds (interval : guint) -> * mut GSource ; } unsafe extern "C" { pub fn g_get_current_time (result : * mut GTimeVal) ; } unsafe extern "C" { pub fn g_get_monotonic_time () -> gint64 ; } unsafe extern "C" { pub fn g_get_real_time () -> gint64 ; } unsafe extern "C" { pub fn g_source_remove (tag : guint) -> gboolean ; } unsafe extern "C" { pub fn g_source_remove_by_user_data (user_data : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_source_remove_by_funcs_user_data (funcs : * mut GSourceFuncs , user_data : gpointer) -> gboolean ; } pub type GClearHandleFunc = :: std :: option :: Option < unsafe extern "C" fn (handle_id : guint) > ; unsafe extern "C" { pub fn g_clear_handle_id (tag_ptr : * mut guint , clear_func : GClearHandleFunc) ; } unsafe extern "C" { pub fn g_timeout_add_full (priority : gint , interval : guint , function : GSourceFunc , data : gpointer , notify : GDestroyNotify) -> guint ; } unsafe extern "C" { pub fn g_timeout_add (interval : guint , function : GSourceFunc , data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_timeout_add_once (interval : guint , function : GSourceOnceFunc , data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_timeout_add_seconds_full (priority : gint , interval : guint , function : GSourceFunc , data : gpointer , notify : GDestroyNotify) -> guint ; } unsafe extern "C" { pub fn g_timeout_add_seconds (interval : guint , function : GSourceFunc , data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_timeout_add_seconds_once (interval : guint , function : GSourceOnceFunc , data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_child_watch_add_full (priority : gint , pid : GPid , function : GChildWatchFunc , data : gpointer , notify : GDestroyNotify) -> guint ; } unsafe extern "C" { pub fn g_child_watch_add (pid : GPid , function : GChildWatchFunc , data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_idle_add (function : GSourceFunc , data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_idle_add_full (priority : gint , function : GSourceFunc , data : gpointer , notify : GDestroyNotify) -> guint ; } unsafe extern "C" { pub fn g_idle_add_once (function : GSourceOnceFunc , data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_idle_remove_by_data (data : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_main_context_invoke_full (context : * mut GMainContext , priority : gint , function : GSourceFunc , data : gpointer , notify : GDestroyNotify) ; } unsafe extern "C" { pub fn g_main_context_invoke (context : * mut GMainContext , function : GSourceFunc , data : gpointer) ; } unsafe extern "C" { pub static mut g_timeout_funcs : GSourceFuncs ; } unsafe extern "C" { pub static mut g_child_watch_funcs : GSourceFuncs ; } unsafe extern "C" { pub static mut g_idle_funcs : GSourceFuncs ; } unsafe extern "C" { pub static mut g_unix_signal_funcs : GSourceFuncs ; } unsafe extern "C" { pub static mut g_unix_fd_source_funcs : GSourceFuncs ; } pub type gunichar = guint32 ; pub type gunichar2 = guint16 ; pub const GUnicodeType_G_UNICODE_CONTROL : GUnicodeType = 0 ; pub const GUnicodeType_G_UNICODE_FORMAT : GUnicodeType = 1 ; pub const GUnicodeType_G_UNICODE_UNASSIGNED : GUnicodeType = 2 ; pub const GUnicodeType_G_UNICODE_PRIVATE_USE : GUnicodeType = 3 ; pub const GUnicodeType_G_UNICODE_SURROGATE : GUnicodeType = 4 ; pub const GUnicodeType_G_UNICODE_LOWERCASE_LETTER : GUnicodeType = 5 ; pub const GUnicodeType_G_UNICODE_MODIFIER_LETTER : GUnicodeType = 6 ; pub const GUnicodeType_G_UNICODE_OTHER_LETTER : GUnicodeType = 7 ; pub const GUnicodeType_G_UNICODE_TITLECASE_LETTER : GUnicodeType = 8 ; pub const GUnicodeType_G_UNICODE_UPPERCASE_LETTER : GUnicodeType = 9 ; pub const GUnicodeType_G_UNICODE_SPACING_MARK : GUnicodeType = 10 ; pub const GUnicodeType_G_UNICODE_ENCLOSING_MARK : GUnicodeType = 11 ; pub const GUnicodeType_G_UNICODE_NON_SPACING_MARK : GUnicodeType = 12 ; pub const GUnicodeType_G_UNICODE_DECIMAL_NUMBER : GUnicodeType = 13 ; pub const GUnicodeType_G_UNICODE_LETTER_NUMBER : GUnicodeType = 14 ; pub const GUnicodeType_G_UNICODE_OTHER_NUMBER : GUnicodeType = 15 ; pub const GUnicodeType_G_UNICODE_CONNECT_PUNCTUATION : GUnicodeType = 16 ; pub const GUnicodeType_G_UNICODE_DASH_PUNCTUATION : GUnicodeType = 17 ; pub const GUnicodeType_G_UNICODE_CLOSE_PUNCTUATION : GUnicodeType = 18 ; pub const GUnicodeType_G_UNICODE_FINAL_PUNCTUATION : GUnicodeType = 19 ; pub const GUnicodeType_G_UNICODE_INITIAL_PUNCTUATION : GUnicodeType = 20 ; pub const GUnicodeType_G_UNICODE_OTHER_PUNCTUATION : GUnicodeType = 21 ; pub const GUnicodeType_G_UNICODE_OPEN_PUNCTUATION : GUnicodeType = 22 ; pub const GUnicodeType_G_UNICODE_CURRENCY_SYMBOL : GUnicodeType = 23 ; pub const GUnicodeType_G_UNICODE_MODIFIER_SYMBOL : GUnicodeType = 24 ; pub const GUnicodeType_G_UNICODE_MATH_SYMBOL : GUnicodeType = 25 ; pub const GUnicodeType_G_UNICODE_OTHER_SYMBOL : GUnicodeType = 26 ; pub const GUnicodeType_G_UNICODE_LINE_SEPARATOR : GUnicodeType = 27 ; pub const GUnicodeType_G_UNICODE_PARAGRAPH_SEPARATOR : GUnicodeType = 28 ; pub const GUnicodeType_G_UNICODE_SPACE_SEPARATOR : GUnicodeType = 29 ; pub type GUnicodeType = :: std :: os :: raw :: c_uint ; pub const GUnicodeBreakType_G_UNICODE_BREAK_MANDATORY : GUnicodeBreakType = 0 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_CARRIAGE_RETURN : GUnicodeBreakType = 1 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_LINE_FEED : GUnicodeBreakType = 2 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_COMBINING_MARK : GUnicodeBreakType = 3 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_SURROGATE : GUnicodeBreakType = 4 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_SPACE : GUnicodeBreakType = 5 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_INSEPARABLE : GUnicodeBreakType = 6 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_BREAKING_GLUE : GUnicodeBreakType = 7 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_CONTINGENT : GUnicodeBreakType = 8 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_SPACE : GUnicodeBreakType = 9 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_AFTER : GUnicodeBreakType = 10 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE : GUnicodeBreakType = 11 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE_AND_AFTER : GUnicodeBreakType = 12 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_HYPHEN : GUnicodeBreakType = 13 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_STARTER : GUnicodeBreakType = 14 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_OPEN_PUNCTUATION : GUnicodeBreakType = 15 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PUNCTUATION : GUnicodeBreakType = 16 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_QUOTATION : GUnicodeBreakType = 17 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_EXCLAMATION : GUnicodeBreakType = 18 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_IDEOGRAPHIC : GUnicodeBreakType = 19 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_NUMERIC : GUnicodeBreakType = 20 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_INFIX_SEPARATOR : GUnicodeBreakType = 21 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_SYMBOL : GUnicodeBreakType = 22 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_ALPHABETIC : GUnicodeBreakType = 23 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_PREFIX : GUnicodeBreakType = 24 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_POSTFIX : GUnicodeBreakType = 25 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_COMPLEX_CONTEXT : GUnicodeBreakType = 26 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_AMBIGUOUS : GUnicodeBreakType = 27 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_UNKNOWN : GUnicodeBreakType = 28 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_NEXT_LINE : GUnicodeBreakType = 29 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_WORD_JOINER : GUnicodeBreakType = 30 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_L_JAMO : GUnicodeBreakType = 31 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_V_JAMO : GUnicodeBreakType = 32 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_T_JAMO : GUnicodeBreakType = 33 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LV_SYLLABLE : GUnicodeBreakType = 34 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE : GUnicodeBreakType = 35 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARANTHESIS : GUnicodeBreakType = 36 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARENTHESIS : GUnicodeBreakType = 36 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER : GUnicodeBreakType = 37 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_HEBREW_LETTER : GUnicodeBreakType = 38 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_REGIONAL_INDICATOR : GUnicodeBreakType = 39 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_BASE : GUnicodeBreakType = 40 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_MODIFIER : GUnicodeBreakType = 41 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_JOINER : GUnicodeBreakType = 42 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_AKSARA : GUnicodeBreakType = 43 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_AKSARA_PRE_BASE : GUnicodeBreakType = 44 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_AKSARA_START : GUnicodeBreakType = 45 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_VIRAMA_FINAL : GUnicodeBreakType = 46 ; pub const GUnicodeBreakType_G_UNICODE_BREAK_VIRAMA : GUnicodeBreakType = 47 ; pub type GUnicodeBreakType = :: std :: os :: raw :: c_uint ; pub const GUnicodeScript_G_UNICODE_SCRIPT_INVALID_CODE : GUnicodeScript = - 1 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_COMMON : GUnicodeScript = 0 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_INHERITED : GUnicodeScript = 1 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_ARABIC : GUnicodeScript = 2 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_ARMENIAN : GUnicodeScript = 3 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_BENGALI : GUnicodeScript = 4 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_BOPOMOFO : GUnicodeScript = 5 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_CHEROKEE : GUnicodeScript = 6 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_COPTIC : GUnicodeScript = 7 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_CYRILLIC : GUnicodeScript = 8 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_DESERET : GUnicodeScript = 9 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_DEVANAGARI : GUnicodeScript = 10 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_ETHIOPIC : GUnicodeScript = 11 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_GEORGIAN : GUnicodeScript = 12 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_GOTHIC : GUnicodeScript = 13 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_GREEK : GUnicodeScript = 14 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_GUJARATI : GUnicodeScript = 15 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_GURMUKHI : GUnicodeScript = 16 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_HAN : GUnicodeScript = 17 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_HANGUL : GUnicodeScript = 18 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_HEBREW : GUnicodeScript = 19 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_HIRAGANA : GUnicodeScript = 20 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_KANNADA : GUnicodeScript = 21 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_KATAKANA : GUnicodeScript = 22 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_KHMER : GUnicodeScript = 23 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_LAO : GUnicodeScript = 24 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_LATIN : GUnicodeScript = 25 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MALAYALAM : GUnicodeScript = 26 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MONGOLIAN : GUnicodeScript = 27 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MYANMAR : GUnicodeScript = 28 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_OGHAM : GUnicodeScript = 29 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_ITALIC : GUnicodeScript = 30 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_ORIYA : GUnicodeScript = 31 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_RUNIC : GUnicodeScript = 32 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_SINHALA : GUnicodeScript = 33 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_SYRIAC : GUnicodeScript = 34 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TAMIL : GUnicodeScript = 35 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TELUGU : GUnicodeScript = 36 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_THAANA : GUnicodeScript = 37 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_THAI : GUnicodeScript = 38 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TIBETAN : GUnicodeScript = 39 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL : GUnicodeScript = 40 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_YI : GUnicodeScript = 41 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGALOG : GUnicodeScript = 42 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_HANUNOO : GUnicodeScript = 43 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_BUHID : GUnicodeScript = 44 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGBANWA : GUnicodeScript = 45 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAILLE : GUnicodeScript = 46 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRIOT : GUnicodeScript = 47 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_LIMBU : GUnicodeScript = 48 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_OSMANYA : GUnicodeScript = 49 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_SHAVIAN : GUnicodeScript = 50 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_B : GUnicodeScript = 51 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_LE : GUnicodeScript = 52 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_UGARITIC : GUnicodeScript = 53 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_NEW_TAI_LUE : GUnicodeScript = 54 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_BUGINESE : GUnicodeScript = 55 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_GLAGOLITIC : GUnicodeScript = 56 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TIFINAGH : GUnicodeScript = 57 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_SYLOTI_NAGRI : GUnicodeScript = 58 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERSIAN : GUnicodeScript = 59 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_KHAROSHTHI : GUnicodeScript = 60 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_UNKNOWN : GUnicodeScript = 61 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_BALINESE : GUnicodeScript = 62 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_CUNEIFORM : GUnicodeScript = 63 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_PHOENICIAN : GUnicodeScript = 64 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_PHAGS_PA : GUnicodeScript = 65 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_NKO : GUnicodeScript = 66 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_KAYAH_LI : GUnicodeScript = 67 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_LEPCHA : GUnicodeScript = 68 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_REJANG : GUnicodeScript = 69 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_SUNDANESE : GUnicodeScript = 70 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_SAURASHTRA : GUnicodeScript = 71 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAM : GUnicodeScript = 72 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_OL_CHIKI : GUnicodeScript = 73 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_VAI : GUnicodeScript = 74 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_CARIAN : GUnicodeScript = 75 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_LYCIAN : GUnicodeScript = 76 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_LYDIAN : GUnicodeScript = 77 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_AVESTAN : GUnicodeScript = 78 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_BAMUM : GUnicodeScript = 79 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS : GUnicodeScript = 80 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC : GUnicodeScript = 81 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI : GUnicodeScript = 82 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN : GUnicodeScript = 83 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_JAVANESE : GUnicodeScript = 84 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_KAITHI : GUnicodeScript = 85 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_LISU : GUnicodeScript = 86 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MEETEI_MAYEK : GUnicodeScript = 87 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN : GUnicodeScript = 88 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_TURKIC : GUnicodeScript = 89 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_SAMARITAN : GUnicodeScript = 90 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_THAM : GUnicodeScript = 91 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_VIET : GUnicodeScript = 92 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_BATAK : GUnicodeScript = 93 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAHMI : GUnicodeScript = 94 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MANDAIC : GUnicodeScript = 95 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAKMA : GUnicodeScript = 96 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_CURSIVE : GUnicodeScript = 97 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS : GUnicodeScript = 98 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MIAO : GUnicodeScript = 99 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_SHARADA : GUnicodeScript = 100 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_SORA_SOMPENG : GUnicodeScript = 101 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TAKRI : GUnicodeScript = 102 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_BASSA_VAH : GUnicodeScript = 103 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN : GUnicodeScript = 104 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_DUPLOYAN : GUnicodeScript = 105 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_ELBASAN : GUnicodeScript = 106 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_GRANTHA : GUnicodeScript = 107 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_KHOJKI : GUnicodeScript = 108 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_KHUDAWADI : GUnicodeScript = 109 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_A : GUnicodeScript = 110 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MAHAJANI : GUnicodeScript = 111 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MANICHAEAN : GUnicodeScript = 112 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MENDE_KIKAKUI : GUnicodeScript = 113 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MODI : GUnicodeScript = 114 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MRO : GUnicodeScript = 115 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_NABATAEAN : GUnicodeScript = 116 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN : GUnicodeScript = 117 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERMIC : GUnicodeScript = 118 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_PAHAWH_HMONG : GUnicodeScript = 119 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_PALMYRENE : GUnicodeScript = 120 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_PAU_CIN_HAU : GUnicodeScript = 121 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_PSALTER_PAHLAVI : GUnicodeScript = 122 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_SIDDHAM : GUnicodeScript = 123 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TIRHUTA : GUnicodeScript = 124 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_WARANG_CITI : GUnicodeScript = 125 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_AHOM : GUnicodeScript = 126 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS : GUnicodeScript = 127 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_HATRAN : GUnicodeScript = 128 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MULTANI : GUnicodeScript = 129 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_HUNGARIAN : GUnicodeScript = 130 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_SIGNWRITING : GUnicodeScript = 131 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_ADLAM : GUnicodeScript = 132 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_BHAIKSUKI : GUnicodeScript = 133 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MARCHEN : GUnicodeScript = 134 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_NEWA : GUnicodeScript = 135 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_OSAGE : GUnicodeScript = 136 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGUT : GUnicodeScript = 137 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MASARAM_GONDI : GUnicodeScript = 138 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_NUSHU : GUnicodeScript = 139 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_SOYOMBO : GUnicodeScript = 140 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_ZANABAZAR_SQUARE : GUnicodeScript = 141 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_DOGRA : GUnicodeScript = 142 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_GUNJALA_GONDI : GUnicodeScript = 143 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_HANIFI_ROHINGYA : GUnicodeScript = 144 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MAKASAR : GUnicodeScript = 145 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MEDEFAIDRIN : GUnicodeScript = 146 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOGDIAN : GUnicodeScript = 147 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_SOGDIAN : GUnicodeScript = 148 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_ELYMAIC : GUnicodeScript = 149 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_NANDINAGARI : GUnicodeScript = 150 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG : GUnicodeScript = 151 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_WANCHO : GUnicodeScript = 152 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_CHORASMIAN : GUnicodeScript = 153 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_DIVES_AKURU : GUnicodeScript = 154 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT : GUnicodeScript = 155 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_YEZIDI : GUnicodeScript = 156 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRO_MINOAN : GUnicodeScript = 157 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_UYGHUR : GUnicodeScript = 158 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGSA : GUnicodeScript = 159 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TOTO : GUnicodeScript = 160 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_VITHKUQI : GUnicodeScript = 161 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_MATH : GUnicodeScript = 162 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_KAWI : GUnicodeScript = 163 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_NAG_MUNDARI : GUnicodeScript = 164 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TODHRI : GUnicodeScript = 165 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_GARAY : GUnicodeScript = 166 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_TULU_TIGALARI : GUnicodeScript = 167 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_SUNUWAR : GUnicodeScript = 168 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_GURUNG_KHEMA : GUnicodeScript = 169 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_KIRAT_RAI : GUnicodeScript = 170 ; pub const GUnicodeScript_G_UNICODE_SCRIPT_OL_ONAL : GUnicodeScript = 171 ; pub type GUnicodeScript = :: std :: os :: raw :: c_int ; unsafe extern "C" { pub fn g_unicode_script_to_iso15924 (script : GUnicodeScript) -> guint32 ; } unsafe extern "C" { pub fn g_unicode_script_from_iso15924 (iso15924 : guint32) -> GUnicodeScript ; } unsafe extern "C" { pub fn g_unichar_isalnum (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_isalpha (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_iscntrl (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_isdigit (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_isgraph (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_islower (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_isprint (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_ispunct (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_isspace (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_isupper (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_isxdigit (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_istitle (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_isdefined (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_iswide (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_iswide_cjk (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_iszerowidth (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_ismark (c : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_toupper (c : gunichar) -> gunichar ; } unsafe extern "C" { pub fn g_unichar_tolower (c : gunichar) -> gunichar ; } unsafe extern "C" { pub fn g_unichar_totitle (c : gunichar) -> gunichar ; } unsafe extern "C" { pub fn g_unichar_digit_value (c : gunichar) -> gint ; } unsafe extern "C" { pub fn g_unichar_xdigit_value (c : gunichar) -> gint ; } unsafe extern "C" { pub fn g_unichar_type (c : gunichar) -> GUnicodeType ; } unsafe extern "C" { pub fn g_unichar_break_type (c : gunichar) -> GUnicodeBreakType ; } unsafe extern "C" { pub fn g_unichar_combining_class (uc : gunichar) -> gint ; } unsafe extern "C" { pub fn g_unichar_get_mirror_char (ch : gunichar , mirrored_ch : * mut gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_get_script (ch : gunichar) -> GUnicodeScript ; } unsafe extern "C" { pub fn g_unichar_validate (ch : gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_compose (a : gunichar , b : gunichar , ch : * mut gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_decompose (ch : gunichar , a : * mut gunichar , b : * mut gunichar) -> gboolean ; } unsafe extern "C" { pub fn g_unichar_fully_decompose (ch : gunichar , compat : gboolean , result : * mut gunichar , result_len : gsize) -> gsize ; } unsafe extern "C" { pub fn g_unicode_canonical_ordering (string : * mut gunichar , len : gsize) ; } unsafe extern "C" { pub fn g_unicode_canonical_decomposition (ch : gunichar , result_len : * mut gsize) -> * mut gunichar ; } unsafe extern "C" { pub static g_utf8_skip : * const gchar ; } unsafe extern "C" { pub fn g_utf8_get_char (p : * const gchar) -> gunichar ; } unsafe extern "C" { pub fn g_utf8_get_char_validated (p : * const gchar , max_len : gssize) -> gunichar ; } unsafe extern "C" { pub fn g_utf8_offset_to_pointer (str_ : * const gchar , offset : glong) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_pointer_to_offset (str_ : * const gchar , pos : * const gchar) -> glong ; } unsafe extern "C" { pub fn g_utf8_prev_char (p : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_find_next_char (p : * const gchar , end : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_find_prev_char (str_ : * const gchar , p : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_strlen (p : * const gchar , max : gssize) -> glong ; } unsafe extern "C" { pub fn g_utf8_substring (str_ : * const gchar , start_pos : glong , end_pos : glong) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_strncpy (dest : * mut gchar , src : * const gchar , n : gsize) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_truncate_middle (string : * const gchar , truncate_length : gsize) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_strchr (p : * const gchar , len : gssize , c : gunichar) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_strrchr (p : * const gchar , len : gssize , c : gunichar) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_strreverse (str_ : * const gchar , len : gssize) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_to_utf16 (str_ : * const gchar , len : glong , items_read : * mut glong , items_written : * mut glong , error : * mut * mut GError) -> * mut gunichar2 ; } unsafe extern "C" { pub fn g_utf8_to_ucs4 (str_ : * const gchar , len : glong , items_read : * mut glong , items_written : * mut glong , error : * mut * mut GError) -> * mut gunichar ; } unsafe extern "C" { pub fn g_utf8_to_ucs4_fast (str_ : * const gchar , len : glong , items_written : * mut glong) -> * mut gunichar ; } unsafe extern "C" { pub fn g_utf16_to_ucs4 (str_ : * const gunichar2 , len : glong , items_read : * mut glong , items_written : * mut glong , error : * mut * mut GError) -> * mut gunichar ; } unsafe extern "C" { pub fn g_utf16_to_utf8 (str_ : * const gunichar2 , len : glong , items_read : * mut glong , items_written : * mut glong , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_ucs4_to_utf16 (str_ : * const gunichar , len : glong , items_read : * mut glong , items_written : * mut glong , error : * mut * mut GError) -> * mut gunichar2 ; } unsafe extern "C" { pub fn g_ucs4_to_utf8 (str_ : * const gunichar , len : glong , items_read : * mut glong , items_written : * mut glong , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_unichar_to_utf8 (c : gunichar , outbuf : * mut gchar) -> gint ; } unsafe extern "C" { pub fn g_utf8_validate (str_ : * const gchar , max_len : gssize , end : * mut * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_utf8_validate_len (str_ : * const gchar , max_len : gsize , end : * mut * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_utf8_strup (str_ : * const gchar , len : gssize) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_strdown (str_ : * const gchar , len : gssize) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_casefold (str_ : * const gchar , len : gssize) -> * mut gchar ; } pub const GNormalizeMode_G_NORMALIZE_DEFAULT : GNormalizeMode = 0 ; pub const GNormalizeMode_G_NORMALIZE_NFD : GNormalizeMode = 0 ; pub const GNormalizeMode_G_NORMALIZE_DEFAULT_COMPOSE : GNormalizeMode = 1 ; pub const GNormalizeMode_G_NORMALIZE_NFC : GNormalizeMode = 1 ; pub const GNormalizeMode_G_NORMALIZE_ALL : GNormalizeMode = 2 ; pub const GNormalizeMode_G_NORMALIZE_NFKD : GNormalizeMode = 2 ; pub const GNormalizeMode_G_NORMALIZE_ALL_COMPOSE : GNormalizeMode = 3 ; pub const GNormalizeMode_G_NORMALIZE_NFKC : GNormalizeMode = 3 ; pub type GNormalizeMode = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_utf8_normalize (str_ : * const gchar , len : gssize , mode : GNormalizeMode) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_collate (str1 : * const gchar , str2 : * const gchar) -> gint ; } unsafe extern "C" { pub fn g_utf8_collate_key (str_ : * const gchar , len : gssize) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_collate_key_for_filename (str_ : * const gchar , len : gssize) -> * mut gchar ; } unsafe extern "C" { pub fn g_utf8_make_valid (str_ : * const gchar , len : gssize) -> * mut gchar ; } pub const GAsciiType_G_ASCII_ALNUM : GAsciiType = 1 ; pub const GAsciiType_G_ASCII_ALPHA : GAsciiType = 2 ; pub const GAsciiType_G_ASCII_CNTRL : GAsciiType = 4 ; pub const GAsciiType_G_ASCII_DIGIT : GAsciiType = 8 ; pub const GAsciiType_G_ASCII_GRAPH : GAsciiType = 16 ; pub const GAsciiType_G_ASCII_LOWER : GAsciiType = 32 ; pub const GAsciiType_G_ASCII_PRINT : GAsciiType = 64 ; pub const GAsciiType_G_ASCII_PUNCT : GAsciiType = 128 ; pub const GAsciiType_G_ASCII_SPACE : GAsciiType = 256 ; pub const GAsciiType_G_ASCII_UPPER : GAsciiType = 512 ; pub const GAsciiType_G_ASCII_XDIGIT : GAsciiType = 1024 ; pub type GAsciiType = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub static g_ascii_table : * const guint16 ; } unsafe extern "C" { pub fn g_ascii_tolower (c : gchar) -> gchar ; } unsafe extern "C" { pub fn g_ascii_toupper (c : gchar) -> gchar ; } unsafe extern "C" { pub fn g_ascii_digit_value (c : gchar) -> gint ; } unsafe extern "C" { pub fn g_ascii_xdigit_value (c : gchar) -> gint ; } unsafe extern "C" { pub fn g_strdelimit (string : * mut gchar , delimiters : * const gchar , new_delimiter : gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_strcanon (string : * mut gchar , valid_chars : * const gchar , substitutor : gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_strerror (errnum : gint) -> * const gchar ; } unsafe extern "C" { pub fn g_strsignal (signum : gint) -> * const gchar ; } unsafe extern "C" { pub fn g_strreverse (string : * mut gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_strlcpy (dest : * mut gchar , src : * const gchar , dest_size : gsize) -> gsize ; } unsafe extern "C" { pub fn g_strlcat (dest : * mut gchar , src : * const gchar , dest_size : gsize) -> gsize ; } unsafe extern "C" { pub fn g_strstr_len (haystack : * const gchar , haystack_len : gssize , needle : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_strrstr (haystack : * const gchar , needle : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_strrstr_len (haystack : * const gchar , haystack_len : gssize , needle : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_str_has_suffix (str_ : * const gchar , suffix : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_str_has_prefix (str_ : * const gchar , prefix : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_strtod (nptr : * const gchar , endptr : * mut * mut gchar) -> gdouble ; } unsafe extern "C" { pub fn g_ascii_strtod (nptr : * const gchar , endptr : * mut * mut gchar) -> gdouble ; } unsafe extern "C" { pub fn g_ascii_strtoull (nptr : * const gchar , endptr : * mut * mut gchar , base : guint) -> guint64 ; } unsafe extern "C" { pub fn g_ascii_strtoll (nptr : * const gchar , endptr : * mut * mut gchar , base : guint) -> gint64 ; } unsafe extern "C" { pub fn g_ascii_dtostr (buffer : * mut gchar , buf_len : gint , d : gdouble) -> * mut gchar ; } unsafe extern "C" { pub fn g_ascii_formatd (buffer : * mut gchar , buf_len : gint , format : * const gchar , d : gdouble) -> * mut gchar ; } unsafe extern "C" { pub fn g_strchug (string : * mut gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_strchomp (string : * mut gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_ascii_strcasecmp (s1 : * const gchar , s2 : * const gchar) -> gint ; } unsafe extern "C" { pub fn g_ascii_strncasecmp (s1 : * const gchar , s2 : * const gchar , n : gsize) -> gint ; } unsafe extern "C" { pub fn g_ascii_strdown (str_ : * const gchar , len : gssize) -> * mut gchar ; } unsafe extern "C" { pub fn g_ascii_strup (str_ : * const gchar , len : gssize) -> * mut gchar ; } unsafe extern "C" { pub fn g_str_is_ascii (str_ : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_strcasecmp (s1 : * const gchar , s2 : * const gchar) -> gint ; } unsafe extern "C" { pub fn g_strncasecmp (s1 : * const gchar , s2 : * const gchar , n : guint) -> gint ; } unsafe extern "C" { pub fn g_strdown (string : * mut gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_strup (string : * mut gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_strdup (str_ : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_strdup_printf (format : * const gchar , ...) -> * mut gchar ; } unsafe extern "C" { pub fn g_strdup_vprintf (format : * const gchar , args : * mut __va_list_tag) -> * mut gchar ; } unsafe extern "C" { pub fn g_strndup (str_ : * const gchar , n : gsize) -> * mut gchar ; } unsafe extern "C" { pub fn g_strnfill (length : gsize , fill_char : gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_strconcat (string1 : * const gchar , ...) -> * mut gchar ; } unsafe extern "C" { pub fn g_strjoin (separator : * const gchar , ...) -> * mut gchar ; } unsafe extern "C" { pub fn g_strcompress (source : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_strescape (source : * const gchar , exceptions : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_memdup (mem : gconstpointer , byte_size : guint) -> gpointer ; } unsafe extern "C" { pub fn g_memdup2 (mem : gconstpointer , byte_size : gsize) -> gpointer ; } pub type GStrv = * mut * mut gchar ; unsafe extern "C" { pub fn g_strsplit (string : * const gchar , delimiter : * const gchar , max_tokens : gint) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_strsplit_set (string : * const gchar , delimiters : * const gchar , max_tokens : gint) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_strjoinv (separator : * const gchar , str_array : * mut * mut gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_strfreev (str_array : * mut * mut gchar) ; } unsafe extern "C" { pub fn g_strdupv (str_array : * mut * mut gchar) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_strv_length (str_array : * mut * mut gchar) -> guint ; } unsafe extern "C" { pub fn g_stpcpy (dest : * mut gchar , src : * const :: std :: os :: raw :: c_char) -> * mut gchar ; } unsafe extern "C" { pub fn g_str_to_ascii (str_ : * const gchar , from_locale : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_str_tokenize_and_fold (string : * const gchar , translit_locale : * const gchar , ascii_alternates : * mut * mut * mut gchar) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_str_match_string (search_term : * const gchar , potential_hit : * const gchar , accept_alternates : gboolean) -> gboolean ; } unsafe extern "C" { pub fn g_strv_contains (strv : * const * const gchar , str_ : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_strv_equal (strv1 : * const * const gchar , strv2 : * const * const gchar) -> gboolean ; } pub const GNumberParserError_G_NUMBER_PARSER_ERROR_INVALID : GNumberParserError = 0 ; pub const GNumberParserError_G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS : GNumberParserError = 1 ; pub type GNumberParserError = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_number_parser_error_quark () -> GQuark ; } unsafe extern "C" { pub fn g_ascii_string_to_signed (str_ : * const gchar , base : guint , min : gint64 , max : gint64 , out_num : * mut gint64 , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_ascii_string_to_unsigned (str_ : * const gchar , base : guint , min : guint64 , max : guint64 , out_num : * mut guint64 , error : * mut * mut GError) -> gboolean ; } pub type GString = _GString ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GString { pub str_ : * mut gchar , pub len : gsize , pub allocated_len : gsize , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GString"] [:: std :: mem :: size_of :: < _GString > () - 24usize] ; ["Alignment of _GString"] [:: std :: mem :: align_of :: < _GString > () - 8usize] ; ["Offset of field: _GString::str_"] [:: std :: mem :: offset_of ! (_GString , str_) - 0usize] ; ["Offset of field: _GString::len"] [:: std :: mem :: offset_of ! (_GString , len) - 8usize] ; ["Offset of field: _GString::allocated_len"] [:: std :: mem :: offset_of ! (_GString , allocated_len) - 16usize] ; } ; unsafe extern "C" { pub fn g_string_new (init : * const gchar) -> * mut GString ; } unsafe extern "C" { pub fn g_string_new_take (init : * mut gchar) -> * mut GString ; } unsafe extern "C" { pub fn g_string_new_len (init : * const gchar , len : gssize) -> * mut GString ; } unsafe extern "C" { pub fn g_string_sized_new (dfl_size : gsize) -> * mut GString ; } unsafe extern "C" { pub fn g_string_free (string : * mut GString , free_segment : gboolean) -> * mut gchar ; } unsafe extern "C" { pub fn g_string_free_and_steal (string : * mut GString) -> * mut gchar ; } unsafe extern "C" { pub fn g_string_free_to_bytes (string : * mut GString) -> * mut GBytes ; } unsafe extern "C" { pub fn g_string_equal (v : * const GString , v2 : * const GString) -> gboolean ; } unsafe extern "C" { pub fn g_string_hash (str_ : * const GString) -> guint ; } unsafe extern "C" { pub fn g_string_assign (string : * mut GString , rval : * const gchar) -> * mut GString ; } unsafe extern "C" { pub fn g_string_truncate (string : * mut GString , len : gsize) -> * mut GString ; } unsafe extern "C" { pub fn g_string_set_size (string : * mut GString , len : gsize) -> * mut GString ; } unsafe extern "C" { pub fn g_string_insert_len (string : * mut GString , pos : gssize , val : * const gchar , len : gssize) -> * mut GString ; } unsafe extern "C" { pub fn g_string_append (string : * mut GString , val : * const gchar) -> * mut GString ; } unsafe extern "C" { pub fn g_string_append_len (string : * mut GString , val : * const gchar , len : gssize) -> * mut GString ; } unsafe extern "C" { pub fn g_string_append_c (string : * mut GString , c : gchar) -> * mut GString ; } unsafe extern "C" { pub fn g_string_append_unichar (string : * mut GString , wc : gunichar) -> * mut GString ; } unsafe extern "C" { pub fn g_string_prepend (string : * mut GString , val : * const gchar) -> * mut GString ; } unsafe extern "C" { pub fn g_string_prepend_c (string : * mut GString , c : gchar) -> * mut GString ; } unsafe extern "C" { pub fn g_string_prepend_unichar (string : * mut GString , wc : gunichar) -> * mut GString ; } unsafe extern "C" { pub fn g_string_prepend_len (string : * mut GString , val : * const gchar , len : gssize) -> * mut GString ; } unsafe extern "C" { pub fn g_string_insert (string : * mut GString , pos : gssize , val : * const gchar) -> * mut GString ; } unsafe extern "C" { pub fn g_string_insert_c (string : * mut GString , pos : gssize , c : gchar) -> * mut GString ; } unsafe extern "C" { pub fn g_string_insert_unichar (string : * mut GString , pos : gssize , wc : gunichar) -> * mut GString ; } unsafe extern "C" { pub fn g_string_overwrite (string : * mut GString , pos : gsize , val : * const gchar) -> * mut GString ; } unsafe extern "C" { pub fn g_string_overwrite_len (string : * mut GString , pos : gsize , val : * const gchar , len : gssize) -> * mut GString ; } unsafe extern "C" { pub fn g_string_erase (string : * mut GString , pos : gssize , len : gssize) -> * mut GString ; } unsafe extern "C" { pub fn g_string_replace (string : * mut GString , find : * const gchar , replace : * const gchar , limit : guint) -> guint ; } unsafe extern "C" { pub fn g_string_ascii_down (string : * mut GString) -> * mut GString ; } unsafe extern "C" { pub fn g_string_ascii_up (string : * mut GString) -> * mut GString ; } unsafe extern "C" { pub fn g_string_vprintf (string : * mut GString , format : * const gchar , args : * mut __va_list_tag) ; } unsafe extern "C" { pub fn g_string_printf (string : * mut GString , format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_string_append_vprintf (string : * mut GString , format : * const gchar , args : * mut __va_list_tag) ; } unsafe extern "C" { pub fn g_string_append_printf (string : * mut GString , format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_string_append_uri_escaped (string : * mut GString , unescaped : * const gchar , reserved_chars_allowed : * const gchar , allow_utf8 : gboolean) -> * mut GString ; } unsafe extern "C" { pub fn g_string_down (string : * mut GString) -> * mut GString ; } unsafe extern "C" { pub fn g_string_up (string : * mut GString) -> * mut GString ; } pub type GIOChannel = _GIOChannel ; pub type GIOFuncs = _GIOFuncs ; pub const GIOError_G_IO_ERROR_NONE : GIOError = 0 ; pub const GIOError_G_IO_ERROR_AGAIN : GIOError = 1 ; pub const GIOError_G_IO_ERROR_INVAL : GIOError = 2 ; pub const GIOError_G_IO_ERROR_UNKNOWN : GIOError = 3 ; pub type GIOError = :: std :: os :: raw :: c_uint ; pub const GIOChannelError_G_IO_CHANNEL_ERROR_FBIG : GIOChannelError = 0 ; pub const GIOChannelError_G_IO_CHANNEL_ERROR_INVAL : GIOChannelError = 1 ; pub const GIOChannelError_G_IO_CHANNEL_ERROR_IO : GIOChannelError = 2 ; pub const GIOChannelError_G_IO_CHANNEL_ERROR_ISDIR : GIOChannelError = 3 ; pub const GIOChannelError_G_IO_CHANNEL_ERROR_NOSPC : GIOChannelError = 4 ; pub const GIOChannelError_G_IO_CHANNEL_ERROR_NXIO : GIOChannelError = 5 ; pub const GIOChannelError_G_IO_CHANNEL_ERROR_OVERFLOW : GIOChannelError = 6 ; pub const GIOChannelError_G_IO_CHANNEL_ERROR_PIPE : GIOChannelError = 7 ; pub const GIOChannelError_G_IO_CHANNEL_ERROR_FAILED : GIOChannelError = 8 ; pub type GIOChannelError = :: std :: os :: raw :: c_uint ; pub const GIOStatus_G_IO_STATUS_ERROR : GIOStatus = 0 ; pub const GIOStatus_G_IO_STATUS_NORMAL : GIOStatus = 1 ; pub const GIOStatus_G_IO_STATUS_EOF : GIOStatus = 2 ; pub const GIOStatus_G_IO_STATUS_AGAIN : GIOStatus = 3 ; pub type GIOStatus = :: std :: os :: raw :: c_uint ; pub const GSeekType_G_SEEK_CUR : GSeekType = 0 ; pub const GSeekType_G_SEEK_SET : GSeekType = 1 ; pub const GSeekType_G_SEEK_END : GSeekType = 2 ; pub type GSeekType = :: std :: os :: raw :: c_uint ; pub const GIOFlags_G_IO_FLAG_NONE : GIOFlags = 0 ; pub const GIOFlags_G_IO_FLAG_APPEND : GIOFlags = 1 ; pub const GIOFlags_G_IO_FLAG_NONBLOCK : GIOFlags = 2 ; pub const GIOFlags_G_IO_FLAG_IS_READABLE : GIOFlags = 4 ; pub const GIOFlags_G_IO_FLAG_IS_WRITABLE : GIOFlags = 8 ; pub const GIOFlags_G_IO_FLAG_IS_WRITEABLE : GIOFlags = 8 ; pub const GIOFlags_G_IO_FLAG_IS_SEEKABLE : GIOFlags = 16 ; pub const GIOFlags_G_IO_FLAG_MASK : GIOFlags = 31 ; pub const GIOFlags_G_IO_FLAG_GET_MASK : GIOFlags = 31 ; pub const GIOFlags_G_IO_FLAG_SET_MASK : GIOFlags = 3 ; pub type GIOFlags = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIOChannel { pub ref_count : gint , pub funcs : * mut GIOFuncs , pub encoding : * mut gchar , pub read_cd : GIConv , pub write_cd : GIConv , pub line_term : * mut gchar , pub line_term_len : guint , pub buf_size : gsize , pub read_buf : * mut GString , pub encoded_read_buf : * mut GString , pub write_buf : * mut GString , pub partial_write_buf : [gchar ; 6usize] , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub reserved1 : gpointer , pub reserved2 : gpointer , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GIOChannel"] [:: std :: mem :: size_of :: < _GIOChannel > () - 112usize] ; ["Alignment of _GIOChannel"] [:: std :: mem :: align_of :: < _GIOChannel > () - 8usize] ; ["Offset of field: _GIOChannel::ref_count"] [:: std :: mem :: offset_of ! (_GIOChannel , ref_count) - 0usize] ; ["Offset of field: _GIOChannel::funcs"] [:: std :: mem :: offset_of ! (_GIOChannel , funcs) - 8usize] ; ["Offset of field: _GIOChannel::encoding"] [:: std :: mem :: offset_of ! (_GIOChannel , encoding) - 16usize] ; ["Offset of field: _GIOChannel::read_cd"] [:: std :: mem :: offset_of ! (_GIOChannel , read_cd) - 24usize] ; ["Offset of field: _GIOChannel::write_cd"] [:: std :: mem :: offset_of ! (_GIOChannel , write_cd) - 32usize] ; ["Offset of field: _GIOChannel::line_term"] [:: std :: mem :: offset_of ! (_GIOChannel , line_term) - 40usize] ; ["Offset of field: _GIOChannel::line_term_len"] [:: std :: mem :: offset_of ! (_GIOChannel , line_term_len) - 48usize] ; ["Offset of field: _GIOChannel::buf_size"] [:: std :: mem :: offset_of ! (_GIOChannel , buf_size) - 56usize] ; ["Offset of field: _GIOChannel::read_buf"] [:: std :: mem :: offset_of ! (_GIOChannel , read_buf) - 64usize] ; ["Offset of field: _GIOChannel::encoded_read_buf"] [:: std :: mem :: offset_of ! (_GIOChannel , encoded_read_buf) - 72usize] ; ["Offset of field: _GIOChannel::write_buf"] [:: std :: mem :: offset_of ! (_GIOChannel , write_buf) - 80usize] ; ["Offset of field: _GIOChannel::partial_write_buf"] [:: std :: mem :: offset_of ! (_GIOChannel , partial_write_buf) - 88usize] ; ["Offset of field: _GIOChannel::reserved1"] [:: std :: mem :: offset_of ! (_GIOChannel , reserved1) - 96usize] ; ["Offset of field: _GIOChannel::reserved2"] [:: std :: mem :: offset_of ! (_GIOChannel , reserved2) - 104usize] ; } ; impl _GIOChannel { # [inline] pub fn use_buffer (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_use_buffer (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub unsafe fn use_buffer_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 0usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_use_buffer_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 0usize , 1u8 , val as u64 ,) } } # [inline] pub fn do_encode (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_do_encode (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub unsafe fn do_encode_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 1usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_do_encode_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 1usize , 1u8 , val as u64 ,) } } # [inline] pub fn close_on_unref (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_close_on_unref (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub unsafe fn close_on_unref_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 2usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_close_on_unref_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 2usize , 1u8 , val as u64 ,) } } # [inline] pub fn is_readable (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (3usize , 1u8) as u32) } } # [inline] pub fn set_is_readable (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (3usize , 1u8 , val as u64) } } # [inline] pub unsafe fn is_readable_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 3usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_is_readable_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 3usize , 1u8 , val as u64 ,) } } # [inline] pub fn is_writeable (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (4usize , 1u8) as u32) } } # [inline] pub fn set_is_writeable (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (4usize , 1u8 , val as u64) } } # [inline] pub unsafe fn is_writeable_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 4usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_is_writeable_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 4usize , 1u8 , val as u64 ,) } } # [inline] pub fn is_seekable (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (5usize , 1u8) as u32) } } # [inline] pub fn set_is_seekable (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (5usize , 1u8 , val as u64) } } # [inline] pub unsafe fn is_seekable_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 5usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_is_seekable_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 5usize , 1u8 , val as u64 ,) } } # [inline] pub fn new_bitfield_1 (use_buffer : guint , do_encode : guint , close_on_unref : guint , is_readable : guint , is_writeable : guint , is_seekable : guint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let use_buffer : u32 = unsafe { :: std :: mem :: transmute (use_buffer) } ; use_buffer as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let do_encode : u32 = unsafe { :: std :: mem :: transmute (do_encode) } ; do_encode as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let close_on_unref : u32 = unsafe { :: std :: mem :: transmute (close_on_unref) } ; close_on_unref as u64 }) ; __bindgen_bitfield_unit . set (3usize , 1u8 , { let is_readable : u32 = unsafe { :: std :: mem :: transmute (is_readable) } ; is_readable as u64 }) ; __bindgen_bitfield_unit . set (4usize , 1u8 , { let is_writeable : u32 = unsafe { :: std :: mem :: transmute (is_writeable) } ; is_writeable as u64 }) ; __bindgen_bitfield_unit . set (5usize , 1u8 , { let is_seekable : u32 = unsafe { :: std :: mem :: transmute (is_seekable) } ; is_seekable as u64 }) ; __bindgen_bitfield_unit } } pub type GIOFunc = :: std :: option :: Option < unsafe extern "C" fn (source : * mut GIOChannel , condition : GIOCondition , data : gpointer) -> gboolean > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIOFuncs { pub io_read : :: std :: option :: Option < unsafe extern "C" fn (channel : * mut GIOChannel , buf : * mut gchar , count : gsize , bytes_read : * mut gsize , err : * mut * mut GError) -> GIOStatus > , pub io_write : :: std :: option :: Option < unsafe extern "C" fn (channel : * mut GIOChannel , buf : * const gchar , count : gsize , bytes_written : * mut gsize , err : * mut * mut GError) -> GIOStatus > , pub io_seek : :: std :: option :: Option < unsafe extern "C" fn (channel : * mut GIOChannel , offset : gint64 , type_ : GSeekType , err : * mut * mut GError) -> GIOStatus > , pub io_close : :: std :: option :: Option < unsafe extern "C" fn (channel : * mut GIOChannel , err : * mut * mut GError) -> GIOStatus > , pub io_create_watch : :: std :: option :: Option < unsafe extern "C" fn (channel : * mut GIOChannel , condition : GIOCondition) -> * mut GSource > , pub io_free : :: std :: option :: Option < unsafe extern "C" fn (channel : * mut GIOChannel) > , pub io_set_flags : :: std :: option :: Option < unsafe extern "C" fn (channel : * mut GIOChannel , flags : GIOFlags , err : * mut * mut GError) -> GIOStatus > , pub io_get_flags : :: std :: option :: Option < unsafe extern "C" fn (channel : * mut GIOChannel) -> GIOFlags > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GIOFuncs"] [:: std :: mem :: size_of :: < _GIOFuncs > () - 64usize] ; ["Alignment of _GIOFuncs"] [:: std :: mem :: align_of :: < _GIOFuncs > () - 8usize] ; ["Offset of field: _GIOFuncs::io_read"] [:: std :: mem :: offset_of ! (_GIOFuncs , io_read) - 0usize] ; ["Offset of field: _GIOFuncs::io_write"] [:: std :: mem :: offset_of ! (_GIOFuncs , io_write) - 8usize] ; ["Offset of field: _GIOFuncs::io_seek"] [:: std :: mem :: offset_of ! (_GIOFuncs , io_seek) - 16usize] ; ["Offset of field: _GIOFuncs::io_close"] [:: std :: mem :: offset_of ! (_GIOFuncs , io_close) - 24usize] ; ["Offset of field: _GIOFuncs::io_create_watch"] [:: std :: mem :: offset_of ! (_GIOFuncs , io_create_watch) - 32usize] ; ["Offset of field: _GIOFuncs::io_free"] [:: std :: mem :: offset_of ! (_GIOFuncs , io_free) - 40usize] ; ["Offset of field: _GIOFuncs::io_set_flags"] [:: std :: mem :: offset_of ! (_GIOFuncs , io_set_flags) - 48usize] ; ["Offset of field: _GIOFuncs::io_get_flags"] [:: std :: mem :: offset_of ! (_GIOFuncs , io_get_flags) - 56usize] ; } ; unsafe extern "C" { pub fn g_io_channel_init (channel : * mut GIOChannel) ; } unsafe extern "C" { pub fn g_io_channel_ref (channel : * mut GIOChannel) -> * mut GIOChannel ; } unsafe extern "C" { pub fn g_io_channel_unref (channel : * mut GIOChannel) ; } unsafe extern "C" { pub fn g_io_channel_read (channel : * mut GIOChannel , buf : * mut gchar , count : gsize , bytes_read : * mut gsize) -> GIOError ; } unsafe extern "C" { pub fn g_io_channel_write (channel : * mut GIOChannel , buf : * const gchar , count : gsize , bytes_written : * mut gsize) -> GIOError ; } unsafe extern "C" { pub fn g_io_channel_seek (channel : * mut GIOChannel , offset : gint64 , type_ : GSeekType) -> GIOError ; } unsafe extern "C" { pub fn g_io_channel_close (channel : * mut GIOChannel) ; } unsafe extern "C" { pub fn g_io_channel_shutdown (channel : * mut GIOChannel , flush : gboolean , err : * mut * mut GError) -> GIOStatus ; } unsafe extern "C" { pub fn g_io_add_watch_full (channel : * mut GIOChannel , priority : gint , condition : GIOCondition , func : GIOFunc , user_data : gpointer , notify : GDestroyNotify) -> guint ; } unsafe extern "C" { pub fn g_io_create_watch (channel : * mut GIOChannel , condition : GIOCondition) -> * mut GSource ; } unsafe extern "C" { pub fn g_io_add_watch (channel : * mut GIOChannel , condition : GIOCondition , func : GIOFunc , user_data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_io_channel_set_buffer_size (channel : * mut GIOChannel , size : gsize) ; } unsafe extern "C" { pub fn g_io_channel_get_buffer_size (channel : * mut GIOChannel) -> gsize ; } unsafe extern "C" { pub fn g_io_channel_get_buffer_condition (channel : * mut GIOChannel) -> GIOCondition ; } unsafe extern "C" { pub fn g_io_channel_set_flags (channel : * mut GIOChannel , flags : GIOFlags , error : * mut * mut GError) -> GIOStatus ; } unsafe extern "C" { pub fn g_io_channel_get_flags (channel : * mut GIOChannel) -> GIOFlags ; } unsafe extern "C" { pub fn g_io_channel_set_line_term (channel : * mut GIOChannel , line_term : * const gchar , length : gint) ; } unsafe extern "C" { pub fn g_io_channel_get_line_term (channel : * mut GIOChannel , length : * mut gint) -> * const gchar ; } unsafe extern "C" { pub fn g_io_channel_set_buffered (channel : * mut GIOChannel , buffered : gboolean) ; } unsafe extern "C" { pub fn g_io_channel_get_buffered (channel : * mut GIOChannel) -> gboolean ; } unsafe extern "C" { pub fn g_io_channel_set_encoding (channel : * mut GIOChannel , encoding : * const gchar , error : * mut * mut GError) -> GIOStatus ; } unsafe extern "C" { pub fn g_io_channel_get_encoding (channel : * mut GIOChannel) -> * const gchar ; } unsafe extern "C" { pub fn g_io_channel_set_close_on_unref (channel : * mut GIOChannel , do_close : gboolean) ; } unsafe extern "C" { pub fn g_io_channel_get_close_on_unref (channel : * mut GIOChannel) -> gboolean ; } unsafe extern "C" { pub fn g_io_channel_flush (channel : * mut GIOChannel , error : * mut * mut GError) -> GIOStatus ; } unsafe extern "C" { pub fn g_io_channel_read_line (channel : * mut GIOChannel , str_return : * mut * mut gchar , length : * mut gsize , terminator_pos : * mut gsize , error : * mut * mut GError) -> GIOStatus ; } unsafe extern "C" { pub fn g_io_channel_read_line_string (channel : * mut GIOChannel , buffer : * mut GString , terminator_pos : * mut gsize , error : * mut * mut GError) -> GIOStatus ; } unsafe extern "C" { pub fn g_io_channel_read_to_end (channel : * mut GIOChannel , str_return : * mut * mut gchar , length : * mut gsize , error : * mut * mut GError) -> GIOStatus ; } unsafe extern "C" { pub fn g_io_channel_read_chars (channel : * mut GIOChannel , buf : * mut gchar , count : gsize , bytes_read : * mut gsize , error : * mut * mut GError) -> GIOStatus ; } unsafe extern "C" { pub fn g_io_channel_read_unichar (channel : * mut GIOChannel , thechar : * mut gunichar , error : * mut * mut GError) -> GIOStatus ; } unsafe extern "C" { pub fn g_io_channel_write_chars (channel : * mut GIOChannel , buf : * const gchar , count : gssize , bytes_written : * mut gsize , error : * mut * mut GError) -> GIOStatus ; } unsafe extern "C" { pub fn g_io_channel_write_unichar (channel : * mut GIOChannel , thechar : gunichar , error : * mut * mut GError) -> GIOStatus ; } unsafe extern "C" { pub fn g_io_channel_seek_position (channel : * mut GIOChannel , offset : gint64 , type_ : GSeekType , error : * mut * mut GError) -> GIOStatus ; } unsafe extern "C" { pub fn g_io_channel_new_file (filename : * const gchar , mode : * const gchar , error : * mut * mut GError) -> * mut GIOChannel ; } unsafe extern "C" { pub fn g_io_channel_error_quark () -> GQuark ; } unsafe extern "C" { pub fn g_io_channel_error_from_errno (en : gint) -> GIOChannelError ; } unsafe extern "C" { pub fn g_io_channel_unix_new (fd : :: std :: os :: raw :: c_int) -> * mut GIOChannel ; } unsafe extern "C" { pub fn g_io_channel_unix_get_fd (channel : * mut GIOChannel) -> gint ; } unsafe extern "C" { pub static mut g_io_watch_funcs : GSourceFuncs ; } pub const GKeyFileError_G_KEY_FILE_ERROR_UNKNOWN_ENCODING : GKeyFileError = 0 ; pub const GKeyFileError_G_KEY_FILE_ERROR_PARSE : GKeyFileError = 1 ; pub const GKeyFileError_G_KEY_FILE_ERROR_NOT_FOUND : GKeyFileError = 2 ; pub const GKeyFileError_G_KEY_FILE_ERROR_KEY_NOT_FOUND : GKeyFileError = 3 ; pub const GKeyFileError_G_KEY_FILE_ERROR_GROUP_NOT_FOUND : GKeyFileError = 4 ; pub const GKeyFileError_G_KEY_FILE_ERROR_INVALID_VALUE : GKeyFileError = 5 ; pub type GKeyFileError = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_key_file_error_quark () -> GQuark ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GKeyFile { _unused : [u8 ; 0] , } pub type GKeyFile = _GKeyFile ; pub const GKeyFileFlags_G_KEY_FILE_NONE : GKeyFileFlags = 0 ; pub const GKeyFileFlags_G_KEY_FILE_KEEP_COMMENTS : GKeyFileFlags = 1 ; pub const GKeyFileFlags_G_KEY_FILE_KEEP_TRANSLATIONS : GKeyFileFlags = 2 ; pub type GKeyFileFlags = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_key_file_new () -> * mut GKeyFile ; } unsafe extern "C" { pub fn g_key_file_ref (key_file : * mut GKeyFile) -> * mut GKeyFile ; } unsafe extern "C" { pub fn g_key_file_unref (key_file : * mut GKeyFile) ; } unsafe extern "C" { pub fn g_key_file_free (key_file : * mut GKeyFile) ; } unsafe extern "C" { pub fn g_key_file_set_list_separator (key_file : * mut GKeyFile , separator : gchar) ; } unsafe extern "C" { pub fn g_key_file_load_from_file (key_file : * mut GKeyFile , file : * const gchar , flags : GKeyFileFlags , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_key_file_load_from_data (key_file : * mut GKeyFile , data : * const gchar , length : gsize , flags : GKeyFileFlags , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_key_file_load_from_bytes (key_file : * mut GKeyFile , bytes : * mut GBytes , flags : GKeyFileFlags , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_key_file_load_from_dirs (key_file : * mut GKeyFile , file : * const gchar , search_dirs : * mut * const gchar , full_path : * mut * mut gchar , flags : GKeyFileFlags , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_key_file_load_from_data_dirs (key_file : * mut GKeyFile , file : * const gchar , full_path : * mut * mut gchar , flags : GKeyFileFlags , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_key_file_to_data (key_file : * mut GKeyFile , length : * mut gsize , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_key_file_save_to_file (key_file : * mut GKeyFile , filename : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_key_file_get_start_group (key_file : * mut GKeyFile) -> * mut gchar ; } unsafe extern "C" { pub fn g_key_file_get_groups (key_file : * mut GKeyFile , length : * mut gsize) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_key_file_get_keys (key_file : * mut GKeyFile , group_name : * const gchar , length : * mut gsize , error : * mut * mut GError) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_key_file_has_group (key_file : * mut GKeyFile , group_name : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_key_file_has_key (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_key_file_get_value (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_key_file_set_value (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , value : * const gchar) ; } unsafe extern "C" { pub fn g_key_file_get_string (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_key_file_set_string (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , string : * const gchar) ; } unsafe extern "C" { pub fn g_key_file_get_locale_string (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , locale : * const gchar , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_key_file_get_locale_for_key (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , locale : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_key_file_set_locale_string (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , locale : * const gchar , string : * const gchar) ; } unsafe extern "C" { pub fn g_key_file_get_boolean (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_key_file_set_boolean (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , value : gboolean) ; } unsafe extern "C" { pub fn g_key_file_get_integer (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , error : * mut * mut GError) -> gint ; } unsafe extern "C" { pub fn g_key_file_set_integer (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , value : gint) ; } unsafe extern "C" { pub fn g_key_file_get_int64 (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , error : * mut * mut GError) -> gint64 ; } unsafe extern "C" { pub fn g_key_file_set_int64 (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , value : gint64) ; } unsafe extern "C" { pub fn g_key_file_get_uint64 (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , error : * mut * mut GError) -> guint64 ; } unsafe extern "C" { pub fn g_key_file_set_uint64 (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , value : guint64) ; } unsafe extern "C" { pub fn g_key_file_get_double (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , error : * mut * mut GError) -> gdouble ; } unsafe extern "C" { pub fn g_key_file_set_double (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , value : gdouble) ; } unsafe extern "C" { pub fn g_key_file_get_string_list (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , length : * mut gsize , error : * mut * mut GError) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_key_file_set_string_list (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , list : * const * const gchar , length : gsize) ; } unsafe extern "C" { pub fn g_key_file_get_locale_string_list (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , locale : * const gchar , length : * mut gsize , error : * mut * mut GError) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_key_file_set_locale_string_list (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , locale : * const gchar , list : * const * const gchar , length : gsize) ; } unsafe extern "C" { pub fn g_key_file_get_boolean_list (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , length : * mut gsize , error : * mut * mut GError) -> * mut gboolean ; } unsafe extern "C" { pub fn g_key_file_set_boolean_list (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , list : * mut gboolean , length : gsize) ; } unsafe extern "C" { pub fn g_key_file_get_integer_list (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , length : * mut gsize , error : * mut * mut GError) -> * mut gint ; } unsafe extern "C" { pub fn g_key_file_set_double_list (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , list : * mut gdouble , length : gsize) ; } unsafe extern "C" { pub fn g_key_file_get_double_list (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , length : * mut gsize , error : * mut * mut GError) -> * mut gdouble ; } unsafe extern "C" { pub fn g_key_file_set_integer_list (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , list : * mut gint , length : gsize) ; } unsafe extern "C" { pub fn g_key_file_set_comment (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , comment : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_key_file_get_comment (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_key_file_remove_comment (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_key_file_remove_key (key_file : * mut GKeyFile , group_name : * const gchar , key : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_key_file_remove_group (key_file : * mut GKeyFile , group_name : * const gchar , error : * mut * mut GError) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMappedFile { _unused : [u8 ; 0] , } pub type GMappedFile = _GMappedFile ; unsafe extern "C" { pub fn g_mapped_file_new (filename : * const gchar , writable : gboolean , error : * mut * mut GError) -> * mut GMappedFile ; } unsafe extern "C" { pub fn g_mapped_file_new_from_fd (fd : gint , writable : gboolean , error : * mut * mut GError) -> * mut GMappedFile ; } unsafe extern "C" { pub fn g_mapped_file_get_length (file : * mut GMappedFile) -> gsize ; } unsafe extern "C" { pub fn g_mapped_file_get_contents (file : * mut GMappedFile) -> * mut gchar ; } unsafe extern "C" { pub fn g_mapped_file_get_bytes (file : * mut GMappedFile) -> * mut GBytes ; } unsafe extern "C" { pub fn g_mapped_file_ref (file : * mut GMappedFile) -> * mut GMappedFile ; } unsafe extern "C" { pub fn g_mapped_file_unref (file : * mut GMappedFile) ; } unsafe extern "C" { pub fn g_mapped_file_free (file : * mut GMappedFile) ; } pub const GMarkupError_G_MARKUP_ERROR_BAD_UTF8 : GMarkupError = 0 ; pub const GMarkupError_G_MARKUP_ERROR_EMPTY : GMarkupError = 1 ; pub const GMarkupError_G_MARKUP_ERROR_PARSE : GMarkupError = 2 ; pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ELEMENT : GMarkupError = 3 ; pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE : GMarkupError = 4 ; pub const GMarkupError_G_MARKUP_ERROR_INVALID_CONTENT : GMarkupError = 5 ; pub const GMarkupError_G_MARKUP_ERROR_MISSING_ATTRIBUTE : GMarkupError = 6 ; pub type GMarkupError = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_markup_error_quark () -> GQuark ; } pub const GMarkupParseFlags_G_MARKUP_DEFAULT_FLAGS : GMarkupParseFlags = 0 ; pub const GMarkupParseFlags_G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG : GMarkupParseFlags = 1 ; pub const GMarkupParseFlags_G_MARKUP_TREAT_CDATA_AS_TEXT : GMarkupParseFlags = 2 ; pub const GMarkupParseFlags_G_MARKUP_PREFIX_ERROR_POSITION : GMarkupParseFlags = 4 ; pub const GMarkupParseFlags_G_MARKUP_IGNORE_QUALIFIED : GMarkupParseFlags = 8 ; pub type GMarkupParseFlags = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMarkupParseContext { _unused : [u8 ; 0] , } pub type GMarkupParseContext = _GMarkupParseContext ; pub type GMarkupParser = _GMarkupParser ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMarkupParser { pub start_element : :: std :: option :: Option < unsafe extern "C" fn (context : * mut GMarkupParseContext , element_name : * const gchar , attribute_names : * mut * const gchar , attribute_values : * mut * const gchar , user_data : gpointer , error : * mut * mut GError) > , pub end_element : :: std :: option :: Option < unsafe extern "C" fn (context : * mut GMarkupParseContext , element_name : * const gchar , user_data : gpointer , error : * mut * mut GError) > , pub text : :: std :: option :: Option < unsafe extern "C" fn (context : * mut GMarkupParseContext , text : * const gchar , text_len : gsize , user_data : gpointer , error : * mut * mut GError) > , pub passthrough : :: std :: option :: Option < unsafe extern "C" fn (context : * mut GMarkupParseContext , passthrough_text : * const gchar , text_len : gsize , user_data : gpointer , error : * mut * mut GError) > , pub error : :: std :: option :: Option < unsafe extern "C" fn (context : * mut GMarkupParseContext , error : * mut GError , user_data : gpointer) > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMarkupParser"] [:: std :: mem :: size_of :: < _GMarkupParser > () - 40usize] ; ["Alignment of _GMarkupParser"] [:: std :: mem :: align_of :: < _GMarkupParser > () - 8usize] ; ["Offset of field: _GMarkupParser::start_element"] [:: std :: mem :: offset_of ! (_GMarkupParser , start_element) - 0usize] ; ["Offset of field: _GMarkupParser::end_element"] [:: std :: mem :: offset_of ! (_GMarkupParser , end_element) - 8usize] ; ["Offset of field: _GMarkupParser::text"] [:: std :: mem :: offset_of ! (_GMarkupParser , text) - 16usize] ; ["Offset of field: _GMarkupParser::passthrough"] [:: std :: mem :: offset_of ! (_GMarkupParser , passthrough) - 24usize] ; ["Offset of field: _GMarkupParser::error"] [:: std :: mem :: offset_of ! (_GMarkupParser , error) - 32usize] ; } ; unsafe extern "C" { pub fn g_markup_parse_context_new (parser : * const GMarkupParser , flags : GMarkupParseFlags , user_data : gpointer , user_data_dnotify : GDestroyNotify) -> * mut GMarkupParseContext ; } unsafe extern "C" { pub fn g_markup_parse_context_ref (context : * mut GMarkupParseContext) -> * mut GMarkupParseContext ; } unsafe extern "C" { pub fn g_markup_parse_context_unref (context : * mut GMarkupParseContext) ; } unsafe extern "C" { pub fn g_markup_parse_context_free (context : * mut GMarkupParseContext) ; } unsafe extern "C" { pub fn g_markup_parse_context_parse (context : * mut GMarkupParseContext , text : * const gchar , text_len : gssize , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_markup_parse_context_push (context : * mut GMarkupParseContext , parser : * const GMarkupParser , user_data : gpointer) ; } unsafe extern "C" { pub fn g_markup_parse_context_pop (context : * mut GMarkupParseContext) -> gpointer ; } unsafe extern "C" { pub fn g_markup_parse_context_end_parse (context : * mut GMarkupParseContext , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_markup_parse_context_get_element (context : * mut GMarkupParseContext) -> * const gchar ; } unsafe extern "C" { pub fn g_markup_parse_context_get_element_stack (context : * mut GMarkupParseContext) -> * const GSList ; } unsafe extern "C" { pub fn g_markup_parse_context_get_position (context : * mut GMarkupParseContext , line_number : * mut gint , char_number : * mut gint) ; } unsafe extern "C" { pub fn g_markup_parse_context_get_user_data (context : * mut GMarkupParseContext) -> gpointer ; } unsafe extern "C" { pub fn g_markup_escape_text (text : * const gchar , length : gssize) -> * mut gchar ; } unsafe extern "C" { pub fn g_markup_printf_escaped (format : * const :: std :: os :: raw :: c_char , ...) -> * mut gchar ; } unsafe extern "C" { pub fn g_markup_vprintf_escaped (format : * const :: std :: os :: raw :: c_char , args : * mut __va_list_tag) -> * mut gchar ; } pub const GMarkupCollectType_G_MARKUP_COLLECT_INVALID : GMarkupCollectType = 0 ; pub const GMarkupCollectType_G_MARKUP_COLLECT_STRING : GMarkupCollectType = 1 ; pub const GMarkupCollectType_G_MARKUP_COLLECT_STRDUP : GMarkupCollectType = 2 ; pub const GMarkupCollectType_G_MARKUP_COLLECT_BOOLEAN : GMarkupCollectType = 3 ; pub const GMarkupCollectType_G_MARKUP_COLLECT_TRISTATE : GMarkupCollectType = 4 ; pub const GMarkupCollectType_G_MARKUP_COLLECT_OPTIONAL : GMarkupCollectType = 65536 ; pub type GMarkupCollectType = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_markup_collect_attributes (element_name : * const gchar , attribute_names : * mut * const gchar , attribute_values : * mut * const gchar , error : * mut * mut GError , first_type : GMarkupCollectType , first_attr : * const gchar , ...) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GVariantType { _unused : [u8 ; 0] , } pub type GVariantType = _GVariantType ; unsafe extern "C" { pub fn g_variant_type_string_is_valid (type_string : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_variant_type_string_scan (string : * const gchar , limit : * const gchar , endptr : * mut * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_variant_type_free (type_ : * mut GVariantType) ; } unsafe extern "C" { pub fn g_variant_type_copy (type_ : * const GVariantType) -> * mut GVariantType ; } unsafe extern "C" { pub fn g_variant_type_new (type_string : * const gchar) -> * mut GVariantType ; } unsafe extern "C" { pub fn g_variant_type_get_string_length (type_ : * const GVariantType) -> gsize ; } unsafe extern "C" { pub fn g_variant_type_peek_string (type_ : * const GVariantType) -> * const gchar ; } unsafe extern "C" { pub fn g_variant_type_dup_string (type_ : * const GVariantType) -> * mut gchar ; } unsafe extern "C" { pub fn g_variant_type_is_definite (type_ : * const GVariantType) -> gboolean ; } unsafe extern "C" { pub fn g_variant_type_is_container (type_ : * const GVariantType) -> gboolean ; } unsafe extern "C" { pub fn g_variant_type_is_basic (type_ : * const GVariantType) -> gboolean ; } unsafe extern "C" { pub fn g_variant_type_is_maybe (type_ : * const GVariantType) -> gboolean ; } unsafe extern "C" { pub fn g_variant_type_is_array (type_ : * const GVariantType) -> gboolean ; } unsafe extern "C" { pub fn g_variant_type_is_tuple (type_ : * const GVariantType) -> gboolean ; } unsafe extern "C" { pub fn g_variant_type_is_dict_entry (type_ : * const GVariantType) -> gboolean ; } unsafe extern "C" { pub fn g_variant_type_is_variant (type_ : * const GVariantType) -> gboolean ; } unsafe extern "C" { pub fn g_variant_type_hash (type_ : gconstpointer) -> guint ; } unsafe extern "C" { pub fn g_variant_type_equal (type1 : gconstpointer , type2 : gconstpointer) -> gboolean ; } unsafe extern "C" { pub fn g_variant_type_is_subtype_of (type_ : * const GVariantType , supertype : * const GVariantType) -> gboolean ; } unsafe extern "C" { pub fn g_variant_type_element (type_ : * const GVariantType) -> * const GVariantType ; } unsafe extern "C" { pub fn g_variant_type_first (type_ : * const GVariantType) -> * const GVariantType ; } unsafe extern "C" { pub fn g_variant_type_next (type_ : * const GVariantType) -> * const GVariantType ; } unsafe extern "C" { pub fn g_variant_type_n_items (type_ : * const GVariantType) -> gsize ; } unsafe extern "C" { pub fn g_variant_type_key (type_ : * const GVariantType) -> * const GVariantType ; } unsafe extern "C" { pub fn g_variant_type_value (type_ : * const GVariantType) -> * const GVariantType ; } unsafe extern "C" { pub fn g_variant_type_new_array (element : * const GVariantType) -> * mut GVariantType ; } unsafe extern "C" { pub fn g_variant_type_new_maybe (element : * const GVariantType) -> * mut GVariantType ; } unsafe extern "C" { pub fn g_variant_type_new_tuple (items : * const * const GVariantType , length : gint) -> * mut GVariantType ; } unsafe extern "C" { pub fn g_variant_type_new_dict_entry (key : * const GVariantType , value : * const GVariantType) -> * mut GVariantType ; } unsafe extern "C" { pub fn g_variant_type_checked_ (type_string : * const gchar) -> * const GVariantType ; } unsafe extern "C" { pub fn g_variant_type_string_get_depth_ (type_string : * const gchar) -> gsize ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GVariant { _unused : [u8 ; 0] , } pub type GVariant = _GVariant ; pub const GVariantClass_G_VARIANT_CLASS_BOOLEAN : GVariantClass = 98 ; pub const GVariantClass_G_VARIANT_CLASS_BYTE : GVariantClass = 121 ; pub const GVariantClass_G_VARIANT_CLASS_INT16 : GVariantClass = 110 ; pub const GVariantClass_G_VARIANT_CLASS_UINT16 : GVariantClass = 113 ; pub const GVariantClass_G_VARIANT_CLASS_INT32 : GVariantClass = 105 ; pub const GVariantClass_G_VARIANT_CLASS_UINT32 : GVariantClass = 117 ; pub const GVariantClass_G_VARIANT_CLASS_INT64 : GVariantClass = 120 ; pub const GVariantClass_G_VARIANT_CLASS_UINT64 : GVariantClass = 116 ; pub const GVariantClass_G_VARIANT_CLASS_HANDLE : GVariantClass = 104 ; pub const GVariantClass_G_VARIANT_CLASS_DOUBLE : GVariantClass = 100 ; pub const GVariantClass_G_VARIANT_CLASS_STRING : GVariantClass = 115 ; pub const GVariantClass_G_VARIANT_CLASS_OBJECT_PATH : GVariantClass = 111 ; pub const GVariantClass_G_VARIANT_CLASS_SIGNATURE : GVariantClass = 103 ; pub const GVariantClass_G_VARIANT_CLASS_VARIANT : GVariantClass = 118 ; pub const GVariantClass_G_VARIANT_CLASS_MAYBE : GVariantClass = 109 ; pub const GVariantClass_G_VARIANT_CLASS_ARRAY : GVariantClass = 97 ; pub const GVariantClass_G_VARIANT_CLASS_TUPLE : GVariantClass = 40 ; pub const GVariantClass_G_VARIANT_CLASS_DICT_ENTRY : GVariantClass = 123 ; pub type GVariantClass = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_variant_unref (value : * mut GVariant) ; } unsafe extern "C" { pub fn g_variant_ref (value : * mut GVariant) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_ref_sink (value : * mut GVariant) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_is_floating (value : * mut GVariant) -> gboolean ; } unsafe extern "C" { pub fn g_variant_take_ref (value : * mut GVariant) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_get_type (value : * mut GVariant) -> * const GVariantType ; } unsafe extern "C" { pub fn g_variant_get_type_string (value : * mut GVariant) -> * const gchar ; } unsafe extern "C" { pub fn g_variant_is_of_type (value : * mut GVariant , type_ : * const GVariantType) -> gboolean ; } unsafe extern "C" { pub fn g_variant_is_container (value : * mut GVariant) -> gboolean ; } unsafe extern "C" { pub fn g_variant_classify (value : * mut GVariant) -> GVariantClass ; } unsafe extern "C" { pub fn g_variant_new_boolean (value : gboolean) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_byte (value : guint8) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_int16 (value : gint16) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_uint16 (value : guint16) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_int32 (value : gint32) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_uint32 (value : guint32) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_int64 (value : gint64) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_uint64 (value : guint64) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_handle (value : gint32) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_double (value : gdouble) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_string (string : * const gchar) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_take_string (string : * mut gchar) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_printf (format_string : * const gchar , ...) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_object_path (object_path : * const gchar) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_is_object_path (string : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_variant_new_signature (signature : * const gchar) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_is_signature (string : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_variant_new_variant (value : * mut GVariant) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_strv (strv : * const * const gchar , length : gssize) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_objv (strv : * const * const gchar , length : gssize) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_bytestring (string : * const gchar) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_bytestring_array (strv : * const * const gchar , length : gssize) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_fixed_array (element_type : * const GVariantType , elements : gconstpointer , n_elements : gsize , element_size : gsize) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_get_boolean (value : * mut GVariant) -> gboolean ; } unsafe extern "C" { pub fn g_variant_get_byte (value : * mut GVariant) -> guint8 ; } unsafe extern "C" { pub fn g_variant_get_int16 (value : * mut GVariant) -> gint16 ; } unsafe extern "C" { pub fn g_variant_get_uint16 (value : * mut GVariant) -> guint16 ; } unsafe extern "C" { pub fn g_variant_get_int32 (value : * mut GVariant) -> gint32 ; } unsafe extern "C" { pub fn g_variant_get_uint32 (value : * mut GVariant) -> guint32 ; } unsafe extern "C" { pub fn g_variant_get_int64 (value : * mut GVariant) -> gint64 ; } unsafe extern "C" { pub fn g_variant_get_uint64 (value : * mut GVariant) -> guint64 ; } unsafe extern "C" { pub fn g_variant_get_handle (value : * mut GVariant) -> gint32 ; } unsafe extern "C" { pub fn g_variant_get_double (value : * mut GVariant) -> gdouble ; } unsafe extern "C" { pub fn g_variant_get_variant (value : * mut GVariant) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_get_string (value : * mut GVariant , length : * mut gsize) -> * const gchar ; } unsafe extern "C" { pub fn g_variant_dup_string (value : * mut GVariant , length : * mut gsize) -> * mut gchar ; } unsafe extern "C" { pub fn g_variant_get_strv (value : * mut GVariant , length : * mut gsize) -> * mut * const gchar ; } unsafe extern "C" { pub fn g_variant_dup_strv (value : * mut GVariant , length : * mut gsize) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_variant_get_objv (value : * mut GVariant , length : * mut gsize) -> * mut * const gchar ; } unsafe extern "C" { pub fn g_variant_dup_objv (value : * mut GVariant , length : * mut gsize) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_variant_get_bytestring (value : * mut GVariant) -> * const gchar ; } unsafe extern "C" { pub fn g_variant_dup_bytestring (value : * mut GVariant , length : * mut gsize) -> * mut gchar ; } unsafe extern "C" { pub fn g_variant_get_bytestring_array (value : * mut GVariant , length : * mut gsize) -> * mut * const gchar ; } unsafe extern "C" { pub fn g_variant_dup_bytestring_array (value : * mut GVariant , length : * mut gsize) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_variant_new_maybe (child_type : * const GVariantType , child : * mut GVariant) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_array (child_type : * const GVariantType , children : * const * mut GVariant , n_children : gsize) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_tuple (children : * const * mut GVariant , n_children : gsize) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_dict_entry (key : * mut GVariant , value : * mut GVariant) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_get_maybe (value : * mut GVariant) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_n_children (value : * mut GVariant) -> gsize ; } unsafe extern "C" { pub fn g_variant_get_child (value : * mut GVariant , index_ : gsize , format_string : * const gchar , ...) ; } unsafe extern "C" { pub fn g_variant_get_child_value (value : * mut GVariant , index_ : gsize) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_lookup (dictionary : * mut GVariant , key : * const gchar , format_string : * const gchar , ...) -> gboolean ; } unsafe extern "C" { pub fn g_variant_lookup_value (dictionary : * mut GVariant , key : * const gchar , expected_type : * const GVariantType) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_get_fixed_array (value : * mut GVariant , n_elements : * mut gsize , element_size : gsize) -> gconstpointer ; } unsafe extern "C" { pub fn g_variant_get_size (value : * mut GVariant) -> gsize ; } unsafe extern "C" { pub fn g_variant_get_data (value : * mut GVariant) -> gconstpointer ; } unsafe extern "C" { pub fn g_variant_get_data_as_bytes (value : * mut GVariant) -> * mut GBytes ; } unsafe extern "C" { pub fn g_variant_store (value : * mut GVariant , data : gpointer) ; } unsafe extern "C" { pub fn g_variant_print (value : * mut GVariant , type_annotate : gboolean) -> * mut gchar ; } unsafe extern "C" { pub fn g_variant_print_string (value : * mut GVariant , string : * mut GString , type_annotate : gboolean) -> * mut GString ; } unsafe extern "C" { pub fn g_variant_hash (value : gconstpointer) -> guint ; } unsafe extern "C" { pub fn g_variant_equal (one : gconstpointer , two : gconstpointer) -> gboolean ; } unsafe extern "C" { pub fn g_variant_get_normal_form (value : * mut GVariant) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_is_normal_form (value : * mut GVariant) -> gboolean ; } unsafe extern "C" { pub fn g_variant_byteswap (value : * mut GVariant) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_from_bytes (type_ : * const GVariantType , bytes : * mut GBytes , trusted : gboolean) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_from_data (type_ : * const GVariantType , data : gconstpointer , size : gsize , trusted : gboolean , notify : GDestroyNotify , user_data : gpointer) -> * mut GVariant ; } pub type GVariantIter = _GVariantIter ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GVariantIter { pub x : [guintptr ; 16usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GVariantIter"] [:: std :: mem :: size_of :: < _GVariantIter > () - 128usize] ; ["Alignment of _GVariantIter"] [:: std :: mem :: align_of :: < _GVariantIter > () - 8usize] ; ["Offset of field: _GVariantIter::x"] [:: std :: mem :: offset_of ! (_GVariantIter , x) - 0usize] ; } ; unsafe extern "C" { pub fn g_variant_iter_new (value : * mut GVariant) -> * mut GVariantIter ; } unsafe extern "C" { pub fn g_variant_iter_init (iter : * mut GVariantIter , value : * mut GVariant) -> gsize ; } unsafe extern "C" { pub fn g_variant_iter_copy (iter : * mut GVariantIter) -> * mut GVariantIter ; } unsafe extern "C" { pub fn g_variant_iter_n_children (iter : * mut GVariantIter) -> gsize ; } unsafe extern "C" { pub fn g_variant_iter_free (iter : * mut GVariantIter) ; } unsafe extern "C" { pub fn g_variant_iter_next_value (iter : * mut GVariantIter) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_iter_next (iter : * mut GVariantIter , format_string : * const gchar , ...) -> gboolean ; } unsafe extern "C" { pub fn g_variant_iter_loop (iter : * mut GVariantIter , format_string : * const gchar , ...) -> gboolean ; } pub type GVariantBuilder = _GVariantBuilder ; # [repr (C)] # [derive (Copy , Clone)] pub struct _GVariantBuilder { pub u : _GVariantBuilder__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union _GVariantBuilder__bindgen_ty_1 { pub s : _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 , pub x : [guintptr ; 16usize] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 { pub partial_magic : gsize , pub type_ : * const GVariantType , pub y : [guintptr ; 14usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GVariantBuilder__bindgen_ty_1__bindgen_ty_1"] [:: std :: mem :: size_of :: < _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 > () - 128usize] ; ["Alignment of _GVariantBuilder__bindgen_ty_1__bindgen_ty_1"] [:: std :: mem :: align_of :: < _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 > () - 8usize] ; ["Offset of field: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1::partial_magic"] [:: std :: mem :: offset_of ! (_GVariantBuilder__bindgen_ty_1__bindgen_ty_1 , partial_magic) - 0usize] ; ["Offset of field: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1::type_"] [:: std :: mem :: offset_of ! (_GVariantBuilder__bindgen_ty_1__bindgen_ty_1 , type_) - 8usize] ; ["Offset of field: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1::y"] [:: std :: mem :: offset_of ! (_GVariantBuilder__bindgen_ty_1__bindgen_ty_1 , y) - 16usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GVariantBuilder__bindgen_ty_1"] [:: std :: mem :: size_of :: < _GVariantBuilder__bindgen_ty_1 > () - 128usize] ; ["Alignment of _GVariantBuilder__bindgen_ty_1"] [:: std :: mem :: align_of :: < _GVariantBuilder__bindgen_ty_1 > () - 8usize] ; ["Offset of field: _GVariantBuilder__bindgen_ty_1::s"] [:: std :: mem :: offset_of ! (_GVariantBuilder__bindgen_ty_1 , s) - 0usize] ; ["Offset of field: _GVariantBuilder__bindgen_ty_1::x"] [:: std :: mem :: offset_of ! (_GVariantBuilder__bindgen_ty_1 , x) - 0usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GVariantBuilder"] [:: std :: mem :: size_of :: < _GVariantBuilder > () - 128usize] ; ["Alignment of _GVariantBuilder"] [:: std :: mem :: align_of :: < _GVariantBuilder > () - 8usize] ; ["Offset of field: _GVariantBuilder::u"] [:: std :: mem :: offset_of ! (_GVariantBuilder , u) - 0usize] ; } ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_FAILED : GVariantParseError = 0 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED : GVariantParseError = 1 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE : GVariantParseError = 2 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED : GVariantParseError = 3 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END : GVariantParseError = 4 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_CHARACTER : GVariantParseError = 5 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING : GVariantParseError = 6 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH : GVariantParseError = 7 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE : GVariantParseError = 8 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING : GVariantParseError = 9 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE : GVariantParseError = 10 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE : GVariantParseError = 11 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG : GVariantParseError = 12 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_TYPE_ERROR : GVariantParseError = 13 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN : GVariantParseError = 14 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD : GVariantParseError = 15 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT : GVariantParseError = 16 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_VALUE_EXPECTED : GVariantParseError = 17 ; pub const GVariantParseError_G_VARIANT_PARSE_ERROR_RECURSION : GVariantParseError = 18 ; pub type GVariantParseError = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_variant_parser_get_error_quark () -> GQuark ; } unsafe extern "C" { pub fn g_variant_parse_error_quark () -> GQuark ; } unsafe extern "C" { pub fn g_variant_builder_new (type_ : * const GVariantType) -> * mut GVariantBuilder ; } unsafe extern "C" { pub fn g_variant_builder_unref (builder : * mut GVariantBuilder) ; } unsafe extern "C" { pub fn g_variant_builder_ref (builder : * mut GVariantBuilder) -> * mut GVariantBuilder ; } unsafe extern "C" { pub fn g_variant_builder_init (builder : * mut GVariantBuilder , type_ : * const GVariantType) ; } unsafe extern "C" { pub fn g_variant_builder_init_static (builder : * mut GVariantBuilder , type_ : * const GVariantType) ; } unsafe extern "C" { pub fn g_variant_builder_end (builder : * mut GVariantBuilder) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_builder_clear (builder : * mut GVariantBuilder) ; } unsafe extern "C" { pub fn g_variant_builder_open (builder : * mut GVariantBuilder , type_ : * const GVariantType) ; } unsafe extern "C" { pub fn g_variant_builder_close (builder : * mut GVariantBuilder) ; } unsafe extern "C" { pub fn g_variant_builder_add_value (builder : * mut GVariantBuilder , value : * mut GVariant) ; } unsafe extern "C" { pub fn g_variant_builder_add (builder : * mut GVariantBuilder , format_string : * const gchar , ...) ; } unsafe extern "C" { pub fn g_variant_builder_add_parsed (builder : * mut GVariantBuilder , format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_variant_new (format_string : * const gchar , ...) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_get (value : * mut GVariant , format_string : * const gchar , ...) ; } unsafe extern "C" { pub fn g_variant_new_va (format_string : * const gchar , endptr : * mut * const gchar , app : * mut va_list) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_get_va (value : * mut GVariant , format_string : * const gchar , endptr : * mut * const gchar , app : * mut va_list) ; } unsafe extern "C" { pub fn g_variant_check_format_string (value : * mut GVariant , format_string : * const gchar , copy_only : gboolean) -> gboolean ; } unsafe extern "C" { pub fn g_variant_parse (type_ : * const GVariantType , text : * const gchar , limit : * const gchar , endptr : * mut * const gchar , error : * mut * mut GError) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_parsed (format : * const gchar , ...) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_new_parsed_va (format : * const gchar , app : * mut va_list) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_parse_error_print_context (error : * mut GError , source_str : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_variant_compare (one : gconstpointer , two : gconstpointer) -> gint ; } pub type GVariantDict = _GVariantDict ; # [repr (C)] # [derive (Copy , Clone)] pub struct _GVariantDict { pub u : _GVariantDict__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union _GVariantDict__bindgen_ty_1 { pub s : _GVariantDict__bindgen_ty_1__bindgen_ty_1 , pub x : [guintptr ; 16usize] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GVariantDict__bindgen_ty_1__bindgen_ty_1 { pub asv : * mut GVariant , pub partial_magic : gsize , pub y : [guintptr ; 14usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GVariantDict__bindgen_ty_1__bindgen_ty_1"] [:: std :: mem :: size_of :: < _GVariantDict__bindgen_ty_1__bindgen_ty_1 > () - 128usize] ; ["Alignment of _GVariantDict__bindgen_ty_1__bindgen_ty_1"] [:: std :: mem :: align_of :: < _GVariantDict__bindgen_ty_1__bindgen_ty_1 > () - 8usize] ; ["Offset of field: _GVariantDict__bindgen_ty_1__bindgen_ty_1::asv"] [:: std :: mem :: offset_of ! (_GVariantDict__bindgen_ty_1__bindgen_ty_1 , asv) - 0usize] ; ["Offset of field: _GVariantDict__bindgen_ty_1__bindgen_ty_1::partial_magic"] [:: std :: mem :: offset_of ! (_GVariantDict__bindgen_ty_1__bindgen_ty_1 , partial_magic) - 8usize] ; ["Offset of field: _GVariantDict__bindgen_ty_1__bindgen_ty_1::y"] [:: std :: mem :: offset_of ! (_GVariantDict__bindgen_ty_1__bindgen_ty_1 , y) - 16usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GVariantDict__bindgen_ty_1"] [:: std :: mem :: size_of :: < _GVariantDict__bindgen_ty_1 > () - 128usize] ; ["Alignment of _GVariantDict__bindgen_ty_1"] [:: std :: mem :: align_of :: < _GVariantDict__bindgen_ty_1 > () - 8usize] ; ["Offset of field: _GVariantDict__bindgen_ty_1::s"] [:: std :: mem :: offset_of ! (_GVariantDict__bindgen_ty_1 , s) - 0usize] ; ["Offset of field: _GVariantDict__bindgen_ty_1::x"] [:: std :: mem :: offset_of ! (_GVariantDict__bindgen_ty_1 , x) - 0usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GVariantDict"] [:: std :: mem :: size_of :: < _GVariantDict > () - 128usize] ; ["Alignment of _GVariantDict"] [:: std :: mem :: align_of :: < _GVariantDict > () - 8usize] ; ["Offset of field: _GVariantDict::u"] [:: std :: mem :: offset_of ! (_GVariantDict , u) - 0usize] ; } ; unsafe extern "C" { pub fn g_variant_dict_new (from_asv : * mut GVariant) -> * mut GVariantDict ; } unsafe extern "C" { pub fn g_variant_dict_init (dict : * mut GVariantDict , from_asv : * mut GVariant) ; } unsafe extern "C" { pub fn g_variant_dict_lookup (dict : * mut GVariantDict , key : * const gchar , format_string : * const gchar , ...) -> gboolean ; } unsafe extern "C" { pub fn g_variant_dict_lookup_value (dict : * mut GVariantDict , key : * const gchar , expected_type : * const GVariantType) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_dict_contains (dict : * mut GVariantDict , key : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_variant_dict_insert (dict : * mut GVariantDict , key : * const gchar , format_string : * const gchar , ...) ; } unsafe extern "C" { pub fn g_variant_dict_insert_value (dict : * mut GVariantDict , key : * const gchar , value : * mut GVariant) ; } unsafe extern "C" { pub fn g_variant_dict_remove (dict : * mut GVariantDict , key : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_variant_dict_clear (dict : * mut GVariantDict) ; } unsafe extern "C" { pub fn g_variant_dict_end (dict : * mut GVariantDict) -> * mut GVariant ; } unsafe extern "C" { pub fn g_variant_dict_ref (dict : * mut GVariantDict) -> * mut GVariantDict ; } unsafe extern "C" { pub fn g_variant_dict_unref (dict : * mut GVariantDict) ; } unsafe extern "C" { pub fn g_printf_string_upper_bound (format : * const gchar , args : * mut __va_list_tag) -> gsize ; } pub const GLogLevelFlags_G_LOG_FLAG_RECURSION : GLogLevelFlags = 1 ; pub const GLogLevelFlags_G_LOG_FLAG_FATAL : GLogLevelFlags = 2 ; pub const GLogLevelFlags_G_LOG_LEVEL_ERROR : GLogLevelFlags = 4 ; pub const GLogLevelFlags_G_LOG_LEVEL_CRITICAL : GLogLevelFlags = 8 ; pub const GLogLevelFlags_G_LOG_LEVEL_WARNING : GLogLevelFlags = 16 ; pub const GLogLevelFlags_G_LOG_LEVEL_MESSAGE : GLogLevelFlags = 32 ; pub const GLogLevelFlags_G_LOG_LEVEL_INFO : GLogLevelFlags = 64 ; pub const GLogLevelFlags_G_LOG_LEVEL_DEBUG : GLogLevelFlags = 128 ; pub const GLogLevelFlags_G_LOG_LEVEL_MASK : GLogLevelFlags = - 4 ; pub type GLogLevelFlags = :: std :: os :: raw :: c_int ; pub type GLogFunc = :: std :: option :: Option < unsafe extern "C" fn (log_domain : * const gchar , log_level : GLogLevelFlags , message : * const gchar , user_data : gpointer) > ; unsafe extern "C" { pub fn g_log_set_handler (log_domain : * const gchar , log_levels : GLogLevelFlags , log_func : GLogFunc , user_data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_log_set_handler_full (log_domain : * const gchar , log_levels : GLogLevelFlags , log_func : GLogFunc , user_data : gpointer , destroy : GDestroyNotify) -> guint ; } unsafe extern "C" { pub fn g_log_remove_handler (log_domain : * const gchar , handler_id : guint) ; } unsafe extern "C" { pub fn g_log_default_handler (log_domain : * const gchar , log_level : GLogLevelFlags , message : * const gchar , unused_data : gpointer) ; } unsafe extern "C" { pub fn g_log_set_default_handler (log_func : GLogFunc , user_data : gpointer) -> GLogFunc ; } unsafe extern "C" { pub fn g_log (log_domain : * const gchar , log_level : GLogLevelFlags , format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_logv (log_domain : * const gchar , log_level : GLogLevelFlags , format : * const gchar , args : * mut __va_list_tag) ; } unsafe extern "C" { pub fn g_log_set_fatal_mask (log_domain : * const gchar , fatal_mask : GLogLevelFlags) -> GLogLevelFlags ; } unsafe extern "C" { pub fn g_log_set_always_fatal (fatal_mask : GLogLevelFlags) -> GLogLevelFlags ; } pub const GLogWriterOutput_G_LOG_WRITER_HANDLED : GLogWriterOutput = 1 ; pub const GLogWriterOutput_G_LOG_WRITER_UNHANDLED : GLogWriterOutput = 0 ; pub type GLogWriterOutput = :: std :: os :: raw :: c_uint ; pub type GLogField = _GLogField ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GLogField { pub key : * const gchar , pub value : gconstpointer , pub length : gssize , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GLogField"] [:: std :: mem :: size_of :: < _GLogField > () - 24usize] ; ["Alignment of _GLogField"] [:: std :: mem :: align_of :: < _GLogField > () - 8usize] ; ["Offset of field: _GLogField::key"] [:: std :: mem :: offset_of ! (_GLogField , key) - 0usize] ; ["Offset of field: _GLogField::value"] [:: std :: mem :: offset_of ! (_GLogField , value) - 8usize] ; ["Offset of field: _GLogField::length"] [:: std :: mem :: offset_of ! (_GLogField , length) - 16usize] ; } ; pub type GLogWriterFunc = :: std :: option :: Option < unsafe extern "C" fn (log_level : GLogLevelFlags , fields : * const GLogField , n_fields : gsize , user_data : gpointer) -> GLogWriterOutput > ; unsafe extern "C" { pub fn g_log_structured (log_domain : * const gchar , log_level : GLogLevelFlags , ...) ; } unsafe extern "C" { pub fn g_log_structured_array (log_level : GLogLevelFlags , fields : * const GLogField , n_fields : gsize) ; } unsafe extern "C" { pub fn g_log_variant (log_domain : * const gchar , log_level : GLogLevelFlags , fields : * mut GVariant) ; } unsafe extern "C" { pub fn g_log_set_writer_func (func : GLogWriterFunc , user_data : gpointer , user_data_free : GDestroyNotify) ; } unsafe extern "C" { pub fn g_log_writer_supports_color (output_fd : gint) -> gboolean ; } unsafe extern "C" { pub fn g_log_writer_is_journald (output_fd : gint) -> gboolean ; } unsafe extern "C" { pub fn g_log_writer_format_fields (log_level : GLogLevelFlags , fields : * const GLogField , n_fields : gsize , use_color : gboolean) -> * mut gchar ; } unsafe extern "C" { pub fn g_log_writer_syslog (log_level : GLogLevelFlags , fields : * const GLogField , n_fields : gsize , user_data : gpointer) -> GLogWriterOutput ; } unsafe extern "C" { pub fn g_log_writer_journald (log_level : GLogLevelFlags , fields : * const GLogField , n_fields : gsize , user_data : gpointer) -> GLogWriterOutput ; } unsafe extern "C" { pub fn g_log_writer_standard_streams (log_level : GLogLevelFlags , fields : * const GLogField , n_fields : gsize , user_data : gpointer) -> GLogWriterOutput ; } unsafe extern "C" { pub fn g_log_writer_default (log_level : GLogLevelFlags , fields : * const GLogField , n_fields : gsize , user_data : gpointer) -> GLogWriterOutput ; } unsafe extern "C" { pub fn g_log_writer_default_set_use_stderr (use_stderr : gboolean) ; } unsafe extern "C" { pub fn g_log_writer_default_would_drop (log_level : GLogLevelFlags , log_domain : * const :: std :: os :: raw :: c_char) -> gboolean ; } unsafe extern "C" { pub fn g_log_writer_default_set_debug_domains (domains : * const * const gchar) ; } unsafe extern "C" { pub fn g_log_get_debug_enabled () -> gboolean ; } unsafe extern "C" { pub fn g_log_set_debug_enabled (enabled : gboolean) ; } unsafe extern "C" { pub fn _g_log_fallback_handler (log_domain : * const gchar , log_level : GLogLevelFlags , message : * const gchar , unused_data : gpointer) ; } unsafe extern "C" { pub fn g_return_if_fail_warning (log_domain : * const :: std :: os :: raw :: c_char , pretty_function : * const :: std :: os :: raw :: c_char , expression : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_warn_message (domain : * const :: std :: os :: raw :: c_char , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , func : * const :: std :: os :: raw :: c_char , warnexpr : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_assert_warning (log_domain : * const :: std :: os :: raw :: c_char , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , pretty_function : * const :: std :: os :: raw :: c_char , expression : * const :: std :: os :: raw :: c_char) -> ! ; } unsafe extern "C" { pub fn g_log_structured_standard (log_domain : * const gchar , log_level : GLogLevelFlags , file : * const gchar , line : * const gchar , func : * const gchar , message_format : * const gchar , ...) ; } pub type GPrintFunc = :: std :: option :: Option < unsafe extern "C" fn (string : * const gchar) > ; unsafe extern "C" { pub fn g_print (format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_set_print_handler (func : GPrintFunc) -> GPrintFunc ; } unsafe extern "C" { pub fn g_printerr (format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_set_printerr_handler (func : GPrintFunc) -> GPrintFunc ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GOptionContext { _unused : [u8 ; 0] , } pub type GOptionContext = _GOptionContext ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GOptionGroup { _unused : [u8 ; 0] , } pub type GOptionGroup = _GOptionGroup ; pub type GOptionEntry = _GOptionEntry ; pub const GOptionFlags_G_OPTION_FLAG_NONE : GOptionFlags = 0 ; pub const GOptionFlags_G_OPTION_FLAG_HIDDEN : GOptionFlags = 1 ; pub const GOptionFlags_G_OPTION_FLAG_IN_MAIN : GOptionFlags = 2 ; pub const GOptionFlags_G_OPTION_FLAG_REVERSE : GOptionFlags = 4 ; pub const GOptionFlags_G_OPTION_FLAG_NO_ARG : GOptionFlags = 8 ; pub const GOptionFlags_G_OPTION_FLAG_FILENAME : GOptionFlags = 16 ; pub const GOptionFlags_G_OPTION_FLAG_OPTIONAL_ARG : GOptionFlags = 32 ; pub const GOptionFlags_G_OPTION_FLAG_NOALIAS : GOptionFlags = 64 ; pub const GOptionFlags_G_OPTION_FLAG_DEPRECATED : GOptionFlags = 128 ; pub type GOptionFlags = :: std :: os :: raw :: c_uint ; pub const GOptionArg_G_OPTION_ARG_NONE : GOptionArg = 0 ; pub const GOptionArg_G_OPTION_ARG_STRING : GOptionArg = 1 ; pub const GOptionArg_G_OPTION_ARG_INT : GOptionArg = 2 ; pub const GOptionArg_G_OPTION_ARG_CALLBACK : GOptionArg = 3 ; pub const GOptionArg_G_OPTION_ARG_FILENAME : GOptionArg = 4 ; pub const GOptionArg_G_OPTION_ARG_STRING_ARRAY : GOptionArg = 5 ; pub const GOptionArg_G_OPTION_ARG_FILENAME_ARRAY : GOptionArg = 6 ; pub const GOptionArg_G_OPTION_ARG_DOUBLE : GOptionArg = 7 ; pub const GOptionArg_G_OPTION_ARG_INT64 : GOptionArg = 8 ; pub type GOptionArg = :: std :: os :: raw :: c_uint ; pub type GOptionArgFunc = :: std :: option :: Option < unsafe extern "C" fn (option_name : * const gchar , value : * const gchar , data : gpointer , error : * mut * mut GError) -> gboolean > ; pub type GOptionParseFunc = :: std :: option :: Option < unsafe extern "C" fn (context : * mut GOptionContext , group : * mut GOptionGroup , data : gpointer , error : * mut * mut GError) -> gboolean > ; pub type GOptionErrorFunc = :: std :: option :: Option < unsafe extern "C" fn (context : * mut GOptionContext , group : * mut GOptionGroup , data : gpointer , error : * mut * mut GError) > ; pub const GOptionError_G_OPTION_ERROR_UNKNOWN_OPTION : GOptionError = 0 ; pub const GOptionError_G_OPTION_ERROR_BAD_VALUE : GOptionError = 1 ; pub const GOptionError_G_OPTION_ERROR_FAILED : GOptionError = 2 ; pub type GOptionError = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_option_error_quark () -> GQuark ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GOptionEntry { pub long_name : * const gchar , pub short_name : gchar , pub flags : gint , pub arg : GOptionArg , pub arg_data : gpointer , pub description : * const gchar , pub arg_description : * const gchar , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GOptionEntry"] [:: std :: mem :: size_of :: < _GOptionEntry > () - 48usize] ; ["Alignment of _GOptionEntry"] [:: std :: mem :: align_of :: < _GOptionEntry > () - 8usize] ; ["Offset of field: _GOptionEntry::long_name"] [:: std :: mem :: offset_of ! (_GOptionEntry , long_name) - 0usize] ; ["Offset of field: _GOptionEntry::short_name"] [:: std :: mem :: offset_of ! (_GOptionEntry , short_name) - 8usize] ; ["Offset of field: _GOptionEntry::flags"] [:: std :: mem :: offset_of ! (_GOptionEntry , flags) - 12usize] ; ["Offset of field: _GOptionEntry::arg"] [:: std :: mem :: offset_of ! (_GOptionEntry , arg) - 16usize] ; ["Offset of field: _GOptionEntry::arg_data"] [:: std :: mem :: offset_of ! (_GOptionEntry , arg_data) - 24usize] ; ["Offset of field: _GOptionEntry::description"] [:: std :: mem :: offset_of ! (_GOptionEntry , description) - 32usize] ; ["Offset of field: _GOptionEntry::arg_description"] [:: std :: mem :: offset_of ! (_GOptionEntry , arg_description) - 40usize] ; } ; unsafe extern "C" { pub fn g_option_context_new (parameter_string : * const gchar) -> * mut GOptionContext ; } unsafe extern "C" { pub fn g_option_context_set_summary (context : * mut GOptionContext , summary : * const gchar) ; } unsafe extern "C" { pub fn g_option_context_get_summary (context : * mut GOptionContext) -> * const gchar ; } unsafe extern "C" { pub fn g_option_context_set_description (context : * mut GOptionContext , description : * const gchar) ; } unsafe extern "C" { pub fn g_option_context_get_description (context : * mut GOptionContext) -> * const gchar ; } unsafe extern "C" { pub fn g_option_context_free (context : * mut GOptionContext) ; } unsafe extern "C" { pub fn g_option_context_set_help_enabled (context : * mut GOptionContext , help_enabled : gboolean) ; } unsafe extern "C" { pub fn g_option_context_get_help_enabled (context : * mut GOptionContext) -> gboolean ; } unsafe extern "C" { pub fn g_option_context_set_ignore_unknown_options (context : * mut GOptionContext , ignore_unknown : gboolean) ; } unsafe extern "C" { pub fn g_option_context_get_ignore_unknown_options (context : * mut GOptionContext) -> gboolean ; } unsafe extern "C" { pub fn g_option_context_set_strict_posix (context : * mut GOptionContext , strict_posix : gboolean) ; } unsafe extern "C" { pub fn g_option_context_get_strict_posix (context : * mut GOptionContext) -> gboolean ; } unsafe extern "C" { pub fn g_option_context_add_main_entries (context : * mut GOptionContext , entries : * const GOptionEntry , translation_domain : * const gchar) ; } unsafe extern "C" { pub fn g_option_context_parse (context : * mut GOptionContext , argc : * mut gint , argv : * mut * mut * mut gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_option_context_parse_strv (context : * mut GOptionContext , arguments : * mut * mut * mut gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_option_context_set_translate_func (context : * mut GOptionContext , func : GTranslateFunc , data : gpointer , destroy_notify : GDestroyNotify) ; } unsafe extern "C" { pub fn g_option_context_set_translation_domain (context : * mut GOptionContext , domain : * const gchar) ; } unsafe extern "C" { pub fn g_option_context_add_group (context : * mut GOptionContext , group : * mut GOptionGroup) ; } unsafe extern "C" { pub fn g_option_context_set_main_group (context : * mut GOptionContext , group : * mut GOptionGroup) ; } unsafe extern "C" { pub fn g_option_context_get_main_group (context : * mut GOptionContext) -> * mut GOptionGroup ; } unsafe extern "C" { pub fn g_option_context_get_help (context : * mut GOptionContext , main_help : gboolean , group : * mut GOptionGroup) -> * mut gchar ; } unsafe extern "C" { pub fn g_option_group_new (name : * const gchar , description : * const gchar , help_description : * const gchar , user_data : gpointer , destroy : GDestroyNotify) -> * mut GOptionGroup ; } unsafe extern "C" { pub fn g_option_group_set_parse_hooks (group : * mut GOptionGroup , pre_parse_func : GOptionParseFunc , post_parse_func : GOptionParseFunc) ; } unsafe extern "C" { pub fn g_option_group_set_error_hook (group : * mut GOptionGroup , error_func : GOptionErrorFunc) ; } unsafe extern "C" { pub fn g_option_group_free (group : * mut GOptionGroup) ; } unsafe extern "C" { pub fn g_option_group_ref (group : * mut GOptionGroup) -> * mut GOptionGroup ; } unsafe extern "C" { pub fn g_option_group_unref (group : * mut GOptionGroup) ; } unsafe extern "C" { pub fn g_option_group_add_entries (group : * mut GOptionGroup , entries : * const GOptionEntry) ; } unsafe extern "C" { pub fn g_option_group_set_translate_func (group : * mut GOptionGroup , func : GTranslateFunc , data : gpointer , destroy_notify : GDestroyNotify) ; } unsafe extern "C" { pub fn g_option_group_set_translation_domain (group : * mut GOptionGroup , domain : * const gchar) ; } pub type GPathBuf = _GPathBuf ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPathBuf { pub dummy : [gpointer ; 8usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GPathBuf"] [:: std :: mem :: size_of :: < _GPathBuf > () - 64usize] ; ["Alignment of _GPathBuf"] [:: std :: mem :: align_of :: < _GPathBuf > () - 8usize] ; ["Offset of field: _GPathBuf::dummy"] [:: std :: mem :: offset_of ! (_GPathBuf , dummy) - 0usize] ; } ; unsafe extern "C" { pub fn g_path_buf_new () -> * mut GPathBuf ; } unsafe extern "C" { pub fn g_path_buf_new_from_path (path : * const :: std :: os :: raw :: c_char) -> * mut GPathBuf ; } unsafe extern "C" { pub fn g_path_buf_init (buf : * mut GPathBuf) -> * mut GPathBuf ; } unsafe extern "C" { pub fn g_path_buf_init_from_path (buf : * mut GPathBuf , path : * const :: std :: os :: raw :: c_char) -> * mut GPathBuf ; } unsafe extern "C" { pub fn g_path_buf_clear (buf : * mut GPathBuf) ; } unsafe extern "C" { pub fn g_path_buf_clear_to_path (buf : * mut GPathBuf) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_path_buf_free (buf : * mut GPathBuf) ; } unsafe extern "C" { pub fn g_path_buf_free_to_path (buf : * mut GPathBuf) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_path_buf_copy (buf : * mut GPathBuf) -> * mut GPathBuf ; } unsafe extern "C" { pub fn g_path_buf_push (buf : * mut GPathBuf , path : * const :: std :: os :: raw :: c_char) -> * mut GPathBuf ; } unsafe extern "C" { pub fn g_path_buf_pop (buf : * mut GPathBuf) -> gboolean ; } unsafe extern "C" { pub fn g_path_buf_set_filename (buf : * mut GPathBuf , file_name : * const :: std :: os :: raw :: c_char) -> gboolean ; } unsafe extern "C" { pub fn g_path_buf_set_extension (buf : * mut GPathBuf , extension : * const :: std :: os :: raw :: c_char) -> gboolean ; } unsafe extern "C" { pub fn g_path_buf_to_path (buf : * mut GPathBuf) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_path_buf_equal (v1 : gconstpointer , v2 : gconstpointer) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPatternSpec { _unused : [u8 ; 0] , } pub type GPatternSpec = _GPatternSpec ; unsafe extern "C" { pub fn g_pattern_spec_new (pattern : * const gchar) -> * mut GPatternSpec ; } unsafe extern "C" { pub fn g_pattern_spec_free (pspec : * mut GPatternSpec) ; } unsafe extern "C" { pub fn g_pattern_spec_copy (pspec : * mut GPatternSpec) -> * mut GPatternSpec ; } unsafe extern "C" { pub fn g_pattern_spec_equal (pspec1 : * mut GPatternSpec , pspec2 : * mut GPatternSpec) -> gboolean ; } unsafe extern "C" { pub fn g_pattern_spec_match (pspec : * mut GPatternSpec , string_length : gsize , string : * const gchar , string_reversed : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_pattern_spec_match_string (pspec : * mut GPatternSpec , string : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_pattern_match (pspec : * mut GPatternSpec , string_length : guint , string : * const gchar , string_reversed : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_pattern_match_string (pspec : * mut GPatternSpec , string : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_pattern_match_simple (pattern : * const gchar , string : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_spaced_primes_closest (num : guint) -> guint ; } unsafe extern "C" { pub fn g_qsort_with_data (pbase : gconstpointer , total_elems : gint , size : gsize , compare_func : GCompareDataFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_sort_array (array : * const :: std :: os :: raw :: c_void , n_elements : usize , element_size : usize , compare_func : GCompareDataFunc , user_data : * mut :: std :: os :: raw :: c_void) ; } pub type GQueue = _GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GQueue { pub head : * mut GList , pub tail : * mut GList , pub length : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GQueue"] [:: std :: mem :: size_of :: < _GQueue > () - 24usize] ; ["Alignment of _GQueue"] [:: std :: mem :: align_of :: < _GQueue > () - 8usize] ; ["Offset of field: _GQueue::head"] [:: std :: mem :: offset_of ! (_GQueue , head) - 0usize] ; ["Offset of field: _GQueue::tail"] [:: std :: mem :: offset_of ! (_GQueue , tail) - 8usize] ; ["Offset of field: _GQueue::length"] [:: std :: mem :: offset_of ! (_GQueue , length) - 16usize] ; } ; unsafe extern "C" { pub fn g_queue_new () -> * mut GQueue ; } unsafe extern "C" { pub fn g_queue_free (queue : * mut GQueue) ; } unsafe extern "C" { pub fn g_queue_free_full (queue : * mut GQueue , free_func : GDestroyNotify) ; } unsafe extern "C" { pub fn g_queue_init (queue : * mut GQueue) ; } unsafe extern "C" { pub fn g_queue_clear (queue : * mut GQueue) ; } unsafe extern "C" { pub fn g_queue_is_empty (queue : * mut GQueue) -> gboolean ; } unsafe extern "C" { pub fn g_queue_clear_full (queue : * mut GQueue , free_func : GDestroyNotify) ; } unsafe extern "C" { pub fn g_queue_get_length (queue : * mut GQueue) -> guint ; } unsafe extern "C" { pub fn g_queue_reverse (queue : * mut GQueue) ; } unsafe extern "C" { pub fn g_queue_copy (queue : * mut GQueue) -> * mut GQueue ; } unsafe extern "C" { pub fn g_queue_foreach (queue : * mut GQueue , func : GFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_queue_find (queue : * mut GQueue , data : gconstpointer) -> * mut GList ; } unsafe extern "C" { pub fn g_queue_find_custom (queue : * mut GQueue , data : gconstpointer , func : GCompareFunc) -> * mut GList ; } unsafe extern "C" { pub fn g_queue_sort (queue : * mut GQueue , compare_func : GCompareDataFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_queue_push_head (queue : * mut GQueue , data : gpointer) ; } unsafe extern "C" { pub fn g_queue_push_tail (queue : * mut GQueue , data : gpointer) ; } unsafe extern "C" { pub fn g_queue_push_nth (queue : * mut GQueue , data : gpointer , n : gint) ; } unsafe extern "C" { pub fn g_queue_pop_head (queue : * mut GQueue) -> gpointer ; } unsafe extern "C" { pub fn g_queue_pop_tail (queue : * mut GQueue) -> gpointer ; } unsafe extern "C" { pub fn g_queue_pop_nth (queue : * mut GQueue , n : guint) -> gpointer ; } unsafe extern "C" { pub fn g_queue_peek_head (queue : * mut GQueue) -> gpointer ; } unsafe extern "C" { pub fn g_queue_peek_tail (queue : * mut GQueue) -> gpointer ; } unsafe extern "C" { pub fn g_queue_peek_nth (queue : * mut GQueue , n : guint) -> gpointer ; } unsafe extern "C" { pub fn g_queue_index (queue : * mut GQueue , data : gconstpointer) -> gint ; } unsafe extern "C" { pub fn g_queue_remove (queue : * mut GQueue , data : gconstpointer) -> gboolean ; } unsafe extern "C" { pub fn g_queue_remove_all (queue : * mut GQueue , data : gconstpointer) -> guint ; } unsafe extern "C" { pub fn g_queue_insert_before (queue : * mut GQueue , sibling : * mut GList , data : gpointer) ; } unsafe extern "C" { pub fn g_queue_insert_before_link (queue : * mut GQueue , sibling : * mut GList , link_ : * mut GList) ; } unsafe extern "C" { pub fn g_queue_insert_after (queue : * mut GQueue , sibling : * mut GList , data : gpointer) ; } unsafe extern "C" { pub fn g_queue_insert_after_link (queue : * mut GQueue , sibling : * mut GList , link_ : * mut GList) ; } unsafe extern "C" { pub fn g_queue_insert_sorted (queue : * mut GQueue , data : gpointer , func : GCompareDataFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_queue_push_head_link (queue : * mut GQueue , link_ : * mut GList) ; } unsafe extern "C" { pub fn g_queue_push_tail_link (queue : * mut GQueue , link_ : * mut GList) ; } unsafe extern "C" { pub fn g_queue_push_nth_link (queue : * mut GQueue , n : gint , link_ : * mut GList) ; } unsafe extern "C" { pub fn g_queue_pop_head_link (queue : * mut GQueue) -> * mut GList ; } unsafe extern "C" { pub fn g_queue_pop_tail_link (queue : * mut GQueue) -> * mut GList ; } unsafe extern "C" { pub fn g_queue_pop_nth_link (queue : * mut GQueue , n : guint) -> * mut GList ; } unsafe extern "C" { pub fn g_queue_peek_head_link (queue : * mut GQueue) -> * mut GList ; } unsafe extern "C" { pub fn g_queue_peek_tail_link (queue : * mut GQueue) -> * mut GList ; } unsafe extern "C" { pub fn g_queue_peek_nth_link (queue : * mut GQueue , n : guint) -> * mut GList ; } unsafe extern "C" { pub fn g_queue_link_index (queue : * mut GQueue , link_ : * mut GList) -> gint ; } unsafe extern "C" { pub fn g_queue_unlink (queue : * mut GQueue , link_ : * mut GList) ; } unsafe extern "C" { pub fn g_queue_delete_link (queue : * mut GQueue , link_ : * mut GList) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GRand { _unused : [u8 ; 0] , } pub type GRand = _GRand ; unsafe extern "C" { pub fn g_rand_new_with_seed (seed : guint32) -> * mut GRand ; } unsafe extern "C" { pub fn g_rand_new_with_seed_array (seed : * const guint32 , seed_length : guint) -> * mut GRand ; } unsafe extern "C" { pub fn g_rand_new () -> * mut GRand ; } unsafe extern "C" { pub fn g_rand_free (rand_ : * mut GRand) ; } unsafe extern "C" { pub fn g_rand_copy (rand_ : * mut GRand) -> * mut GRand ; } unsafe extern "C" { pub fn g_rand_set_seed (rand_ : * mut GRand , seed : guint32) ; } unsafe extern "C" { pub fn g_rand_set_seed_array (rand_ : * mut GRand , seed : * const guint32 , seed_length : guint) ; } unsafe extern "C" { pub fn g_rand_int (rand_ : * mut GRand) -> guint32 ; } unsafe extern "C" { pub fn g_rand_int_range (rand_ : * mut GRand , begin : gint32 , end : gint32) -> gint32 ; } unsafe extern "C" { pub fn g_rand_double (rand_ : * mut GRand) -> gdouble ; } unsafe extern "C" { pub fn g_rand_double_range (rand_ : * mut GRand , begin : gdouble , end : gdouble) -> gdouble ; } unsafe extern "C" { pub fn g_random_set_seed (seed : guint32) ; } unsafe extern "C" { pub fn g_random_int () -> guint32 ; } unsafe extern "C" { pub fn g_random_int_range (begin : gint32 , end : gint32) -> gint32 ; } unsafe extern "C" { pub fn g_random_double () -> gdouble ; } unsafe extern "C" { pub fn g_random_double_range (begin : gdouble , end : gdouble) -> gdouble ; } unsafe extern "C" { pub fn g_rc_box_alloc (block_size : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_rc_box_alloc0 (block_size : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_rc_box_dup (block_size : gsize , mem_block : gconstpointer) -> gpointer ; } unsafe extern "C" { pub fn g_rc_box_acquire (mem_block : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_rc_box_release (mem_block : gpointer) ; } unsafe extern "C" { pub fn g_rc_box_release_full (mem_block : gpointer , clear_func : GDestroyNotify) ; } unsafe extern "C" { pub fn g_rc_box_get_size (mem_block : gpointer) -> gsize ; } unsafe extern "C" { pub fn g_atomic_rc_box_alloc (block_size : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_atomic_rc_box_alloc0 (block_size : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_atomic_rc_box_dup (block_size : gsize , mem_block : gconstpointer) -> gpointer ; } unsafe extern "C" { pub fn g_atomic_rc_box_acquire (mem_block : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_atomic_rc_box_release (mem_block : gpointer) ; } unsafe extern "C" { pub fn g_atomic_rc_box_release_full (mem_block : gpointer , clear_func : GDestroyNotify) ; } unsafe extern "C" { pub fn g_atomic_rc_box_get_size (mem_block : gpointer) -> gsize ; } unsafe extern "C" { pub fn g_ref_count_init (rc : * mut grefcount) ; } unsafe extern "C" { pub fn g_ref_count_inc (rc : * mut grefcount) ; } unsafe extern "C" { pub fn g_ref_count_dec (rc : * mut grefcount) -> gboolean ; } unsafe extern "C" { pub fn g_ref_count_compare (rc : * mut grefcount , val : gint) -> gboolean ; } unsafe extern "C" { pub fn g_atomic_ref_count_init (arc : * mut gatomicrefcount) ; } unsafe extern "C" { pub fn g_atomic_ref_count_inc (arc : * mut gatomicrefcount) ; } unsafe extern "C" { pub fn g_atomic_ref_count_dec (arc : * mut gatomicrefcount) -> gboolean ; } unsafe extern "C" { pub fn g_atomic_ref_count_compare (arc : * mut gatomicrefcount , val : gint) -> gboolean ; } unsafe extern "C" { pub fn g_ref_string_new (str_ : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_ref_string_new_len (str_ : * const :: std :: os :: raw :: c_char , len : gssize) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_ref_string_new_intern (str_ : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_ref_string_acquire (str_ : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_ref_string_release (str_ : * mut :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_ref_string_length (str_ : * mut :: std :: os :: raw :: c_char) -> gsize ; } pub type GRefString = :: std :: os :: raw :: c_char ; unsafe extern "C" { pub fn g_ref_string_equal (str1 : * const :: std :: os :: raw :: c_char , str2 : * const :: std :: os :: raw :: c_char) -> gboolean ; } pub const GRegexError_G_REGEX_ERROR_COMPILE : GRegexError = 0 ; pub const GRegexError_G_REGEX_ERROR_OPTIMIZE : GRegexError = 1 ; pub const GRegexError_G_REGEX_ERROR_REPLACE : GRegexError = 2 ; pub const GRegexError_G_REGEX_ERROR_MATCH : GRegexError = 3 ; pub const GRegexError_G_REGEX_ERROR_INTERNAL : GRegexError = 4 ; pub const GRegexError_G_REGEX_ERROR_STRAY_BACKSLASH : GRegexError = 101 ; pub const GRegexError_G_REGEX_ERROR_MISSING_CONTROL_CHAR : GRegexError = 102 ; pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_ESCAPE : GRegexError = 103 ; pub const GRegexError_G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER : GRegexError = 104 ; pub const GRegexError_G_REGEX_ERROR_QUANTIFIER_TOO_BIG : GRegexError = 105 ; pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS : GRegexError = 106 ; pub const GRegexError_G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS : GRegexError = 107 ; pub const GRegexError_G_REGEX_ERROR_RANGE_OUT_OF_ORDER : GRegexError = 108 ; pub const GRegexError_G_REGEX_ERROR_NOTHING_TO_REPEAT : GRegexError = 109 ; pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_CHARACTER : GRegexError = 112 ; pub const GRegexError_G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS : GRegexError = 113 ; pub const GRegexError_G_REGEX_ERROR_UNMATCHED_PARENTHESIS : GRegexError = 114 ; pub const GRegexError_G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE : GRegexError = 115 ; pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_COMMENT : GRegexError = 118 ; pub const GRegexError_G_REGEX_ERROR_EXPRESSION_TOO_LARGE : GRegexError = 120 ; pub const GRegexError_G_REGEX_ERROR_MEMORY_ERROR : GRegexError = 121 ; pub const GRegexError_G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND : GRegexError = 125 ; pub const GRegexError_G_REGEX_ERROR_MALFORMED_CONDITION : GRegexError = 126 ; pub const GRegexError_G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES : GRegexError = 127 ; pub const GRegexError_G_REGEX_ERROR_ASSERTION_EXPECTED : GRegexError = 128 ; pub const GRegexError_G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME : GRegexError = 130 ; pub const GRegexError_G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED : GRegexError = 131 ; pub const GRegexError_G_REGEX_ERROR_HEX_CODE_TOO_LARGE : GRegexError = 134 ; pub const GRegexError_G_REGEX_ERROR_INVALID_CONDITION : GRegexError = 135 ; pub const GRegexError_G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND : GRegexError = 136 ; pub const GRegexError_G_REGEX_ERROR_INFINITE_LOOP : GRegexError = 140 ; pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR : GRegexError = 142 ; pub const GRegexError_G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME : GRegexError = 143 ; pub const GRegexError_G_REGEX_ERROR_MALFORMED_PROPERTY : GRegexError = 146 ; pub const GRegexError_G_REGEX_ERROR_UNKNOWN_PROPERTY : GRegexError = 147 ; pub const GRegexError_G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG : GRegexError = 148 ; pub const GRegexError_G_REGEX_ERROR_TOO_MANY_SUBPATTERNS : GRegexError = 149 ; pub const GRegexError_G_REGEX_ERROR_INVALID_OCTAL_VALUE : GRegexError = 151 ; pub const GRegexError_G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE : GRegexError = 154 ; pub const GRegexError_G_REGEX_ERROR_DEFINE_REPETION : GRegexError = 155 ; pub const GRegexError_G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS : GRegexError = 156 ; pub const GRegexError_G_REGEX_ERROR_MISSING_BACK_REFERENCE : GRegexError = 157 ; pub const GRegexError_G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE : GRegexError = 158 ; pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN : GRegexError = 159 ; pub const GRegexError_G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB : GRegexError = 160 ; pub const GRegexError_G_REGEX_ERROR_NUMBER_TOO_BIG : GRegexError = 161 ; pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME : GRegexError = 162 ; pub const GRegexError_G_REGEX_ERROR_MISSING_DIGIT : GRegexError = 163 ; pub const GRegexError_G_REGEX_ERROR_INVALID_DATA_CHARACTER : GRegexError = 164 ; pub const GRegexError_G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME : GRegexError = 165 ; pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED : GRegexError = 166 ; pub const GRegexError_G_REGEX_ERROR_INVALID_CONTROL_CHAR : GRegexError = 168 ; pub const GRegexError_G_REGEX_ERROR_MISSING_NAME : GRegexError = 169 ; pub const GRegexError_G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS : GRegexError = 171 ; pub const GRegexError_G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES : GRegexError = 172 ; pub const GRegexError_G_REGEX_ERROR_NAME_TOO_LONG : GRegexError = 175 ; pub const GRegexError_G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE : GRegexError = 176 ; pub type GRegexError = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_regex_error_quark () -> GQuark ; } pub const GRegexCompileFlags_G_REGEX_DEFAULT : GRegexCompileFlags = 0 ; pub const GRegexCompileFlags_G_REGEX_CASELESS : GRegexCompileFlags = 1 ; pub const GRegexCompileFlags_G_REGEX_MULTILINE : GRegexCompileFlags = 2 ; pub const GRegexCompileFlags_G_REGEX_DOTALL : GRegexCompileFlags = 4 ; pub const GRegexCompileFlags_G_REGEX_EXTENDED : GRegexCompileFlags = 8 ; pub const GRegexCompileFlags_G_REGEX_ANCHORED : GRegexCompileFlags = 16 ; pub const GRegexCompileFlags_G_REGEX_DOLLAR_ENDONLY : GRegexCompileFlags = 32 ; pub const GRegexCompileFlags_G_REGEX_UNGREEDY : GRegexCompileFlags = 512 ; pub const GRegexCompileFlags_G_REGEX_RAW : GRegexCompileFlags = 2048 ; pub const GRegexCompileFlags_G_REGEX_NO_AUTO_CAPTURE : GRegexCompileFlags = 4096 ; pub const GRegexCompileFlags_G_REGEX_OPTIMIZE : GRegexCompileFlags = 8192 ; pub const GRegexCompileFlags_G_REGEX_FIRSTLINE : GRegexCompileFlags = 262144 ; pub const GRegexCompileFlags_G_REGEX_DUPNAMES : GRegexCompileFlags = 524288 ; pub const GRegexCompileFlags_G_REGEX_NEWLINE_CR : GRegexCompileFlags = 1048576 ; pub const GRegexCompileFlags_G_REGEX_NEWLINE_LF : GRegexCompileFlags = 2097152 ; pub const GRegexCompileFlags_G_REGEX_NEWLINE_CRLF : GRegexCompileFlags = 3145728 ; pub const GRegexCompileFlags_G_REGEX_NEWLINE_ANYCRLF : GRegexCompileFlags = 5242880 ; pub const GRegexCompileFlags_G_REGEX_BSR_ANYCRLF : GRegexCompileFlags = 8388608 ; pub const GRegexCompileFlags_G_REGEX_JAVASCRIPT_COMPAT : GRegexCompileFlags = 33554432 ; pub type GRegexCompileFlags = :: std :: os :: raw :: c_uint ; pub const GRegexMatchFlags_G_REGEX_MATCH_DEFAULT : GRegexMatchFlags = 0 ; pub const GRegexMatchFlags_G_REGEX_MATCH_ANCHORED : GRegexMatchFlags = 16 ; pub const GRegexMatchFlags_G_REGEX_MATCH_NOTBOL : GRegexMatchFlags = 128 ; pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEOL : GRegexMatchFlags = 256 ; pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY : GRegexMatchFlags = 1024 ; pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL : GRegexMatchFlags = 32768 ; pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CR : GRegexMatchFlags = 1048576 ; pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_LF : GRegexMatchFlags = 2097152 ; pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CRLF : GRegexMatchFlags = 3145728 ; pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANY : GRegexMatchFlags = 4194304 ; pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANYCRLF : GRegexMatchFlags = 5242880 ; pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANYCRLF : GRegexMatchFlags = 8388608 ; pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANY : GRegexMatchFlags = 16777216 ; pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_SOFT : GRegexMatchFlags = 32768 ; pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_HARD : GRegexMatchFlags = 134217728 ; pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY_ATSTART : GRegexMatchFlags = 268435456 ; pub type GRegexMatchFlags = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GRegex { _unused : [u8 ; 0] , } pub type GRegex = _GRegex ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMatchInfo { _unused : [u8 ; 0] , } pub type GMatchInfo = _GMatchInfo ; pub type GRegexEvalCallback = :: std :: option :: Option < unsafe extern "C" fn (match_info : * const GMatchInfo , result : * mut GString , user_data : gpointer) -> gboolean > ; unsafe extern "C" { pub fn g_regex_new (pattern : * const gchar , compile_options : GRegexCompileFlags , match_options : GRegexMatchFlags , error : * mut * mut GError) -> * mut GRegex ; } unsafe extern "C" { pub fn g_regex_ref (regex : * mut GRegex) -> * mut GRegex ; } unsafe extern "C" { pub fn g_regex_unref (regex : * mut GRegex) ; } unsafe extern "C" { pub fn g_regex_get_pattern (regex : * const GRegex) -> * const gchar ; } unsafe extern "C" { pub fn g_regex_get_max_backref (regex : * const GRegex) -> gint ; } unsafe extern "C" { pub fn g_regex_get_capture_count (regex : * const GRegex) -> gint ; } unsafe extern "C" { pub fn g_regex_get_has_cr_or_lf (regex : * const GRegex) -> gboolean ; } unsafe extern "C" { pub fn g_regex_get_max_lookbehind (regex : * const GRegex) -> gint ; } unsafe extern "C" { pub fn g_regex_get_string_number (regex : * const GRegex , name : * const gchar) -> gint ; } unsafe extern "C" { pub fn g_regex_escape_string (string : * const gchar , length : gint) -> * mut gchar ; } unsafe extern "C" { pub fn g_regex_escape_nul (string : * const gchar , length : gint) -> * mut gchar ; } unsafe extern "C" { pub fn g_regex_get_compile_flags (regex : * const GRegex) -> GRegexCompileFlags ; } unsafe extern "C" { pub fn g_regex_get_match_flags (regex : * const GRegex) -> GRegexMatchFlags ; } unsafe extern "C" { pub fn g_regex_match_simple (pattern : * const gchar , string : * const gchar , compile_options : GRegexCompileFlags , match_options : GRegexMatchFlags) -> gboolean ; } unsafe extern "C" { pub fn g_regex_match (regex : * const GRegex , string : * const gchar , match_options : GRegexMatchFlags , match_info : * mut * mut GMatchInfo) -> gboolean ; } unsafe extern "C" { pub fn g_regex_match_full (regex : * const GRegex , string : * const gchar , string_len : gssize , start_position : gint , match_options : GRegexMatchFlags , match_info : * mut * mut GMatchInfo , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_regex_match_all (regex : * const GRegex , string : * const gchar , match_options : GRegexMatchFlags , match_info : * mut * mut GMatchInfo) -> gboolean ; } unsafe extern "C" { pub fn g_regex_match_all_full (regex : * const GRegex , string : * const gchar , string_len : gssize , start_position : gint , match_options : GRegexMatchFlags , match_info : * mut * mut GMatchInfo , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_regex_split_simple (pattern : * const gchar , string : * const gchar , compile_options : GRegexCompileFlags , match_options : GRegexMatchFlags) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_regex_split (regex : * const GRegex , string : * const gchar , match_options : GRegexMatchFlags) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_regex_split_full (regex : * const GRegex , string : * const gchar , string_len : gssize , start_position : gint , match_options : GRegexMatchFlags , max_tokens : gint , error : * mut * mut GError) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_regex_replace (regex : * const GRegex , string : * const gchar , string_len : gssize , start_position : gint , replacement : * const gchar , match_options : GRegexMatchFlags , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_regex_replace_literal (regex : * const GRegex , string : * const gchar , string_len : gssize , start_position : gint , replacement : * const gchar , match_options : GRegexMatchFlags , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_regex_replace_eval (regex : * const GRegex , string : * const gchar , string_len : gssize , start_position : gint , match_options : GRegexMatchFlags , eval : GRegexEvalCallback , user_data : gpointer , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_regex_check_replacement (replacement : * const gchar , has_references : * mut gboolean , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_match_info_get_regex (match_info : * const GMatchInfo) -> * mut GRegex ; } unsafe extern "C" { pub fn g_match_info_get_string (match_info : * const GMatchInfo) -> * const gchar ; } unsafe extern "C" { pub fn g_match_info_ref (match_info : * mut GMatchInfo) -> * mut GMatchInfo ; } unsafe extern "C" { pub fn g_match_info_unref (match_info : * mut GMatchInfo) ; } unsafe extern "C" { pub fn g_match_info_free (match_info : * mut GMatchInfo) ; } unsafe extern "C" { pub fn g_match_info_next (match_info : * mut GMatchInfo , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_match_info_matches (match_info : * const GMatchInfo) -> gboolean ; } unsafe extern "C" { pub fn g_match_info_get_match_count (match_info : * const GMatchInfo) -> gint ; } unsafe extern "C" { pub fn g_match_info_is_partial_match (match_info : * const GMatchInfo) -> gboolean ; } unsafe extern "C" { pub fn g_match_info_expand_references (match_info : * const GMatchInfo , string_to_expand : * const gchar , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_match_info_fetch (match_info : * const GMatchInfo , match_num : gint) -> * mut gchar ; } unsafe extern "C" { pub fn g_match_info_fetch_pos (match_info : * const GMatchInfo , match_num : gint , start_pos : * mut gint , end_pos : * mut gint) -> gboolean ; } unsafe extern "C" { pub fn g_match_info_fetch_named (match_info : * const GMatchInfo , name : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_match_info_fetch_named_pos (match_info : * const GMatchInfo , name : * const gchar , start_pos : * mut gint , end_pos : * mut gint) -> gboolean ; } unsafe extern "C" { pub fn g_match_info_fetch_all (match_info : * const GMatchInfo) -> * mut * mut gchar ; } pub type GScanner = _GScanner ; pub type GScannerConfig = _GScannerConfig ; pub type GTokenValue = _GTokenValue ; pub type GScannerMsgFunc = :: std :: option :: Option < unsafe extern "C" fn (scanner : * mut GScanner , message : * mut gchar , error : gboolean) > ; pub const GErrorType_G_ERR_UNKNOWN : GErrorType = 0 ; pub const GErrorType_G_ERR_UNEXP_EOF : GErrorType = 1 ; pub const GErrorType_G_ERR_UNEXP_EOF_IN_STRING : GErrorType = 2 ; pub const GErrorType_G_ERR_UNEXP_EOF_IN_COMMENT : GErrorType = 3 ; pub const GErrorType_G_ERR_NON_DIGIT_IN_CONST : GErrorType = 4 ; pub const GErrorType_G_ERR_DIGIT_RADIX : GErrorType = 5 ; pub const GErrorType_G_ERR_FLOAT_RADIX : GErrorType = 6 ; pub const GErrorType_G_ERR_FLOAT_MALFORMED : GErrorType = 7 ; pub type GErrorType = :: std :: os :: raw :: c_uint ; pub const GTokenType_G_TOKEN_EOF : GTokenType = 0 ; pub const GTokenType_G_TOKEN_LEFT_PAREN : GTokenType = 40 ; pub const GTokenType_G_TOKEN_RIGHT_PAREN : GTokenType = 41 ; pub const GTokenType_G_TOKEN_LEFT_CURLY : GTokenType = 123 ; pub const GTokenType_G_TOKEN_RIGHT_CURLY : GTokenType = 125 ; pub const GTokenType_G_TOKEN_LEFT_BRACE : GTokenType = 91 ; pub const GTokenType_G_TOKEN_RIGHT_BRACE : GTokenType = 93 ; pub const GTokenType_G_TOKEN_EQUAL_SIGN : GTokenType = 61 ; pub const GTokenType_G_TOKEN_COMMA : GTokenType = 44 ; pub const GTokenType_G_TOKEN_NONE : GTokenType = 256 ; pub const GTokenType_G_TOKEN_ERROR : GTokenType = 257 ; pub const GTokenType_G_TOKEN_CHAR : GTokenType = 258 ; pub const GTokenType_G_TOKEN_BINARY : GTokenType = 259 ; pub const GTokenType_G_TOKEN_OCTAL : GTokenType = 260 ; pub const GTokenType_G_TOKEN_INT : GTokenType = 261 ; pub const GTokenType_G_TOKEN_HEX : GTokenType = 262 ; pub const GTokenType_G_TOKEN_FLOAT : GTokenType = 263 ; pub const GTokenType_G_TOKEN_STRING : GTokenType = 264 ; pub const GTokenType_G_TOKEN_SYMBOL : GTokenType = 265 ; pub const GTokenType_G_TOKEN_IDENTIFIER : GTokenType = 266 ; pub const GTokenType_G_TOKEN_IDENTIFIER_NULL : GTokenType = 267 ; pub const GTokenType_G_TOKEN_COMMENT_SINGLE : GTokenType = 268 ; pub const GTokenType_G_TOKEN_COMMENT_MULTI : GTokenType = 269 ; pub const GTokenType_G_TOKEN_LAST : GTokenType = 270 ; pub type GTokenType = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Copy , Clone)] pub union _GTokenValue { pub v_symbol : gpointer , pub v_identifier : * mut gchar , pub v_binary : gulong , pub v_octal : gulong , pub v_int : gulong , pub v_int64 : guint64 , pub v_float : gdouble , pub v_hex : gulong , pub v_string : * mut gchar , pub v_comment : * mut gchar , pub v_char : guchar , pub v_error : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTokenValue"] [:: std :: mem :: size_of :: < _GTokenValue > () - 8usize] ; ["Alignment of _GTokenValue"] [:: std :: mem :: align_of :: < _GTokenValue > () - 8usize] ; ["Offset of field: _GTokenValue::v_symbol"] [:: std :: mem :: offset_of ! (_GTokenValue , v_symbol) - 0usize] ; ["Offset of field: _GTokenValue::v_identifier"] [:: std :: mem :: offset_of ! (_GTokenValue , v_identifier) - 0usize] ; ["Offset of field: _GTokenValue::v_binary"] [:: std :: mem :: offset_of ! (_GTokenValue , v_binary) - 0usize] ; ["Offset of field: _GTokenValue::v_octal"] [:: std :: mem :: offset_of ! (_GTokenValue , v_octal) - 0usize] ; ["Offset of field: _GTokenValue::v_int"] [:: std :: mem :: offset_of ! (_GTokenValue , v_int) - 0usize] ; ["Offset of field: _GTokenValue::v_int64"] [:: std :: mem :: offset_of ! (_GTokenValue , v_int64) - 0usize] ; ["Offset of field: _GTokenValue::v_float"] [:: std :: mem :: offset_of ! (_GTokenValue , v_float) - 0usize] ; ["Offset of field: _GTokenValue::v_hex"] [:: std :: mem :: offset_of ! (_GTokenValue , v_hex) - 0usize] ; ["Offset of field: _GTokenValue::v_string"] [:: std :: mem :: offset_of ! (_GTokenValue , v_string) - 0usize] ; ["Offset of field: _GTokenValue::v_comment"] [:: std :: mem :: offset_of ! (_GTokenValue , v_comment) - 0usize] ; ["Offset of field: _GTokenValue::v_char"] [:: std :: mem :: offset_of ! (_GTokenValue , v_char) - 0usize] ; ["Offset of field: _GTokenValue::v_error"] [:: std :: mem :: offset_of ! (_GTokenValue , v_error) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GScannerConfig { pub cset_skip_characters : * mut gchar , pub cset_identifier_first : * mut gchar , pub cset_identifier_nth : * mut gchar , pub cpair_comment_single : * mut gchar , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 3usize] > , pub padding_dummy : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GScannerConfig"] [:: std :: mem :: size_of :: < _GScannerConfig > () - 40usize] ; ["Alignment of _GScannerConfig"] [:: std :: mem :: align_of :: < _GScannerConfig > () - 8usize] ; ["Offset of field: _GScannerConfig::cset_skip_characters"] [:: std :: mem :: offset_of ! (_GScannerConfig , cset_skip_characters) - 0usize] ; ["Offset of field: _GScannerConfig::cset_identifier_first"] [:: std :: mem :: offset_of ! (_GScannerConfig , cset_identifier_first) - 8usize] ; ["Offset of field: _GScannerConfig::cset_identifier_nth"] [:: std :: mem :: offset_of ! (_GScannerConfig , cset_identifier_nth) - 16usize] ; ["Offset of field: _GScannerConfig::cpair_comment_single"] [:: std :: mem :: offset_of ! (_GScannerConfig , cpair_comment_single) - 24usize] ; ["Offset of field: _GScannerConfig::padding_dummy"] [:: std :: mem :: offset_of ! (_GScannerConfig , padding_dummy) - 36usize] ; } ; impl _GScannerConfig { # [inline] pub fn case_sensitive (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_case_sensitive (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub unsafe fn case_sensitive_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 0usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_case_sensitive_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 0usize , 1u8 , val as u64 ,) } } # [inline] pub fn skip_comment_multi (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_skip_comment_multi (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub unsafe fn skip_comment_multi_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 1usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_skip_comment_multi_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 1usize , 1u8 , val as u64 ,) } } # [inline] pub fn skip_comment_single (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_skip_comment_single (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub unsafe fn skip_comment_single_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 2usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_skip_comment_single_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 2usize , 1u8 , val as u64 ,) } } # [inline] pub fn scan_comment_multi (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (3usize , 1u8) as u32) } } # [inline] pub fn set_scan_comment_multi (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (3usize , 1u8 , val as u64) } } # [inline] pub unsafe fn scan_comment_multi_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 3usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_scan_comment_multi_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 3usize , 1u8 , val as u64 ,) } } # [inline] pub fn scan_identifier (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (4usize , 1u8) as u32) } } # [inline] pub fn set_scan_identifier (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (4usize , 1u8 , val as u64) } } # [inline] pub unsafe fn scan_identifier_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 4usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_scan_identifier_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 4usize , 1u8 , val as u64 ,) } } # [inline] pub fn scan_identifier_1char (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (5usize , 1u8) as u32) } } # [inline] pub fn set_scan_identifier_1char (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (5usize , 1u8 , val as u64) } } # [inline] pub unsafe fn scan_identifier_1char_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 5usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_scan_identifier_1char_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 5usize , 1u8 , val as u64 ,) } } # [inline] pub fn scan_identifier_NULL (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (6usize , 1u8) as u32) } } # [inline] pub fn set_scan_identifier_NULL (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (6usize , 1u8 , val as u64) } } # [inline] pub unsafe fn scan_identifier_NULL_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 6usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_scan_identifier_NULL_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 6usize , 1u8 , val as u64 ,) } } # [inline] pub fn scan_symbols (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (7usize , 1u8) as u32) } } # [inline] pub fn set_scan_symbols (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (7usize , 1u8 , val as u64) } } # [inline] pub unsafe fn scan_symbols_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 7usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_scan_symbols_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 7usize , 1u8 , val as u64 ,) } } # [inline] pub fn scan_binary (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (8usize , 1u8) as u32) } } # [inline] pub fn set_scan_binary (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (8usize , 1u8 , val as u64) } } # [inline] pub unsafe fn scan_binary_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 8usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_scan_binary_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 8usize , 1u8 , val as u64 ,) } } # [inline] pub fn scan_octal (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (9usize , 1u8) as u32) } } # [inline] pub fn set_scan_octal (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (9usize , 1u8 , val as u64) } } # [inline] pub unsafe fn scan_octal_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 9usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_scan_octal_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 9usize , 1u8 , val as u64 ,) } } # [inline] pub fn scan_float (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (10usize , 1u8) as u32) } } # [inline] pub fn set_scan_float (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (10usize , 1u8 , val as u64) } } # [inline] pub unsafe fn scan_float_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 10usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_scan_float_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 10usize , 1u8 , val as u64 ,) } } # [inline] pub fn scan_hex (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (11usize , 1u8) as u32) } } # [inline] pub fn set_scan_hex (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (11usize , 1u8 , val as u64) } } # [inline] pub unsafe fn scan_hex_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 11usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_scan_hex_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 11usize , 1u8 , val as u64 ,) } } # [inline] pub fn scan_hex_dollar (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (12usize , 1u8) as u32) } } # [inline] pub fn set_scan_hex_dollar (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (12usize , 1u8 , val as u64) } } # [inline] pub unsafe fn scan_hex_dollar_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 12usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_scan_hex_dollar_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 12usize , 1u8 , val as u64 ,) } } # [inline] pub fn scan_string_sq (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (13usize , 1u8) as u32) } } # [inline] pub fn set_scan_string_sq (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (13usize , 1u8 , val as u64) } } # [inline] pub unsafe fn scan_string_sq_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 13usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_scan_string_sq_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 13usize , 1u8 , val as u64 ,) } } # [inline] pub fn scan_string_dq (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (14usize , 1u8) as u32) } } # [inline] pub fn set_scan_string_dq (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (14usize , 1u8 , val as u64) } } # [inline] pub unsafe fn scan_string_dq_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 14usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_scan_string_dq_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 14usize , 1u8 , val as u64 ,) } } # [inline] pub fn numbers_2_int (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (15usize , 1u8) as u32) } } # [inline] pub fn set_numbers_2_int (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (15usize , 1u8 , val as u64) } } # [inline] pub unsafe fn numbers_2_int_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 15usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_numbers_2_int_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 15usize , 1u8 , val as u64 ,) } } # [inline] pub fn int_2_float (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (16usize , 1u8) as u32) } } # [inline] pub fn set_int_2_float (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (16usize , 1u8 , val as u64) } } # [inline] pub unsafe fn int_2_float_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 16usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_int_2_float_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 16usize , 1u8 , val as u64 ,) } } # [inline] pub fn identifier_2_string (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (17usize , 1u8) as u32) } } # [inline] pub fn set_identifier_2_string (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (17usize , 1u8 , val as u64) } } # [inline] pub unsafe fn identifier_2_string_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 17usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_identifier_2_string_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 17usize , 1u8 , val as u64 ,) } } # [inline] pub fn char_2_token (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (18usize , 1u8) as u32) } } # [inline] pub fn set_char_2_token (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (18usize , 1u8 , val as u64) } } # [inline] pub unsafe fn char_2_token_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 18usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_char_2_token_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 18usize , 1u8 , val as u64 ,) } } # [inline] pub fn symbol_2_token (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (19usize , 1u8) as u32) } } # [inline] pub fn set_symbol_2_token (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (19usize , 1u8 , val as u64) } } # [inline] pub unsafe fn symbol_2_token_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 19usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_symbol_2_token_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 19usize , 1u8 , val as u64 ,) } } # [inline] pub fn scope_0_fallback (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (20usize , 1u8) as u32) } } # [inline] pub fn set_scope_0_fallback (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (20usize , 1u8 , val as u64) } } # [inline] pub unsafe fn scope_0_fallback_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 20usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_scope_0_fallback_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 20usize , 1u8 , val as u64 ,) } } # [inline] pub fn store_int64 (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (21usize , 1u8) as u32) } } # [inline] pub fn set_store_int64 (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (21usize , 1u8 , val as u64) } } # [inline] pub unsafe fn store_int64_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 21usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_store_int64_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 3usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 21usize , 1u8 , val as u64 ,) } } # [inline] pub fn new_bitfield_1 (case_sensitive : guint , skip_comment_multi : guint , skip_comment_single : guint , scan_comment_multi : guint , scan_identifier : guint , scan_identifier_1char : guint , scan_identifier_NULL : guint , scan_symbols : guint , scan_binary : guint , scan_octal : guint , scan_float : guint , scan_hex : guint , scan_hex_dollar : guint , scan_string_sq : guint , scan_string_dq : guint , numbers_2_int : guint , int_2_float : guint , identifier_2_string : guint , char_2_token : guint , symbol_2_token : guint , scope_0_fallback : guint , store_int64 : guint) -> __BindgenBitfieldUnit < [u8 ; 3usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 3usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let case_sensitive : u32 = unsafe { :: std :: mem :: transmute (case_sensitive) } ; case_sensitive as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let skip_comment_multi : u32 = unsafe { :: std :: mem :: transmute (skip_comment_multi) } ; skip_comment_multi as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let skip_comment_single : u32 = unsafe { :: std :: mem :: transmute (skip_comment_single) } ; skip_comment_single as u64 }) ; __bindgen_bitfield_unit . set (3usize , 1u8 , { let scan_comment_multi : u32 = unsafe { :: std :: mem :: transmute (scan_comment_multi) } ; scan_comment_multi as u64 }) ; __bindgen_bitfield_unit . set (4usize , 1u8 , { let scan_identifier : u32 = unsafe { :: std :: mem :: transmute (scan_identifier) } ; scan_identifier as u64 }) ; __bindgen_bitfield_unit . set (5usize , 1u8 , { let scan_identifier_1char : u32 = unsafe { :: std :: mem :: transmute (scan_identifier_1char) } ; scan_identifier_1char as u64 }) ; __bindgen_bitfield_unit . set (6usize , 1u8 , { let scan_identifier_NULL : u32 = unsafe { :: std :: mem :: transmute (scan_identifier_NULL) } ; scan_identifier_NULL as u64 }) ; __bindgen_bitfield_unit . set (7usize , 1u8 , { let scan_symbols : u32 = unsafe { :: std :: mem :: transmute (scan_symbols) } ; scan_symbols as u64 }) ; __bindgen_bitfield_unit . set (8usize , 1u8 , { let scan_binary : u32 = unsafe { :: std :: mem :: transmute (scan_binary) } ; scan_binary as u64 }) ; __bindgen_bitfield_unit . set (9usize , 1u8 , { let scan_octal : u32 = unsafe { :: std :: mem :: transmute (scan_octal) } ; scan_octal as u64 }) ; __bindgen_bitfield_unit . set (10usize , 1u8 , { let scan_float : u32 = unsafe { :: std :: mem :: transmute (scan_float) } ; scan_float as u64 }) ; __bindgen_bitfield_unit . set (11usize , 1u8 , { let scan_hex : u32 = unsafe { :: std :: mem :: transmute (scan_hex) } ; scan_hex as u64 }) ; __bindgen_bitfield_unit . set (12usize , 1u8 , { let scan_hex_dollar : u32 = unsafe { :: std :: mem :: transmute (scan_hex_dollar) } ; scan_hex_dollar as u64 }) ; __bindgen_bitfield_unit . set (13usize , 1u8 , { let scan_string_sq : u32 = unsafe { :: std :: mem :: transmute (scan_string_sq) } ; scan_string_sq as u64 }) ; __bindgen_bitfield_unit . set (14usize , 1u8 , { let scan_string_dq : u32 = unsafe { :: std :: mem :: transmute (scan_string_dq) } ; scan_string_dq as u64 }) ; __bindgen_bitfield_unit . set (15usize , 1u8 , { let numbers_2_int : u32 = unsafe { :: std :: mem :: transmute (numbers_2_int) } ; numbers_2_int as u64 }) ; __bindgen_bitfield_unit . set (16usize , 1u8 , { let int_2_float : u32 = unsafe { :: std :: mem :: transmute (int_2_float) } ; int_2_float as u64 }) ; __bindgen_bitfield_unit . set (17usize , 1u8 , { let identifier_2_string : u32 = unsafe { :: std :: mem :: transmute (identifier_2_string) } ; identifier_2_string as u64 }) ; __bindgen_bitfield_unit . set (18usize , 1u8 , { let char_2_token : u32 = unsafe { :: std :: mem :: transmute (char_2_token) } ; char_2_token as u64 }) ; __bindgen_bitfield_unit . set (19usize , 1u8 , { let symbol_2_token : u32 = unsafe { :: std :: mem :: transmute (symbol_2_token) } ; symbol_2_token as u64 }) ; __bindgen_bitfield_unit . set (20usize , 1u8 , { let scope_0_fallback : u32 = unsafe { :: std :: mem :: transmute (scope_0_fallback) } ; scope_0_fallback as u64 }) ; __bindgen_bitfield_unit . set (21usize , 1u8 , { let store_int64 : u32 = unsafe { :: std :: mem :: transmute (store_int64) } ; store_int64 as u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Copy , Clone)] pub struct _GScanner { pub user_data : gpointer , pub max_parse_errors : guint , pub parse_errors : guint , pub input_name : * const gchar , pub qdata : * mut GData , pub config : * mut GScannerConfig , pub token : GTokenType , pub value : GTokenValue , pub line : guint , pub position : guint , pub next_token : GTokenType , pub next_value : GTokenValue , pub next_line : guint , pub next_position : guint , pub symbol_table : * mut GHashTable , pub input_fd : gint , pub text : * const gchar , pub text_end : * const gchar , pub buffer : * mut gchar , pub scope_id : guint , pub msg_handler : GScannerMsgFunc , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GScanner"] [:: std :: mem :: size_of :: < _GScanner > () - 144usize] ; ["Alignment of _GScanner"] [:: std :: mem :: align_of :: < _GScanner > () - 8usize] ; ["Offset of field: _GScanner::user_data"] [:: std :: mem :: offset_of ! (_GScanner , user_data) - 0usize] ; ["Offset of field: _GScanner::max_parse_errors"] [:: std :: mem :: offset_of ! (_GScanner , max_parse_errors) - 8usize] ; ["Offset of field: _GScanner::parse_errors"] [:: std :: mem :: offset_of ! (_GScanner , parse_errors) - 12usize] ; ["Offset of field: _GScanner::input_name"] [:: std :: mem :: offset_of ! (_GScanner , input_name) - 16usize] ; ["Offset of field: _GScanner::qdata"] [:: std :: mem :: offset_of ! (_GScanner , qdata) - 24usize] ; ["Offset of field: _GScanner::config"] [:: std :: mem :: offset_of ! (_GScanner , config) - 32usize] ; ["Offset of field: _GScanner::token"] [:: std :: mem :: offset_of ! (_GScanner , token) - 40usize] ; ["Offset of field: _GScanner::value"] [:: std :: mem :: offset_of ! (_GScanner , value) - 48usize] ; ["Offset of field: _GScanner::line"] [:: std :: mem :: offset_of ! (_GScanner , line) - 56usize] ; ["Offset of field: _GScanner::position"] [:: std :: mem :: offset_of ! (_GScanner , position) - 60usize] ; ["Offset of field: _GScanner::next_token"] [:: std :: mem :: offset_of ! (_GScanner , next_token) - 64usize] ; ["Offset of field: _GScanner::next_value"] [:: std :: mem :: offset_of ! (_GScanner , next_value) - 72usize] ; ["Offset of field: _GScanner::next_line"] [:: std :: mem :: offset_of ! (_GScanner , next_line) - 80usize] ; ["Offset of field: _GScanner::next_position"] [:: std :: mem :: offset_of ! (_GScanner , next_position) - 84usize] ; ["Offset of field: _GScanner::symbol_table"] [:: std :: mem :: offset_of ! (_GScanner , symbol_table) - 88usize] ; ["Offset of field: _GScanner::input_fd"] [:: std :: mem :: offset_of ! (_GScanner , input_fd) - 96usize] ; ["Offset of field: _GScanner::text"] [:: std :: mem :: offset_of ! (_GScanner , text) - 104usize] ; ["Offset of field: _GScanner::text_end"] [:: std :: mem :: offset_of ! (_GScanner , text_end) - 112usize] ; ["Offset of field: _GScanner::buffer"] [:: std :: mem :: offset_of ! (_GScanner , buffer) - 120usize] ; ["Offset of field: _GScanner::scope_id"] [:: std :: mem :: offset_of ! (_GScanner , scope_id) - 128usize] ; ["Offset of field: _GScanner::msg_handler"] [:: std :: mem :: offset_of ! (_GScanner , msg_handler) - 136usize] ; } ; unsafe extern "C" { pub fn g_scanner_new (config_templ : * const GScannerConfig) -> * mut GScanner ; } unsafe extern "C" { pub fn g_scanner_destroy (scanner : * mut GScanner) ; } unsafe extern "C" { pub fn g_scanner_input_file (scanner : * mut GScanner , input_fd : gint) ; } unsafe extern "C" { pub fn g_scanner_sync_file_offset (scanner : * mut GScanner) ; } unsafe extern "C" { pub fn g_scanner_input_text (scanner : * mut GScanner , text : * const gchar , text_len : guint) ; } unsafe extern "C" { pub fn g_scanner_get_next_token (scanner : * mut GScanner) -> GTokenType ; } unsafe extern "C" { pub fn g_scanner_peek_next_token (scanner : * mut GScanner) -> GTokenType ; } unsafe extern "C" { pub fn g_scanner_cur_token (scanner : * mut GScanner) -> GTokenType ; } unsafe extern "C" { pub fn g_scanner_cur_value (scanner : * mut GScanner) -> GTokenValue ; } unsafe extern "C" { pub fn g_scanner_cur_line (scanner : * mut GScanner) -> guint ; } unsafe extern "C" { pub fn g_scanner_cur_position (scanner : * mut GScanner) -> guint ; } unsafe extern "C" { pub fn g_scanner_eof (scanner : * mut GScanner) -> gboolean ; } unsafe extern "C" { pub fn g_scanner_set_scope (scanner : * mut GScanner , scope_id : guint) -> guint ; } unsafe extern "C" { pub fn g_scanner_scope_add_symbol (scanner : * mut GScanner , scope_id : guint , symbol : * const gchar , value : gpointer) ; } unsafe extern "C" { pub fn g_scanner_scope_remove_symbol (scanner : * mut GScanner , scope_id : guint , symbol : * const gchar) ; } unsafe extern "C" { pub fn g_scanner_scope_lookup_symbol (scanner : * mut GScanner , scope_id : guint , symbol : * const gchar) -> gpointer ; } unsafe extern "C" { pub fn g_scanner_scope_foreach_symbol (scanner : * mut GScanner , scope_id : guint , func : GHFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_scanner_lookup_symbol (scanner : * mut GScanner , symbol : * const gchar) -> gpointer ; } unsafe extern "C" { pub fn g_scanner_unexp_token (scanner : * mut GScanner , expected_token : GTokenType , identifier_spec : * const gchar , symbol_spec : * const gchar , symbol_name : * const gchar , message : * const gchar , is_error : gint) ; } unsafe extern "C" { pub fn g_scanner_error (scanner : * mut GScanner , format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_scanner_warn (scanner : * mut GScanner , format : * const gchar , ...) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSequence { _unused : [u8 ; 0] , } pub type GSequence = _GSequence ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSequenceNode { _unused : [u8 ; 0] , } pub type GSequenceIter = _GSequenceNode ; pub type GSequenceIterCompareFunc = :: std :: option :: Option < unsafe extern "C" fn (a : * mut GSequenceIter , b : * mut GSequenceIter , data : gpointer) -> gint > ; unsafe extern "C" { pub fn g_sequence_new (data_destroy : GDestroyNotify) -> * mut GSequence ; } unsafe extern "C" { pub fn g_sequence_free (seq : * mut GSequence) ; } unsafe extern "C" { pub fn g_sequence_get_length (seq : * mut GSequence) -> gint ; } unsafe extern "C" { pub fn g_sequence_foreach (seq : * mut GSequence , func : GFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_sequence_foreach_range (begin : * mut GSequenceIter , end : * mut GSequenceIter , func : GFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_sequence_sort (seq : * mut GSequence , cmp_func : GCompareDataFunc , cmp_data : gpointer) ; } unsafe extern "C" { pub fn g_sequence_sort_iter (seq : * mut GSequence , cmp_func : GSequenceIterCompareFunc , cmp_data : gpointer) ; } unsafe extern "C" { pub fn g_sequence_is_empty (seq : * mut GSequence) -> gboolean ; } unsafe extern "C" { pub fn g_sequence_get_begin_iter (seq : * mut GSequence) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_get_end_iter (seq : * mut GSequence) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_get_iter_at_pos (seq : * mut GSequence , pos : gint) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_append (seq : * mut GSequence , data : gpointer) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_prepend (seq : * mut GSequence , data : gpointer) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_insert_before (iter : * mut GSequenceIter , data : gpointer) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_move (src : * mut GSequenceIter , dest : * mut GSequenceIter) ; } unsafe extern "C" { pub fn g_sequence_swap (a : * mut GSequenceIter , b : * mut GSequenceIter) ; } unsafe extern "C" { pub fn g_sequence_insert_sorted (seq : * mut GSequence , data : gpointer , cmp_func : GCompareDataFunc , cmp_data : gpointer) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_insert_sorted_iter (seq : * mut GSequence , data : gpointer , iter_cmp : GSequenceIterCompareFunc , cmp_data : gpointer) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_sort_changed (iter : * mut GSequenceIter , cmp_func : GCompareDataFunc , cmp_data : gpointer) ; } unsafe extern "C" { pub fn g_sequence_sort_changed_iter (iter : * mut GSequenceIter , iter_cmp : GSequenceIterCompareFunc , cmp_data : gpointer) ; } unsafe extern "C" { pub fn g_sequence_remove (iter : * mut GSequenceIter) ; } unsafe extern "C" { pub fn g_sequence_remove_range (begin : * mut GSequenceIter , end : * mut GSequenceIter) ; } unsafe extern "C" { pub fn g_sequence_move_range (dest : * mut GSequenceIter , begin : * mut GSequenceIter , end : * mut GSequenceIter) ; } unsafe extern "C" { pub fn g_sequence_search (seq : * mut GSequence , data : gpointer , cmp_func : GCompareDataFunc , cmp_data : gpointer) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_search_iter (seq : * mut GSequence , data : gpointer , iter_cmp : GSequenceIterCompareFunc , cmp_data : gpointer) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_lookup (seq : * mut GSequence , data : gpointer , cmp_func : GCompareDataFunc , cmp_data : gpointer) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_lookup_iter (seq : * mut GSequence , data : gpointer , iter_cmp : GSequenceIterCompareFunc , cmp_data : gpointer) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_get (iter : * mut GSequenceIter) -> gpointer ; } unsafe extern "C" { pub fn g_sequence_set (iter : * mut GSequenceIter , data : gpointer) ; } unsafe extern "C" { pub fn g_sequence_iter_is_begin (iter : * mut GSequenceIter) -> gboolean ; } unsafe extern "C" { pub fn g_sequence_iter_is_end (iter : * mut GSequenceIter) -> gboolean ; } unsafe extern "C" { pub fn g_sequence_iter_next (iter : * mut GSequenceIter) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_iter_prev (iter : * mut GSequenceIter) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_iter_get_position (iter : * mut GSequenceIter) -> gint ; } unsafe extern "C" { pub fn g_sequence_iter_move (iter : * mut GSequenceIter , delta : gint) -> * mut GSequenceIter ; } unsafe extern "C" { pub fn g_sequence_iter_get_sequence (iter : * mut GSequenceIter) -> * mut GSequence ; } unsafe extern "C" { pub fn g_sequence_iter_compare (a : * mut GSequenceIter , b : * mut GSequenceIter) -> gint ; } unsafe extern "C" { pub fn g_sequence_range_get_midpoint (begin : * mut GSequenceIter , end : * mut GSequenceIter) -> * mut GSequenceIter ; } pub const GShellError_G_SHELL_ERROR_BAD_QUOTING : GShellError = 0 ; pub const GShellError_G_SHELL_ERROR_EMPTY_STRING : GShellError = 1 ; pub const GShellError_G_SHELL_ERROR_FAILED : GShellError = 2 ; pub type GShellError = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_shell_error_quark () -> GQuark ; } unsafe extern "C" { pub fn g_shell_quote (unquoted_string : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_shell_unquote (quoted_string : * const gchar , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_shell_parse_argv (command_line : * const gchar , argcp : * mut gint , argvp : * mut * mut * mut gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_slice_alloc (block_size : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_slice_alloc0 (block_size : gsize) -> gpointer ; } unsafe extern "C" { pub fn g_slice_copy (block_size : gsize , mem_block : gconstpointer) -> gpointer ; } unsafe extern "C" { pub fn g_slice_free1 (block_size : gsize , mem_block : gpointer) ; } unsafe extern "C" { pub fn g_slice_free_chain_with_offset (block_size : gsize , mem_chain : gpointer , next_offset : gsize) ; } pub const GSliceConfig_G_SLICE_CONFIG_ALWAYS_MALLOC : GSliceConfig = 1 ; pub const GSliceConfig_G_SLICE_CONFIG_BYPASS_MAGAZINES : GSliceConfig = 2 ; pub const GSliceConfig_G_SLICE_CONFIG_WORKING_SET_MSECS : GSliceConfig = 3 ; pub const GSliceConfig_G_SLICE_CONFIG_COLOR_INCREMENT : GSliceConfig = 4 ; pub const GSliceConfig_G_SLICE_CONFIG_CHUNK_SIZES : GSliceConfig = 5 ; pub const GSliceConfig_G_SLICE_CONFIG_CONTENTION_COUNTER : GSliceConfig = 6 ; pub type GSliceConfig = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_slice_set_config (ckey : GSliceConfig , value : gint64) ; } unsafe extern "C" { pub fn g_slice_get_config (ckey : GSliceConfig) -> gint64 ; } unsafe extern "C" { pub fn g_slice_get_config_state (ckey : GSliceConfig , address : gint64 , n_values : * mut guint) -> * mut gint64 ; } pub const GSpawnError_G_SPAWN_ERROR_FORK : GSpawnError = 0 ; pub const GSpawnError_G_SPAWN_ERROR_READ : GSpawnError = 1 ; pub const GSpawnError_G_SPAWN_ERROR_CHDIR : GSpawnError = 2 ; pub const GSpawnError_G_SPAWN_ERROR_ACCES : GSpawnError = 3 ; pub const GSpawnError_G_SPAWN_ERROR_PERM : GSpawnError = 4 ; pub const GSpawnError_G_SPAWN_ERROR_TOO_BIG : GSpawnError = 5 ; pub const GSpawnError_G_SPAWN_ERROR_2BIG : GSpawnError = 5 ; pub const GSpawnError_G_SPAWN_ERROR_NOEXEC : GSpawnError = 6 ; pub const GSpawnError_G_SPAWN_ERROR_NAMETOOLONG : GSpawnError = 7 ; pub const GSpawnError_G_SPAWN_ERROR_NOENT : GSpawnError = 8 ; pub const GSpawnError_G_SPAWN_ERROR_NOMEM : GSpawnError = 9 ; pub const GSpawnError_G_SPAWN_ERROR_NOTDIR : GSpawnError = 10 ; pub const GSpawnError_G_SPAWN_ERROR_LOOP : GSpawnError = 11 ; pub const GSpawnError_G_SPAWN_ERROR_TXTBUSY : GSpawnError = 12 ; pub const GSpawnError_G_SPAWN_ERROR_IO : GSpawnError = 13 ; pub const GSpawnError_G_SPAWN_ERROR_NFILE : GSpawnError = 14 ; pub const GSpawnError_G_SPAWN_ERROR_MFILE : GSpawnError = 15 ; pub const GSpawnError_G_SPAWN_ERROR_INVAL : GSpawnError = 16 ; pub const GSpawnError_G_SPAWN_ERROR_ISDIR : GSpawnError = 17 ; pub const GSpawnError_G_SPAWN_ERROR_LIBBAD : GSpawnError = 18 ; pub const GSpawnError_G_SPAWN_ERROR_FAILED : GSpawnError = 19 ; pub type GSpawnError = :: std :: os :: raw :: c_uint ; pub type GSpawnChildSetupFunc = :: std :: option :: Option < unsafe extern "C" fn (data : gpointer) > ; pub const GSpawnFlags_G_SPAWN_DEFAULT : GSpawnFlags = 0 ; pub const GSpawnFlags_G_SPAWN_LEAVE_DESCRIPTORS_OPEN : GSpawnFlags = 1 ; pub const GSpawnFlags_G_SPAWN_DO_NOT_REAP_CHILD : GSpawnFlags = 2 ; pub const GSpawnFlags_G_SPAWN_SEARCH_PATH : GSpawnFlags = 4 ; pub const GSpawnFlags_G_SPAWN_STDOUT_TO_DEV_NULL : GSpawnFlags = 8 ; pub const GSpawnFlags_G_SPAWN_STDERR_TO_DEV_NULL : GSpawnFlags = 16 ; pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDIN : GSpawnFlags = 32 ; pub const GSpawnFlags_G_SPAWN_FILE_AND_ARGV_ZERO : GSpawnFlags = 64 ; pub const GSpawnFlags_G_SPAWN_SEARCH_PATH_FROM_ENVP : GSpawnFlags = 128 ; pub const GSpawnFlags_G_SPAWN_CLOEXEC_PIPES : GSpawnFlags = 256 ; pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDOUT : GSpawnFlags = 512 ; pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDERR : GSpawnFlags = 1024 ; pub const GSpawnFlags_G_SPAWN_STDIN_FROM_DEV_NULL : GSpawnFlags = 2048 ; pub type GSpawnFlags = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_spawn_error_quark () -> GQuark ; } unsafe extern "C" { pub fn g_spawn_exit_error_quark () -> GQuark ; } unsafe extern "C" { pub fn g_spawn_async (working_directory : * const gchar , argv : * mut * mut gchar , envp : * mut * mut gchar , flags : GSpawnFlags , child_setup : GSpawnChildSetupFunc , user_data : gpointer , child_pid : * mut GPid , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_spawn_async_with_pipes (working_directory : * const gchar , argv : * mut * mut gchar , envp : * mut * mut gchar , flags : GSpawnFlags , child_setup : GSpawnChildSetupFunc , user_data : gpointer , child_pid : * mut GPid , standard_input : * mut gint , standard_output : * mut gint , standard_error : * mut gint , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_spawn_async_with_pipes_and_fds (working_directory : * const gchar , argv : * const * const gchar , envp : * const * const gchar , flags : GSpawnFlags , child_setup : GSpawnChildSetupFunc , user_data : gpointer , stdin_fd : gint , stdout_fd : gint , stderr_fd : gint , source_fds : * const gint , target_fds : * const gint , n_fds : gsize , child_pid_out : * mut GPid , stdin_pipe_out : * mut gint , stdout_pipe_out : * mut gint , stderr_pipe_out : * mut gint , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_spawn_async_with_fds (working_directory : * const gchar , argv : * mut * mut gchar , envp : * mut * mut gchar , flags : GSpawnFlags , child_setup : GSpawnChildSetupFunc , user_data : gpointer , child_pid : * mut GPid , stdin_fd : gint , stdout_fd : gint , stderr_fd : gint , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_spawn_sync (working_directory : * const gchar , argv : * mut * mut gchar , envp : * mut * mut gchar , flags : GSpawnFlags , child_setup : GSpawnChildSetupFunc , user_data : gpointer , standard_output : * mut * mut gchar , standard_error : * mut * mut gchar , wait_status : * mut gint , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_spawn_command_line_sync (command_line : * const gchar , standard_output : * mut * mut gchar , standard_error : * mut * mut gchar , wait_status : * mut gint , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_spawn_command_line_async (command_line : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_spawn_check_wait_status (wait_status : gint , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_spawn_check_exit_status (wait_status : gint , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_spawn_close_pid (pid : GPid) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GStringChunk { _unused : [u8 ; 0] , } pub type GStringChunk = _GStringChunk ; unsafe extern "C" { pub fn g_string_chunk_new (size : gsize) -> * mut GStringChunk ; } unsafe extern "C" { pub fn g_string_chunk_free (chunk : * mut GStringChunk) ; } unsafe extern "C" { pub fn g_string_chunk_clear (chunk : * mut GStringChunk) ; } unsafe extern "C" { pub fn g_string_chunk_insert (chunk : * mut GStringChunk , string : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_string_chunk_insert_len (chunk : * mut GStringChunk , string : * const gchar , len : gssize) -> * mut gchar ; } unsafe extern "C" { pub fn g_string_chunk_insert_const (chunk : * mut GStringChunk , string : * const gchar) -> * mut gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GStrvBuilder { _unused : [u8 ; 0] , } pub type GStrvBuilder = _GStrvBuilder ; unsafe extern "C" { pub fn g_strv_builder_new () -> * mut GStrvBuilder ; } unsafe extern "C" { pub fn g_strv_builder_unref (builder : * mut GStrvBuilder) ; } unsafe extern "C" { pub fn g_strv_builder_unref_to_strv (builder : * mut GStrvBuilder) -> GStrv ; } unsafe extern "C" { pub fn g_strv_builder_ref (builder : * mut GStrvBuilder) -> * mut GStrvBuilder ; } unsafe extern "C" { pub fn g_strv_builder_add (builder : * mut GStrvBuilder , value : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_strv_builder_addv (builder : * mut GStrvBuilder , value : * mut * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_strv_builder_add_many (builder : * mut GStrvBuilder , ...) ; } unsafe extern "C" { pub fn g_strv_builder_take (builder : * mut GStrvBuilder , value : * mut :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_strv_builder_end (builder : * mut GStrvBuilder) -> GStrv ; } unsafe extern "C" { pub fn __errno_location () -> * mut :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GTestCase { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GTestSuite { _unused : [u8 ; 0] , } pub type GTestFunc = :: std :: option :: Option < unsafe extern "C" fn () > ; pub type GTestDataFunc = :: std :: option :: Option < unsafe extern "C" fn (user_data : gconstpointer) > ; pub type GTestFixtureFunc = :: std :: option :: Option < unsafe extern "C" fn (fixture : gpointer , user_data : gconstpointer) > ; unsafe extern "C" { pub fn g_strcmp0 (str1 : * const :: std :: os :: raw :: c_char , str2 : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn g_test_minimized_result (minimized_quantity : f64 , format : * const :: std :: os :: raw :: c_char , ...) ; } unsafe extern "C" { pub fn g_test_maximized_result (maximized_quantity : f64 , format : * const :: std :: os :: raw :: c_char , ...) ; } unsafe extern "C" { pub fn g_test_init (argc : * mut :: std :: os :: raw :: c_int , argv : * mut * mut * mut :: std :: os :: raw :: c_char , ...) ; } unsafe extern "C" { pub fn g_test_subprocess () -> gboolean ; } unsafe extern "C" { pub fn g_test_run () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn g_test_add_func (testpath : * const :: std :: os :: raw :: c_char , test_func : GTestFunc) ; } unsafe extern "C" { pub fn g_test_add_data_func (testpath : * const :: std :: os :: raw :: c_char , test_data : gconstpointer , test_func : GTestDataFunc) ; } unsafe extern "C" { pub fn g_test_add_data_func_full (testpath : * const :: std :: os :: raw :: c_char , test_data : gpointer , test_func : GTestDataFunc , data_free_func : GDestroyNotify) ; } unsafe extern "C" { pub fn g_test_get_path () -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_test_fail () ; } unsafe extern "C" { pub fn g_test_fail_printf (format : * const :: std :: os :: raw :: c_char , ...) ; } unsafe extern "C" { pub fn g_test_incomplete (msg : * const gchar) ; } unsafe extern "C" { pub fn g_test_incomplete_printf (format : * const :: std :: os :: raw :: c_char , ...) ; } unsafe extern "C" { pub fn g_test_skip (msg : * const gchar) ; } unsafe extern "C" { pub fn g_test_skip_printf (format : * const :: std :: os :: raw :: c_char , ...) ; } unsafe extern "C" { pub fn g_test_failed () -> gboolean ; } unsafe extern "C" { pub fn g_test_set_nonfatal_assertions () ; } unsafe extern "C" { pub fn g_test_disable_crash_reporting () ; } unsafe extern "C" { pub fn g_test_message (format : * const :: std :: os :: raw :: c_char , ...) ; } unsafe extern "C" { pub fn g_test_bug_base (uri_pattern : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_test_bug (bug_uri_snippet : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_test_summary (summary : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_test_timer_start () ; } unsafe extern "C" { pub fn g_test_timer_elapsed () -> f64 ; } unsafe extern "C" { pub fn g_test_timer_last () -> f64 ; } unsafe extern "C" { pub fn g_test_queue_free (gfree_pointer : gpointer) ; } unsafe extern "C" { pub fn g_test_queue_destroy (destroy_func : GDestroyNotify , destroy_data : gpointer) ; } pub const GTestTrapFlags_G_TEST_TRAP_DEFAULT : GTestTrapFlags = 0 ; pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDOUT : GTestTrapFlags = 128 ; pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDERR : GTestTrapFlags = 256 ; pub const GTestTrapFlags_G_TEST_TRAP_INHERIT_STDIN : GTestTrapFlags = 512 ; pub type GTestTrapFlags = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_test_trap_fork (usec_timeout : guint64 , test_trap_flags : GTestTrapFlags) -> gboolean ; } pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_DEFAULT : GTestSubprocessFlags = 0 ; pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDIN : GTestSubprocessFlags = 1 ; pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDOUT : GTestSubprocessFlags = 2 ; pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDERR : GTestSubprocessFlags = 4 ; pub type GTestSubprocessFlags = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_test_trap_subprocess (test_path : * const :: std :: os :: raw :: c_char , usec_timeout : guint64 , test_flags : GTestSubprocessFlags) ; } unsafe extern "C" { pub fn g_test_trap_subprocess_with_envp (test_path : * const :: std :: os :: raw :: c_char , envp : * const * const :: std :: os :: raw :: c_char , usec_timeout : guint64 , test_flags : GTestSubprocessFlags) ; } unsafe extern "C" { pub fn g_test_trap_has_passed () -> gboolean ; } unsafe extern "C" { pub fn g_test_trap_reached_timeout () -> gboolean ; } unsafe extern "C" { pub fn g_test_rand_int () -> gint32 ; } unsafe extern "C" { pub fn g_test_rand_int_range (begin : gint32 , end : gint32) -> gint32 ; } unsafe extern "C" { pub fn g_test_rand_double () -> f64 ; } unsafe extern "C" { pub fn g_test_rand_double_range (range_start : f64 , range_end : f64) -> f64 ; } unsafe extern "C" { pub fn g_test_create_case (test_name : * const :: std :: os :: raw :: c_char , data_size : gsize , test_data : gconstpointer , data_setup : GTestFixtureFunc , data_test : GTestFixtureFunc , data_teardown : GTestFixtureFunc) -> * mut GTestCase ; } unsafe extern "C" { pub fn g_test_create_suite (suite_name : * const :: std :: os :: raw :: c_char) -> * mut GTestSuite ; } unsafe extern "C" { pub fn g_test_get_root () -> * mut GTestSuite ; } unsafe extern "C" { pub fn g_test_suite_add (suite : * mut GTestSuite , test_case : * mut GTestCase) ; } unsafe extern "C" { pub fn g_test_suite_add_suite (suite : * mut GTestSuite , nestedsuite : * mut GTestSuite) ; } unsafe extern "C" { pub fn g_test_run_suite (suite : * mut GTestSuite) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn g_test_case_free (test_case : * mut GTestCase) ; } unsafe extern "C" { pub fn g_test_suite_free (suite : * mut GTestSuite) ; } unsafe extern "C" { pub fn g_test_trap_assertions (domain : * const :: std :: os :: raw :: c_char , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , func : * const :: std :: os :: raw :: c_char , assertion_flags : guint64 , pattern : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_assertion_message (domain : * const :: std :: os :: raw :: c_char , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , func : * const :: std :: os :: raw :: c_char , message : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_assertion_message_expr (domain : * const :: std :: os :: raw :: c_char , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , func : * const :: std :: os :: raw :: c_char , expr : * const :: std :: os :: raw :: c_char) -> ! ; } unsafe extern "C" { pub fn g_assertion_message_cmpstr (domain : * const :: std :: os :: raw :: c_char , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , func : * const :: std :: os :: raw :: c_char , expr : * const :: std :: os :: raw :: c_char , arg1 : * const :: std :: os :: raw :: c_char , cmp : * const :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_assertion_message_cmpstrv (domain : * const :: std :: os :: raw :: c_char , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , func : * const :: std :: os :: raw :: c_char , expr : * const :: std :: os :: raw :: c_char , arg1 : * const * const :: std :: os :: raw :: c_char , arg2 : * const * const :: std :: os :: raw :: c_char , first_wrong_idx : gsize) ; } unsafe extern "C" { pub fn g_assertion_message_cmpint (domain : * const :: std :: os :: raw :: c_char , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , func : * const :: std :: os :: raw :: c_char , expr : * const :: std :: os :: raw :: c_char , arg1 : guint64 , cmp : * const :: std :: os :: raw :: c_char , arg2 : guint64 , numtype : :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_assertion_message_cmpnum (domain : * const :: std :: os :: raw :: c_char , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , func : * const :: std :: os :: raw :: c_char , expr : * const :: std :: os :: raw :: c_char , arg1 : u128 , cmp : * const :: std :: os :: raw :: c_char , arg2 : u128 , numtype : :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_assertion_message_error (domain : * const :: std :: os :: raw :: c_char , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , func : * const :: std :: os :: raw :: c_char , expr : * const :: std :: os :: raw :: c_char , error : * const GError , error_domain : GQuark , error_code : :: std :: os :: raw :: c_int) ; } unsafe extern "C" { pub fn g_test_add_vtable (testpath : * const :: std :: os :: raw :: c_char , data_size : gsize , test_data : gconstpointer , data_setup : GTestFixtureFunc , data_test : GTestFixtureFunc , data_teardown : GTestFixtureFunc) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GTestConfig { pub test_initialized : gboolean , pub test_quick : gboolean , pub test_perf : gboolean , pub test_verbose : gboolean , pub test_quiet : gboolean , pub test_undefined : gboolean , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of GTestConfig"] [:: std :: mem :: size_of :: < GTestConfig > () - 24usize] ; ["Alignment of GTestConfig"] [:: std :: mem :: align_of :: < GTestConfig > () - 4usize] ; ["Offset of field: GTestConfig::test_initialized"] [:: std :: mem :: offset_of ! (GTestConfig , test_initialized) - 0usize] ; ["Offset of field: GTestConfig::test_quick"] [:: std :: mem :: offset_of ! (GTestConfig , test_quick) - 4usize] ; ["Offset of field: GTestConfig::test_perf"] [:: std :: mem :: offset_of ! (GTestConfig , test_perf) - 8usize] ; ["Offset of field: GTestConfig::test_verbose"] [:: std :: mem :: offset_of ! (GTestConfig , test_verbose) - 12usize] ; ["Offset of field: GTestConfig::test_quiet"] [:: std :: mem :: offset_of ! (GTestConfig , test_quiet) - 16usize] ; ["Offset of field: GTestConfig::test_undefined"] [:: std :: mem :: offset_of ! (GTestConfig , test_undefined) - 20usize] ; } ; unsafe extern "C" { pub static g_test_config_vars : * const GTestConfig ; } pub const GTestResult_G_TEST_RUN_SUCCESS : GTestResult = 0 ; pub const GTestResult_G_TEST_RUN_SKIPPED : GTestResult = 1 ; pub const GTestResult_G_TEST_RUN_FAILURE : GTestResult = 2 ; pub const GTestResult_G_TEST_RUN_INCOMPLETE : GTestResult = 3 ; pub type GTestResult = :: std :: os :: raw :: c_uint ; pub const GTestLogType_G_TEST_LOG_NONE : GTestLogType = 0 ; pub const GTestLogType_G_TEST_LOG_ERROR : GTestLogType = 1 ; pub const GTestLogType_G_TEST_LOG_START_BINARY : GTestLogType = 2 ; pub const GTestLogType_G_TEST_LOG_LIST_CASE : GTestLogType = 3 ; pub const GTestLogType_G_TEST_LOG_SKIP_CASE : GTestLogType = 4 ; pub const GTestLogType_G_TEST_LOG_START_CASE : GTestLogType = 5 ; pub const GTestLogType_G_TEST_LOG_STOP_CASE : GTestLogType = 6 ; pub const GTestLogType_G_TEST_LOG_MIN_RESULT : GTestLogType = 7 ; pub const GTestLogType_G_TEST_LOG_MAX_RESULT : GTestLogType = 8 ; pub const GTestLogType_G_TEST_LOG_MESSAGE : GTestLogType = 9 ; pub const GTestLogType_G_TEST_LOG_START_SUITE : GTestLogType = 10 ; pub const GTestLogType_G_TEST_LOG_STOP_SUITE : GTestLogType = 11 ; pub type GTestLogType = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GTestLogMsg { pub log_type : GTestLogType , pub n_strings : guint , pub strings : * mut * mut gchar , pub n_nums : guint , pub nums : * mut u128 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of GTestLogMsg"] [:: std :: mem :: size_of :: < GTestLogMsg > () - 32usize] ; ["Alignment of GTestLogMsg"] [:: std :: mem :: align_of :: < GTestLogMsg > () - 8usize] ; ["Offset of field: GTestLogMsg::log_type"] [:: std :: mem :: offset_of ! (GTestLogMsg , log_type) - 0usize] ; ["Offset of field: GTestLogMsg::n_strings"] [:: std :: mem :: offset_of ! (GTestLogMsg , n_strings) - 4usize] ; ["Offset of field: GTestLogMsg::strings"] [:: std :: mem :: offset_of ! (GTestLogMsg , strings) - 8usize] ; ["Offset of field: GTestLogMsg::n_nums"] [:: std :: mem :: offset_of ! (GTestLogMsg , n_nums) - 16usize] ; ["Offset of field: GTestLogMsg::nums"] [:: std :: mem :: offset_of ! (GTestLogMsg , nums) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GTestLogBuffer { pub data : * mut GString , pub msgs : * mut GSList , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of GTestLogBuffer"] [:: std :: mem :: size_of :: < GTestLogBuffer > () - 16usize] ; ["Alignment of GTestLogBuffer"] [:: std :: mem :: align_of :: < GTestLogBuffer > () - 8usize] ; ["Offset of field: GTestLogBuffer::data"] [:: std :: mem :: offset_of ! (GTestLogBuffer , data) - 0usize] ; ["Offset of field: GTestLogBuffer::msgs"] [:: std :: mem :: offset_of ! (GTestLogBuffer , msgs) - 8usize] ; } ; unsafe extern "C" { pub fn g_test_log_type_name (log_type : GTestLogType) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_test_log_buffer_new () -> * mut GTestLogBuffer ; } unsafe extern "C" { pub fn g_test_log_buffer_free (tbuffer : * mut GTestLogBuffer) ; } unsafe extern "C" { pub fn g_test_log_buffer_push (tbuffer : * mut GTestLogBuffer , n_bytes : guint , bytes : * const guint8) ; } unsafe extern "C" { pub fn g_test_log_buffer_pop (tbuffer : * mut GTestLogBuffer) -> * mut GTestLogMsg ; } unsafe extern "C" { pub fn g_test_log_msg_free (tmsg : * mut GTestLogMsg) ; } pub type GTestLogFatalFunc = :: std :: option :: Option < unsafe extern "C" fn (log_domain : * const gchar , log_level : GLogLevelFlags , message : * const gchar , user_data : gpointer) -> gboolean > ; unsafe extern "C" { pub fn g_test_log_set_fatal_handler (log_func : GTestLogFatalFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_test_expect_message (log_domain : * const gchar , log_level : GLogLevelFlags , pattern : * const gchar) ; } unsafe extern "C" { pub fn g_test_assert_expected_messages_internal (domain : * const :: std :: os :: raw :: c_char , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , func : * const :: std :: os :: raw :: c_char) ; } pub const GTestFileType_G_TEST_DIST : GTestFileType = 0 ; pub const GTestFileType_G_TEST_BUILT : GTestFileType = 1 ; pub type GTestFileType = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_test_build_filename (file_type : GTestFileType , first_path : * const gchar , ...) -> * mut gchar ; } unsafe extern "C" { pub fn g_test_get_dir (file_type : GTestFileType) -> * const gchar ; } unsafe extern "C" { pub fn g_test_get_filename (file_type : GTestFileType , first_path : * const gchar , ...) -> * const gchar ; } pub type GThreadPool = _GThreadPool ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GThreadPool { pub func : GFunc , pub user_data : gpointer , pub exclusive : gboolean , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GThreadPool"] [:: std :: mem :: size_of :: < _GThreadPool > () - 24usize] ; ["Alignment of _GThreadPool"] [:: std :: mem :: align_of :: < _GThreadPool > () - 8usize] ; ["Offset of field: _GThreadPool::func"] [:: std :: mem :: offset_of ! (_GThreadPool , func) - 0usize] ; ["Offset of field: _GThreadPool::user_data"] [:: std :: mem :: offset_of ! (_GThreadPool , user_data) - 8usize] ; ["Offset of field: _GThreadPool::exclusive"] [:: std :: mem :: offset_of ! (_GThreadPool , exclusive) - 16usize] ; } ; unsafe extern "C" { pub fn g_thread_pool_new (func : GFunc , user_data : gpointer , max_threads : gint , exclusive : gboolean , error : * mut * mut GError) -> * mut GThreadPool ; } unsafe extern "C" { pub fn g_thread_pool_new_full (func : GFunc , user_data : gpointer , item_free_func : GDestroyNotify , max_threads : gint , exclusive : gboolean , error : * mut * mut GError) -> * mut GThreadPool ; } unsafe extern "C" { pub fn g_thread_pool_free (pool : * mut GThreadPool , immediate : gboolean , wait_ : gboolean) ; } unsafe extern "C" { pub fn g_thread_pool_push (pool : * mut GThreadPool , data : gpointer , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_thread_pool_unprocessed (pool : * mut GThreadPool) -> guint ; } unsafe extern "C" { pub fn g_thread_pool_set_sort_function (pool : * mut GThreadPool , func : GCompareDataFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_thread_pool_move_to_front (pool : * mut GThreadPool , data : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_thread_pool_set_max_threads (pool : * mut GThreadPool , max_threads : gint , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_thread_pool_get_max_threads (pool : * mut GThreadPool) -> gint ; } unsafe extern "C" { pub fn g_thread_pool_get_num_threads (pool : * mut GThreadPool) -> guint ; } unsafe extern "C" { pub fn g_thread_pool_set_max_unused_threads (max_threads : gint) ; } unsafe extern "C" { pub fn g_thread_pool_get_max_unused_threads () -> gint ; } unsafe extern "C" { pub fn g_thread_pool_get_num_unused_threads () -> guint ; } unsafe extern "C" { pub fn g_thread_pool_stop_unused_threads () ; } unsafe extern "C" { pub fn g_thread_pool_set_max_idle_time (interval : guint) ; } unsafe extern "C" { pub fn g_thread_pool_get_max_idle_time () -> guint ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTimer { _unused : [u8 ; 0] , } pub type GTimer = _GTimer ; unsafe extern "C" { pub fn g_timer_new () -> * mut GTimer ; } unsafe extern "C" { pub fn g_timer_destroy (timer : * mut GTimer) ; } unsafe extern "C" { pub fn g_timer_start (timer : * mut GTimer) ; } unsafe extern "C" { pub fn g_timer_stop (timer : * mut GTimer) ; } unsafe extern "C" { pub fn g_timer_reset (timer : * mut GTimer) ; } unsafe extern "C" { pub fn g_timer_continue (timer : * mut GTimer) ; } unsafe extern "C" { pub fn g_timer_elapsed (timer : * mut GTimer , microseconds : * mut gulong) -> gdouble ; } unsafe extern "C" { pub fn g_timer_is_active (timer : * mut GTimer) -> gboolean ; } unsafe extern "C" { pub fn g_usleep (microseconds : gulong) ; } unsafe extern "C" { pub fn g_time_val_add (time_ : * mut GTimeVal , microseconds : glong) ; } unsafe extern "C" { pub fn g_time_val_from_iso8601 (iso_date : * const gchar , time_ : * mut GTimeVal) -> gboolean ; } unsafe extern "C" { pub fn g_time_val_to_iso8601 (time_ : * mut GTimeVal) -> * mut gchar ; } pub type GTrashStack = _GTrashStack ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTrashStack { pub next : * mut GTrashStack , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTrashStack"] [:: std :: mem :: size_of :: < _GTrashStack > () - 8usize] ; ["Alignment of _GTrashStack"] [:: std :: mem :: align_of :: < _GTrashStack > () - 8usize] ; ["Offset of field: _GTrashStack::next"] [:: std :: mem :: offset_of ! (_GTrashStack , next) - 0usize] ; } ; unsafe extern "C" { pub fn g_trash_stack_push (stack_p : * mut * mut GTrashStack , data_p : gpointer) ; } unsafe extern "C" { pub fn g_trash_stack_pop (stack_p : * mut * mut GTrashStack) -> gpointer ; } unsafe extern "C" { pub fn g_trash_stack_peek (stack_p : * mut * mut GTrashStack) -> gpointer ; } unsafe extern "C" { pub fn g_trash_stack_height (stack_p : * mut * mut GTrashStack) -> guint ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTree { _unused : [u8 ; 0] , } pub type GTree = _GTree ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTreeNode { _unused : [u8 ; 0] , } pub type GTreeNode = _GTreeNode ; pub type GTraverseFunc = :: std :: option :: Option < unsafe extern "C" fn (key : gpointer , value : gpointer , data : gpointer) -> gboolean > ; pub type GTraverseNodeFunc = :: std :: option :: Option < unsafe extern "C" fn (node : * mut GTreeNode , data : gpointer) -> gboolean > ; unsafe extern "C" { pub fn g_tree_new (key_compare_func : GCompareFunc) -> * mut GTree ; } unsafe extern "C" { pub fn g_tree_new_with_data (key_compare_func : GCompareDataFunc , key_compare_data : gpointer) -> * mut GTree ; } unsafe extern "C" { pub fn g_tree_new_full (key_compare_func : GCompareDataFunc , key_compare_data : gpointer , key_destroy_func : GDestroyNotify , value_destroy_func : GDestroyNotify) -> * mut GTree ; } unsafe extern "C" { pub fn g_tree_node_first (tree : * mut GTree) -> * mut GTreeNode ; } unsafe extern "C" { pub fn g_tree_node_last (tree : * mut GTree) -> * mut GTreeNode ; } unsafe extern "C" { pub fn g_tree_node_previous (node : * mut GTreeNode) -> * mut GTreeNode ; } unsafe extern "C" { pub fn g_tree_node_next (node : * mut GTreeNode) -> * mut GTreeNode ; } unsafe extern "C" { pub fn g_tree_ref (tree : * mut GTree) -> * mut GTree ; } unsafe extern "C" { pub fn g_tree_unref (tree : * mut GTree) ; } unsafe extern "C" { pub fn g_tree_destroy (tree : * mut GTree) ; } unsafe extern "C" { pub fn g_tree_insert_node (tree : * mut GTree , key : gpointer , value : gpointer) -> * mut GTreeNode ; } unsafe extern "C" { pub fn g_tree_insert (tree : * mut GTree , key : gpointer , value : gpointer) ; } unsafe extern "C" { pub fn g_tree_replace_node (tree : * mut GTree , key : gpointer , value : gpointer) -> * mut GTreeNode ; } unsafe extern "C" { pub fn g_tree_replace (tree : * mut GTree , key : gpointer , value : gpointer) ; } unsafe extern "C" { pub fn g_tree_remove (tree : * mut GTree , key : gconstpointer) -> gboolean ; } unsafe extern "C" { pub fn g_tree_remove_all (tree : * mut GTree) ; } unsafe extern "C" { pub fn g_tree_steal (tree : * mut GTree , key : gconstpointer) -> gboolean ; } unsafe extern "C" { pub fn g_tree_node_key (node : * mut GTreeNode) -> gpointer ; } unsafe extern "C" { pub fn g_tree_node_value (node : * mut GTreeNode) -> gpointer ; } unsafe extern "C" { pub fn g_tree_lookup_node (tree : * mut GTree , key : gconstpointer) -> * mut GTreeNode ; } unsafe extern "C" { pub fn g_tree_lookup (tree : * mut GTree , key : gconstpointer) -> gpointer ; } unsafe extern "C" { pub fn g_tree_lookup_extended (tree : * mut GTree , lookup_key : gconstpointer , orig_key : * mut gpointer , value : * mut gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_tree_foreach (tree : * mut GTree , func : GTraverseFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_tree_foreach_node (tree : * mut GTree , func : GTraverseNodeFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_tree_traverse (tree : * mut GTree , traverse_func : GTraverseFunc , traverse_type : GTraverseType , user_data : gpointer) ; } unsafe extern "C" { pub fn g_tree_search_node (tree : * mut GTree , search_func : GCompareFunc , user_data : gconstpointer) -> * mut GTreeNode ; } unsafe extern "C" { pub fn g_tree_search (tree : * mut GTree , search_func : GCompareFunc , user_data : gconstpointer) -> gpointer ; } unsafe extern "C" { pub fn g_tree_lower_bound (tree : * mut GTree , key : gconstpointer) -> * mut GTreeNode ; } unsafe extern "C" { pub fn g_tree_upper_bound (tree : * mut GTree , key : gconstpointer) -> * mut GTreeNode ; } unsafe extern "C" { pub fn g_tree_height (tree : * mut GTree) -> gint ; } unsafe extern "C" { pub fn g_tree_nnodes (tree : * mut GTree) -> gint ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GUri { _unused : [u8 ; 0] , } pub type GUri = _GUri ; unsafe extern "C" { pub fn g_uri_ref (uri : * mut GUri) -> * mut GUri ; } unsafe extern "C" { pub fn g_uri_unref (uri : * mut GUri) ; } pub const GUriFlags_G_URI_FLAGS_NONE : GUriFlags = 0 ; pub const GUriFlags_G_URI_FLAGS_PARSE_RELAXED : GUriFlags = 1 ; pub const GUriFlags_G_URI_FLAGS_HAS_PASSWORD : GUriFlags = 2 ; pub const GUriFlags_G_URI_FLAGS_HAS_AUTH_PARAMS : GUriFlags = 4 ; pub const GUriFlags_G_URI_FLAGS_ENCODED : GUriFlags = 8 ; pub const GUriFlags_G_URI_FLAGS_NON_DNS : GUriFlags = 16 ; pub const GUriFlags_G_URI_FLAGS_ENCODED_QUERY : GUriFlags = 32 ; pub const GUriFlags_G_URI_FLAGS_ENCODED_PATH : GUriFlags = 64 ; pub const GUriFlags_G_URI_FLAGS_ENCODED_FRAGMENT : GUriFlags = 128 ; pub const GUriFlags_G_URI_FLAGS_SCHEME_NORMALIZE : GUriFlags = 256 ; pub type GUriFlags = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_uri_split (uri_ref : * const gchar , flags : GUriFlags , scheme : * mut * mut gchar , userinfo : * mut * mut gchar , host : * mut * mut gchar , port : * mut gint , path : * mut * mut gchar , query : * mut * mut gchar , fragment : * mut * mut gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_uri_split_with_user (uri_ref : * const gchar , flags : GUriFlags , scheme : * mut * mut gchar , user : * mut * mut gchar , password : * mut * mut gchar , auth_params : * mut * mut gchar , host : * mut * mut gchar , port : * mut gint , path : * mut * mut gchar , query : * mut * mut gchar , fragment : * mut * mut gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_uri_split_network (uri_string : * const gchar , flags : GUriFlags , scheme : * mut * mut gchar , host : * mut * mut gchar , port : * mut gint , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_uri_is_valid (uri_string : * const gchar , flags : GUriFlags , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_uri_join (flags : GUriFlags , scheme : * const gchar , userinfo : * const gchar , host : * const gchar , port : gint , path : * const gchar , query : * const gchar , fragment : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_uri_join_with_user (flags : GUriFlags , scheme : * const gchar , user : * const gchar , password : * const gchar , auth_params : * const gchar , host : * const gchar , port : gint , path : * const gchar , query : * const gchar , fragment : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_uri_parse (uri_string : * const gchar , flags : GUriFlags , error : * mut * mut GError) -> * mut GUri ; } unsafe extern "C" { pub fn g_uri_parse_relative (base_uri : * mut GUri , uri_ref : * const gchar , flags : GUriFlags , error : * mut * mut GError) -> * mut GUri ; } unsafe extern "C" { pub fn g_uri_resolve_relative (base_uri_string : * const gchar , uri_ref : * const gchar , flags : GUriFlags , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_uri_build (flags : GUriFlags , scheme : * const gchar , userinfo : * const gchar , host : * const gchar , port : gint , path : * const gchar , query : * const gchar , fragment : * const gchar) -> * mut GUri ; } unsafe extern "C" { pub fn g_uri_build_with_user (flags : GUriFlags , scheme : * const gchar , user : * const gchar , password : * const gchar , auth_params : * const gchar , host : * const gchar , port : gint , path : * const gchar , query : * const gchar , fragment : * const gchar) -> * mut GUri ; } pub const GUriHideFlags_G_URI_HIDE_NONE : GUriHideFlags = 0 ; pub const GUriHideFlags_G_URI_HIDE_USERINFO : GUriHideFlags = 1 ; pub const GUriHideFlags_G_URI_HIDE_PASSWORD : GUriHideFlags = 2 ; pub const GUriHideFlags_G_URI_HIDE_AUTH_PARAMS : GUriHideFlags = 4 ; pub const GUriHideFlags_G_URI_HIDE_QUERY : GUriHideFlags = 8 ; pub const GUriHideFlags_G_URI_HIDE_FRAGMENT : GUriHideFlags = 16 ; pub type GUriHideFlags = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_uri_to_string (uri : * mut GUri) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_uri_to_string_partial (uri : * mut GUri , flags : GUriHideFlags) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_uri_get_scheme (uri : * mut GUri) -> * const gchar ; } unsafe extern "C" { pub fn g_uri_get_userinfo (uri : * mut GUri) -> * const gchar ; } unsafe extern "C" { pub fn g_uri_get_user (uri : * mut GUri) -> * const gchar ; } unsafe extern "C" { pub fn g_uri_get_password (uri : * mut GUri) -> * const gchar ; } unsafe extern "C" { pub fn g_uri_get_auth_params (uri : * mut GUri) -> * const gchar ; } unsafe extern "C" { pub fn g_uri_get_host (uri : * mut GUri) -> * const gchar ; } unsafe extern "C" { pub fn g_uri_get_port (uri : * mut GUri) -> gint ; } unsafe extern "C" { pub fn g_uri_get_path (uri : * mut GUri) -> * const gchar ; } unsafe extern "C" { pub fn g_uri_get_query (uri : * mut GUri) -> * const gchar ; } unsafe extern "C" { pub fn g_uri_get_fragment (uri : * mut GUri) -> * const gchar ; } unsafe extern "C" { pub fn g_uri_get_flags (uri : * mut GUri) -> GUriFlags ; } pub const GUriParamsFlags_G_URI_PARAMS_NONE : GUriParamsFlags = 0 ; pub const GUriParamsFlags_G_URI_PARAMS_CASE_INSENSITIVE : GUriParamsFlags = 1 ; pub const GUriParamsFlags_G_URI_PARAMS_WWW_FORM : GUriParamsFlags = 2 ; pub const GUriParamsFlags_G_URI_PARAMS_PARSE_RELAXED : GUriParamsFlags = 4 ; pub type GUriParamsFlags = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_uri_parse_params (params : * const gchar , length : gssize , separators : * const gchar , flags : GUriParamsFlags , error : * mut * mut GError) -> * mut GHashTable ; } pub type GUriParamsIter = _GUriParamsIter ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GUriParamsIter { pub dummy0 : gint , pub dummy1 : gpointer , pub dummy2 : gpointer , pub dummy3 : [guint8 ; 256usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GUriParamsIter"] [:: std :: mem :: size_of :: < _GUriParamsIter > () - 280usize] ; ["Alignment of _GUriParamsIter"] [:: std :: mem :: align_of :: < _GUriParamsIter > () - 8usize] ; ["Offset of field: _GUriParamsIter::dummy0"] [:: std :: mem :: offset_of ! (_GUriParamsIter , dummy0) - 0usize] ; ["Offset of field: _GUriParamsIter::dummy1"] [:: std :: mem :: offset_of ! (_GUriParamsIter , dummy1) - 8usize] ; ["Offset of field: _GUriParamsIter::dummy2"] [:: std :: mem :: offset_of ! (_GUriParamsIter , dummy2) - 16usize] ; ["Offset of field: _GUriParamsIter::dummy3"] [:: std :: mem :: offset_of ! (_GUriParamsIter , dummy3) - 24usize] ; } ; unsafe extern "C" { pub fn g_uri_params_iter_init (iter : * mut GUriParamsIter , params : * const gchar , length : gssize , separators : * const gchar , flags : GUriParamsFlags) ; } unsafe extern "C" { pub fn g_uri_params_iter_next (iter : * mut GUriParamsIter , attribute : * mut * mut gchar , value : * mut * mut gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_uri_error_quark () -> GQuark ; } pub const GUriError_G_URI_ERROR_FAILED : GUriError = 0 ; pub const GUriError_G_URI_ERROR_BAD_SCHEME : GUriError = 1 ; pub const GUriError_G_URI_ERROR_BAD_USER : GUriError = 2 ; pub const GUriError_G_URI_ERROR_BAD_PASSWORD : GUriError = 3 ; pub const GUriError_G_URI_ERROR_BAD_AUTH_PARAMS : GUriError = 4 ; pub const GUriError_G_URI_ERROR_BAD_HOST : GUriError = 5 ; pub const GUriError_G_URI_ERROR_BAD_PORT : GUriError = 6 ; pub const GUriError_G_URI_ERROR_BAD_PATH : GUriError = 7 ; pub const GUriError_G_URI_ERROR_BAD_QUERY : GUriError = 8 ; pub const GUriError_G_URI_ERROR_BAD_FRAGMENT : GUriError = 9 ; pub type GUriError = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_uri_unescape_string (escaped_string : * const :: std :: os :: raw :: c_char , illegal_characters : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_uri_unescape_segment (escaped_string : * const :: std :: os :: raw :: c_char , escaped_string_end : * const :: std :: os :: raw :: c_char , illegal_characters : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_uri_parse_scheme (uri : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_uri_peek_scheme (uri : * const :: std :: os :: raw :: c_char) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_uri_escape_string (unescaped : * const :: std :: os :: raw :: c_char , reserved_chars_allowed : * const :: std :: os :: raw :: c_char , allow_utf8 : gboolean) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_uri_unescape_bytes (escaped_string : * const :: std :: os :: raw :: c_char , length : gssize , illegal_characters : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> * mut GBytes ; } unsafe extern "C" { pub fn g_uri_escape_bytes (unescaped : * const guint8 , length : gsize , reserved_chars_allowed : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_uuid_string_is_valid (str_ : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_uuid_string_random () -> * mut gchar ; } unsafe extern "C" { pub static glib_major_version : guint ; } unsafe extern "C" { pub static glib_minor_version : guint ; } unsafe extern "C" { pub static glib_micro_version : guint ; } unsafe extern "C" { pub static glib_interface_age : guint ; } unsafe extern "C" { pub static glib_binary_age : guint ; } unsafe extern "C" { pub fn glib_check_version (required_major : guint , required_minor : guint , required_micro : guint) -> * const gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GAllocator { _unused : [u8 ; 0] , } pub type GAllocator = _GAllocator ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMemChunk { _unused : [u8 ; 0] , } pub type GMemChunk = _GMemChunk ; unsafe extern "C" { pub fn g_mem_chunk_new (name : * const gchar , atom_size : gint , area_size : gsize , type_ : gint) -> * mut GMemChunk ; } unsafe extern "C" { pub fn g_mem_chunk_destroy (mem_chunk : * mut GMemChunk) ; } unsafe extern "C" { pub fn g_mem_chunk_alloc (mem_chunk : * mut GMemChunk) -> gpointer ; } unsafe extern "C" { pub fn g_mem_chunk_alloc0 (mem_chunk : * mut GMemChunk) -> gpointer ; } unsafe extern "C" { pub fn g_mem_chunk_free (mem_chunk : * mut GMemChunk , mem : gpointer) ; } unsafe extern "C" { pub fn g_mem_chunk_clean (mem_chunk : * mut GMemChunk) ; } unsafe extern "C" { pub fn g_mem_chunk_reset (mem_chunk : * mut GMemChunk) ; } unsafe extern "C" { pub fn g_mem_chunk_print (mem_chunk : * mut GMemChunk) ; } unsafe extern "C" { pub fn g_mem_chunk_info () ; } unsafe extern "C" { pub fn g_blow_chunks () ; } unsafe extern "C" { pub fn g_allocator_new (name : * const gchar , n_preallocs : guint) -> * mut GAllocator ; } unsafe extern "C" { pub fn g_allocator_free (allocator : * mut GAllocator) ; } unsafe extern "C" { pub fn g_list_push_allocator (allocator : * mut GAllocator) ; } unsafe extern "C" { pub fn g_list_pop_allocator () ; } unsafe extern "C" { pub fn g_slist_push_allocator (allocator : * mut GAllocator) ; } unsafe extern "C" { pub fn g_slist_pop_allocator () ; } unsafe extern "C" { pub fn g_node_push_allocator (allocator : * mut GAllocator) ; } unsafe extern "C" { pub fn g_node_pop_allocator () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GCache { _unused : [u8 ; 0] , } pub type GCache = _GCache ; pub type GCacheNewFunc = :: std :: option :: Option < unsafe extern "C" fn (key : gpointer) -> gpointer > ; pub type GCacheDupFunc = :: std :: option :: Option < unsafe extern "C" fn (value : gpointer) -> gpointer > ; pub type GCacheDestroyFunc = :: std :: option :: Option < unsafe extern "C" fn (value : gpointer) > ; unsafe extern "C" { pub fn g_cache_new (value_new_func : GCacheNewFunc , value_destroy_func : GCacheDestroyFunc , key_dup_func : GCacheDupFunc , key_destroy_func : GCacheDestroyFunc , hash_key_func : GHashFunc , hash_value_func : GHashFunc , key_equal_func : GEqualFunc) -> * mut GCache ; } unsafe extern "C" { pub fn g_cache_destroy (cache : * mut GCache) ; } unsafe extern "C" { pub fn g_cache_insert (cache : * mut GCache , key : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_cache_remove (cache : * mut GCache , value : gconstpointer) ; } unsafe extern "C" { pub fn g_cache_key_foreach (cache : * mut GCache , func : GHFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_cache_value_foreach (cache : * mut GCache , func : GHFunc , user_data : gpointer) ; } pub type GCompletion = _GCompletion ; pub type GCompletionFunc = :: std :: option :: Option < unsafe extern "C" fn (item : gpointer) -> * mut gchar > ; pub type GCompletionStrncmpFunc = :: std :: option :: Option < unsafe extern "C" fn (s1 : * const gchar , s2 : * const gchar , n : gsize) -> gint > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GCompletion { pub items : * mut GList , pub func : GCompletionFunc , pub prefix : * mut gchar , pub cache : * mut GList , pub strncmp_func : GCompletionStrncmpFunc , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GCompletion"] [:: std :: mem :: size_of :: < _GCompletion > () - 40usize] ; ["Alignment of _GCompletion"] [:: std :: mem :: align_of :: < _GCompletion > () - 8usize] ; ["Offset of field: _GCompletion::items"] [:: std :: mem :: offset_of ! (_GCompletion , items) - 0usize] ; ["Offset of field: _GCompletion::func"] [:: std :: mem :: offset_of ! (_GCompletion , func) - 8usize] ; ["Offset of field: _GCompletion::prefix"] [:: std :: mem :: offset_of ! (_GCompletion , prefix) - 16usize] ; ["Offset of field: _GCompletion::cache"] [:: std :: mem :: offset_of ! (_GCompletion , cache) - 24usize] ; ["Offset of field: _GCompletion::strncmp_func"] [:: std :: mem :: offset_of ! (_GCompletion , strncmp_func) - 32usize] ; } ; unsafe extern "C" { pub fn g_completion_new (func : GCompletionFunc) -> * mut GCompletion ; } unsafe extern "C" { pub fn g_completion_add_items (cmp : * mut GCompletion , items : * mut GList) ; } unsafe extern "C" { pub fn g_completion_remove_items (cmp : * mut GCompletion , items : * mut GList) ; } unsafe extern "C" { pub fn g_completion_clear_items (cmp : * mut GCompletion) ; } unsafe extern "C" { pub fn g_completion_complete (cmp : * mut GCompletion , prefix : * const gchar , new_prefix : * mut * mut gchar) -> * mut GList ; } unsafe extern "C" { pub fn g_completion_complete_utf8 (cmp : * mut GCompletion , prefix : * const gchar , new_prefix : * mut * mut gchar) -> * mut GList ; } unsafe extern "C" { pub fn g_completion_set_compare (cmp : * mut GCompletion , strncmp_func : GCompletionStrncmpFunc) ; } unsafe extern "C" { pub fn g_completion_free (cmp : * mut GCompletion) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GRelation { _unused : [u8 ; 0] , } pub type GRelation = _GRelation ; pub type GTuples = _GTuples ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTuples { pub len : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTuples"] [:: std :: mem :: size_of :: < _GTuples > () - 4usize] ; ["Alignment of _GTuples"] [:: std :: mem :: align_of :: < _GTuples > () - 4usize] ; ["Offset of field: _GTuples::len"] [:: std :: mem :: offset_of ! (_GTuples , len) - 0usize] ; } ; unsafe extern "C" { pub fn g_relation_new (fields : gint) -> * mut GRelation ; } unsafe extern "C" { pub fn g_relation_destroy (relation : * mut GRelation) ; } unsafe extern "C" { pub fn g_relation_index (relation : * mut GRelation , field : gint , hash_func : GHashFunc , key_equal_func : GEqualFunc) ; } unsafe extern "C" { pub fn g_relation_insert (relation : * mut GRelation , ...) ; } unsafe extern "C" { pub fn g_relation_delete (relation : * mut GRelation , key : gconstpointer , field : gint) -> gint ; } unsafe extern "C" { pub fn g_relation_select (relation : * mut GRelation , key : gconstpointer , field : gint) -> * mut GTuples ; } unsafe extern "C" { pub fn g_relation_count (relation : * mut GRelation , key : gconstpointer , field : gint) -> gint ; } unsafe extern "C" { pub fn g_relation_exists (relation : * mut GRelation , ...) -> gboolean ; } unsafe extern "C" { pub fn g_relation_print (relation : * mut GRelation) ; } unsafe extern "C" { pub fn g_tuples_destroy (tuples : * mut GTuples) ; } unsafe extern "C" { pub fn g_tuples_index (tuples : * mut GTuples , index_ : gint , field : gint) -> gpointer ; } pub const GThreadPriority_G_THREAD_PRIORITY_LOW : GThreadPriority = 0 ; pub const GThreadPriority_G_THREAD_PRIORITY_NORMAL : GThreadPriority = 1 ; pub const GThreadPriority_G_THREAD_PRIORITY_HIGH : GThreadPriority = 2 ; pub const GThreadPriority_G_THREAD_PRIORITY_URGENT : GThreadPriority = 3 ; pub type GThreadPriority = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GThread { pub func : GThreadFunc , pub data : gpointer , pub joinable : gboolean , pub priority : GThreadPriority , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GThread"] [:: std :: mem :: size_of :: < _GThread > () - 24usize] ; ["Alignment of _GThread"] [:: std :: mem :: align_of :: < _GThread > () - 8usize] ; ["Offset of field: _GThread::func"] [:: std :: mem :: offset_of ! (_GThread , func) - 0usize] ; ["Offset of field: _GThread::data"] [:: std :: mem :: offset_of ! (_GThread , data) - 8usize] ; ["Offset of field: _GThread::joinable"] [:: std :: mem :: offset_of ! (_GThread , joinable) - 16usize] ; ["Offset of field: _GThread::priority"] [:: std :: mem :: offset_of ! (_GThread , priority) - 20usize] ; } ; pub type GThreadFunctions = _GThreadFunctions ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GThreadFunctions { pub mutex_new : :: std :: option :: Option < unsafe extern "C" fn () -> * mut GMutex > , pub mutex_lock : :: std :: option :: Option < unsafe extern "C" fn (mutex : * mut GMutex) > , pub mutex_trylock : :: std :: option :: Option < unsafe extern "C" fn (mutex : * mut GMutex) -> gboolean > , pub mutex_unlock : :: std :: option :: Option < unsafe extern "C" fn (mutex : * mut GMutex) > , pub mutex_free : :: std :: option :: Option < unsafe extern "C" fn (mutex : * mut GMutex) > , pub cond_new : :: std :: option :: Option < unsafe extern "C" fn () -> * mut GCond > , pub cond_signal : :: std :: option :: Option < unsafe extern "C" fn (cond : * mut GCond) > , pub cond_broadcast : :: std :: option :: Option < unsafe extern "C" fn (cond : * mut GCond) > , pub cond_wait : :: std :: option :: Option < unsafe extern "C" fn (cond : * mut GCond , mutex : * mut GMutex) > , pub cond_timed_wait : :: std :: option :: Option < unsafe extern "C" fn (cond : * mut GCond , mutex : * mut GMutex , end_time : * mut GTimeVal) -> gboolean > , pub cond_free : :: std :: option :: Option < unsafe extern "C" fn (cond : * mut GCond) > , pub private_new : :: std :: option :: Option < unsafe extern "C" fn (destructor : GDestroyNotify) -> * mut GPrivate > , pub private_get : :: std :: option :: Option < unsafe extern "C" fn (private_key : * mut GPrivate) -> gpointer > , pub private_set : :: std :: option :: Option < unsafe extern "C" fn (private_key : * mut GPrivate , data : gpointer) > , pub thread_create : :: std :: option :: Option < unsafe extern "C" fn (func : GThreadFunc , data : gpointer , stack_size : gulong , joinable : gboolean , bound : gboolean , priority : GThreadPriority , thread : gpointer , error : * mut * mut GError) > , pub thread_yield : :: std :: option :: Option < unsafe extern "C" fn () > , pub thread_join : :: std :: option :: Option < unsafe extern "C" fn (thread : gpointer) > , pub thread_exit : :: std :: option :: Option < unsafe extern "C" fn () > , pub thread_set_priority : :: std :: option :: Option < unsafe extern "C" fn (thread : gpointer , priority : GThreadPriority) > , pub thread_self : :: std :: option :: Option < unsafe extern "C" fn (thread : gpointer) > , pub thread_equal : :: std :: option :: Option < unsafe extern "C" fn (thread1 : gpointer , thread2 : gpointer) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GThreadFunctions"] [:: std :: mem :: size_of :: < _GThreadFunctions > () - 168usize] ; ["Alignment of _GThreadFunctions"] [:: std :: mem :: align_of :: < _GThreadFunctions > () - 8usize] ; ["Offset of field: _GThreadFunctions::mutex_new"] [:: std :: mem :: offset_of ! (_GThreadFunctions , mutex_new) - 0usize] ; ["Offset of field: _GThreadFunctions::mutex_lock"] [:: std :: mem :: offset_of ! (_GThreadFunctions , mutex_lock) - 8usize] ; ["Offset of field: _GThreadFunctions::mutex_trylock"] [:: std :: mem :: offset_of ! (_GThreadFunctions , mutex_trylock) - 16usize] ; ["Offset of field: _GThreadFunctions::mutex_unlock"] [:: std :: mem :: offset_of ! (_GThreadFunctions , mutex_unlock) - 24usize] ; ["Offset of field: _GThreadFunctions::mutex_free"] [:: std :: mem :: offset_of ! (_GThreadFunctions , mutex_free) - 32usize] ; ["Offset of field: _GThreadFunctions::cond_new"] [:: std :: mem :: offset_of ! (_GThreadFunctions , cond_new) - 40usize] ; ["Offset of field: _GThreadFunctions::cond_signal"] [:: std :: mem :: offset_of ! (_GThreadFunctions , cond_signal) - 48usize] ; ["Offset of field: _GThreadFunctions::cond_broadcast"] [:: std :: mem :: offset_of ! (_GThreadFunctions , cond_broadcast) - 56usize] ; ["Offset of field: _GThreadFunctions::cond_wait"] [:: std :: mem :: offset_of ! (_GThreadFunctions , cond_wait) - 64usize] ; ["Offset of field: _GThreadFunctions::cond_timed_wait"] [:: std :: mem :: offset_of ! (_GThreadFunctions , cond_timed_wait) - 72usize] ; ["Offset of field: _GThreadFunctions::cond_free"] [:: std :: mem :: offset_of ! (_GThreadFunctions , cond_free) - 80usize] ; ["Offset of field: _GThreadFunctions::private_new"] [:: std :: mem :: offset_of ! (_GThreadFunctions , private_new) - 88usize] ; ["Offset of field: _GThreadFunctions::private_get"] [:: std :: mem :: offset_of ! (_GThreadFunctions , private_get) - 96usize] ; ["Offset of field: _GThreadFunctions::private_set"] [:: std :: mem :: offset_of ! (_GThreadFunctions , private_set) - 104usize] ; ["Offset of field: _GThreadFunctions::thread_create"] [:: std :: mem :: offset_of ! (_GThreadFunctions , thread_create) - 112usize] ; ["Offset of field: _GThreadFunctions::thread_yield"] [:: std :: mem :: offset_of ! (_GThreadFunctions , thread_yield) - 120usize] ; ["Offset of field: _GThreadFunctions::thread_join"] [:: std :: mem :: offset_of ! (_GThreadFunctions , thread_join) - 128usize] ; ["Offset of field: _GThreadFunctions::thread_exit"] [:: std :: mem :: offset_of ! (_GThreadFunctions , thread_exit) - 136usize] ; ["Offset of field: _GThreadFunctions::thread_set_priority"] [:: std :: mem :: offset_of ! (_GThreadFunctions , thread_set_priority) - 144usize] ; ["Offset of field: _GThreadFunctions::thread_self"] [:: std :: mem :: offset_of ! (_GThreadFunctions , thread_self) - 152usize] ; ["Offset of field: _GThreadFunctions::thread_equal"] [:: std :: mem :: offset_of ! (_GThreadFunctions , thread_equal) - 160usize] ; } ; unsafe extern "C" { pub static mut g_thread_functions_for_glib_use : GThreadFunctions ; } unsafe extern "C" { pub static mut g_thread_use_default_impl : gboolean ; } unsafe extern "C" { pub static mut g_thread_gettime : :: std :: option :: Option < unsafe extern "C" fn () -> guint64 > ; } unsafe extern "C" { pub fn g_thread_create (func : GThreadFunc , data : gpointer , joinable : gboolean , error : * mut * mut GError) -> * mut GThread ; } unsafe extern "C" { pub fn g_thread_create_full (func : GThreadFunc , data : gpointer , stack_size : gulong , joinable : gboolean , bound : gboolean , priority : GThreadPriority , error : * mut * mut GError) -> * mut GThread ; } unsafe extern "C" { pub fn g_thread_set_priority (thread : * mut GThread , priority : GThreadPriority) ; } unsafe extern "C" { pub fn g_thread_foreach (thread_func : GFunc , user_data : gpointer) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct sched_param { pub sched_priority : :: std :: os :: raw :: c_int , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of sched_param"] [:: std :: mem :: size_of :: < sched_param > () - 4usize] ; ["Alignment of sched_param"] [:: std :: mem :: align_of :: < sched_param > () - 4usize] ; ["Offset of field: sched_param::sched_priority"] [:: std :: mem :: offset_of ! (sched_param , sched_priority) - 0usize] ; } ; pub type __cpu_mask = :: std :: os :: raw :: c_ulong ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct cpu_set_t { pub __bits : [__cpu_mask ; 16usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of cpu_set_t"] [:: std :: mem :: size_of :: < cpu_set_t > () - 128usize] ; ["Alignment of cpu_set_t"] [:: std :: mem :: align_of :: < cpu_set_t > () - 8usize] ; ["Offset of field: cpu_set_t::__bits"] [:: std :: mem :: offset_of ! (cpu_set_t , __bits) - 0usize] ; } ; unsafe extern "C" { pub fn __sched_cpucount (__setsize : usize , __setp : * const cpu_set_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn __sched_cpualloc (__count : usize) -> * mut cpu_set_t ; } unsafe extern "C" { pub fn __sched_cpufree (__set : * mut cpu_set_t) ; } unsafe extern "C" { pub fn sched_setparam (__pid : __pid_t , __param : * const sched_param) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sched_getparam (__pid : __pid_t , __param : * mut sched_param) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sched_setscheduler (__pid : __pid_t , __policy : :: std :: os :: raw :: c_int , __param : * const sched_param) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sched_getscheduler (__pid : __pid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sched_yield () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sched_get_priority_max (__algorithm : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sched_get_priority_min (__algorithm : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sched_rr_get_interval (__pid : __pid_t , __t : * mut timespec) -> :: std :: os :: raw :: c_int ; } pub type __jmp_buf = [:: std :: os :: raw :: c_long ; 8usize] ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __jmp_buf_tag { pub __jmpbuf : __jmp_buf , pub __mask_was_saved : :: std :: os :: raw :: c_int , pub __saved_mask : __sigset_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __jmp_buf_tag"] [:: std :: mem :: size_of :: < __jmp_buf_tag > () - 200usize] ; ["Alignment of __jmp_buf_tag"] [:: std :: mem :: align_of :: < __jmp_buf_tag > () - 8usize] ; ["Offset of field: __jmp_buf_tag::__jmpbuf"] [:: std :: mem :: offset_of ! (__jmp_buf_tag , __jmpbuf) - 0usize] ; ["Offset of field: __jmp_buf_tag::__mask_was_saved"] [:: std :: mem :: offset_of ! (__jmp_buf_tag , __mask_was_saved) - 64usize] ; ["Offset of field: __jmp_buf_tag::__saved_mask"] [:: std :: mem :: offset_of ! (__jmp_buf_tag , __saved_mask) - 72usize] ; } ; pub const PTHREAD_CREATE_JOINABLE : _bindgen_ty_11 = 0 ; pub const PTHREAD_CREATE_DETACHED : _bindgen_ty_11 = 1 ; pub type _bindgen_ty_11 = :: std :: os :: raw :: c_uint ; pub const PTHREAD_MUTEX_TIMED_NP : _bindgen_ty_12 = 0 ; pub const PTHREAD_MUTEX_RECURSIVE_NP : _bindgen_ty_12 = 1 ; pub const PTHREAD_MUTEX_ERRORCHECK_NP : _bindgen_ty_12 = 2 ; pub const PTHREAD_MUTEX_ADAPTIVE_NP : _bindgen_ty_12 = 3 ; pub const PTHREAD_MUTEX_NORMAL : _bindgen_ty_12 = 0 ; pub const PTHREAD_MUTEX_RECURSIVE : _bindgen_ty_12 = 1 ; pub const PTHREAD_MUTEX_ERRORCHECK : _bindgen_ty_12 = 2 ; pub const PTHREAD_MUTEX_DEFAULT : _bindgen_ty_12 = 0 ; pub type _bindgen_ty_12 = :: std :: os :: raw :: c_uint ; pub const PTHREAD_MUTEX_STALLED : _bindgen_ty_13 = 0 ; pub const PTHREAD_MUTEX_STALLED_NP : _bindgen_ty_13 = 0 ; pub const PTHREAD_MUTEX_ROBUST : _bindgen_ty_13 = 1 ; pub const PTHREAD_MUTEX_ROBUST_NP : _bindgen_ty_13 = 1 ; pub type _bindgen_ty_13 = :: std :: os :: raw :: c_uint ; pub const PTHREAD_PRIO_NONE : _bindgen_ty_14 = 0 ; pub const PTHREAD_PRIO_INHERIT : _bindgen_ty_14 = 1 ; pub const PTHREAD_PRIO_PROTECT : _bindgen_ty_14 = 2 ; pub type _bindgen_ty_14 = :: std :: os :: raw :: c_uint ; pub const PTHREAD_RWLOCK_PREFER_READER_NP : _bindgen_ty_15 = 0 ; pub const PTHREAD_RWLOCK_PREFER_WRITER_NP : _bindgen_ty_15 = 1 ; pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP : _bindgen_ty_15 = 2 ; pub const PTHREAD_RWLOCK_DEFAULT_NP : _bindgen_ty_15 = 0 ; pub type _bindgen_ty_15 = :: std :: os :: raw :: c_uint ; pub const PTHREAD_INHERIT_SCHED : _bindgen_ty_16 = 0 ; pub const PTHREAD_EXPLICIT_SCHED : _bindgen_ty_16 = 1 ; pub type _bindgen_ty_16 = :: std :: os :: raw :: c_uint ; pub const PTHREAD_SCOPE_SYSTEM : _bindgen_ty_17 = 0 ; pub const PTHREAD_SCOPE_PROCESS : _bindgen_ty_17 = 1 ; pub type _bindgen_ty_17 = :: std :: os :: raw :: c_uint ; pub const PTHREAD_PROCESS_PRIVATE : _bindgen_ty_18 = 0 ; pub const PTHREAD_PROCESS_SHARED : _bindgen_ty_18 = 1 ; pub type _bindgen_ty_18 = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _pthread_cleanup_buffer { pub __routine : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void) > , pub __arg : * mut :: std :: os :: raw :: c_void , pub __canceltype : :: std :: os :: raw :: c_int , pub __prev : * mut _pthread_cleanup_buffer , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _pthread_cleanup_buffer"] [:: std :: mem :: size_of :: < _pthread_cleanup_buffer > () - 32usize] ; ["Alignment of _pthread_cleanup_buffer"] [:: std :: mem :: align_of :: < _pthread_cleanup_buffer > () - 8usize] ; ["Offset of field: _pthread_cleanup_buffer::__routine"] [:: std :: mem :: offset_of ! (_pthread_cleanup_buffer , __routine) - 0usize] ; ["Offset of field: _pthread_cleanup_buffer::__arg"] [:: std :: mem :: offset_of ! (_pthread_cleanup_buffer , __arg) - 8usize] ; ["Offset of field: _pthread_cleanup_buffer::__canceltype"] [:: std :: mem :: offset_of ! (_pthread_cleanup_buffer , __canceltype) - 16usize] ; ["Offset of field: _pthread_cleanup_buffer::__prev"] [:: std :: mem :: offset_of ! (_pthread_cleanup_buffer , __prev) - 24usize] ; } ; pub const PTHREAD_CANCEL_ENABLE : _bindgen_ty_19 = 0 ; pub const PTHREAD_CANCEL_DISABLE : _bindgen_ty_19 = 1 ; pub type _bindgen_ty_19 = :: std :: os :: raw :: c_uint ; pub const PTHREAD_CANCEL_DEFERRED : _bindgen_ty_20 = 0 ; pub const PTHREAD_CANCEL_ASYNCHRONOUS : _bindgen_ty_20 = 1 ; pub type _bindgen_ty_20 = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn pthread_create (__newthread : * mut pthread_t , __attr : * const pthread_attr_t , __start_routine : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void) -> * mut :: std :: os :: raw :: c_void > , __arg : * mut :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_exit (__retval : * mut :: std :: os :: raw :: c_void) -> ! ; } unsafe extern "C" { pub fn pthread_join (__th : pthread_t , __thread_return : * mut * mut :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_detach (__th : pthread_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_self () -> pthread_t ; } unsafe extern "C" { pub fn pthread_equal (__thread1 : pthread_t , __thread2 : pthread_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_init (__attr : * mut pthread_attr_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_destroy (__attr : * mut pthread_attr_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_getdetachstate (__attr : * const pthread_attr_t , __detachstate : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_setdetachstate (__attr : * mut pthread_attr_t , __detachstate : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_getguardsize (__attr : * const pthread_attr_t , __guardsize : * mut usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_setguardsize (__attr : * mut pthread_attr_t , __guardsize : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_getschedparam (__attr : * const pthread_attr_t , __param : * mut sched_param) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_setschedparam (__attr : * mut pthread_attr_t , __param : * const sched_param) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_getschedpolicy (__attr : * const pthread_attr_t , __policy : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_setschedpolicy (__attr : * mut pthread_attr_t , __policy : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_getinheritsched (__attr : * const pthread_attr_t , __inherit : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_setinheritsched (__attr : * mut pthread_attr_t , __inherit : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_getscope (__attr : * const pthread_attr_t , __scope : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_setscope (__attr : * mut pthread_attr_t , __scope : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_getstackaddr (__attr : * const pthread_attr_t , __stackaddr : * mut * mut :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_setstackaddr (__attr : * mut pthread_attr_t , __stackaddr : * mut :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_getstacksize (__attr : * const pthread_attr_t , __stacksize : * mut usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_setstacksize (__attr : * mut pthread_attr_t , __stacksize : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_getstack (__attr : * const pthread_attr_t , __stackaddr : * mut * mut :: std :: os :: raw :: c_void , __stacksize : * mut usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_attr_setstack (__attr : * mut pthread_attr_t , __stackaddr : * mut :: std :: os :: raw :: c_void , __stacksize : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_setschedparam (__target_thread : pthread_t , __policy : :: std :: os :: raw :: c_int , __param : * const sched_param) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_getschedparam (__target_thread : pthread_t , __policy : * mut :: std :: os :: raw :: c_int , __param : * mut sched_param) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_setschedprio (__target_thread : pthread_t , __prio : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_once (__once_control : * mut pthread_once_t , __init_routine : :: std :: option :: Option < unsafe extern "C" fn () >) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_setcancelstate (__state : :: std :: os :: raw :: c_int , __oldstate : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_setcanceltype (__type : :: std :: os :: raw :: c_int , __oldtype : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_cancel (__th : pthread_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_testcancel () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __cancel_jmp_buf_tag { pub __cancel_jmp_buf : __jmp_buf , pub __mask_was_saved : :: std :: os :: raw :: c_int , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __cancel_jmp_buf_tag"] [:: std :: mem :: size_of :: < __cancel_jmp_buf_tag > () - 72usize] ; ["Alignment of __cancel_jmp_buf_tag"] [:: std :: mem :: align_of :: < __cancel_jmp_buf_tag > () - 8usize] ; ["Offset of field: __cancel_jmp_buf_tag::__cancel_jmp_buf"] [:: std :: mem :: offset_of ! (__cancel_jmp_buf_tag , __cancel_jmp_buf) - 0usize] ; ["Offset of field: __cancel_jmp_buf_tag::__mask_was_saved"] [:: std :: mem :: offset_of ! (__cancel_jmp_buf_tag , __mask_was_saved) - 64usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __pthread_unwind_buf_t { pub __cancel_jmp_buf : [__cancel_jmp_buf_tag ; 1usize] , pub __pad : [* mut :: std :: os :: raw :: c_void ; 4usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __pthread_unwind_buf_t"] [:: std :: mem :: size_of :: < __pthread_unwind_buf_t > () - 104usize] ; ["Alignment of __pthread_unwind_buf_t"] [:: std :: mem :: align_of :: < __pthread_unwind_buf_t > () - 8usize] ; ["Offset of field: __pthread_unwind_buf_t::__cancel_jmp_buf"] [:: std :: mem :: offset_of ! (__pthread_unwind_buf_t , __cancel_jmp_buf) - 0usize] ; ["Offset of field: __pthread_unwind_buf_t::__pad"] [:: std :: mem :: offset_of ! (__pthread_unwind_buf_t , __pad) - 72usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __pthread_cleanup_frame { pub __cancel_routine : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void) > , pub __cancel_arg : * mut :: std :: os :: raw :: c_void , pub __do_it : :: std :: os :: raw :: c_int , pub __cancel_type : :: std :: os :: raw :: c_int , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __pthread_cleanup_frame"] [:: std :: mem :: size_of :: < __pthread_cleanup_frame > () - 24usize] ; ["Alignment of __pthread_cleanup_frame"] [:: std :: mem :: align_of :: < __pthread_cleanup_frame > () - 8usize] ; ["Offset of field: __pthread_cleanup_frame::__cancel_routine"] [:: std :: mem :: offset_of ! (__pthread_cleanup_frame , __cancel_routine) - 0usize] ; ["Offset of field: __pthread_cleanup_frame::__cancel_arg"] [:: std :: mem :: offset_of ! (__pthread_cleanup_frame , __cancel_arg) - 8usize] ; ["Offset of field: __pthread_cleanup_frame::__do_it"] [:: std :: mem :: offset_of ! (__pthread_cleanup_frame , __do_it) - 16usize] ; ["Offset of field: __pthread_cleanup_frame::__cancel_type"] [:: std :: mem :: offset_of ! (__pthread_cleanup_frame , __cancel_type) - 20usize] ; } ; unsafe extern "C" { pub fn __pthread_register_cancel (__buf : * mut __pthread_unwind_buf_t) ; } unsafe extern "C" { pub fn __pthread_unregister_cancel (__buf : * mut __pthread_unwind_buf_t) ; } unsafe extern "C" { pub fn __pthread_unwind_next (__buf : * mut __pthread_unwind_buf_t) -> ! ; } unsafe extern "C" { pub fn __sigsetjmp (__env : * mut __jmp_buf_tag , __savemask : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutex_init (__mutex : * mut pthread_mutex_t , __mutexattr : * const pthread_mutexattr_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutex_destroy (__mutex : * mut pthread_mutex_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutex_trylock (__mutex : * mut pthread_mutex_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutex_lock (__mutex : * mut pthread_mutex_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutex_timedlock (__mutex : * mut pthread_mutex_t , __abstime : * const timespec) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutex_unlock (__mutex : * mut pthread_mutex_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutex_getprioceiling (__mutex : * const pthread_mutex_t , __prioceiling : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutex_setprioceiling (__mutex : * mut pthread_mutex_t , __prioceiling : :: std :: os :: raw :: c_int , __old_ceiling : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutex_consistent (__mutex : * mut pthread_mutex_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutexattr_init (__attr : * mut pthread_mutexattr_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutexattr_destroy (__attr : * mut pthread_mutexattr_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutexattr_getpshared (__attr : * const pthread_mutexattr_t , __pshared : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutexattr_setpshared (__attr : * mut pthread_mutexattr_t , __pshared : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutexattr_gettype (__attr : * const pthread_mutexattr_t , __kind : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutexattr_settype (__attr : * mut pthread_mutexattr_t , __kind : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutexattr_getprotocol (__attr : * const pthread_mutexattr_t , __protocol : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutexattr_setprotocol (__attr : * mut pthread_mutexattr_t , __protocol : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutexattr_getprioceiling (__attr : * const pthread_mutexattr_t , __prioceiling : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutexattr_setprioceiling (__attr : * mut pthread_mutexattr_t , __prioceiling : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutexattr_getrobust (__attr : * const pthread_mutexattr_t , __robustness : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_mutexattr_setrobust (__attr : * mut pthread_mutexattr_t , __robustness : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlock_init (__rwlock : * mut pthread_rwlock_t , __attr : * const pthread_rwlockattr_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlock_destroy (__rwlock : * mut pthread_rwlock_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlock_rdlock (__rwlock : * mut pthread_rwlock_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlock_tryrdlock (__rwlock : * mut pthread_rwlock_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlock_timedrdlock (__rwlock : * mut pthread_rwlock_t , __abstime : * const timespec) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlock_wrlock (__rwlock : * mut pthread_rwlock_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlock_trywrlock (__rwlock : * mut pthread_rwlock_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlock_timedwrlock (__rwlock : * mut pthread_rwlock_t , __abstime : * const timespec) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlock_unlock (__rwlock : * mut pthread_rwlock_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlockattr_init (__attr : * mut pthread_rwlockattr_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlockattr_destroy (__attr : * mut pthread_rwlockattr_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlockattr_getpshared (__attr : * const pthread_rwlockattr_t , __pshared : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlockattr_setpshared (__attr : * mut pthread_rwlockattr_t , __pshared : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlockattr_getkind_np (__attr : * const pthread_rwlockattr_t , __pref : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_rwlockattr_setkind_np (__attr : * mut pthread_rwlockattr_t , __pref : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_cond_init (__cond : * mut pthread_cond_t , __cond_attr : * const pthread_condattr_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_cond_destroy (__cond : * mut pthread_cond_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_cond_signal (__cond : * mut pthread_cond_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_cond_broadcast (__cond : * mut pthread_cond_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_cond_wait (__cond : * mut pthread_cond_t , __mutex : * mut pthread_mutex_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_cond_timedwait (__cond : * mut pthread_cond_t , __mutex : * mut pthread_mutex_t , __abstime : * const timespec) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_condattr_init (__attr : * mut pthread_condattr_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_condattr_destroy (__attr : * mut pthread_condattr_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_condattr_getpshared (__attr : * const pthread_condattr_t , __pshared : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_condattr_setpshared (__attr : * mut pthread_condattr_t , __pshared : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_condattr_getclock (__attr : * const pthread_condattr_t , __clock_id : * mut __clockid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_condattr_setclock (__attr : * mut pthread_condattr_t , __clock_id : __clockid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_spin_init (__lock : * mut pthread_spinlock_t , __pshared : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_spin_destroy (__lock : * mut pthread_spinlock_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_spin_lock (__lock : * mut pthread_spinlock_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_spin_trylock (__lock : * mut pthread_spinlock_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_spin_unlock (__lock : * mut pthread_spinlock_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_barrier_init (__barrier : * mut pthread_barrier_t , __attr : * const pthread_barrierattr_t , __count : :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_barrier_destroy (__barrier : * mut pthread_barrier_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_barrier_wait (__barrier : * mut pthread_barrier_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_barrierattr_init (__attr : * mut pthread_barrierattr_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_barrierattr_destroy (__attr : * mut pthread_barrierattr_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_barrierattr_getpshared (__attr : * const pthread_barrierattr_t , __pshared : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_barrierattr_setpshared (__attr : * mut pthread_barrierattr_t , __pshared : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_key_create (__key : * mut pthread_key_t , __destr_function : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void) >) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_key_delete (__key : pthread_key_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_getspecific (__key : pthread_key_t) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn pthread_setspecific (__key : pthread_key_t , __pointer : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_getcpuclockid (__thread_id : pthread_t , __clock_id : * mut __clockid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pthread_atfork (__prepare : :: std :: option :: Option < unsafe extern "C" fn () > , __parent : :: std :: option :: Option < unsafe extern "C" fn () > , __child : :: std :: option :: Option < unsafe extern "C" fn () >) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct GStaticMutex { pub mutex : * mut GMutex , pub unused : pthread_mutex_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of GStaticMutex"] [:: std :: mem :: size_of :: < GStaticMutex > () - 48usize] ; ["Alignment of GStaticMutex"] [:: std :: mem :: align_of :: < GStaticMutex > () - 8usize] ; ["Offset of field: GStaticMutex::mutex"] [:: std :: mem :: offset_of ! (GStaticMutex , mutex) - 0usize] ; ["Offset of field: GStaticMutex::unused"] [:: std :: mem :: offset_of ! (GStaticMutex , unused) - 8usize] ; } ; unsafe extern "C" { pub fn g_static_mutex_init (mutex : * mut GStaticMutex) ; } unsafe extern "C" { pub fn g_static_mutex_free (mutex : * mut GStaticMutex) ; } unsafe extern "C" { pub fn g_static_mutex_get_mutex_impl (mutex : * mut GStaticMutex) -> * mut GMutex ; } pub type GStaticRecMutex = _GStaticRecMutex ; # [repr (C)] # [derive (Copy , Clone)] pub struct _GStaticRecMutex { pub mutex : GStaticMutex , pub depth : guint , pub unused : _GStaticRecMutex__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union _GStaticRecMutex__bindgen_ty_1 { pub owner : pthread_t , pub dummy : gdouble , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GStaticRecMutex__bindgen_ty_1"] [:: std :: mem :: size_of :: < _GStaticRecMutex__bindgen_ty_1 > () - 8usize] ; ["Alignment of _GStaticRecMutex__bindgen_ty_1"] [:: std :: mem :: align_of :: < _GStaticRecMutex__bindgen_ty_1 > () - 8usize] ; ["Offset of field: _GStaticRecMutex__bindgen_ty_1::owner"] [:: std :: mem :: offset_of ! (_GStaticRecMutex__bindgen_ty_1 , owner) - 0usize] ; ["Offset of field: _GStaticRecMutex__bindgen_ty_1::dummy"] [:: std :: mem :: offset_of ! (_GStaticRecMutex__bindgen_ty_1 , dummy) - 0usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GStaticRecMutex"] [:: std :: mem :: size_of :: < _GStaticRecMutex > () - 64usize] ; ["Alignment of _GStaticRecMutex"] [:: std :: mem :: align_of :: < _GStaticRecMutex > () - 8usize] ; ["Offset of field: _GStaticRecMutex::mutex"] [:: std :: mem :: offset_of ! (_GStaticRecMutex , mutex) - 0usize] ; ["Offset of field: _GStaticRecMutex::depth"] [:: std :: mem :: offset_of ! (_GStaticRecMutex , depth) - 48usize] ; ["Offset of field: _GStaticRecMutex::unused"] [:: std :: mem :: offset_of ! (_GStaticRecMutex , unused) - 56usize] ; } ; unsafe extern "C" { pub fn g_static_rec_mutex_init (mutex : * mut GStaticRecMutex) ; } unsafe extern "C" { pub fn g_static_rec_mutex_lock (mutex : * mut GStaticRecMutex) ; } unsafe extern "C" { pub fn g_static_rec_mutex_trylock (mutex : * mut GStaticRecMutex) -> gboolean ; } unsafe extern "C" { pub fn g_static_rec_mutex_unlock (mutex : * mut GStaticRecMutex) ; } unsafe extern "C" { pub fn g_static_rec_mutex_lock_full (mutex : * mut GStaticRecMutex , depth : guint) ; } unsafe extern "C" { pub fn g_static_rec_mutex_unlock_full (mutex : * mut GStaticRecMutex) -> guint ; } unsafe extern "C" { pub fn g_static_rec_mutex_free (mutex : * mut GStaticRecMutex) ; } pub type GStaticRWLock = _GStaticRWLock ; # [repr (C)] # [derive (Copy , Clone)] pub struct _GStaticRWLock { pub mutex : GStaticMutex , pub read_cond : * mut GCond , pub write_cond : * mut GCond , pub read_counter : guint , pub have_writer : gboolean , pub want_to_read : guint , pub want_to_write : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GStaticRWLock"] [:: std :: mem :: size_of :: < _GStaticRWLock > () - 80usize] ; ["Alignment of _GStaticRWLock"] [:: std :: mem :: align_of :: < _GStaticRWLock > () - 8usize] ; ["Offset of field: _GStaticRWLock::mutex"] [:: std :: mem :: offset_of ! (_GStaticRWLock , mutex) - 0usize] ; ["Offset of field: _GStaticRWLock::read_cond"] [:: std :: mem :: offset_of ! (_GStaticRWLock , read_cond) - 48usize] ; ["Offset of field: _GStaticRWLock::write_cond"] [:: std :: mem :: offset_of ! (_GStaticRWLock , write_cond) - 56usize] ; ["Offset of field: _GStaticRWLock::read_counter"] [:: std :: mem :: offset_of ! (_GStaticRWLock , read_counter) - 64usize] ; ["Offset of field: _GStaticRWLock::have_writer"] [:: std :: mem :: offset_of ! (_GStaticRWLock , have_writer) - 68usize] ; ["Offset of field: _GStaticRWLock::want_to_read"] [:: std :: mem :: offset_of ! (_GStaticRWLock , want_to_read) - 72usize] ; ["Offset of field: _GStaticRWLock::want_to_write"] [:: std :: mem :: offset_of ! (_GStaticRWLock , want_to_write) - 76usize] ; } ; unsafe extern "C" { pub fn g_static_rw_lock_init (lock : * mut GStaticRWLock) ; } unsafe extern "C" { pub fn g_static_rw_lock_reader_lock (lock : * mut GStaticRWLock) ; } unsafe extern "C" { pub fn g_static_rw_lock_reader_trylock (lock : * mut GStaticRWLock) -> gboolean ; } unsafe extern "C" { pub fn g_static_rw_lock_reader_unlock (lock : * mut GStaticRWLock) ; } unsafe extern "C" { pub fn g_static_rw_lock_writer_lock (lock : * mut GStaticRWLock) ; } unsafe extern "C" { pub fn g_static_rw_lock_writer_trylock (lock : * mut GStaticRWLock) -> gboolean ; } unsafe extern "C" { pub fn g_static_rw_lock_writer_unlock (lock : * mut GStaticRWLock) ; } unsafe extern "C" { pub fn g_static_rw_lock_free (lock : * mut GStaticRWLock) ; } unsafe extern "C" { pub fn g_private_new (notify : GDestroyNotify) -> * mut GPrivate ; } pub type GStaticPrivate = _GStaticPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GStaticPrivate { pub index : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GStaticPrivate"] [:: std :: mem :: size_of :: < _GStaticPrivate > () - 4usize] ; ["Alignment of _GStaticPrivate"] [:: std :: mem :: align_of :: < _GStaticPrivate > () - 4usize] ; ["Offset of field: _GStaticPrivate::index"] [:: std :: mem :: offset_of ! (_GStaticPrivate , index) - 0usize] ; } ; unsafe extern "C" { pub fn g_static_private_init (private_key : * mut GStaticPrivate) ; } unsafe extern "C" { pub fn g_static_private_get (private_key : * mut GStaticPrivate) -> gpointer ; } unsafe extern "C" { pub fn g_static_private_set (private_key : * mut GStaticPrivate , data : gpointer , notify : GDestroyNotify) ; } unsafe extern "C" { pub fn g_static_private_free (private_key : * mut GStaticPrivate) ; } unsafe extern "C" { pub fn g_once_init_enter_impl (location : * mut gsize) -> gboolean ; } unsafe extern "C" { pub fn g_thread_init (vtable : gpointer) ; } unsafe extern "C" { pub fn g_thread_init_with_errorcheck_mutexes (vtable : gpointer) ; } unsafe extern "C" { pub fn g_thread_get_initialized () -> gboolean ; } unsafe extern "C" { pub static mut g_threads_got_initialized : gboolean ; } unsafe extern "C" { pub fn g_mutex_new () -> * mut GMutex ; } unsafe extern "C" { pub fn g_mutex_free (mutex : * mut GMutex) ; } unsafe extern "C" { pub fn g_cond_new () -> * mut GCond ; } unsafe extern "C" { pub fn g_cond_free (cond : * mut GCond) ; } unsafe extern "C" { pub fn g_cond_timed_wait (cond : * mut GCond , mutex : * mut GMutex , abs_time : * mut GTimeVal) -> gboolean ; } pub type GAsyncQueue_autoptr = * mut GAsyncQueue ; pub type GAsyncQueue_listautoptr = * mut GList ; pub type GAsyncQueue_slistautoptr = * mut GSList ; pub type GAsyncQueue_queueautoptr = * mut GQueue ; pub type GBookmarkFile_autoptr = * mut GBookmarkFile ; pub type GBookmarkFile_listautoptr = * mut GList ; pub type GBookmarkFile_slistautoptr = * mut GSList ; pub type GBookmarkFile_queueautoptr = * mut GQueue ; pub type GBytes_autoptr = * mut GBytes ; pub type GBytes_listautoptr = * mut GList ; pub type GBytes_slistautoptr = * mut GSList ; pub type GBytes_queueautoptr = * mut GQueue ; pub type GChecksum_autoptr = * mut GChecksum ; pub type GChecksum_listautoptr = * mut GList ; pub type GChecksum_slistautoptr = * mut GSList ; pub type GChecksum_queueautoptr = * mut GQueue ; pub type GDateTime_autoptr = * mut GDateTime ; pub type GDateTime_listautoptr = * mut GList ; pub type GDateTime_slistautoptr = * mut GSList ; pub type GDateTime_queueautoptr = * mut GQueue ; pub type GDate_autoptr = * mut GDate ; pub type GDate_listautoptr = * mut GList ; pub type GDate_slistautoptr = * mut GSList ; pub type GDate_queueautoptr = * mut GQueue ; pub type GDir_autoptr = * mut GDir ; pub type GDir_listautoptr = * mut GList ; pub type GDir_slistautoptr = * mut GSList ; pub type GDir_queueautoptr = * mut GQueue ; pub type GError_autoptr = * mut GError ; pub type GError_listautoptr = * mut GList ; pub type GError_slistautoptr = * mut GSList ; pub type GError_queueautoptr = * mut GQueue ; pub type GHashTable_autoptr = * mut GHashTable ; pub type GHashTable_listautoptr = * mut GList ; pub type GHashTable_slistautoptr = * mut GSList ; pub type GHashTable_queueautoptr = * mut GQueue ; pub type GHmac_autoptr = * mut GHmac ; pub type GHmac_listautoptr = * mut GList ; pub type GHmac_slistautoptr = * mut GSList ; pub type GHmac_queueautoptr = * mut GQueue ; pub type GIOChannel_autoptr = * mut GIOChannel ; pub type GIOChannel_listautoptr = * mut GList ; pub type GIOChannel_slistautoptr = * mut GSList ; pub type GIOChannel_queueautoptr = * mut GQueue ; pub type GKeyFile_autoptr = * mut GKeyFile ; pub type GKeyFile_listautoptr = * mut GList ; pub type GKeyFile_slistautoptr = * mut GSList ; pub type GKeyFile_queueautoptr = * mut GQueue ; pub type GList_autoptr = * mut GList ; pub type GList_listautoptr = * mut GList ; pub type GList_slistautoptr = * mut GSList ; pub type GList_queueautoptr = * mut GQueue ; pub type GArray_autoptr = * mut GArray ; pub type GArray_listautoptr = * mut GList ; pub type GArray_slistautoptr = * mut GSList ; pub type GArray_queueautoptr = * mut GQueue ; pub type GPtrArray_autoptr = * mut GPtrArray ; pub type GPtrArray_listautoptr = * mut GList ; pub type GPtrArray_slistautoptr = * mut GSList ; pub type GPtrArray_queueautoptr = * mut GQueue ; pub type GByteArray_autoptr = * mut GByteArray ; pub type GByteArray_listautoptr = * mut GList ; pub type GByteArray_slistautoptr = * mut GSList ; pub type GByteArray_queueautoptr = * mut GQueue ; pub type GMainContext_autoptr = * mut GMainContext ; pub type GMainContext_listautoptr = * mut GList ; pub type GMainContext_slistautoptr = * mut GSList ; pub type GMainContext_queueautoptr = * mut GQueue ; pub type GMainContextPusher_autoptr = * mut GMainContextPusher ; pub type GMainContextPusher_listautoptr = * mut GList ; pub type GMainContextPusher_slistautoptr = * mut GSList ; pub type GMainContextPusher_queueautoptr = * mut GQueue ; pub type GMainLoop_autoptr = * mut GMainLoop ; pub type GMainLoop_listautoptr = * mut GList ; pub type GMainLoop_slistautoptr = * mut GSList ; pub type GMainLoop_queueautoptr = * mut GQueue ; pub type GSource_autoptr = * mut GSource ; pub type GSource_listautoptr = * mut GList ; pub type GSource_slistautoptr = * mut GSList ; pub type GSource_queueautoptr = * mut GQueue ; pub type GMappedFile_autoptr = * mut GMappedFile ; pub type GMappedFile_listautoptr = * mut GList ; pub type GMappedFile_slistautoptr = * mut GSList ; pub type GMappedFile_queueautoptr = * mut GQueue ; pub type GMarkupParseContext_autoptr = * mut GMarkupParseContext ; pub type GMarkupParseContext_listautoptr = * mut GList ; pub type GMarkupParseContext_slistautoptr = * mut GSList ; pub type GMarkupParseContext_queueautoptr = * mut GQueue ; pub type GNode_autoptr = * mut GNode ; pub type GNode_listautoptr = * mut GList ; pub type GNode_slistautoptr = * mut GSList ; pub type GNode_queueautoptr = * mut GQueue ; pub type GOptionContext_autoptr = * mut GOptionContext ; pub type GOptionContext_listautoptr = * mut GList ; pub type GOptionContext_slistautoptr = * mut GSList ; pub type GOptionContext_queueautoptr = * mut GQueue ; pub type GOptionGroup_autoptr = * mut GOptionGroup ; pub type GOptionGroup_listautoptr = * mut GList ; pub type GOptionGroup_slistautoptr = * mut GSList ; pub type GOptionGroup_queueautoptr = * mut GQueue ; pub type GPatternSpec_autoptr = * mut GPatternSpec ; pub type GPatternSpec_listautoptr = * mut GList ; pub type GPatternSpec_slistautoptr = * mut GSList ; pub type GPatternSpec_queueautoptr = * mut GQueue ; pub type GQueue_autoptr = * mut GQueue ; pub type GQueue_listautoptr = * mut GList ; pub type GQueue_slistautoptr = * mut GSList ; pub type GQueue_queueautoptr = * mut GQueue ; pub type GRand_autoptr = * mut GRand ; pub type GRand_listautoptr = * mut GList ; pub type GRand_slistautoptr = * mut GSList ; pub type GRand_queueautoptr = * mut GQueue ; pub type GRegex_autoptr = * mut GRegex ; pub type GRegex_listautoptr = * mut GList ; pub type GRegex_slistautoptr = * mut GSList ; pub type GRegex_queueautoptr = * mut GQueue ; pub type GMatchInfo_autoptr = * mut GMatchInfo ; pub type GMatchInfo_listautoptr = * mut GList ; pub type GMatchInfo_slistautoptr = * mut GSList ; pub type GMatchInfo_queueautoptr = * mut GQueue ; pub type GScanner_autoptr = * mut GScanner ; pub type GScanner_listautoptr = * mut GList ; pub type GScanner_slistautoptr = * mut GSList ; pub type GScanner_queueautoptr = * mut GQueue ; pub type GSequence_autoptr = * mut GSequence ; pub type GSequence_listautoptr = * mut GList ; pub type GSequence_slistautoptr = * mut GSList ; pub type GSequence_queueautoptr = * mut GQueue ; pub type GSList_autoptr = * mut GSList ; pub type GSList_listautoptr = * mut GList ; pub type GSList_slistautoptr = * mut GSList ; pub type GSList_queueautoptr = * mut GQueue ; pub type GString_autoptr = * mut GString ; pub type GString_listautoptr = * mut GList ; pub type GString_slistautoptr = * mut GSList ; pub type GString_queueautoptr = * mut GQueue ; pub type GStringChunk_autoptr = * mut GStringChunk ; pub type GStringChunk_listautoptr = * mut GList ; pub type GStringChunk_slistautoptr = * mut GSList ; pub type GStringChunk_queueautoptr = * mut GQueue ; pub type GStrvBuilder_autoptr = * mut GStrvBuilder ; pub type GStrvBuilder_listautoptr = * mut GList ; pub type GStrvBuilder_slistautoptr = * mut GSList ; pub type GStrvBuilder_queueautoptr = * mut GQueue ; pub type GThread_autoptr = * mut GThread ; pub type GThread_listautoptr = * mut GList ; pub type GThread_slistautoptr = * mut GSList ; pub type GThread_queueautoptr = * mut GQueue ; pub type GMutexLocker_autoptr = * mut GMutexLocker ; pub type GMutexLocker_listautoptr = * mut GList ; pub type GMutexLocker_slistautoptr = * mut GSList ; pub type GMutexLocker_queueautoptr = * mut GQueue ; pub type GRecMutexLocker_autoptr = * mut GRecMutexLocker ; pub type GRecMutexLocker_listautoptr = * mut GList ; pub type GRecMutexLocker_slistautoptr = * mut GSList ; pub type GRecMutexLocker_queueautoptr = * mut GQueue ; pub type GRWLockWriterLocker_autoptr = * mut GRWLockWriterLocker ; pub type GRWLockWriterLocker_listautoptr = * mut GList ; pub type GRWLockWriterLocker_slistautoptr = * mut GSList ; pub type GRWLockWriterLocker_queueautoptr = * mut GQueue ; pub type GRWLockReaderLocker_autoptr = * mut GRWLockReaderLocker ; pub type GRWLockReaderLocker_listautoptr = * mut GList ; pub type GRWLockReaderLocker_slistautoptr = * mut GSList ; pub type GRWLockReaderLocker_queueautoptr = * mut GQueue ; pub type GTimer_autoptr = * mut GTimer ; pub type GTimer_listautoptr = * mut GList ; pub type GTimer_slistautoptr = * mut GSList ; pub type GTimer_queueautoptr = * mut GQueue ; pub type GTimeZone_autoptr = * mut GTimeZone ; pub type GTimeZone_listautoptr = * mut GList ; pub type GTimeZone_slistautoptr = * mut GSList ; pub type GTimeZone_queueautoptr = * mut GQueue ; pub type GTree_autoptr = * mut GTree ; pub type GTree_listautoptr = * mut GList ; pub type GTree_slistautoptr = * mut GSList ; pub type GTree_queueautoptr = * mut GQueue ; pub type GVariant_autoptr = * mut GVariant ; pub type GVariant_listautoptr = * mut GList ; pub type GVariant_slistautoptr = * mut GSList ; pub type GVariant_queueautoptr = * mut GQueue ; pub type GVariantBuilder_autoptr = * mut GVariantBuilder ; pub type GVariantBuilder_listautoptr = * mut GList ; pub type GVariantBuilder_slistautoptr = * mut GSList ; pub type GVariantBuilder_queueautoptr = * mut GQueue ; pub type GVariantIter_autoptr = * mut GVariantIter ; pub type GVariantIter_listautoptr = * mut GList ; pub type GVariantIter_slistautoptr = * mut GSList ; pub type GVariantIter_queueautoptr = * mut GQueue ; pub type GVariantDict_autoptr = * mut GVariantDict ; pub type GVariantDict_listautoptr = * mut GList ; pub type GVariantDict_slistautoptr = * mut GSList ; pub type GVariantDict_queueautoptr = * mut GQueue ; pub type GVariantType_autoptr = * mut GVariantType ; pub type GVariantType_listautoptr = * mut GList ; pub type GVariantType_slistautoptr = * mut GSList ; pub type GVariantType_queueautoptr = * mut GQueue ; pub type GRefString_autoptr = * mut GRefString ; pub type GRefString_listautoptr = * mut GList ; pub type GRefString_slistautoptr = * mut GSList ; pub type GRefString_queueautoptr = * mut GQueue ; pub type GUri_autoptr = * mut GUri ; pub type GUri_listautoptr = * mut GList ; pub type GUri_slistautoptr = * mut GSList ; pub type GUri_queueautoptr = * mut GQueue ; pub type GPathBuf_autoptr = * mut GPathBuf ; pub type GPathBuf_listautoptr = * mut GList ; pub type GPathBuf_slistautoptr = * mut GSList ; pub type GPathBuf_queueautoptr = * mut GQueue ; pub type GType = gsize ; pub type GValue = _GValue ; # [repr (C)] # [derive (Copy , Clone)] pub struct _GTypeCValue { _unused : [u8 ; 0] , } pub type GTypeCValue = _GTypeCValue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTypePlugin { _unused : [u8 ; 0] , } pub type GTypePlugin = _GTypePlugin ; pub type GTypeClass = _GTypeClass ; pub type GTypeInterface = _GTypeInterface ; pub type GTypeInstance = _GTypeInstance ; pub type GTypeInfo = _GTypeInfo ; pub type GTypeFundamentalInfo = _GTypeFundamentalInfo ; pub type GInterfaceInfo = _GInterfaceInfo ; pub type GTypeValueTable = _GTypeValueTable ; pub type GTypeQuery = _GTypeQuery ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTypeClass { pub g_type : GType , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTypeClass"] [:: std :: mem :: size_of :: < _GTypeClass > () - 8usize] ; ["Alignment of _GTypeClass"] [:: std :: mem :: align_of :: < _GTypeClass > () - 8usize] ; ["Offset of field: _GTypeClass::g_type"] [:: std :: mem :: offset_of ! (_GTypeClass , g_type) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTypeInstance { pub g_class : * mut GTypeClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTypeInstance"] [:: std :: mem :: size_of :: < _GTypeInstance > () - 8usize] ; ["Alignment of _GTypeInstance"] [:: std :: mem :: align_of :: < _GTypeInstance > () - 8usize] ; ["Offset of field: _GTypeInstance::g_class"] [:: std :: mem :: offset_of ! (_GTypeInstance , g_class) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTypeInterface { pub g_type : GType , pub g_instance_type : GType , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTypeInterface"] [:: std :: mem :: size_of :: < _GTypeInterface > () - 16usize] ; ["Alignment of _GTypeInterface"] [:: std :: mem :: align_of :: < _GTypeInterface > () - 8usize] ; ["Offset of field: _GTypeInterface::g_type"] [:: std :: mem :: offset_of ! (_GTypeInterface , g_type) - 0usize] ; ["Offset of field: _GTypeInterface::g_instance_type"] [:: std :: mem :: offset_of ! (_GTypeInterface , g_instance_type) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTypeQuery { pub type_ : GType , pub type_name : * const gchar , pub class_size : guint , pub instance_size : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTypeQuery"] [:: std :: mem :: size_of :: < _GTypeQuery > () - 24usize] ; ["Alignment of _GTypeQuery"] [:: std :: mem :: align_of :: < _GTypeQuery > () - 8usize] ; ["Offset of field: _GTypeQuery::type_"] [:: std :: mem :: offset_of ! (_GTypeQuery , type_) - 0usize] ; ["Offset of field: _GTypeQuery::type_name"] [:: std :: mem :: offset_of ! (_GTypeQuery , type_name) - 8usize] ; ["Offset of field: _GTypeQuery::class_size"] [:: std :: mem :: offset_of ! (_GTypeQuery , class_size) - 16usize] ; ["Offset of field: _GTypeQuery::instance_size"] [:: std :: mem :: offset_of ! (_GTypeQuery , instance_size) - 20usize] ; } ; pub const GTypeDebugFlags_G_TYPE_DEBUG_NONE : GTypeDebugFlags = 0 ; pub const GTypeDebugFlags_G_TYPE_DEBUG_OBJECTS : GTypeDebugFlags = 1 ; pub const GTypeDebugFlags_G_TYPE_DEBUG_SIGNALS : GTypeDebugFlags = 2 ; pub const GTypeDebugFlags_G_TYPE_DEBUG_INSTANCE_COUNT : GTypeDebugFlags = 4 ; pub const GTypeDebugFlags_G_TYPE_DEBUG_MASK : GTypeDebugFlags = 7 ; pub type GTypeDebugFlags = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_type_init () ; } unsafe extern "C" { pub fn g_type_init_with_debug_flags (debug_flags : GTypeDebugFlags) ; } unsafe extern "C" { pub fn g_type_name (type_ : GType) -> * const gchar ; } unsafe extern "C" { pub fn g_type_qname (type_ : GType) -> GQuark ; } unsafe extern "C" { pub fn g_type_from_name (name : * const gchar) -> GType ; } unsafe extern "C" { pub fn g_type_parent (type_ : GType) -> GType ; } unsafe extern "C" { pub fn g_type_depth (type_ : GType) -> guint ; } unsafe extern "C" { pub fn g_type_next_base (leaf_type : GType , root_type : GType) -> GType ; } unsafe extern "C" { pub fn g_type_is_a (type_ : GType , is_a_type : GType) -> gboolean ; } unsafe extern "C" { pub fn g_type_class_get (type_ : GType) -> gpointer ; } unsafe extern "C" { pub fn g_type_class_ref (type_ : GType) -> gpointer ; } unsafe extern "C" { pub fn g_type_class_peek (type_ : GType) -> gpointer ; } unsafe extern "C" { pub fn g_type_class_peek_static (type_ : GType) -> gpointer ; } unsafe extern "C" { pub fn g_type_class_unref (g_class : gpointer) ; } unsafe extern "C" { pub fn g_type_class_peek_parent (g_class : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_type_interface_peek (instance_class : gpointer , iface_type : GType) -> gpointer ; } unsafe extern "C" { pub fn g_type_interface_peek_parent (g_iface : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_type_default_interface_get (g_type : GType) -> gpointer ; } unsafe extern "C" { pub fn g_type_default_interface_ref (g_type : GType) -> gpointer ; } unsafe extern "C" { pub fn g_type_default_interface_peek (g_type : GType) -> gpointer ; } unsafe extern "C" { pub fn g_type_default_interface_unref (g_iface : gpointer) ; } unsafe extern "C" { pub fn g_type_children (type_ : GType , n_children : * mut guint) -> * mut GType ; } unsafe extern "C" { pub fn g_type_interfaces (type_ : GType , n_interfaces : * mut guint) -> * mut GType ; } unsafe extern "C" { pub fn g_type_set_qdata (type_ : GType , quark : GQuark , data : gpointer) ; } unsafe extern "C" { pub fn g_type_get_qdata (type_ : GType , quark : GQuark) -> gpointer ; } unsafe extern "C" { pub fn g_type_query (type_ : GType , query : * mut GTypeQuery) ; } unsafe extern "C" { pub fn g_type_get_instance_count (type_ : GType) -> :: std :: os :: raw :: c_int ; } pub type GBaseInitFunc = :: std :: option :: Option < unsafe extern "C" fn (g_class : gpointer) > ; pub type GBaseFinalizeFunc = :: std :: option :: Option < unsafe extern "C" fn (g_class : gpointer) > ; pub type GClassInitFunc = :: std :: option :: Option < unsafe extern "C" fn (g_class : gpointer , class_data : gpointer) > ; pub type GClassFinalizeFunc = :: std :: option :: Option < unsafe extern "C" fn (g_class : gpointer , class_data : gpointer) > ; pub type GInstanceInitFunc = :: std :: option :: Option < unsafe extern "C" fn (instance : * mut GTypeInstance , g_class : gpointer) > ; pub type GInterfaceInitFunc = :: std :: option :: Option < unsafe extern "C" fn (g_iface : gpointer , iface_data : gpointer) > ; pub type GInterfaceFinalizeFunc = :: std :: option :: Option < unsafe extern "C" fn (g_iface : gpointer , iface_data : gpointer) > ; pub type GTypeClassCacheFunc = :: std :: option :: Option < unsafe extern "C" fn (cache_data : gpointer , g_class : * mut GTypeClass) -> gboolean > ; pub type GTypeInterfaceCheckFunc = :: std :: option :: Option < unsafe extern "C" fn (check_data : gpointer , g_iface : gpointer) > ; pub const GTypeFundamentalFlags_G_TYPE_FLAG_CLASSED : GTypeFundamentalFlags = 1 ; pub const GTypeFundamentalFlags_G_TYPE_FLAG_INSTANTIATABLE : GTypeFundamentalFlags = 2 ; pub const GTypeFundamentalFlags_G_TYPE_FLAG_DERIVABLE : GTypeFundamentalFlags = 4 ; pub const GTypeFundamentalFlags_G_TYPE_FLAG_DEEP_DERIVABLE : GTypeFundamentalFlags = 8 ; pub type GTypeFundamentalFlags = :: std :: os :: raw :: c_uint ; pub const GTypeFlags_G_TYPE_FLAG_NONE : GTypeFlags = 0 ; pub const GTypeFlags_G_TYPE_FLAG_ABSTRACT : GTypeFlags = 16 ; pub const GTypeFlags_G_TYPE_FLAG_VALUE_ABSTRACT : GTypeFlags = 32 ; pub const GTypeFlags_G_TYPE_FLAG_FINAL : GTypeFlags = 64 ; pub const GTypeFlags_G_TYPE_FLAG_DEPRECATED : GTypeFlags = 128 ; pub type GTypeFlags = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTypeInfo { pub class_size : guint16 , pub base_init : GBaseInitFunc , pub base_finalize : GBaseFinalizeFunc , pub class_init : GClassInitFunc , pub class_finalize : GClassFinalizeFunc , pub class_data : gconstpointer , pub instance_size : guint16 , pub n_preallocs : guint16 , pub instance_init : GInstanceInitFunc , pub value_table : * const GTypeValueTable , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTypeInfo"] [:: std :: mem :: size_of :: < _GTypeInfo > () - 72usize] ; ["Alignment of _GTypeInfo"] [:: std :: mem :: align_of :: < _GTypeInfo > () - 8usize] ; ["Offset of field: _GTypeInfo::class_size"] [:: std :: mem :: offset_of ! (_GTypeInfo , class_size) - 0usize] ; ["Offset of field: _GTypeInfo::base_init"] [:: std :: mem :: offset_of ! (_GTypeInfo , base_init) - 8usize] ; ["Offset of field: _GTypeInfo::base_finalize"] [:: std :: mem :: offset_of ! (_GTypeInfo , base_finalize) - 16usize] ; ["Offset of field: _GTypeInfo::class_init"] [:: std :: mem :: offset_of ! (_GTypeInfo , class_init) - 24usize] ; ["Offset of field: _GTypeInfo::class_finalize"] [:: std :: mem :: offset_of ! (_GTypeInfo , class_finalize) - 32usize] ; ["Offset of field: _GTypeInfo::class_data"] [:: std :: mem :: offset_of ! (_GTypeInfo , class_data) - 40usize] ; ["Offset of field: _GTypeInfo::instance_size"] [:: std :: mem :: offset_of ! (_GTypeInfo , instance_size) - 48usize] ; ["Offset of field: _GTypeInfo::n_preallocs"] [:: std :: mem :: offset_of ! (_GTypeInfo , n_preallocs) - 50usize] ; ["Offset of field: _GTypeInfo::instance_init"] [:: std :: mem :: offset_of ! (_GTypeInfo , instance_init) - 56usize] ; ["Offset of field: _GTypeInfo::value_table"] [:: std :: mem :: offset_of ! (_GTypeInfo , value_table) - 64usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTypeFundamentalInfo { pub type_flags : GTypeFundamentalFlags , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTypeFundamentalInfo"] [:: std :: mem :: size_of :: < _GTypeFundamentalInfo > () - 4usize] ; ["Alignment of _GTypeFundamentalInfo"] [:: std :: mem :: align_of :: < _GTypeFundamentalInfo > () - 4usize] ; ["Offset of field: _GTypeFundamentalInfo::type_flags"] [:: std :: mem :: offset_of ! (_GTypeFundamentalInfo , type_flags) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInterfaceInfo { pub interface_init : GInterfaceInitFunc , pub interface_finalize : GInterfaceFinalizeFunc , pub interface_data : gpointer , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GInterfaceInfo"] [:: std :: mem :: size_of :: < _GInterfaceInfo > () - 24usize] ; ["Alignment of _GInterfaceInfo"] [:: std :: mem :: align_of :: < _GInterfaceInfo > () - 8usize] ; ["Offset of field: _GInterfaceInfo::interface_init"] [:: std :: mem :: offset_of ! (_GInterfaceInfo , interface_init) - 0usize] ; ["Offset of field: _GInterfaceInfo::interface_finalize"] [:: std :: mem :: offset_of ! (_GInterfaceInfo , interface_finalize) - 8usize] ; ["Offset of field: _GInterfaceInfo::interface_data"] [:: std :: mem :: offset_of ! (_GInterfaceInfo , interface_data) - 16usize] ; } ; pub type GTypeValueInitFunc = :: std :: option :: Option < unsafe extern "C" fn (value : * mut GValue) > ; pub type GTypeValueFreeFunc = :: std :: option :: Option < unsafe extern "C" fn (value : * mut GValue) > ; pub type GTypeValueCopyFunc = :: std :: option :: Option < unsafe extern "C" fn (src_value : * const GValue , dest_value : * mut GValue) > ; pub type GTypeValuePeekPointerFunc = :: std :: option :: Option < unsafe extern "C" fn (value : * const GValue) -> gpointer > ; pub type GTypeValueCollectFunc = :: std :: option :: Option < unsafe extern "C" fn (value : * mut GValue , n_collect_values : guint , collect_values : * mut GTypeCValue , collect_flags : guint) -> * mut gchar > ; pub type GTypeValueLCopyFunc = :: std :: option :: Option < unsafe extern "C" fn (value : * const GValue , n_collect_values : guint , collect_values : * mut GTypeCValue , collect_flags : guint) -> * mut gchar > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTypeValueTable { pub value_init : GTypeValueInitFunc , pub value_free : GTypeValueFreeFunc , pub value_copy : GTypeValueCopyFunc , pub value_peek_pointer : GTypeValuePeekPointerFunc , pub collect_format : * const gchar , pub collect_value : GTypeValueCollectFunc , pub lcopy_format : * const gchar , pub lcopy_value : GTypeValueLCopyFunc , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTypeValueTable"] [:: std :: mem :: size_of :: < _GTypeValueTable > () - 64usize] ; ["Alignment of _GTypeValueTable"] [:: std :: mem :: align_of :: < _GTypeValueTable > () - 8usize] ; ["Offset of field: _GTypeValueTable::value_init"] [:: std :: mem :: offset_of ! (_GTypeValueTable , value_init) - 0usize] ; ["Offset of field: _GTypeValueTable::value_free"] [:: std :: mem :: offset_of ! (_GTypeValueTable , value_free) - 8usize] ; ["Offset of field: _GTypeValueTable::value_copy"] [:: std :: mem :: offset_of ! (_GTypeValueTable , value_copy) - 16usize] ; ["Offset of field: _GTypeValueTable::value_peek_pointer"] [:: std :: mem :: offset_of ! (_GTypeValueTable , value_peek_pointer) - 24usize] ; ["Offset of field: _GTypeValueTable::collect_format"] [:: std :: mem :: offset_of ! (_GTypeValueTable , collect_format) - 32usize] ; ["Offset of field: _GTypeValueTable::collect_value"] [:: std :: mem :: offset_of ! (_GTypeValueTable , collect_value) - 40usize] ; ["Offset of field: _GTypeValueTable::lcopy_format"] [:: std :: mem :: offset_of ! (_GTypeValueTable , lcopy_format) - 48usize] ; ["Offset of field: _GTypeValueTable::lcopy_value"] [:: std :: mem :: offset_of ! (_GTypeValueTable , lcopy_value) - 56usize] ; } ; unsafe extern "C" { pub fn g_type_register_static (parent_type : GType , type_name : * const gchar , info : * const GTypeInfo , flags : GTypeFlags) -> GType ; } unsafe extern "C" { pub fn g_type_register_static_simple (parent_type : GType , type_name : * const gchar , class_size : guint , class_init : GClassInitFunc , instance_size : guint , instance_init : GInstanceInitFunc , flags : GTypeFlags) -> GType ; } unsafe extern "C" { pub fn g_type_register_dynamic (parent_type : GType , type_name : * const gchar , plugin : * mut GTypePlugin , flags : GTypeFlags) -> GType ; } unsafe extern "C" { pub fn g_type_register_fundamental (type_id : GType , type_name : * const gchar , info : * const GTypeInfo , finfo : * const GTypeFundamentalInfo , flags : GTypeFlags) -> GType ; } unsafe extern "C" { pub fn g_type_add_interface_static (instance_type : GType , interface_type : GType , info : * const GInterfaceInfo) ; } unsafe extern "C" { pub fn g_type_add_interface_dynamic (instance_type : GType , interface_type : GType , plugin : * mut GTypePlugin) ; } unsafe extern "C" { pub fn g_type_interface_add_prerequisite (interface_type : GType , prerequisite_type : GType) ; } unsafe extern "C" { pub fn g_type_interface_prerequisites (interface_type : GType , n_prerequisites : * mut guint) -> * mut GType ; } unsafe extern "C" { pub fn g_type_interface_instantiatable_prerequisite (interface_type : GType) -> GType ; } unsafe extern "C" { pub fn g_type_class_add_private (g_class : gpointer , private_size : gsize) ; } unsafe extern "C" { pub fn g_type_add_instance_private (class_type : GType , private_size : gsize) -> gint ; } unsafe extern "C" { pub fn g_type_instance_get_private (instance : * mut GTypeInstance , private_type : GType) -> gpointer ; } unsafe extern "C" { pub fn g_type_class_adjust_private_offset (g_class : gpointer , private_size_or_offset : * mut gint) ; } unsafe extern "C" { pub fn g_type_add_class_private (class_type : GType , private_size : gsize) ; } unsafe extern "C" { pub fn g_type_class_get_private (klass : * mut GTypeClass , private_type : GType) -> gpointer ; } unsafe extern "C" { pub fn g_type_class_get_instance_private_offset (g_class : gpointer) -> gint ; } unsafe extern "C" { pub fn g_type_ensure (type_ : GType) ; } unsafe extern "C" { pub fn g_type_get_type_registration_serial () -> guint ; } unsafe extern "C" { pub fn g_type_get_plugin (type_ : GType) -> * mut GTypePlugin ; } unsafe extern "C" { pub fn g_type_interface_get_plugin (instance_type : GType , interface_type : GType) -> * mut GTypePlugin ; } unsafe extern "C" { pub fn g_type_fundamental_next () -> GType ; } unsafe extern "C" { pub fn g_type_fundamental (type_id : GType) -> GType ; } unsafe extern "C" { pub fn g_type_create_instance (type_ : GType) -> * mut GTypeInstance ; } unsafe extern "C" { pub fn g_type_free_instance (instance : * mut GTypeInstance) ; } unsafe extern "C" { pub fn g_type_add_class_cache_func (cache_data : gpointer , cache_func : GTypeClassCacheFunc) ; } unsafe extern "C" { pub fn g_type_remove_class_cache_func (cache_data : gpointer , cache_func : GTypeClassCacheFunc) ; } unsafe extern "C" { pub fn g_type_class_unref_uncached (g_class : gpointer) ; } unsafe extern "C" { pub fn g_type_add_interface_check (check_data : gpointer , check_func : GTypeInterfaceCheckFunc) ; } unsafe extern "C" { pub fn g_type_remove_interface_check (check_data : gpointer , check_func : GTypeInterfaceCheckFunc) ; } unsafe extern "C" { pub fn g_type_value_table_peek (type_ : GType) -> * mut GTypeValueTable ; } unsafe extern "C" { pub fn g_type_check_instance (instance : * mut GTypeInstance) -> gboolean ; } unsafe extern "C" { pub fn g_type_check_instance_cast (instance : * mut GTypeInstance , iface_type : GType) -> * mut GTypeInstance ; } unsafe extern "C" { pub fn g_type_check_instance_is_a (instance : * mut GTypeInstance , iface_type : GType) -> gboolean ; } unsafe extern "C" { pub fn g_type_check_instance_is_fundamentally_a (instance : * mut GTypeInstance , fundamental_type : GType) -> gboolean ; } unsafe extern "C" { pub fn g_type_check_class_cast (g_class : * mut GTypeClass , is_a_type : GType) -> * mut GTypeClass ; } unsafe extern "C" { pub fn g_type_check_class_is_a (g_class : * mut GTypeClass , is_a_type : GType) -> gboolean ; } unsafe extern "C" { pub fn g_type_check_is_value_type (type_ : GType) -> gboolean ; } unsafe extern "C" { pub fn g_type_check_value (value : * const GValue) -> gboolean ; } unsafe extern "C" { pub fn g_type_check_value_holds (value : * const GValue , type_ : GType) -> gboolean ; } unsafe extern "C" { pub fn g_type_test_flags (type_ : GType , flags : guint) -> gboolean ; } unsafe extern "C" { pub fn g_type_name_from_instance (instance : * mut GTypeInstance) -> * const gchar ; } unsafe extern "C" { pub fn g_type_name_from_class (g_class : * mut GTypeClass) -> * const gchar ; } pub type GValueTransform = :: std :: option :: Option < unsafe extern "C" fn (src_value : * const GValue , dest_value : * mut GValue) > ; # [repr (C)] # [derive (Copy , Clone)] pub struct _GValue { pub g_type : GType , pub data : [_GValue__bindgen_ty_1 ; 2usize] , } # [repr (C)] # [derive (Copy , Clone)] pub union _GValue__bindgen_ty_1 { pub v_int : gint , pub v_uint : guint , pub v_long : glong , pub v_ulong : gulong , pub v_int64 : gint64 , pub v_uint64 : guint64 , pub v_float : gfloat , pub v_double : gdouble , pub v_pointer : gpointer , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GValue__bindgen_ty_1"] [:: std :: mem :: size_of :: < _GValue__bindgen_ty_1 > () - 8usize] ; ["Alignment of _GValue__bindgen_ty_1"] [:: std :: mem :: align_of :: < _GValue__bindgen_ty_1 > () - 8usize] ; ["Offset of field: _GValue__bindgen_ty_1::v_int"] [:: std :: mem :: offset_of ! (_GValue__bindgen_ty_1 , v_int) - 0usize] ; ["Offset of field: _GValue__bindgen_ty_1::v_uint"] [:: std :: mem :: offset_of ! (_GValue__bindgen_ty_1 , v_uint) - 0usize] ; ["Offset of field: _GValue__bindgen_ty_1::v_long"] [:: std :: mem :: offset_of ! (_GValue__bindgen_ty_1 , v_long) - 0usize] ; ["Offset of field: _GValue__bindgen_ty_1::v_ulong"] [:: std :: mem :: offset_of ! (_GValue__bindgen_ty_1 , v_ulong) - 0usize] ; ["Offset of field: _GValue__bindgen_ty_1::v_int64"] [:: std :: mem :: offset_of ! (_GValue__bindgen_ty_1 , v_int64) - 0usize] ; ["Offset of field: _GValue__bindgen_ty_1::v_uint64"] [:: std :: mem :: offset_of ! (_GValue__bindgen_ty_1 , v_uint64) - 0usize] ; ["Offset of field: _GValue__bindgen_ty_1::v_float"] [:: std :: mem :: offset_of ! (_GValue__bindgen_ty_1 , v_float) - 0usize] ; ["Offset of field: _GValue__bindgen_ty_1::v_double"] [:: std :: mem :: offset_of ! (_GValue__bindgen_ty_1 , v_double) - 0usize] ; ["Offset of field: _GValue__bindgen_ty_1::v_pointer"] [:: std :: mem :: offset_of ! (_GValue__bindgen_ty_1 , v_pointer) - 0usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GValue"] [:: std :: mem :: size_of :: < _GValue > () - 24usize] ; ["Alignment of _GValue"] [:: std :: mem :: align_of :: < _GValue > () - 8usize] ; ["Offset of field: _GValue::g_type"] [:: std :: mem :: offset_of ! (_GValue , g_type) - 0usize] ; ["Offset of field: _GValue::data"] [:: std :: mem :: offset_of ! (_GValue , data) - 8usize] ; } ; unsafe extern "C" { pub fn g_value_init (value : * mut GValue , g_type : GType) -> * mut GValue ; } unsafe extern "C" { pub fn g_value_copy (src_value : * const GValue , dest_value : * mut GValue) ; } unsafe extern "C" { pub fn g_value_reset (value : * mut GValue) -> * mut GValue ; } unsafe extern "C" { pub fn g_value_unset (value : * mut GValue) ; } unsafe extern "C" { pub fn g_value_set_instance (value : * mut GValue , instance : gpointer) ; } unsafe extern "C" { pub fn g_value_init_from_instance (value : * mut GValue , instance : gpointer) ; } unsafe extern "C" { pub fn g_value_fits_pointer (value : * const GValue) -> gboolean ; } unsafe extern "C" { pub fn g_value_peek_pointer (value : * const GValue) -> gpointer ; } unsafe extern "C" { pub fn g_value_type_compatible (src_type : GType , dest_type : GType) -> gboolean ; } unsafe extern "C" { pub fn g_value_type_transformable (src_type : GType , dest_type : GType) -> gboolean ; } unsafe extern "C" { pub fn g_value_transform (src_value : * const GValue , dest_value : * mut GValue) -> gboolean ; } unsafe extern "C" { pub fn g_value_register_transform_func (src_type : GType , dest_type : GType , transform_func : GValueTransform) ; } pub const GParamFlags_G_PARAM_READABLE : GParamFlags = 1 ; pub const GParamFlags_G_PARAM_WRITABLE : GParamFlags = 2 ; pub const GParamFlags_G_PARAM_READWRITE : GParamFlags = 3 ; pub const GParamFlags_G_PARAM_CONSTRUCT : GParamFlags = 4 ; pub const GParamFlags_G_PARAM_CONSTRUCT_ONLY : GParamFlags = 8 ; pub const GParamFlags_G_PARAM_LAX_VALIDATION : GParamFlags = 16 ; pub const GParamFlags_G_PARAM_STATIC_NAME : GParamFlags = 32 ; pub const GParamFlags_G_PARAM_PRIVATE : GParamFlags = 32 ; pub const GParamFlags_G_PARAM_STATIC_NICK : GParamFlags = 64 ; pub const GParamFlags_G_PARAM_STATIC_BLURB : GParamFlags = 128 ; pub const GParamFlags_G_PARAM_EXPLICIT_NOTIFY : GParamFlags = 1073741824 ; pub const GParamFlags_G_PARAM_DEPRECATED : GParamFlags = - 2147483648 ; pub type GParamFlags = :: std :: os :: raw :: c_int ; pub type GParamSpec = _GParamSpec ; pub type GParamSpecClass = _GParamSpecClass ; pub type GParameter = _GParameter ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecPool { _unused : [u8 ; 0] , } pub type GParamSpecPool = _GParamSpecPool ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpec { pub g_type_instance : GTypeInstance , pub name : * const gchar , pub flags : GParamFlags , pub value_type : GType , pub owner_type : GType , pub _nick : * mut gchar , pub _blurb : * mut gchar , pub qdata : * mut GData , pub ref_count : guint , pub param_id : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpec"] [:: std :: mem :: size_of :: < _GParamSpec > () - 72usize] ; ["Alignment of _GParamSpec"] [:: std :: mem :: align_of :: < _GParamSpec > () - 8usize] ; ["Offset of field: _GParamSpec::g_type_instance"] [:: std :: mem :: offset_of ! (_GParamSpec , g_type_instance) - 0usize] ; ["Offset of field: _GParamSpec::name"] [:: std :: mem :: offset_of ! (_GParamSpec , name) - 8usize] ; ["Offset of field: _GParamSpec::flags"] [:: std :: mem :: offset_of ! (_GParamSpec , flags) - 16usize] ; ["Offset of field: _GParamSpec::value_type"] [:: std :: mem :: offset_of ! (_GParamSpec , value_type) - 24usize] ; ["Offset of field: _GParamSpec::owner_type"] [:: std :: mem :: offset_of ! (_GParamSpec , owner_type) - 32usize] ; ["Offset of field: _GParamSpec::_nick"] [:: std :: mem :: offset_of ! (_GParamSpec , _nick) - 40usize] ; ["Offset of field: _GParamSpec::_blurb"] [:: std :: mem :: offset_of ! (_GParamSpec , _blurb) - 48usize] ; ["Offset of field: _GParamSpec::qdata"] [:: std :: mem :: offset_of ! (_GParamSpec , qdata) - 56usize] ; ["Offset of field: _GParamSpec::ref_count"] [:: std :: mem :: offset_of ! (_GParamSpec , ref_count) - 64usize] ; ["Offset of field: _GParamSpec::param_id"] [:: std :: mem :: offset_of ! (_GParamSpec , param_id) - 68usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecClass { pub g_type_class : GTypeClass , pub value_type : GType , pub finalize : :: std :: option :: Option < unsafe extern "C" fn (pspec : * mut GParamSpec) > , pub value_set_default : :: std :: option :: Option < unsafe extern "C" fn (pspec : * mut GParamSpec , value : * mut GValue) > , pub value_validate : :: std :: option :: Option < unsafe extern "C" fn (pspec : * mut GParamSpec , value : * mut GValue) -> gboolean > , pub values_cmp : :: std :: option :: Option < unsafe extern "C" fn (pspec : * mut GParamSpec , value1 : * const GValue , value2 : * const GValue) -> gint > , pub value_is_valid : :: std :: option :: Option < unsafe extern "C" fn (pspec : * mut GParamSpec , value : * const GValue) -> gboolean > , pub dummy : [gpointer ; 3usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecClass"] [:: std :: mem :: size_of :: < _GParamSpecClass > () - 80usize] ; ["Alignment of _GParamSpecClass"] [:: std :: mem :: align_of :: < _GParamSpecClass > () - 8usize] ; ["Offset of field: _GParamSpecClass::g_type_class"] [:: std :: mem :: offset_of ! (_GParamSpecClass , g_type_class) - 0usize] ; ["Offset of field: _GParamSpecClass::value_type"] [:: std :: mem :: offset_of ! (_GParamSpecClass , value_type) - 8usize] ; ["Offset of field: _GParamSpecClass::finalize"] [:: std :: mem :: offset_of ! (_GParamSpecClass , finalize) - 16usize] ; ["Offset of field: _GParamSpecClass::value_set_default"] [:: std :: mem :: offset_of ! (_GParamSpecClass , value_set_default) - 24usize] ; ["Offset of field: _GParamSpecClass::value_validate"] [:: std :: mem :: offset_of ! (_GParamSpecClass , value_validate) - 32usize] ; ["Offset of field: _GParamSpecClass::values_cmp"] [:: std :: mem :: offset_of ! (_GParamSpecClass , values_cmp) - 40usize] ; ["Offset of field: _GParamSpecClass::value_is_valid"] [:: std :: mem :: offset_of ! (_GParamSpecClass , value_is_valid) - 48usize] ; ["Offset of field: _GParamSpecClass::dummy"] [:: std :: mem :: offset_of ! (_GParamSpecClass , dummy) - 56usize] ; } ; # [repr (C)] # [derive (Copy , Clone)] pub struct _GParameter { pub name : * const gchar , pub value : GValue , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParameter"] [:: std :: mem :: size_of :: < _GParameter > () - 32usize] ; ["Alignment of _GParameter"] [:: std :: mem :: align_of :: < _GParameter > () - 8usize] ; ["Offset of field: _GParameter::name"] [:: std :: mem :: offset_of ! (_GParameter , name) - 0usize] ; ["Offset of field: _GParameter::value"] [:: std :: mem :: offset_of ! (_GParameter , value) - 8usize] ; } ; unsafe extern "C" { pub fn g_param_spec_ref (pspec : * mut GParamSpec) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_unref (pspec : * mut GParamSpec) ; } unsafe extern "C" { pub fn g_param_spec_sink (pspec : * mut GParamSpec) ; } unsafe extern "C" { pub fn g_param_spec_ref_sink (pspec : * mut GParamSpec) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_get_qdata (pspec : * mut GParamSpec , quark : GQuark) -> gpointer ; } unsafe extern "C" { pub fn g_param_spec_set_qdata (pspec : * mut GParamSpec , quark : GQuark , data : gpointer) ; } unsafe extern "C" { pub fn g_param_spec_set_qdata_full (pspec : * mut GParamSpec , quark : GQuark , data : gpointer , destroy : GDestroyNotify) ; } unsafe extern "C" { pub fn g_param_spec_steal_qdata (pspec : * mut GParamSpec , quark : GQuark) -> gpointer ; } unsafe extern "C" { pub fn g_param_spec_get_redirect_target (pspec : * mut GParamSpec) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_value_set_default (pspec : * mut GParamSpec , value : * mut GValue) ; } unsafe extern "C" { pub fn g_param_value_defaults (pspec : * mut GParamSpec , value : * const GValue) -> gboolean ; } unsafe extern "C" { pub fn g_param_value_validate (pspec : * mut GParamSpec , value : * mut GValue) -> gboolean ; } unsafe extern "C" { pub fn g_param_value_is_valid (pspec : * mut GParamSpec , value : * const GValue) -> gboolean ; } unsafe extern "C" { pub fn g_param_value_convert (pspec : * mut GParamSpec , src_value : * const GValue , dest_value : * mut GValue , strict_validation : gboolean) -> gboolean ; } unsafe extern "C" { pub fn g_param_values_cmp (pspec : * mut GParamSpec , value1 : * const GValue , value2 : * const GValue) -> gint ; } unsafe extern "C" { pub fn g_param_spec_get_name (pspec : * mut GParamSpec) -> * const gchar ; } unsafe extern "C" { pub fn g_param_spec_get_nick (pspec : * mut GParamSpec) -> * const gchar ; } unsafe extern "C" { pub fn g_param_spec_get_blurb (pspec : * mut GParamSpec) -> * const gchar ; } unsafe extern "C" { pub fn g_value_set_param (value : * mut GValue , param : * mut GParamSpec) ; } unsafe extern "C" { pub fn g_value_get_param (value : * const GValue) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_value_dup_param (value : * const GValue) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_value_take_param (value : * mut GValue , param : * mut GParamSpec) ; } unsafe extern "C" { pub fn g_value_set_param_take_ownership (value : * mut GValue , param : * mut GParamSpec) ; } unsafe extern "C" { pub fn g_param_spec_get_default_value (pspec : * mut GParamSpec) -> * const GValue ; } unsafe extern "C" { pub fn g_param_spec_get_name_quark (pspec : * mut GParamSpec) -> GQuark ; } pub type GParamSpecTypeInfo = _GParamSpecTypeInfo ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecTypeInfo { pub instance_size : guint16 , pub n_preallocs : guint16 , pub instance_init : :: std :: option :: Option < unsafe extern "C" fn (pspec : * mut GParamSpec) > , pub value_type : GType , pub finalize : :: std :: option :: Option < unsafe extern "C" fn (pspec : * mut GParamSpec) > , pub value_set_default : :: std :: option :: Option < unsafe extern "C" fn (pspec : * mut GParamSpec , value : * mut GValue) > , pub value_validate : :: std :: option :: Option < unsafe extern "C" fn (pspec : * mut GParamSpec , value : * mut GValue) -> gboolean > , pub values_cmp : :: std :: option :: Option < unsafe extern "C" fn (pspec : * mut GParamSpec , value1 : * const GValue , value2 : * const GValue) -> gint > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecTypeInfo"] [:: std :: mem :: size_of :: < _GParamSpecTypeInfo > () - 56usize] ; ["Alignment of _GParamSpecTypeInfo"] [:: std :: mem :: align_of :: < _GParamSpecTypeInfo > () - 8usize] ; ["Offset of field: _GParamSpecTypeInfo::instance_size"] [:: std :: mem :: offset_of ! (_GParamSpecTypeInfo , instance_size) - 0usize] ; ["Offset of field: _GParamSpecTypeInfo::n_preallocs"] [:: std :: mem :: offset_of ! (_GParamSpecTypeInfo , n_preallocs) - 2usize] ; ["Offset of field: _GParamSpecTypeInfo::instance_init"] [:: std :: mem :: offset_of ! (_GParamSpecTypeInfo , instance_init) - 8usize] ; ["Offset of field: _GParamSpecTypeInfo::value_type"] [:: std :: mem :: offset_of ! (_GParamSpecTypeInfo , value_type) - 16usize] ; ["Offset of field: _GParamSpecTypeInfo::finalize"] [:: std :: mem :: offset_of ! (_GParamSpecTypeInfo , finalize) - 24usize] ; ["Offset of field: _GParamSpecTypeInfo::value_set_default"] [:: std :: mem :: offset_of ! (_GParamSpecTypeInfo , value_set_default) - 32usize] ; ["Offset of field: _GParamSpecTypeInfo::value_validate"] [:: std :: mem :: offset_of ! (_GParamSpecTypeInfo , value_validate) - 40usize] ; ["Offset of field: _GParamSpecTypeInfo::values_cmp"] [:: std :: mem :: offset_of ! (_GParamSpecTypeInfo , values_cmp) - 48usize] ; } ; unsafe extern "C" { pub fn g_param_type_register_static (name : * const gchar , pspec_info : * const GParamSpecTypeInfo) -> GType ; } unsafe extern "C" { pub fn g_param_spec_is_valid_name (name : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn _g_param_type_register_static_constant (name : * const gchar , pspec_info : * const GParamSpecTypeInfo , opt_type : GType) -> GType ; } unsafe extern "C" { pub fn g_param_spec_internal (param_type : GType , name : * const gchar , nick : * const gchar , blurb : * const gchar , flags : GParamFlags) -> gpointer ; } unsafe extern "C" { pub fn g_param_spec_pool_new (type_prefixing : gboolean) -> * mut GParamSpecPool ; } unsafe extern "C" { pub fn g_param_spec_pool_insert (pool : * mut GParamSpecPool , pspec : * mut GParamSpec , owner_type : GType) ; } unsafe extern "C" { pub fn g_param_spec_pool_remove (pool : * mut GParamSpecPool , pspec : * mut GParamSpec) ; } unsafe extern "C" { pub fn g_param_spec_pool_lookup (pool : * mut GParamSpecPool , param_name : * const gchar , owner_type : GType , walk_ancestors : gboolean) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_pool_list_owned (pool : * mut GParamSpecPool , owner_type : GType) -> * mut GList ; } unsafe extern "C" { pub fn g_param_spec_pool_list (pool : * mut GParamSpecPool , owner_type : GType , n_pspecs_p : * mut guint) -> * mut * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_pool_free (pool : * mut GParamSpecPool) ; } pub type GClosure = _GClosure ; pub type GClosureNotifyData = _GClosureNotifyData ; pub type GCallback = :: std :: option :: Option < unsafe extern "C" fn () > ; pub type GClosureNotify = :: std :: option :: Option < unsafe extern "C" fn (data : gpointer , closure : * mut GClosure) > ; pub type GClosureMarshal = :: std :: option :: Option < unsafe extern "C" fn (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) > ; pub type GVaClosureMarshal = :: std :: option :: Option < unsafe extern "C" fn (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) > ; pub type GCClosure = _GCClosure ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GClosureNotifyData { pub data : gpointer , pub notify : GClosureNotify , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GClosureNotifyData"] [:: std :: mem :: size_of :: < _GClosureNotifyData > () - 16usize] ; ["Alignment of _GClosureNotifyData"] [:: std :: mem :: align_of :: < _GClosureNotifyData > () - 8usize] ; ["Offset of field: _GClosureNotifyData::data"] [:: std :: mem :: offset_of ! (_GClosureNotifyData , data) - 0usize] ; ["Offset of field: _GClosureNotifyData::notify"] [:: std :: mem :: offset_of ! (_GClosureNotifyData , notify) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GClosure { pub _bitfield_align_1 : [u16 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 4usize] > , pub marshal : :: std :: option :: Option < unsafe extern "C" fn (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) > , pub data : gpointer , pub notifiers : * mut GClosureNotifyData , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GClosure"] [:: std :: mem :: size_of :: < _GClosure > () - 32usize] ; ["Alignment of _GClosure"] [:: std :: mem :: align_of :: < _GClosure > () - 8usize] ; ["Offset of field: _GClosure::marshal"] [:: std :: mem :: offset_of ! (_GClosure , marshal) - 8usize] ; ["Offset of field: _GClosure::data"] [:: std :: mem :: offset_of ! (_GClosure , data) - 16usize] ; ["Offset of field: _GClosure::notifiers"] [:: std :: mem :: offset_of ! (_GClosure , notifiers) - 24usize] ; } ; impl _GClosure { # [inline] pub fn ref_count (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 15u8) as u32) } } # [inline] pub fn set_ref_count (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 15u8 , val as u64) } } # [inline] pub unsafe fn ref_count_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 0usize , 15u8 ,) as u32) } } # [inline] pub unsafe fn set_ref_count_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 0usize , 15u8 , val as u64 ,) } } # [inline] pub fn meta_marshal_nouse (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (15usize , 1u8) as u32) } } # [inline] pub fn set_meta_marshal_nouse (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (15usize , 1u8 , val as u64) } } # [inline] pub unsafe fn meta_marshal_nouse_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 15usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_meta_marshal_nouse_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 15usize , 1u8 , val as u64 ,) } } # [inline] pub fn n_guards (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (16usize , 1u8) as u32) } } # [inline] pub fn set_n_guards (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (16usize , 1u8 , val as u64) } } # [inline] pub unsafe fn n_guards_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 16usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_n_guards_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 16usize , 1u8 , val as u64 ,) } } # [inline] pub fn n_fnotifiers (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (17usize , 2u8) as u32) } } # [inline] pub fn set_n_fnotifiers (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (17usize , 2u8 , val as u64) } } # [inline] pub unsafe fn n_fnotifiers_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 17usize , 2u8 ,) as u32) } } # [inline] pub unsafe fn set_n_fnotifiers_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 17usize , 2u8 , val as u64 ,) } } # [inline] pub fn n_inotifiers (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (19usize , 8u8) as u32) } } # [inline] pub fn set_n_inotifiers (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (19usize , 8u8 , val as u64) } } # [inline] pub unsafe fn n_inotifiers_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 19usize , 8u8 ,) as u32) } } # [inline] pub unsafe fn set_n_inotifiers_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 19usize , 8u8 , val as u64 ,) } } # [inline] pub fn in_inotify (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (27usize , 1u8) as u32) } } # [inline] pub fn set_in_inotify (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (27usize , 1u8 , val as u64) } } # [inline] pub unsafe fn in_inotify_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 27usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_in_inotify_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 27usize , 1u8 , val as u64 ,) } } # [inline] pub fn floating (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (28usize , 1u8) as u32) } } # [inline] pub fn set_floating (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (28usize , 1u8 , val as u64) } } # [inline] pub unsafe fn floating_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 28usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_floating_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 28usize , 1u8 , val as u64 ,) } } # [inline] pub fn derivative_flag (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (29usize , 1u8) as u32) } } # [inline] pub fn set_derivative_flag (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (29usize , 1u8 , val as u64) } } # [inline] pub unsafe fn derivative_flag_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 29usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_derivative_flag_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 29usize , 1u8 , val as u64 ,) } } # [inline] pub fn in_marshal (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (30usize , 1u8) as u32) } } # [inline] pub fn set_in_marshal (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (30usize , 1u8 , val as u64) } } # [inline] pub unsafe fn in_marshal_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 30usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_in_marshal_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 30usize , 1u8 , val as u64 ,) } } # [inline] pub fn is_invalid (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (31usize , 1u8) as u32) } } # [inline] pub fn set_is_invalid (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (31usize , 1u8 , val as u64) } } # [inline] pub unsafe fn is_invalid_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 31usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_is_invalid_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 31usize , 1u8 , val as u64 ,) } } # [inline] pub fn new_bitfield_1 (ref_count : guint , meta_marshal_nouse : guint , n_guards : guint , n_fnotifiers : guint , n_inotifiers : guint , in_inotify : guint , floating : guint , derivative_flag : guint , in_marshal : guint , is_invalid : guint) -> __BindgenBitfieldUnit < [u8 ; 4usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 4usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 15u8 , { let ref_count : u32 = unsafe { :: std :: mem :: transmute (ref_count) } ; ref_count as u64 }) ; __bindgen_bitfield_unit . set (15usize , 1u8 , { let meta_marshal_nouse : u32 = unsafe { :: std :: mem :: transmute (meta_marshal_nouse) } ; meta_marshal_nouse as u64 }) ; __bindgen_bitfield_unit . set (16usize , 1u8 , { let n_guards : u32 = unsafe { :: std :: mem :: transmute (n_guards) } ; n_guards as u64 }) ; __bindgen_bitfield_unit . set (17usize , 2u8 , { let n_fnotifiers : u32 = unsafe { :: std :: mem :: transmute (n_fnotifiers) } ; n_fnotifiers as u64 }) ; __bindgen_bitfield_unit . set (19usize , 8u8 , { let n_inotifiers : u32 = unsafe { :: std :: mem :: transmute (n_inotifiers) } ; n_inotifiers as u64 }) ; __bindgen_bitfield_unit . set (27usize , 1u8 , { let in_inotify : u32 = unsafe { :: std :: mem :: transmute (in_inotify) } ; in_inotify as u64 }) ; __bindgen_bitfield_unit . set (28usize , 1u8 , { let floating : u32 = unsafe { :: std :: mem :: transmute (floating) } ; floating as u64 }) ; __bindgen_bitfield_unit . set (29usize , 1u8 , { let derivative_flag : u32 = unsafe { :: std :: mem :: transmute (derivative_flag) } ; derivative_flag as u64 }) ; __bindgen_bitfield_unit . set (30usize , 1u8 , { let in_marshal : u32 = unsafe { :: std :: mem :: transmute (in_marshal) } ; in_marshal as u64 }) ; __bindgen_bitfield_unit . set (31usize , 1u8 , { let is_invalid : u32 = unsafe { :: std :: mem :: transmute (is_invalid) } ; is_invalid as u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GCClosure { pub closure : GClosure , pub callback : gpointer , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GCClosure"] [:: std :: mem :: size_of :: < _GCClosure > () - 40usize] ; ["Alignment of _GCClosure"] [:: std :: mem :: align_of :: < _GCClosure > () - 8usize] ; ["Offset of field: _GCClosure::closure"] [:: std :: mem :: offset_of ! (_GCClosure , closure) - 0usize] ; ["Offset of field: _GCClosure::callback"] [:: std :: mem :: offset_of ! (_GCClosure , callback) - 32usize] ; } ; unsafe extern "C" { pub fn g_cclosure_new (callback_func : GCallback , user_data : gpointer , destroy_data : GClosureNotify) -> * mut GClosure ; } unsafe extern "C" { pub fn g_cclosure_new_swap (callback_func : GCallback , user_data : gpointer , destroy_data : GClosureNotify) -> * mut GClosure ; } unsafe extern "C" { pub fn g_signal_type_cclosure_new (itype : GType , struct_offset : guint) -> * mut GClosure ; } unsafe extern "C" { pub fn g_closure_ref (closure : * mut GClosure) -> * mut GClosure ; } unsafe extern "C" { pub fn g_closure_sink (closure : * mut GClosure) ; } unsafe extern "C" { pub fn g_closure_unref (closure : * mut GClosure) ; } unsafe extern "C" { pub fn g_closure_new_simple (sizeof_closure : guint , data : gpointer) -> * mut GClosure ; } unsafe extern "C" { pub fn g_closure_add_finalize_notifier (closure : * mut GClosure , notify_data : gpointer , notify_func : GClosureNotify) ; } unsafe extern "C" { pub fn g_closure_remove_finalize_notifier (closure : * mut GClosure , notify_data : gpointer , notify_func : GClosureNotify) ; } unsafe extern "C" { pub fn g_closure_add_invalidate_notifier (closure : * mut GClosure , notify_data : gpointer , notify_func : GClosureNotify) ; } unsafe extern "C" { pub fn g_closure_remove_invalidate_notifier (closure : * mut GClosure , notify_data : gpointer , notify_func : GClosureNotify) ; } unsafe extern "C" { pub fn g_closure_add_marshal_guards (closure : * mut GClosure , pre_marshal_data : gpointer , pre_marshal_notify : GClosureNotify , post_marshal_data : gpointer , post_marshal_notify : GClosureNotify) ; } unsafe extern "C" { pub fn g_closure_set_marshal (closure : * mut GClosure , marshal : GClosureMarshal) ; } unsafe extern "C" { pub fn g_closure_set_meta_marshal (closure : * mut GClosure , marshal_data : gpointer , meta_marshal : GClosureMarshal) ; } unsafe extern "C" { pub fn g_closure_invalidate (closure : * mut GClosure) ; } unsafe extern "C" { pub fn g_closure_invoke (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_generic (closure : * mut GClosure , return_gvalue : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_generic_va (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args_list : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__VOID (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__VOIDv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__BOOLEAN (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__BOOLEANv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__CHAR (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__CHARv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__UCHAR (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__UCHARv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__INT (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__INTv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__UINT (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__UINTv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__LONG (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__LONGv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__ULONG (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__ULONGv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__ENUM (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__ENUMv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__FLAGS (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__FLAGSv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__FLOAT (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__FLOATv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__DOUBLE (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__DOUBLEv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__STRING (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__STRINGv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__PARAM (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__PARAMv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__BOXED (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__BOXEDv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__POINTER (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__POINTERv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__OBJECT (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__OBJECTv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__VARIANT (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__VARIANTv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__UINT_POINTER (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_VOID__UINT_POINTERv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_BOOLEAN__FLAGS (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_BOOLEAN__FLAGSv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_STRING__OBJECT_POINTER (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_STRING__OBJECT_POINTERv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } unsafe extern "C" { pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED (closure : * mut GClosure , return_value : * mut GValue , n_param_values : guint , param_values : * const GValue , invocation_hint : gpointer , marshal_data : gpointer) ; } unsafe extern "C" { pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv (closure : * mut GClosure , return_value : * mut GValue , instance : gpointer , args : * mut __va_list_tag , marshal_data : gpointer , n_params : :: std :: os :: raw :: c_int , param_types : * mut GType) ; } pub type GSignalQuery = _GSignalQuery ; pub type GSignalInvocationHint = _GSignalInvocationHint ; pub type GSignalCMarshaller = GClosureMarshal ; pub type GSignalCVaMarshaller = GVaClosureMarshal ; pub type GSignalEmissionHook = :: std :: option :: Option < unsafe extern "C" fn (ihint : * mut GSignalInvocationHint , n_param_values : guint , param_values : * const GValue , data : gpointer) -> gboolean > ; pub type GSignalAccumulator = :: std :: option :: Option < unsafe extern "C" fn (ihint : * mut GSignalInvocationHint , return_accu : * mut GValue , handler_return : * const GValue , data : gpointer) -> gboolean > ; pub const GSignalFlags_G_SIGNAL_RUN_FIRST : GSignalFlags = 1 ; pub const GSignalFlags_G_SIGNAL_RUN_LAST : GSignalFlags = 2 ; pub const GSignalFlags_G_SIGNAL_RUN_CLEANUP : GSignalFlags = 4 ; pub const GSignalFlags_G_SIGNAL_NO_RECURSE : GSignalFlags = 8 ; pub const GSignalFlags_G_SIGNAL_DETAILED : GSignalFlags = 16 ; pub const GSignalFlags_G_SIGNAL_ACTION : GSignalFlags = 32 ; pub const GSignalFlags_G_SIGNAL_NO_HOOKS : GSignalFlags = 64 ; pub const GSignalFlags_G_SIGNAL_MUST_COLLECT : GSignalFlags = 128 ; pub const GSignalFlags_G_SIGNAL_DEPRECATED : GSignalFlags = 256 ; pub const GSignalFlags_G_SIGNAL_ACCUMULATOR_FIRST_RUN : GSignalFlags = 131072 ; pub type GSignalFlags = :: std :: os :: raw :: c_uint ; pub const GConnectFlags_G_CONNECT_DEFAULT : GConnectFlags = 0 ; pub const GConnectFlags_G_CONNECT_AFTER : GConnectFlags = 1 ; pub const GConnectFlags_G_CONNECT_SWAPPED : GConnectFlags = 2 ; pub type GConnectFlags = :: std :: os :: raw :: c_uint ; pub const GSignalMatchType_G_SIGNAL_MATCH_ID : GSignalMatchType = 1 ; pub const GSignalMatchType_G_SIGNAL_MATCH_DETAIL : GSignalMatchType = 2 ; pub const GSignalMatchType_G_SIGNAL_MATCH_CLOSURE : GSignalMatchType = 4 ; pub const GSignalMatchType_G_SIGNAL_MATCH_FUNC : GSignalMatchType = 8 ; pub const GSignalMatchType_G_SIGNAL_MATCH_DATA : GSignalMatchType = 16 ; pub const GSignalMatchType_G_SIGNAL_MATCH_UNBLOCKED : GSignalMatchType = 32 ; pub type GSignalMatchType = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSignalInvocationHint { pub signal_id : guint , pub detail : GQuark , pub run_type : GSignalFlags , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSignalInvocationHint"] [:: std :: mem :: size_of :: < _GSignalInvocationHint > () - 12usize] ; ["Alignment of _GSignalInvocationHint"] [:: std :: mem :: align_of :: < _GSignalInvocationHint > () - 4usize] ; ["Offset of field: _GSignalInvocationHint::signal_id"] [:: std :: mem :: offset_of ! (_GSignalInvocationHint , signal_id) - 0usize] ; ["Offset of field: _GSignalInvocationHint::detail"] [:: std :: mem :: offset_of ! (_GSignalInvocationHint , detail) - 4usize] ; ["Offset of field: _GSignalInvocationHint::run_type"] [:: std :: mem :: offset_of ! (_GSignalInvocationHint , run_type) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSignalQuery { pub signal_id : guint , pub signal_name : * const gchar , pub itype : GType , pub signal_flags : GSignalFlags , pub return_type : GType , pub n_params : guint , pub param_types : * const GType , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSignalQuery"] [:: std :: mem :: size_of :: < _GSignalQuery > () - 56usize] ; ["Alignment of _GSignalQuery"] [:: std :: mem :: align_of :: < _GSignalQuery > () - 8usize] ; ["Offset of field: _GSignalQuery::signal_id"] [:: std :: mem :: offset_of ! (_GSignalQuery , signal_id) - 0usize] ; ["Offset of field: _GSignalQuery::signal_name"] [:: std :: mem :: offset_of ! (_GSignalQuery , signal_name) - 8usize] ; ["Offset of field: _GSignalQuery::itype"] [:: std :: mem :: offset_of ! (_GSignalQuery , itype) - 16usize] ; ["Offset of field: _GSignalQuery::signal_flags"] [:: std :: mem :: offset_of ! (_GSignalQuery , signal_flags) - 24usize] ; ["Offset of field: _GSignalQuery::return_type"] [:: std :: mem :: offset_of ! (_GSignalQuery , return_type) - 32usize] ; ["Offset of field: _GSignalQuery::n_params"] [:: std :: mem :: offset_of ! (_GSignalQuery , n_params) - 40usize] ; ["Offset of field: _GSignalQuery::param_types"] [:: std :: mem :: offset_of ! (_GSignalQuery , param_types) - 48usize] ; } ; unsafe extern "C" { pub fn g_signal_newv (signal_name : * const gchar , itype : GType , signal_flags : GSignalFlags , class_closure : * mut GClosure , accumulator : GSignalAccumulator , accu_data : gpointer , c_marshaller : GSignalCMarshaller , return_type : GType , n_params : guint , param_types : * mut GType) -> guint ; } unsafe extern "C" { pub fn g_signal_new_valist (signal_name : * const gchar , itype : GType , signal_flags : GSignalFlags , class_closure : * mut GClosure , accumulator : GSignalAccumulator , accu_data : gpointer , c_marshaller : GSignalCMarshaller , return_type : GType , n_params : guint , args : * mut __va_list_tag) -> guint ; } unsafe extern "C" { pub fn g_signal_new (signal_name : * const gchar , itype : GType , signal_flags : GSignalFlags , class_offset : guint , accumulator : GSignalAccumulator , accu_data : gpointer , c_marshaller : GSignalCMarshaller , return_type : GType , n_params : guint , ...) -> guint ; } unsafe extern "C" { pub fn g_signal_new_class_handler (signal_name : * const gchar , itype : GType , signal_flags : GSignalFlags , class_handler : GCallback , accumulator : GSignalAccumulator , accu_data : gpointer , c_marshaller : GSignalCMarshaller , return_type : GType , n_params : guint , ...) -> guint ; } unsafe extern "C" { pub fn g_signal_set_va_marshaller (signal_id : guint , instance_type : GType , va_marshaller : GSignalCVaMarshaller) ; } unsafe extern "C" { pub fn g_signal_emitv (instance_and_params : * const GValue , signal_id : guint , detail : GQuark , return_value : * mut GValue) ; } unsafe extern "C" { pub fn g_signal_emit_valist (instance : gpointer , signal_id : guint , detail : GQuark , var_args : * mut __va_list_tag) ; } unsafe extern "C" { pub fn g_signal_emit (instance : gpointer , signal_id : guint , detail : GQuark , ...) ; } unsafe extern "C" { pub fn g_signal_emit_by_name (instance : gpointer , detailed_signal : * const gchar , ...) ; } unsafe extern "C" { pub fn g_signal_lookup (name : * const gchar , itype : GType) -> guint ; } unsafe extern "C" { pub fn g_signal_name (signal_id : guint) -> * const gchar ; } unsafe extern "C" { pub fn g_signal_query (signal_id : guint , query : * mut GSignalQuery) ; } unsafe extern "C" { pub fn g_signal_list_ids (itype : GType , n_ids : * mut guint) -> * mut guint ; } unsafe extern "C" { pub fn g_signal_is_valid_name (name : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_signal_parse_name (detailed_signal : * const gchar , itype : GType , signal_id_p : * mut guint , detail_p : * mut GQuark , force_detail_quark : gboolean) -> gboolean ; } unsafe extern "C" { pub fn g_signal_get_invocation_hint (instance : gpointer) -> * mut GSignalInvocationHint ; } unsafe extern "C" { pub fn g_signal_stop_emission (instance : gpointer , signal_id : guint , detail : GQuark) ; } unsafe extern "C" { pub fn g_signal_stop_emission_by_name (instance : gpointer , detailed_signal : * const gchar) ; } unsafe extern "C" { pub fn g_signal_add_emission_hook (signal_id : guint , detail : GQuark , hook_func : GSignalEmissionHook , hook_data : gpointer , data_destroy : GDestroyNotify) -> gulong ; } unsafe extern "C" { pub fn g_signal_remove_emission_hook (signal_id : guint , hook_id : gulong) ; } unsafe extern "C" { pub fn g_signal_has_handler_pending (instance : gpointer , signal_id : guint , detail : GQuark , may_be_blocked : gboolean) -> gboolean ; } unsafe extern "C" { pub fn g_signal_connect_closure_by_id (instance : gpointer , signal_id : guint , detail : GQuark , closure : * mut GClosure , after : gboolean) -> gulong ; } unsafe extern "C" { pub fn g_signal_connect_closure (instance : gpointer , detailed_signal : * const gchar , closure : * mut GClosure , after : gboolean) -> gulong ; } unsafe extern "C" { pub fn g_signal_connect_data (instance : gpointer , detailed_signal : * const gchar , c_handler : GCallback , data : gpointer , destroy_data : GClosureNotify , connect_flags : GConnectFlags) -> gulong ; } unsafe extern "C" { pub fn g_signal_handler_block (instance : gpointer , handler_id : gulong) ; } unsafe extern "C" { pub fn g_signal_handler_unblock (instance : gpointer , handler_id : gulong) ; } unsafe extern "C" { pub fn g_signal_handler_disconnect (instance : gpointer , handler_id : gulong) ; } unsafe extern "C" { pub fn g_signal_handler_is_connected (instance : gpointer , handler_id : gulong) -> gboolean ; } unsafe extern "C" { pub fn g_signal_handler_find (instance : gpointer , mask : GSignalMatchType , signal_id : guint , detail : GQuark , closure : * mut GClosure , func : gpointer , data : gpointer) -> gulong ; } unsafe extern "C" { pub fn g_signal_handlers_block_matched (instance : gpointer , mask : GSignalMatchType , signal_id : guint , detail : GQuark , closure : * mut GClosure , func : gpointer , data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_signal_handlers_unblock_matched (instance : gpointer , mask : GSignalMatchType , signal_id : guint , detail : GQuark , closure : * mut GClosure , func : gpointer , data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_signal_handlers_disconnect_matched (instance : gpointer , mask : GSignalMatchType , signal_id : guint , detail : GQuark , closure : * mut GClosure , func : gpointer , data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_clear_signal_handler (handler_id_ptr : * mut gulong , instance : gpointer) ; } unsafe extern "C" { pub fn g_signal_override_class_closure (signal_id : guint , instance_type : GType , class_closure : * mut GClosure) ; } unsafe extern "C" { pub fn g_signal_override_class_handler (signal_name : * const gchar , instance_type : GType , class_handler : GCallback) ; } unsafe extern "C" { pub fn g_signal_chain_from_overridden (instance_and_params : * const GValue , return_value : * mut GValue) ; } unsafe extern "C" { pub fn g_signal_chain_from_overridden_handler (instance : gpointer , ...) ; } unsafe extern "C" { pub fn g_signal_accumulator_true_handled (ihint : * mut GSignalInvocationHint , return_accu : * mut GValue , handler_return : * const GValue , dummy : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_signal_accumulator_first_wins (ihint : * mut GSignalInvocationHint , return_accu : * mut GValue , handler_return : * const GValue , dummy : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_signal_handlers_destroy (instance : gpointer) ; } unsafe extern "C" { pub fn _g_signals_destroy (itype : GType) ; } unsafe extern "C" { pub fn g_date_get_type () -> GType ; } unsafe extern "C" { pub fn g_strv_get_type () -> GType ; } unsafe extern "C" { pub fn g_gstring_get_type () -> GType ; } unsafe extern "C" { pub fn g_hash_table_get_type () -> GType ; } unsafe extern "C" { pub fn g_array_get_type () -> GType ; } unsafe extern "C" { pub fn g_byte_array_get_type () -> GType ; } unsafe extern "C" { pub fn g_ptr_array_get_type () -> GType ; } unsafe extern "C" { pub fn g_bytes_get_type () -> GType ; } unsafe extern "C" { pub fn g_variant_type_get_gtype () -> GType ; } unsafe extern "C" { pub fn g_regex_get_type () -> GType ; } unsafe extern "C" { pub fn g_match_info_get_type () -> GType ; } unsafe extern "C" { pub fn g_error_get_type () -> GType ; } unsafe extern "C" { pub fn g_date_time_get_type () -> GType ; } unsafe extern "C" { pub fn g_time_zone_get_type () -> GType ; } unsafe extern "C" { pub fn g_io_channel_get_type () -> GType ; } unsafe extern "C" { pub fn g_io_condition_get_type () -> GType ; } unsafe extern "C" { pub fn g_variant_builder_get_type () -> GType ; } unsafe extern "C" { pub fn g_variant_dict_get_type () -> GType ; } unsafe extern "C" { pub fn g_key_file_get_type () -> GType ; } unsafe extern "C" { pub fn g_main_loop_get_type () -> GType ; } unsafe extern "C" { pub fn g_main_context_get_type () -> GType ; } unsafe extern "C" { pub fn g_source_get_type () -> GType ; } unsafe extern "C" { pub fn g_pollfd_get_type () -> GType ; } unsafe extern "C" { pub fn g_thread_get_type () -> GType ; } unsafe extern "C" { pub fn g_checksum_get_type () -> GType ; } unsafe extern "C" { pub fn g_markup_parse_context_get_type () -> GType ; } unsafe extern "C" { pub fn g_mapped_file_get_type () -> GType ; } unsafe extern "C" { pub fn g_option_group_get_type () -> GType ; } unsafe extern "C" { pub fn g_uri_get_type () -> GType ; } unsafe extern "C" { pub fn g_tree_get_type () -> GType ; } unsafe extern "C" { pub fn g_pattern_spec_get_type () -> GType ; } unsafe extern "C" { pub fn g_bookmark_file_get_type () -> GType ; } unsafe extern "C" { pub fn g_hmac_get_type () -> GType ; } unsafe extern "C" { pub fn g_dir_get_type () -> GType ; } unsafe extern "C" { pub fn g_rand_get_type () -> GType ; } unsafe extern "C" { pub fn g_strv_builder_get_type () -> GType ; } unsafe extern "C" { pub fn g_variant_get_gtype () -> GType ; } pub type GBoxedCopyFunc = :: std :: option :: Option < unsafe extern "C" fn (boxed : gpointer) -> gpointer > ; pub type GBoxedFreeFunc = :: std :: option :: Option < unsafe extern "C" fn (boxed : gpointer) > ; unsafe extern "C" { pub fn g_boxed_copy (boxed_type : GType , src_boxed : gconstpointer) -> gpointer ; } unsafe extern "C" { pub fn g_boxed_free (boxed_type : GType , boxed : gpointer) ; } unsafe extern "C" { pub fn g_value_set_boxed (value : * mut GValue , v_boxed : gconstpointer) ; } unsafe extern "C" { pub fn g_value_set_static_boxed (value : * mut GValue , v_boxed : gconstpointer) ; } unsafe extern "C" { pub fn g_value_take_boxed (value : * mut GValue , v_boxed : gconstpointer) ; } unsafe extern "C" { pub fn g_value_set_boxed_take_ownership (value : * mut GValue , v_boxed : gconstpointer) ; } unsafe extern "C" { pub fn g_value_get_boxed (value : * const GValue) -> gpointer ; } unsafe extern "C" { pub fn g_value_dup_boxed (value : * const GValue) -> gpointer ; } unsafe extern "C" { pub fn g_boxed_type_register_static (name : * const gchar , boxed_copy : GBoxedCopyFunc , boxed_free : GBoxedFreeFunc) -> GType ; } unsafe extern "C" { pub fn g_closure_get_type () -> GType ; } unsafe extern "C" { pub fn g_value_get_type () -> GType ; } pub type GObject = _GObject ; pub type GObjectClass = _GObjectClass ; pub type GInitiallyUnowned = _GObject ; pub type GInitiallyUnownedClass = _GObjectClass ; pub type GObjectConstructParam = _GObjectConstructParam ; pub type GObjectGetPropertyFunc = :: std :: option :: Option < unsafe extern "C" fn (object : * mut GObject , property_id : guint , value : * mut GValue , pspec : * mut GParamSpec) > ; pub type GObjectSetPropertyFunc = :: std :: option :: Option < unsafe extern "C" fn (object : * mut GObject , property_id : guint , value : * const GValue , pspec : * mut GParamSpec) > ; pub type GObjectFinalizeFunc = :: std :: option :: Option < unsafe extern "C" fn (object : * mut GObject) > ; pub type GWeakNotify = :: std :: option :: Option < unsafe extern "C" fn (data : gpointer , where_the_object_was : * mut GObject) > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GObject { pub g_type_instance : GTypeInstance , pub ref_count : guint , pub qdata : * mut GData , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GObject"] [:: std :: mem :: size_of :: < _GObject > () - 24usize] ; ["Alignment of _GObject"] [:: std :: mem :: align_of :: < _GObject > () - 8usize] ; ["Offset of field: _GObject::g_type_instance"] [:: std :: mem :: offset_of ! (_GObject , g_type_instance) - 0usize] ; ["Offset of field: _GObject::ref_count"] [:: std :: mem :: offset_of ! (_GObject , ref_count) - 8usize] ; ["Offset of field: _GObject::qdata"] [:: std :: mem :: offset_of ! (_GObject , qdata) - 16usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GObjectClass { pub g_type_class : GTypeClass , pub construct_properties : * mut GSList , pub constructor : :: std :: option :: Option < unsafe extern "C" fn (type_ : GType , n_construct_properties : guint , construct_properties : * mut GObjectConstructParam) -> * mut GObject > , pub set_property : :: std :: option :: Option < unsafe extern "C" fn (object : * mut GObject , property_id : guint , value : * const GValue , pspec : * mut GParamSpec) > , pub get_property : :: std :: option :: Option < unsafe extern "C" fn (object : * mut GObject , property_id : guint , value : * mut GValue , pspec : * mut GParamSpec) > , pub dispose : :: std :: option :: Option < unsafe extern "C" fn (object : * mut GObject) > , pub finalize : :: std :: option :: Option < unsafe extern "C" fn (object : * mut GObject) > , pub dispatch_properties_changed : :: std :: option :: Option < unsafe extern "C" fn (object : * mut GObject , n_pspecs : guint , pspecs : * mut * mut GParamSpec) > , pub notify : :: std :: option :: Option < unsafe extern "C" fn (object : * mut GObject , pspec : * mut GParamSpec) > , pub constructed : :: std :: option :: Option < unsafe extern "C" fn (object : * mut GObject) > , pub flags : gsize , pub n_construct_properties : gsize , pub pspecs : gpointer , pub n_pspecs : gsize , pub pdummy : [gpointer ; 3usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GObjectClass"] [:: std :: mem :: size_of :: < _GObjectClass > () - 136usize] ; ["Alignment of _GObjectClass"] [:: std :: mem :: align_of :: < _GObjectClass > () - 8usize] ; ["Offset of field: _GObjectClass::g_type_class"] [:: std :: mem :: offset_of ! (_GObjectClass , g_type_class) - 0usize] ; ["Offset of field: _GObjectClass::construct_properties"] [:: std :: mem :: offset_of ! (_GObjectClass , construct_properties) - 8usize] ; ["Offset of field: _GObjectClass::constructor"] [:: std :: mem :: offset_of ! (_GObjectClass , constructor) - 16usize] ; ["Offset of field: _GObjectClass::set_property"] [:: std :: mem :: offset_of ! (_GObjectClass , set_property) - 24usize] ; ["Offset of field: _GObjectClass::get_property"] [:: std :: mem :: offset_of ! (_GObjectClass , get_property) - 32usize] ; ["Offset of field: _GObjectClass::dispose"] [:: std :: mem :: offset_of ! (_GObjectClass , dispose) - 40usize] ; ["Offset of field: _GObjectClass::finalize"] [:: std :: mem :: offset_of ! (_GObjectClass , finalize) - 48usize] ; ["Offset of field: _GObjectClass::dispatch_properties_changed"] [:: std :: mem :: offset_of ! (_GObjectClass , dispatch_properties_changed) - 56usize] ; ["Offset of field: _GObjectClass::notify"] [:: std :: mem :: offset_of ! (_GObjectClass , notify) - 64usize] ; ["Offset of field: _GObjectClass::constructed"] [:: std :: mem :: offset_of ! (_GObjectClass , constructed) - 72usize] ; ["Offset of field: _GObjectClass::flags"] [:: std :: mem :: offset_of ! (_GObjectClass , flags) - 80usize] ; ["Offset of field: _GObjectClass::n_construct_properties"] [:: std :: mem :: offset_of ! (_GObjectClass , n_construct_properties) - 88usize] ; ["Offset of field: _GObjectClass::pspecs"] [:: std :: mem :: offset_of ! (_GObjectClass , pspecs) - 96usize] ; ["Offset of field: _GObjectClass::n_pspecs"] [:: std :: mem :: offset_of ! (_GObjectClass , n_pspecs) - 104usize] ; ["Offset of field: _GObjectClass::pdummy"] [:: std :: mem :: offset_of ! (_GObjectClass , pdummy) - 112usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GObjectConstructParam { pub pspec : * mut GParamSpec , pub value : * mut GValue , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GObjectConstructParam"] [:: std :: mem :: size_of :: < _GObjectConstructParam > () - 16usize] ; ["Alignment of _GObjectConstructParam"] [:: std :: mem :: align_of :: < _GObjectConstructParam > () - 8usize] ; ["Offset of field: _GObjectConstructParam::pspec"] [:: std :: mem :: offset_of ! (_GObjectConstructParam , pspec) - 0usize] ; ["Offset of field: _GObjectConstructParam::value"] [:: std :: mem :: offset_of ! (_GObjectConstructParam , value) - 8usize] ; } ; unsafe extern "C" { pub fn g_initially_unowned_get_type () -> GType ; } unsafe extern "C" { pub fn g_object_class_install_property (oclass : * mut GObjectClass , property_id : guint , pspec : * mut GParamSpec) ; } unsafe extern "C" { pub fn g_object_class_find_property (oclass : * mut GObjectClass , property_name : * const gchar) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_object_class_list_properties (oclass : * mut GObjectClass , n_properties : * mut guint) -> * mut * mut GParamSpec ; } unsafe extern "C" { pub fn g_object_class_override_property (oclass : * mut GObjectClass , property_id : guint , name : * const gchar) ; } unsafe extern "C" { pub fn g_object_class_install_properties (oclass : * mut GObjectClass , n_pspecs : guint , pspecs : * mut * mut GParamSpec) ; } unsafe extern "C" { pub fn g_object_interface_install_property (g_iface : gpointer , pspec : * mut GParamSpec) ; } unsafe extern "C" { pub fn g_object_interface_find_property (g_iface : gpointer , property_name : * const gchar) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_object_interface_list_properties (g_iface : gpointer , n_properties_p : * mut guint) -> * mut * mut GParamSpec ; } unsafe extern "C" { pub fn g_object_get_type () -> GType ; } unsafe extern "C" { pub fn g_object_new (object_type : GType , first_property_name : * const gchar , ...) -> gpointer ; } unsafe extern "C" { pub fn g_object_new_with_properties (object_type : GType , n_properties : guint , names : * mut * const :: std :: os :: raw :: c_char , values : * const GValue) -> * mut GObject ; } unsafe extern "C" { pub fn g_object_newv (object_type : GType , n_parameters : guint , parameters : * mut GParameter) -> gpointer ; } unsafe extern "C" { pub fn g_object_new_valist (object_type : GType , first_property_name : * const gchar , var_args : * mut __va_list_tag) -> * mut GObject ; } unsafe extern "C" { pub fn g_object_set (object : gpointer , first_property_name : * const gchar , ...) ; } unsafe extern "C" { pub fn g_object_get (object : gpointer , first_property_name : * const gchar , ...) ; } unsafe extern "C" { pub fn g_object_connect (object : gpointer , signal_spec : * const gchar , ...) -> gpointer ; } unsafe extern "C" { pub fn g_object_disconnect (object : gpointer , signal_spec : * const gchar , ...) ; } unsafe extern "C" { pub fn g_object_setv (object : * mut GObject , n_properties : guint , names : * mut * const gchar , values : * const GValue) ; } unsafe extern "C" { pub fn g_object_set_valist (object : * mut GObject , first_property_name : * const gchar , var_args : * mut __va_list_tag) ; } unsafe extern "C" { pub fn g_object_getv (object : * mut GObject , n_properties : guint , names : * mut * const gchar , values : * mut GValue) ; } unsafe extern "C" { pub fn g_object_get_valist (object : * mut GObject , first_property_name : * const gchar , var_args : * mut __va_list_tag) ; } unsafe extern "C" { pub fn g_object_set_property (object : * mut GObject , property_name : * const gchar , value : * const GValue) ; } unsafe extern "C" { pub fn g_object_get_property (object : * mut GObject , property_name : * const gchar , value : * mut GValue) ; } unsafe extern "C" { pub fn g_object_freeze_notify (object : * mut GObject) ; } unsafe extern "C" { pub fn g_object_notify (object : * mut GObject , property_name : * const gchar) ; } unsafe extern "C" { pub fn g_object_notify_by_pspec (object : * mut GObject , pspec : * mut GParamSpec) ; } unsafe extern "C" { pub fn g_object_thaw_notify (object : * mut GObject) ; } unsafe extern "C" { pub fn g_object_is_floating (object : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_object_ref_sink (object : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_object_take_ref (object : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_object_ref (object : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_object_unref (object : gpointer) ; } unsafe extern "C" { pub fn g_object_weak_ref (object : * mut GObject , notify : GWeakNotify , data : gpointer) ; } unsafe extern "C" { pub fn g_object_weak_unref (object : * mut GObject , notify : GWeakNotify , data : gpointer) ; } unsafe extern "C" { pub fn g_object_add_weak_pointer (object : * mut GObject , weak_pointer_location : * mut gpointer) ; } unsafe extern "C" { pub fn g_object_remove_weak_pointer (object : * mut GObject , weak_pointer_location : * mut gpointer) ; } pub type GToggleNotify = :: std :: option :: Option < unsafe extern "C" fn (data : gpointer , object : * mut GObject , is_last_ref : gboolean) > ; unsafe extern "C" { pub fn g_object_add_toggle_ref (object : * mut GObject , notify : GToggleNotify , data : gpointer) ; } unsafe extern "C" { pub fn g_object_remove_toggle_ref (object : * mut GObject , notify : GToggleNotify , data : gpointer) ; } unsafe extern "C" { pub fn g_object_get_qdata (object : * mut GObject , quark : GQuark) -> gpointer ; } unsafe extern "C" { pub fn g_object_set_qdata (object : * mut GObject , quark : GQuark , data : gpointer) ; } unsafe extern "C" { pub fn g_object_set_qdata_full (object : * mut GObject , quark : GQuark , data : gpointer , destroy : GDestroyNotify) ; } unsafe extern "C" { pub fn g_object_steal_qdata (object : * mut GObject , quark : GQuark) -> gpointer ; } unsafe extern "C" { pub fn g_object_dup_qdata (object : * mut GObject , quark : GQuark , dup_func : GDuplicateFunc , user_data : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_object_replace_qdata (object : * mut GObject , quark : GQuark , oldval : gpointer , newval : gpointer , destroy : GDestroyNotify , old_destroy : * mut GDestroyNotify) -> gboolean ; } unsafe extern "C" { pub fn g_object_get_data (object : * mut GObject , key : * const gchar) -> gpointer ; } unsafe extern "C" { pub fn g_object_set_data (object : * mut GObject , key : * const gchar , data : gpointer) ; } unsafe extern "C" { pub fn g_object_set_data_full (object : * mut GObject , key : * const gchar , data : gpointer , destroy : GDestroyNotify) ; } unsafe extern "C" { pub fn g_object_steal_data (object : * mut GObject , key : * const gchar) -> gpointer ; } unsafe extern "C" { pub fn g_object_dup_data (object : * mut GObject , key : * const gchar , dup_func : GDuplicateFunc , user_data : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_object_replace_data (object : * mut GObject , key : * const gchar , oldval : gpointer , newval : gpointer , destroy : GDestroyNotify , old_destroy : * mut GDestroyNotify) -> gboolean ; } unsafe extern "C" { pub fn g_object_watch_closure (object : * mut GObject , closure : * mut GClosure) ; } unsafe extern "C" { pub fn g_cclosure_new_object (callback_func : GCallback , object : * mut GObject) -> * mut GClosure ; } unsafe extern "C" { pub fn g_cclosure_new_object_swap (callback_func : GCallback , object : * mut GObject) -> * mut GClosure ; } unsafe extern "C" { pub fn g_closure_new_object (sizeof_closure : guint , object : * mut GObject) -> * mut GClosure ; } unsafe extern "C" { pub fn g_value_set_object (value : * mut GValue , v_object : gpointer) ; } unsafe extern "C" { pub fn g_value_get_object (value : * const GValue) -> gpointer ; } unsafe extern "C" { pub fn g_value_dup_object (value : * const GValue) -> gpointer ; } unsafe extern "C" { pub fn g_signal_connect_object (instance : gpointer , detailed_signal : * const gchar , c_handler : GCallback , gobject : gpointer , connect_flags : GConnectFlags) -> gulong ; } unsafe extern "C" { pub fn g_object_force_floating (object : * mut GObject) ; } unsafe extern "C" { pub fn g_object_run_dispose (object : * mut GObject) ; } unsafe extern "C" { pub fn g_value_take_object (value : * mut GValue , v_object : gpointer) ; } unsafe extern "C" { pub fn g_value_set_object_take_ownership (value : * mut GValue , v_object : gpointer) ; } unsafe extern "C" { pub fn g_object_compat_control (what : gsize , data : gpointer) -> gsize ; } unsafe extern "C" { pub fn g_clear_object (object_ptr : * mut * mut GObject) ; } # [repr (C)] # [derive (Copy , Clone)] pub struct GWeakRef { pub priv_ : GWeakRef__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union GWeakRef__bindgen_ty_1 { pub p : gpointer , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of GWeakRef__bindgen_ty_1"] [:: std :: mem :: size_of :: < GWeakRef__bindgen_ty_1 > () - 8usize] ; ["Alignment of GWeakRef__bindgen_ty_1"] [:: std :: mem :: align_of :: < GWeakRef__bindgen_ty_1 > () - 8usize] ; ["Offset of field: GWeakRef__bindgen_ty_1::p"] [:: std :: mem :: offset_of ! (GWeakRef__bindgen_ty_1 , p) - 0usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of GWeakRef"] [:: std :: mem :: size_of :: < GWeakRef > () - 8usize] ; ["Alignment of GWeakRef"] [:: std :: mem :: align_of :: < GWeakRef > () - 8usize] ; ["Offset of field: GWeakRef::priv_"] [:: std :: mem :: offset_of ! (GWeakRef , priv_) - 0usize] ; } ; unsafe extern "C" { pub fn g_weak_ref_init (weak_ref : * mut GWeakRef , object : gpointer) ; } unsafe extern "C" { pub fn g_weak_ref_clear (weak_ref : * mut GWeakRef) ; } unsafe extern "C" { pub fn g_weak_ref_get (weak_ref : * mut GWeakRef) -> gpointer ; } unsafe extern "C" { pub fn g_weak_ref_set (weak_ref : * mut GWeakRef , object : gpointer) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GBinding { _unused : [u8 ; 0] , } pub type GBinding = _GBinding ; pub type GBindingTransformFunc = :: std :: option :: Option < unsafe extern "C" fn (binding : * mut GBinding , from_value : * const GValue , to_value : * mut GValue , user_data : gpointer) -> gboolean > ; pub const GBindingFlags_G_BINDING_DEFAULT : GBindingFlags = 0 ; pub const GBindingFlags_G_BINDING_BIDIRECTIONAL : GBindingFlags = 1 ; pub const GBindingFlags_G_BINDING_SYNC_CREATE : GBindingFlags = 2 ; pub const GBindingFlags_G_BINDING_INVERT_BOOLEAN : GBindingFlags = 4 ; pub type GBindingFlags = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_binding_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_binding_get_type () -> GType ; } unsafe extern "C" { pub fn g_binding_get_flags (binding : * mut GBinding) -> GBindingFlags ; } unsafe extern "C" { pub fn g_binding_get_source (binding : * mut GBinding) -> * mut GObject ; } unsafe extern "C" { pub fn g_binding_dup_source (binding : * mut GBinding) -> * mut GObject ; } unsafe extern "C" { pub fn g_binding_get_target (binding : * mut GBinding) -> * mut GObject ; } unsafe extern "C" { pub fn g_binding_dup_target (binding : * mut GBinding) -> * mut GObject ; } unsafe extern "C" { pub fn g_binding_get_source_property (binding : * mut GBinding) -> * const gchar ; } unsafe extern "C" { pub fn g_binding_get_target_property (binding : * mut GBinding) -> * const gchar ; } unsafe extern "C" { pub fn g_binding_unbind (binding : * mut GBinding) ; } unsafe extern "C" { pub fn g_object_bind_property (source : gpointer , source_property : * const gchar , target : gpointer , target_property : * const gchar , flags : GBindingFlags) -> * mut GBinding ; } unsafe extern "C" { pub fn g_object_bind_property_full (source : gpointer , source_property : * const gchar , target : gpointer , target_property : * const gchar , flags : GBindingFlags , transform_to : GBindingTransformFunc , transform_from : GBindingTransformFunc , user_data : gpointer , notify : GDestroyNotify) -> * mut GBinding ; } unsafe extern "C" { pub fn g_object_bind_property_with_closures (source : gpointer , source_property : * const gchar , target : gpointer , target_property : * const gchar , flags : GBindingFlags , transform_to : * mut GClosure , transform_from : * mut GClosure) -> * mut GBinding ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GBindingGroup { _unused : [u8 ; 0] , } pub type GBindingGroup = _GBindingGroup ; unsafe extern "C" { pub fn g_binding_group_get_type () -> GType ; } unsafe extern "C" { pub fn g_binding_group_new () -> * mut GBindingGroup ; } unsafe extern "C" { pub fn g_binding_group_dup_source (self_ : * mut GBindingGroup) -> gpointer ; } unsafe extern "C" { pub fn g_binding_group_set_source (self_ : * mut GBindingGroup , source : gpointer) ; } unsafe extern "C" { pub fn g_binding_group_bind (self_ : * mut GBindingGroup , source_property : * const gchar , target : gpointer , target_property : * const gchar , flags : GBindingFlags) ; } unsafe extern "C" { pub fn g_binding_group_bind_full (self_ : * mut GBindingGroup , source_property : * const gchar , target : gpointer , target_property : * const gchar , flags : GBindingFlags , transform_to : GBindingTransformFunc , transform_from : GBindingTransformFunc , user_data : gpointer , user_data_destroy : GDestroyNotify) ; } unsafe extern "C" { pub fn g_binding_group_bind_with_closures (self_ : * mut GBindingGroup , source_property : * const gchar , target : gpointer , target_property : * const gchar , flags : GBindingFlags , transform_to : * mut GClosure , transform_from : * mut GClosure) ; } pub type GEnumClass = _GEnumClass ; pub type GFlagsClass = _GFlagsClass ; pub type GEnumValue = _GEnumValue ; pub type GFlagsValue = _GFlagsValue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GEnumClass { pub g_type_class : GTypeClass , pub minimum : gint , pub maximum : gint , pub n_values : guint , pub values : * mut GEnumValue , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GEnumClass"] [:: std :: mem :: size_of :: < _GEnumClass > () - 32usize] ; ["Alignment of _GEnumClass"] [:: std :: mem :: align_of :: < _GEnumClass > () - 8usize] ; ["Offset of field: _GEnumClass::g_type_class"] [:: std :: mem :: offset_of ! (_GEnumClass , g_type_class) - 0usize] ; ["Offset of field: _GEnumClass::minimum"] [:: std :: mem :: offset_of ! (_GEnumClass , minimum) - 8usize] ; ["Offset of field: _GEnumClass::maximum"] [:: std :: mem :: offset_of ! (_GEnumClass , maximum) - 12usize] ; ["Offset of field: _GEnumClass::n_values"] [:: std :: mem :: offset_of ! (_GEnumClass , n_values) - 16usize] ; ["Offset of field: _GEnumClass::values"] [:: std :: mem :: offset_of ! (_GEnumClass , values) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFlagsClass { pub g_type_class : GTypeClass , pub mask : guint , pub n_values : guint , pub values : * mut GFlagsValue , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFlagsClass"] [:: std :: mem :: size_of :: < _GFlagsClass > () - 24usize] ; ["Alignment of _GFlagsClass"] [:: std :: mem :: align_of :: < _GFlagsClass > () - 8usize] ; ["Offset of field: _GFlagsClass::g_type_class"] [:: std :: mem :: offset_of ! (_GFlagsClass , g_type_class) - 0usize] ; ["Offset of field: _GFlagsClass::mask"] [:: std :: mem :: offset_of ! (_GFlagsClass , mask) - 8usize] ; ["Offset of field: _GFlagsClass::n_values"] [:: std :: mem :: offset_of ! (_GFlagsClass , n_values) - 12usize] ; ["Offset of field: _GFlagsClass::values"] [:: std :: mem :: offset_of ! (_GFlagsClass , values) - 16usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GEnumValue { pub value : gint , pub value_name : * const gchar , pub value_nick : * const gchar , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GEnumValue"] [:: std :: mem :: size_of :: < _GEnumValue > () - 24usize] ; ["Alignment of _GEnumValue"] [:: std :: mem :: align_of :: < _GEnumValue > () - 8usize] ; ["Offset of field: _GEnumValue::value"] [:: std :: mem :: offset_of ! (_GEnumValue , value) - 0usize] ; ["Offset of field: _GEnumValue::value_name"] [:: std :: mem :: offset_of ! (_GEnumValue , value_name) - 8usize] ; ["Offset of field: _GEnumValue::value_nick"] [:: std :: mem :: offset_of ! (_GEnumValue , value_nick) - 16usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFlagsValue { pub value : guint , pub value_name : * const gchar , pub value_nick : * const gchar , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFlagsValue"] [:: std :: mem :: size_of :: < _GFlagsValue > () - 24usize] ; ["Alignment of _GFlagsValue"] [:: std :: mem :: align_of :: < _GFlagsValue > () - 8usize] ; ["Offset of field: _GFlagsValue::value"] [:: std :: mem :: offset_of ! (_GFlagsValue , value) - 0usize] ; ["Offset of field: _GFlagsValue::value_name"] [:: std :: mem :: offset_of ! (_GFlagsValue , value_name) - 8usize] ; ["Offset of field: _GFlagsValue::value_nick"] [:: std :: mem :: offset_of ! (_GFlagsValue , value_nick) - 16usize] ; } ; unsafe extern "C" { pub fn g_enum_get_value (enum_class : * mut GEnumClass , value : gint) -> * mut GEnumValue ; } unsafe extern "C" { pub fn g_enum_get_value_by_name (enum_class : * mut GEnumClass , name : * const gchar) -> * mut GEnumValue ; } unsafe extern "C" { pub fn g_enum_get_value_by_nick (enum_class : * mut GEnumClass , nick : * const gchar) -> * mut GEnumValue ; } unsafe extern "C" { pub fn g_flags_get_first_value (flags_class : * mut GFlagsClass , value : guint) -> * mut GFlagsValue ; } unsafe extern "C" { pub fn g_flags_get_value_by_name (flags_class : * mut GFlagsClass , name : * const gchar) -> * mut GFlagsValue ; } unsafe extern "C" { pub fn g_flags_get_value_by_nick (flags_class : * mut GFlagsClass , nick : * const gchar) -> * mut GFlagsValue ; } unsafe extern "C" { pub fn g_enum_to_string (g_enum_type : GType , value : gint) -> * mut gchar ; } unsafe extern "C" { pub fn g_flags_to_string (flags_type : GType , value : guint) -> * mut gchar ; } unsafe extern "C" { pub fn g_value_set_enum (value : * mut GValue , v_enum : gint) ; } unsafe extern "C" { pub fn g_value_get_enum (value : * const GValue) -> gint ; } unsafe extern "C" { pub fn g_value_set_flags (value : * mut GValue , v_flags : guint) ; } unsafe extern "C" { pub fn g_value_get_flags (value : * const GValue) -> guint ; } unsafe extern "C" { pub fn g_enum_register_static (name : * const gchar , const_static_values : * const GEnumValue) -> GType ; } unsafe extern "C" { pub fn g_flags_register_static (name : * const gchar , const_static_values : * const GFlagsValue) -> GType ; } unsafe extern "C" { pub fn g_enum_complete_type_info (g_enum_type : GType , info : * mut GTypeInfo , const_values : * const GEnumValue) ; } unsafe extern "C" { pub fn g_flags_complete_type_info (g_flags_type : GType , info : * mut GTypeInfo , const_values : * const GFlagsValue) ; } unsafe extern "C" { pub fn g_unicode_type_get_type () -> GType ; } unsafe extern "C" { pub fn g_unicode_break_type_get_type () -> GType ; } unsafe extern "C" { pub fn g_unicode_script_get_type () -> GType ; } unsafe extern "C" { pub fn g_normalize_mode_get_type () -> GType ; } pub type GParamSpecChar = _GParamSpecChar ; pub type GParamSpecUChar = _GParamSpecUChar ; pub type GParamSpecBoolean = _GParamSpecBoolean ; pub type GParamSpecInt = _GParamSpecInt ; pub type GParamSpecUInt = _GParamSpecUInt ; pub type GParamSpecLong = _GParamSpecLong ; pub type GParamSpecULong = _GParamSpecULong ; pub type GParamSpecInt64 = _GParamSpecInt64 ; pub type GParamSpecUInt64 = _GParamSpecUInt64 ; pub type GParamSpecUnichar = _GParamSpecUnichar ; pub type GParamSpecEnum = _GParamSpecEnum ; pub type GParamSpecFlags = _GParamSpecFlags ; pub type GParamSpecFloat = _GParamSpecFloat ; pub type GParamSpecDouble = _GParamSpecDouble ; pub type GParamSpecString = _GParamSpecString ; pub type GParamSpecParam = _GParamSpecParam ; pub type GParamSpecBoxed = _GParamSpecBoxed ; pub type GParamSpecPointer = _GParamSpecPointer ; pub type GParamSpecValueArray = _GParamSpecValueArray ; pub type GParamSpecObject = _GParamSpecObject ; pub type GParamSpecOverride = _GParamSpecOverride ; pub type GParamSpecGType = _GParamSpecGType ; pub type GParamSpecVariant = _GParamSpecVariant ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecChar { pub parent_instance : GParamSpec , pub minimum : gint8 , pub maximum : gint8 , pub default_value : gint8 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecChar"] [:: std :: mem :: size_of :: < _GParamSpecChar > () - 80usize] ; ["Alignment of _GParamSpecChar"] [:: std :: mem :: align_of :: < _GParamSpecChar > () - 8usize] ; ["Offset of field: _GParamSpecChar::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecChar , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecChar::minimum"] [:: std :: mem :: offset_of ! (_GParamSpecChar , minimum) - 72usize] ; ["Offset of field: _GParamSpecChar::maximum"] [:: std :: mem :: offset_of ! (_GParamSpecChar , maximum) - 73usize] ; ["Offset of field: _GParamSpecChar::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecChar , default_value) - 74usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecUChar { pub parent_instance : GParamSpec , pub minimum : guint8 , pub maximum : guint8 , pub default_value : guint8 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecUChar"] [:: std :: mem :: size_of :: < _GParamSpecUChar > () - 80usize] ; ["Alignment of _GParamSpecUChar"] [:: std :: mem :: align_of :: < _GParamSpecUChar > () - 8usize] ; ["Offset of field: _GParamSpecUChar::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecUChar , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecUChar::minimum"] [:: std :: mem :: offset_of ! (_GParamSpecUChar , minimum) - 72usize] ; ["Offset of field: _GParamSpecUChar::maximum"] [:: std :: mem :: offset_of ! (_GParamSpecUChar , maximum) - 73usize] ; ["Offset of field: _GParamSpecUChar::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecUChar , default_value) - 74usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecBoolean { pub parent_instance : GParamSpec , pub default_value : gboolean , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecBoolean"] [:: std :: mem :: size_of :: < _GParamSpecBoolean > () - 80usize] ; ["Alignment of _GParamSpecBoolean"] [:: std :: mem :: align_of :: < _GParamSpecBoolean > () - 8usize] ; ["Offset of field: _GParamSpecBoolean::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecBoolean , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecBoolean::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecBoolean , default_value) - 72usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecInt { pub parent_instance : GParamSpec , pub minimum : gint , pub maximum : gint , pub default_value : gint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecInt"] [:: std :: mem :: size_of :: < _GParamSpecInt > () - 88usize] ; ["Alignment of _GParamSpecInt"] [:: std :: mem :: align_of :: < _GParamSpecInt > () - 8usize] ; ["Offset of field: _GParamSpecInt::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecInt , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecInt::minimum"] [:: std :: mem :: offset_of ! (_GParamSpecInt , minimum) - 72usize] ; ["Offset of field: _GParamSpecInt::maximum"] [:: std :: mem :: offset_of ! (_GParamSpecInt , maximum) - 76usize] ; ["Offset of field: _GParamSpecInt::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecInt , default_value) - 80usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecUInt { pub parent_instance : GParamSpec , pub minimum : guint , pub maximum : guint , pub default_value : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecUInt"] [:: std :: mem :: size_of :: < _GParamSpecUInt > () - 88usize] ; ["Alignment of _GParamSpecUInt"] [:: std :: mem :: align_of :: < _GParamSpecUInt > () - 8usize] ; ["Offset of field: _GParamSpecUInt::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecUInt , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecUInt::minimum"] [:: std :: mem :: offset_of ! (_GParamSpecUInt , minimum) - 72usize] ; ["Offset of field: _GParamSpecUInt::maximum"] [:: std :: mem :: offset_of ! (_GParamSpecUInt , maximum) - 76usize] ; ["Offset of field: _GParamSpecUInt::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecUInt , default_value) - 80usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecLong { pub parent_instance : GParamSpec , pub minimum : glong , pub maximum : glong , pub default_value : glong , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecLong"] [:: std :: mem :: size_of :: < _GParamSpecLong > () - 96usize] ; ["Alignment of _GParamSpecLong"] [:: std :: mem :: align_of :: < _GParamSpecLong > () - 8usize] ; ["Offset of field: _GParamSpecLong::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecLong , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecLong::minimum"] [:: std :: mem :: offset_of ! (_GParamSpecLong , minimum) - 72usize] ; ["Offset of field: _GParamSpecLong::maximum"] [:: std :: mem :: offset_of ! (_GParamSpecLong , maximum) - 80usize] ; ["Offset of field: _GParamSpecLong::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecLong , default_value) - 88usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecULong { pub parent_instance : GParamSpec , pub minimum : gulong , pub maximum : gulong , pub default_value : gulong , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecULong"] [:: std :: mem :: size_of :: < _GParamSpecULong > () - 96usize] ; ["Alignment of _GParamSpecULong"] [:: std :: mem :: align_of :: < _GParamSpecULong > () - 8usize] ; ["Offset of field: _GParamSpecULong::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecULong , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecULong::minimum"] [:: std :: mem :: offset_of ! (_GParamSpecULong , minimum) - 72usize] ; ["Offset of field: _GParamSpecULong::maximum"] [:: std :: mem :: offset_of ! (_GParamSpecULong , maximum) - 80usize] ; ["Offset of field: _GParamSpecULong::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecULong , default_value) - 88usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecInt64 { pub parent_instance : GParamSpec , pub minimum : gint64 , pub maximum : gint64 , pub default_value : gint64 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecInt64"] [:: std :: mem :: size_of :: < _GParamSpecInt64 > () - 96usize] ; ["Alignment of _GParamSpecInt64"] [:: std :: mem :: align_of :: < _GParamSpecInt64 > () - 8usize] ; ["Offset of field: _GParamSpecInt64::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecInt64 , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecInt64::minimum"] [:: std :: mem :: offset_of ! (_GParamSpecInt64 , minimum) - 72usize] ; ["Offset of field: _GParamSpecInt64::maximum"] [:: std :: mem :: offset_of ! (_GParamSpecInt64 , maximum) - 80usize] ; ["Offset of field: _GParamSpecInt64::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecInt64 , default_value) - 88usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecUInt64 { pub parent_instance : GParamSpec , pub minimum : guint64 , pub maximum : guint64 , pub default_value : guint64 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecUInt64"] [:: std :: mem :: size_of :: < _GParamSpecUInt64 > () - 96usize] ; ["Alignment of _GParamSpecUInt64"] [:: std :: mem :: align_of :: < _GParamSpecUInt64 > () - 8usize] ; ["Offset of field: _GParamSpecUInt64::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecUInt64 , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecUInt64::minimum"] [:: std :: mem :: offset_of ! (_GParamSpecUInt64 , minimum) - 72usize] ; ["Offset of field: _GParamSpecUInt64::maximum"] [:: std :: mem :: offset_of ! (_GParamSpecUInt64 , maximum) - 80usize] ; ["Offset of field: _GParamSpecUInt64::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecUInt64 , default_value) - 88usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecUnichar { pub parent_instance : GParamSpec , pub default_value : gunichar , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecUnichar"] [:: std :: mem :: size_of :: < _GParamSpecUnichar > () - 80usize] ; ["Alignment of _GParamSpecUnichar"] [:: std :: mem :: align_of :: < _GParamSpecUnichar > () - 8usize] ; ["Offset of field: _GParamSpecUnichar::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecUnichar , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecUnichar::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecUnichar , default_value) - 72usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecEnum { pub parent_instance : GParamSpec , pub enum_class : * mut GEnumClass , pub default_value : gint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecEnum"] [:: std :: mem :: size_of :: < _GParamSpecEnum > () - 88usize] ; ["Alignment of _GParamSpecEnum"] [:: std :: mem :: align_of :: < _GParamSpecEnum > () - 8usize] ; ["Offset of field: _GParamSpecEnum::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecEnum , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecEnum::enum_class"] [:: std :: mem :: offset_of ! (_GParamSpecEnum , enum_class) - 72usize] ; ["Offset of field: _GParamSpecEnum::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecEnum , default_value) - 80usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecFlags { pub parent_instance : GParamSpec , pub flags_class : * mut GFlagsClass , pub default_value : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecFlags"] [:: std :: mem :: size_of :: < _GParamSpecFlags > () - 88usize] ; ["Alignment of _GParamSpecFlags"] [:: std :: mem :: align_of :: < _GParamSpecFlags > () - 8usize] ; ["Offset of field: _GParamSpecFlags::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecFlags , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecFlags::flags_class"] [:: std :: mem :: offset_of ! (_GParamSpecFlags , flags_class) - 72usize] ; ["Offset of field: _GParamSpecFlags::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecFlags , default_value) - 80usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecFloat { pub parent_instance : GParamSpec , pub minimum : gfloat , pub maximum : gfloat , pub default_value : gfloat , pub epsilon : gfloat , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecFloat"] [:: std :: mem :: size_of :: < _GParamSpecFloat > () - 88usize] ; ["Alignment of _GParamSpecFloat"] [:: std :: mem :: align_of :: < _GParamSpecFloat > () - 8usize] ; ["Offset of field: _GParamSpecFloat::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecFloat , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecFloat::minimum"] [:: std :: mem :: offset_of ! (_GParamSpecFloat , minimum) - 72usize] ; ["Offset of field: _GParamSpecFloat::maximum"] [:: std :: mem :: offset_of ! (_GParamSpecFloat , maximum) - 76usize] ; ["Offset of field: _GParamSpecFloat::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecFloat , default_value) - 80usize] ; ["Offset of field: _GParamSpecFloat::epsilon"] [:: std :: mem :: offset_of ! (_GParamSpecFloat , epsilon) - 84usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecDouble { pub parent_instance : GParamSpec , pub minimum : gdouble , pub maximum : gdouble , pub default_value : gdouble , pub epsilon : gdouble , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecDouble"] [:: std :: mem :: size_of :: < _GParamSpecDouble > () - 104usize] ; ["Alignment of _GParamSpecDouble"] [:: std :: mem :: align_of :: < _GParamSpecDouble > () - 8usize] ; ["Offset of field: _GParamSpecDouble::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecDouble , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecDouble::minimum"] [:: std :: mem :: offset_of ! (_GParamSpecDouble , minimum) - 72usize] ; ["Offset of field: _GParamSpecDouble::maximum"] [:: std :: mem :: offset_of ! (_GParamSpecDouble , maximum) - 80usize] ; ["Offset of field: _GParamSpecDouble::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecDouble , default_value) - 88usize] ; ["Offset of field: _GParamSpecDouble::epsilon"] [:: std :: mem :: offset_of ! (_GParamSpecDouble , epsilon) - 96usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecString { pub parent_instance : GParamSpec , pub default_value : * mut gchar , pub cset_first : * mut gchar , pub cset_nth : * mut gchar , pub substitutor : gchar , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u16 ; 3usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecString"] [:: std :: mem :: size_of :: < _GParamSpecString > () - 104usize] ; ["Alignment of _GParamSpecString"] [:: std :: mem :: align_of :: < _GParamSpecString > () - 8usize] ; ["Offset of field: _GParamSpecString::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecString , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecString::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecString , default_value) - 72usize] ; ["Offset of field: _GParamSpecString::cset_first"] [:: std :: mem :: offset_of ! (_GParamSpecString , cset_first) - 80usize] ; ["Offset of field: _GParamSpecString::cset_nth"] [:: std :: mem :: offset_of ! (_GParamSpecString , cset_nth) - 88usize] ; ["Offset of field: _GParamSpecString::substitutor"] [:: std :: mem :: offset_of ! (_GParamSpecString , substitutor) - 96usize] ; } ; impl _GParamSpecString { # [inline] pub fn null_fold_if_empty (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_null_fold_if_empty (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub unsafe fn null_fold_if_empty_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 0usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_null_fold_if_empty_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 0usize , 1u8 , val as u64 ,) } } # [inline] pub fn ensure_non_null (& self) -> guint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_ensure_non_null (& mut self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub unsafe fn ensure_non_null_raw (this : * const Self) -> guint { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 1usize , 1u8 ,) as u32) } } # [inline] pub unsafe fn set_ensure_non_null_raw (this : * mut Self , val : guint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 1usize , 1u8 , val as u64 ,) } } # [inline] pub fn new_bitfield_1 (null_fold_if_empty : guint , ensure_non_null : guint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let null_fold_if_empty : u32 = unsafe { :: std :: mem :: transmute (null_fold_if_empty) } ; null_fold_if_empty as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let ensure_non_null : u32 = unsafe { :: std :: mem :: transmute (ensure_non_null) } ; ensure_non_null as u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecParam { pub parent_instance : GParamSpec , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecParam"] [:: std :: mem :: size_of :: < _GParamSpecParam > () - 72usize] ; ["Alignment of _GParamSpecParam"] [:: std :: mem :: align_of :: < _GParamSpecParam > () - 8usize] ; ["Offset of field: _GParamSpecParam::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecParam , parent_instance) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecBoxed { pub parent_instance : GParamSpec , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecBoxed"] [:: std :: mem :: size_of :: < _GParamSpecBoxed > () - 72usize] ; ["Alignment of _GParamSpecBoxed"] [:: std :: mem :: align_of :: < _GParamSpecBoxed > () - 8usize] ; ["Offset of field: _GParamSpecBoxed::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecBoxed , parent_instance) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecPointer { pub parent_instance : GParamSpec , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecPointer"] [:: std :: mem :: size_of :: < _GParamSpecPointer > () - 72usize] ; ["Alignment of _GParamSpecPointer"] [:: std :: mem :: align_of :: < _GParamSpecPointer > () - 8usize] ; ["Offset of field: _GParamSpecPointer::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecPointer , parent_instance) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecValueArray { pub parent_instance : GParamSpec , pub element_spec : * mut GParamSpec , pub fixed_n_elements : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecValueArray"] [:: std :: mem :: size_of :: < _GParamSpecValueArray > () - 88usize] ; ["Alignment of _GParamSpecValueArray"] [:: std :: mem :: align_of :: < _GParamSpecValueArray > () - 8usize] ; ["Offset of field: _GParamSpecValueArray::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecValueArray , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecValueArray::element_spec"] [:: std :: mem :: offset_of ! (_GParamSpecValueArray , element_spec) - 72usize] ; ["Offset of field: _GParamSpecValueArray::fixed_n_elements"] [:: std :: mem :: offset_of ! (_GParamSpecValueArray , fixed_n_elements) - 80usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecObject { pub parent_instance : GParamSpec , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecObject"] [:: std :: mem :: size_of :: < _GParamSpecObject > () - 72usize] ; ["Alignment of _GParamSpecObject"] [:: std :: mem :: align_of :: < _GParamSpecObject > () - 8usize] ; ["Offset of field: _GParamSpecObject::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecObject , parent_instance) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecOverride { pub parent_instance : GParamSpec , pub overridden : * mut GParamSpec , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecOverride"] [:: std :: mem :: size_of :: < _GParamSpecOverride > () - 80usize] ; ["Alignment of _GParamSpecOverride"] [:: std :: mem :: align_of :: < _GParamSpecOverride > () - 8usize] ; ["Offset of field: _GParamSpecOverride::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecOverride , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecOverride::overridden"] [:: std :: mem :: offset_of ! (_GParamSpecOverride , overridden) - 72usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecGType { pub parent_instance : GParamSpec , pub is_a_type : GType , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecGType"] [:: std :: mem :: size_of :: < _GParamSpecGType > () - 80usize] ; ["Alignment of _GParamSpecGType"] [:: std :: mem :: align_of :: < _GParamSpecGType > () - 8usize] ; ["Offset of field: _GParamSpecGType::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecGType , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecGType::is_a_type"] [:: std :: mem :: offset_of ! (_GParamSpecGType , is_a_type) - 72usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GParamSpecVariant { pub parent_instance : GParamSpec , pub type_ : * mut GVariantType , pub default_value : * mut GVariant , pub padding : [gpointer ; 4usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GParamSpecVariant"] [:: std :: mem :: size_of :: < _GParamSpecVariant > () - 120usize] ; ["Alignment of _GParamSpecVariant"] [:: std :: mem :: align_of :: < _GParamSpecVariant > () - 8usize] ; ["Offset of field: _GParamSpecVariant::parent_instance"] [:: std :: mem :: offset_of ! (_GParamSpecVariant , parent_instance) - 0usize] ; ["Offset of field: _GParamSpecVariant::type_"] [:: std :: mem :: offset_of ! (_GParamSpecVariant , type_) - 72usize] ; ["Offset of field: _GParamSpecVariant::default_value"] [:: std :: mem :: offset_of ! (_GParamSpecVariant , default_value) - 80usize] ; ["Offset of field: _GParamSpecVariant::padding"] [:: std :: mem :: offset_of ! (_GParamSpecVariant , padding) - 88usize] ; } ; unsafe extern "C" { pub fn g_param_spec_char (name : * const gchar , nick : * const gchar , blurb : * const gchar , minimum : gint8 , maximum : gint8 , default_value : gint8 , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_uchar (name : * const gchar , nick : * const gchar , blurb : * const gchar , minimum : guint8 , maximum : guint8 , default_value : guint8 , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_boolean (name : * const gchar , nick : * const gchar , blurb : * const gchar , default_value : gboolean , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_int (name : * const gchar , nick : * const gchar , blurb : * const gchar , minimum : gint , maximum : gint , default_value : gint , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_uint (name : * const gchar , nick : * const gchar , blurb : * const gchar , minimum : guint , maximum : guint , default_value : guint , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_long (name : * const gchar , nick : * const gchar , blurb : * const gchar , minimum : glong , maximum : glong , default_value : glong , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_ulong (name : * const gchar , nick : * const gchar , blurb : * const gchar , minimum : gulong , maximum : gulong , default_value : gulong , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_int64 (name : * const gchar , nick : * const gchar , blurb : * const gchar , minimum : gint64 , maximum : gint64 , default_value : gint64 , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_uint64 (name : * const gchar , nick : * const gchar , blurb : * const gchar , minimum : guint64 , maximum : guint64 , default_value : guint64 , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_unichar (name : * const gchar , nick : * const gchar , blurb : * const gchar , default_value : gunichar , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_enum (name : * const gchar , nick : * const gchar , blurb : * const gchar , enum_type : GType , default_value : gint , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_flags (name : * const gchar , nick : * const gchar , blurb : * const gchar , flags_type : GType , default_value : guint , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_float (name : * const gchar , nick : * const gchar , blurb : * const gchar , minimum : gfloat , maximum : gfloat , default_value : gfloat , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_double (name : * const gchar , nick : * const gchar , blurb : * const gchar , minimum : gdouble , maximum : gdouble , default_value : gdouble , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_string (name : * const gchar , nick : * const gchar , blurb : * const gchar , default_value : * const gchar , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_param (name : * const gchar , nick : * const gchar , blurb : * const gchar , param_type : GType , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_boxed (name : * const gchar , nick : * const gchar , blurb : * const gchar , boxed_type : GType , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_pointer (name : * const gchar , nick : * const gchar , blurb : * const gchar , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_value_array (name : * const gchar , nick : * const gchar , blurb : * const gchar , element_spec : * mut GParamSpec , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_object (name : * const gchar , nick : * const gchar , blurb : * const gchar , object_type : GType , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_override (name : * const gchar , overridden : * mut GParamSpec) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_gtype (name : * const gchar , nick : * const gchar , blurb : * const gchar , is_a_type : GType , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub fn g_param_spec_variant (name : * const gchar , nick : * const gchar , blurb : * const gchar , type_ : * const GVariantType , default_value : * mut GVariant , flags : GParamFlags) -> * mut GParamSpec ; } unsafe extern "C" { pub static mut g_param_spec_types : * mut GType ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSignalGroup { _unused : [u8 ; 0] , } pub type GSignalGroup = _GSignalGroup ; unsafe extern "C" { pub fn g_signal_group_get_type () -> GType ; } unsafe extern "C" { pub fn g_signal_group_new (target_type : GType) -> * mut GSignalGroup ; } unsafe extern "C" { pub fn g_signal_group_set_target (self_ : * mut GSignalGroup , target : gpointer) ; } unsafe extern "C" { pub fn g_signal_group_dup_target (self_ : * mut GSignalGroup) -> gpointer ; } unsafe extern "C" { pub fn g_signal_group_block (self_ : * mut GSignalGroup) ; } unsafe extern "C" { pub fn g_signal_group_unblock (self_ : * mut GSignalGroup) ; } unsafe extern "C" { pub fn g_signal_group_connect_closure (self_ : * mut GSignalGroup , detailed_signal : * const gchar , closure : * mut GClosure , after : gboolean) ; } unsafe extern "C" { pub fn g_signal_group_connect_object (self_ : * mut GSignalGroup , detailed_signal : * const gchar , c_handler : GCallback , object : gpointer , flags : GConnectFlags) ; } unsafe extern "C" { pub fn g_signal_group_connect_data (self_ : * mut GSignalGroup , detailed_signal : * const gchar , c_handler : GCallback , data : gpointer , notify : GClosureNotify , flags : GConnectFlags) ; } unsafe extern "C" { pub fn g_signal_group_connect (self_ : * mut GSignalGroup , detailed_signal : * const gchar , c_handler : GCallback , data : gpointer) ; } unsafe extern "C" { pub fn g_signal_group_connect_after (self_ : * mut GSignalGroup , detailed_signal : * const gchar , c_handler : GCallback , data : gpointer) ; } unsafe extern "C" { pub fn g_signal_group_connect_swapped (self_ : * mut GSignalGroup , detailed_signal : * const gchar , c_handler : GCallback , data : gpointer) ; } unsafe extern "C" { pub fn g_source_set_closure (source : * mut GSource , closure : * mut GClosure) ; } unsafe extern "C" { pub fn g_source_set_dummy_callback (source : * mut GSource) ; } pub type GTypeModule = _GTypeModule ; pub type GTypeModuleClass = _GTypeModuleClass ; pub type GTypeModule_autoptr = * mut GTypeModule ; pub type GTypeModule_listautoptr = * mut GList ; pub type GTypeModule_slistautoptr = * mut GSList ; pub type GTypeModule_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTypeModule { pub parent_instance : GObject , pub use_count : guint , pub type_infos : * mut GSList , pub interface_infos : * mut GSList , pub name : * mut gchar , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTypeModule"] [:: std :: mem :: size_of :: < _GTypeModule > () - 56usize] ; ["Alignment of _GTypeModule"] [:: std :: mem :: align_of :: < _GTypeModule > () - 8usize] ; ["Offset of field: _GTypeModule::parent_instance"] [:: std :: mem :: offset_of ! (_GTypeModule , parent_instance) - 0usize] ; ["Offset of field: _GTypeModule::use_count"] [:: std :: mem :: offset_of ! (_GTypeModule , use_count) - 24usize] ; ["Offset of field: _GTypeModule::type_infos"] [:: std :: mem :: offset_of ! (_GTypeModule , type_infos) - 32usize] ; ["Offset of field: _GTypeModule::interface_infos"] [:: std :: mem :: offset_of ! (_GTypeModule , interface_infos) - 40usize] ; ["Offset of field: _GTypeModule::name"] [:: std :: mem :: offset_of ! (_GTypeModule , name) - 48usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTypeModuleClass { pub parent_class : GObjectClass , pub load : :: std :: option :: Option < unsafe extern "C" fn (module : * mut GTypeModule) -> gboolean > , pub unload : :: std :: option :: Option < unsafe extern "C" fn (module : * mut GTypeModule) > , pub reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTypeModuleClass"] [:: std :: mem :: size_of :: < _GTypeModuleClass > () - 184usize] ; ["Alignment of _GTypeModuleClass"] [:: std :: mem :: align_of :: < _GTypeModuleClass > () - 8usize] ; ["Offset of field: _GTypeModuleClass::parent_class"] [:: std :: mem :: offset_of ! (_GTypeModuleClass , parent_class) - 0usize] ; ["Offset of field: _GTypeModuleClass::load"] [:: std :: mem :: offset_of ! (_GTypeModuleClass , load) - 136usize] ; ["Offset of field: _GTypeModuleClass::unload"] [:: std :: mem :: offset_of ! (_GTypeModuleClass , unload) - 144usize] ; ["Offset of field: _GTypeModuleClass::reserved1"] [:: std :: mem :: offset_of ! (_GTypeModuleClass , reserved1) - 152usize] ; ["Offset of field: _GTypeModuleClass::reserved2"] [:: std :: mem :: offset_of ! (_GTypeModuleClass , reserved2) - 160usize] ; ["Offset of field: _GTypeModuleClass::reserved3"] [:: std :: mem :: offset_of ! (_GTypeModuleClass , reserved3) - 168usize] ; ["Offset of field: _GTypeModuleClass::reserved4"] [:: std :: mem :: offset_of ! (_GTypeModuleClass , reserved4) - 176usize] ; } ; unsafe extern "C" { pub fn g_type_module_get_type () -> GType ; } unsafe extern "C" { pub fn g_type_module_use (module : * mut GTypeModule) -> gboolean ; } unsafe extern "C" { pub fn g_type_module_unuse (module : * mut GTypeModule) ; } unsafe extern "C" { pub fn g_type_module_set_name (module : * mut GTypeModule , name : * const gchar) ; } unsafe extern "C" { pub fn g_type_module_register_type (module : * mut GTypeModule , parent_type : GType , type_name : * const gchar , type_info : * const GTypeInfo , flags : GTypeFlags) -> GType ; } unsafe extern "C" { pub fn g_type_module_add_interface (module : * mut GTypeModule , instance_type : GType , interface_type : GType , interface_info : * const GInterfaceInfo) ; } unsafe extern "C" { pub fn g_type_module_register_enum (module : * mut GTypeModule , name : * const gchar , const_static_values : * const GEnumValue) -> GType ; } unsafe extern "C" { pub fn g_type_module_register_flags (module : * mut GTypeModule , name : * const gchar , const_static_values : * const GFlagsValue) -> GType ; } pub type GTypePluginClass = _GTypePluginClass ; pub type GTypePluginUse = :: std :: option :: Option < unsafe extern "C" fn (plugin : * mut GTypePlugin) > ; pub type GTypePluginUnuse = :: std :: option :: Option < unsafe extern "C" fn (plugin : * mut GTypePlugin) > ; pub type GTypePluginCompleteTypeInfo = :: std :: option :: Option < unsafe extern "C" fn (plugin : * mut GTypePlugin , g_type : GType , info : * mut GTypeInfo , value_table : * mut GTypeValueTable) > ; pub type GTypePluginCompleteInterfaceInfo = :: std :: option :: Option < unsafe extern "C" fn (plugin : * mut GTypePlugin , instance_type : GType , interface_type : GType , info : * mut GInterfaceInfo) > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTypePluginClass { pub base_iface : GTypeInterface , pub use_plugin : GTypePluginUse , pub unuse_plugin : GTypePluginUnuse , pub complete_type_info : GTypePluginCompleteTypeInfo , pub complete_interface_info : GTypePluginCompleteInterfaceInfo , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTypePluginClass"] [:: std :: mem :: size_of :: < _GTypePluginClass > () - 48usize] ; ["Alignment of _GTypePluginClass"] [:: std :: mem :: align_of :: < _GTypePluginClass > () - 8usize] ; ["Offset of field: _GTypePluginClass::base_iface"] [:: std :: mem :: offset_of ! (_GTypePluginClass , base_iface) - 0usize] ; ["Offset of field: _GTypePluginClass::use_plugin"] [:: std :: mem :: offset_of ! (_GTypePluginClass , use_plugin) - 16usize] ; ["Offset of field: _GTypePluginClass::unuse_plugin"] [:: std :: mem :: offset_of ! (_GTypePluginClass , unuse_plugin) - 24usize] ; ["Offset of field: _GTypePluginClass::complete_type_info"] [:: std :: mem :: offset_of ! (_GTypePluginClass , complete_type_info) - 32usize] ; ["Offset of field: _GTypePluginClass::complete_interface_info"] [:: std :: mem :: offset_of ! (_GTypePluginClass , complete_interface_info) - 40usize] ; } ; unsafe extern "C" { pub fn g_type_plugin_get_type () -> GType ; } unsafe extern "C" { pub fn g_type_plugin_use (plugin : * mut GTypePlugin) ; } unsafe extern "C" { pub fn g_type_plugin_unuse (plugin : * mut GTypePlugin) ; } unsafe extern "C" { pub fn g_type_plugin_complete_type_info (plugin : * mut GTypePlugin , g_type : GType , info : * mut GTypeInfo , value_table : * mut GTypeValueTable) ; } unsafe extern "C" { pub fn g_type_plugin_complete_interface_info (plugin : * mut GTypePlugin , instance_type : GType , interface_type : GType , info : * mut GInterfaceInfo) ; } pub type GValueArray = _GValueArray ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GValueArray { pub n_values : guint , pub values : * mut GValue , pub n_prealloced : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GValueArray"] [:: std :: mem :: size_of :: < _GValueArray > () - 24usize] ; ["Alignment of _GValueArray"] [:: std :: mem :: align_of :: < _GValueArray > () - 8usize] ; ["Offset of field: _GValueArray::n_values"] [:: std :: mem :: offset_of ! (_GValueArray , n_values) - 0usize] ; ["Offset of field: _GValueArray::values"] [:: std :: mem :: offset_of ! (_GValueArray , values) - 8usize] ; ["Offset of field: _GValueArray::n_prealloced"] [:: std :: mem :: offset_of ! (_GValueArray , n_prealloced) - 16usize] ; } ; unsafe extern "C" { pub fn g_value_array_get_type () -> GType ; } unsafe extern "C" { pub fn g_value_array_get_nth (value_array : * mut GValueArray , index_ : guint) -> * mut GValue ; } unsafe extern "C" { pub fn g_value_array_new (n_prealloced : guint) -> * mut GValueArray ; } unsafe extern "C" { pub fn g_value_array_free (value_array : * mut GValueArray) ; } unsafe extern "C" { pub fn g_value_array_copy (value_array : * const GValueArray) -> * mut GValueArray ; } unsafe extern "C" { pub fn g_value_array_prepend (value_array : * mut GValueArray , value : * const GValue) -> * mut GValueArray ; } unsafe extern "C" { pub fn g_value_array_append (value_array : * mut GValueArray , value : * const GValue) -> * mut GValueArray ; } unsafe extern "C" { pub fn g_value_array_insert (value_array : * mut GValueArray , index_ : guint , value : * const GValue) -> * mut GValueArray ; } unsafe extern "C" { pub fn g_value_array_remove (value_array : * mut GValueArray , index_ : guint) -> * mut GValueArray ; } unsafe extern "C" { pub fn g_value_array_sort (value_array : * mut GValueArray , compare_func : GCompareFunc) -> * mut GValueArray ; } unsafe extern "C" { pub fn g_value_array_sort_with_data (value_array : * mut GValueArray , compare_func : GCompareDataFunc , user_data : gpointer) -> * mut GValueArray ; } unsafe extern "C" { pub fn g_value_set_char (value : * mut GValue , v_char : gchar) ; } unsafe extern "C" { pub fn g_value_get_char (value : * const GValue) -> gchar ; } unsafe extern "C" { pub fn g_value_set_schar (value : * mut GValue , v_char : gint8) ; } unsafe extern "C" { pub fn g_value_get_schar (value : * const GValue) -> gint8 ; } unsafe extern "C" { pub fn g_value_set_uchar (value : * mut GValue , v_uchar : guchar) ; } unsafe extern "C" { pub fn g_value_get_uchar (value : * const GValue) -> guchar ; } unsafe extern "C" { pub fn g_value_set_boolean (value : * mut GValue , v_boolean : gboolean) ; } unsafe extern "C" { pub fn g_value_get_boolean (value : * const GValue) -> gboolean ; } unsafe extern "C" { pub fn g_value_set_int (value : * mut GValue , v_int : gint) ; } unsafe extern "C" { pub fn g_value_get_int (value : * const GValue) -> gint ; } unsafe extern "C" { pub fn g_value_set_uint (value : * mut GValue , v_uint : guint) ; } unsafe extern "C" { pub fn g_value_get_uint (value : * const GValue) -> guint ; } unsafe extern "C" { pub fn g_value_set_long (value : * mut GValue , v_long : glong) ; } unsafe extern "C" { pub fn g_value_get_long (value : * const GValue) -> glong ; } unsafe extern "C" { pub fn g_value_set_ulong (value : * mut GValue , v_ulong : gulong) ; } unsafe extern "C" { pub fn g_value_get_ulong (value : * const GValue) -> gulong ; } unsafe extern "C" { pub fn g_value_set_int64 (value : * mut GValue , v_int64 : gint64) ; } unsafe extern "C" { pub fn g_value_get_int64 (value : * const GValue) -> gint64 ; } unsafe extern "C" { pub fn g_value_set_uint64 (value : * mut GValue , v_uint64 : guint64) ; } unsafe extern "C" { pub fn g_value_get_uint64 (value : * const GValue) -> guint64 ; } unsafe extern "C" { pub fn g_value_set_float (value : * mut GValue , v_float : gfloat) ; } unsafe extern "C" { pub fn g_value_get_float (value : * const GValue) -> gfloat ; } unsafe extern "C" { pub fn g_value_set_double (value : * mut GValue , v_double : gdouble) ; } unsafe extern "C" { pub fn g_value_get_double (value : * const GValue) -> gdouble ; } unsafe extern "C" { pub fn g_value_set_string (value : * mut GValue , v_string : * const gchar) ; } unsafe extern "C" { pub fn g_value_set_static_string (value : * mut GValue , v_string : * const gchar) ; } unsafe extern "C" { pub fn g_value_set_interned_string (value : * mut GValue , v_string : * const gchar) ; } unsafe extern "C" { pub fn g_value_get_string (value : * const GValue) -> * const gchar ; } unsafe extern "C" { pub fn g_value_dup_string (value : * const GValue) -> * mut gchar ; } unsafe extern "C" { pub fn g_value_steal_string (value : * mut GValue) -> * mut gchar ; } unsafe extern "C" { pub fn g_value_set_pointer (value : * mut GValue , v_pointer : gpointer) ; } unsafe extern "C" { pub fn g_value_get_pointer (value : * const GValue) -> gpointer ; } unsafe extern "C" { pub fn g_gtype_get_type () -> GType ; } unsafe extern "C" { pub fn g_value_set_gtype (value : * mut GValue , v_gtype : GType) ; } unsafe extern "C" { pub fn g_value_get_gtype (value : * const GValue) -> GType ; } unsafe extern "C" { pub fn g_value_set_variant (value : * mut GValue , variant : * mut GVariant) ; } unsafe extern "C" { pub fn g_value_take_variant (value : * mut GValue , variant : * mut GVariant) ; } unsafe extern "C" { pub fn g_value_get_variant (value : * const GValue) -> * mut GVariant ; } unsafe extern "C" { pub fn g_value_dup_variant (value : * const GValue) -> * mut GVariant ; } unsafe extern "C" { pub fn g_pointer_type_register_static (name : * const gchar) -> GType ; } unsafe extern "C" { pub fn g_strdup_value_contents (value : * const GValue) -> * mut gchar ; } unsafe extern "C" { pub fn g_value_take_string (value : * mut GValue , v_string : * mut gchar) ; } unsafe extern "C" { pub fn g_value_set_string_take_ownership (value : * mut GValue , v_string : * mut gchar) ; } pub type gchararray = * mut gchar ; pub type GClosure_autoptr = * mut GClosure ; pub type GClosure_listautoptr = * mut GList ; pub type GClosure_slistautoptr = * mut GSList ; pub type GClosure_queueautoptr = * mut GQueue ; pub type GEnumClass_autoptr = * mut GEnumClass ; pub type GEnumClass_listautoptr = * mut GList ; pub type GEnumClass_slistautoptr = * mut GSList ; pub type GEnumClass_queueautoptr = * mut GQueue ; pub type GFlagsClass_autoptr = * mut GFlagsClass ; pub type GFlagsClass_listautoptr = * mut GList ; pub type GFlagsClass_slistautoptr = * mut GSList ; pub type GFlagsClass_queueautoptr = * mut GQueue ; pub type GObject_autoptr = * mut GObject ; pub type GObject_listautoptr = * mut GList ; pub type GObject_slistautoptr = * mut GSList ; pub type GObject_queueautoptr = * mut GQueue ; pub type GInitiallyUnowned_autoptr = * mut GInitiallyUnowned ; pub type GInitiallyUnowned_listautoptr = * mut GList ; pub type GInitiallyUnowned_slistautoptr = * mut GSList ; pub type GInitiallyUnowned_queueautoptr = * mut GQueue ; pub type GParamSpec_autoptr = * mut GParamSpec ; pub type GParamSpec_listautoptr = * mut GList ; pub type GParamSpec_slistautoptr = * mut GSList ; pub type GParamSpec_queueautoptr = * mut GQueue ; pub type GTypeClass_autoptr = * mut GTypeClass ; pub type GTypeClass_listautoptr = * mut GList ; pub type GTypeClass_slistautoptr = * mut GSList ; pub type GTypeClass_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkSourcePrivate { _unused : [u8 ; 0] , } pub type PkSourcePrivate = _PkSourcePrivate ; pub type PkSource = _PkSource ; pub type PkSourceClass = _PkSourceClass ; pub type PkSource_autoptr = * mut PkSource ; pub type PkSource_listautoptr = * mut GList ; pub type PkSource_slistautoptr = * mut GSList ; pub type PkSource_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkSource { pub parent : GObject , pub priv_ : * mut PkSourcePrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkSource"] [:: std :: mem :: size_of :: < _PkSource > () - 32usize] ; ["Alignment of _PkSource"] [:: std :: mem :: align_of :: < _PkSource > () - 8usize] ; ["Offset of field: _PkSource::parent"] [:: std :: mem :: offset_of ! (_PkSource , parent) - 0usize] ; ["Offset of field: _PkSource::priv_"] [:: std :: mem :: offset_of ! (_PkSource , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkSourceClass { pub parent_class : GObjectClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkSourceClass"] [:: std :: mem :: size_of :: < _PkSourceClass > () - 176usize] ; ["Alignment of _PkSourceClass"] [:: std :: mem :: align_of :: < _PkSourceClass > () - 8usize] ; ["Offset of field: _PkSourceClass::parent_class"] [:: std :: mem :: offset_of ! (_PkSourceClass , parent_class) - 0usize] ; ["Offset of field: _PkSourceClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkSourceClass , _pk_reserved1) - 136usize] ; ["Offset of field: _PkSourceClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkSourceClass , _pk_reserved2) - 144usize] ; ["Offset of field: _PkSourceClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkSourceClass , _pk_reserved3) - 152usize] ; ["Offset of field: _PkSourceClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkSourceClass , _pk_reserved4) - 160usize] ; ["Offset of field: _PkSourceClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkSourceClass , _pk_reserved5) - 168usize] ; } ; unsafe extern "C" { pub fn pk_source_get_type () -> GType ; } unsafe extern "C" { pub fn pk_source_new () -> * mut PkSource ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkCategoryPrivate { _unused : [u8 ; 0] , } pub type PkCategoryPrivate = _PkCategoryPrivate ; pub type PkCategory = _PkCategory ; pub type PkCategoryClass = _PkCategoryClass ; pub type PkCategory_autoptr = * mut PkCategory ; pub type PkCategory_listautoptr = * mut GList ; pub type PkCategory_slistautoptr = * mut GSList ; pub type PkCategory_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkCategory { pub parent : PkSource , pub priv_ : * mut PkCategoryPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkCategory"] [:: std :: mem :: size_of :: < _PkCategory > () - 40usize] ; ["Alignment of _PkCategory"] [:: std :: mem :: align_of :: < _PkCategory > () - 8usize] ; ["Offset of field: _PkCategory::parent"] [:: std :: mem :: offset_of ! (_PkCategory , parent) - 0usize] ; ["Offset of field: _PkCategory::priv_"] [:: std :: mem :: offset_of ! (_PkCategory , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkCategoryClass { pub parent_class : PkSourceClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkCategoryClass"] [:: std :: mem :: size_of :: < _PkCategoryClass > () - 216usize] ; ["Alignment of _PkCategoryClass"] [:: std :: mem :: align_of :: < _PkCategoryClass > () - 8usize] ; ["Offset of field: _PkCategoryClass::parent_class"] [:: std :: mem :: offset_of ! (_PkCategoryClass , parent_class) - 0usize] ; ["Offset of field: _PkCategoryClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkCategoryClass , _pk_reserved1) - 176usize] ; ["Offset of field: _PkCategoryClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkCategoryClass , _pk_reserved2) - 184usize] ; ["Offset of field: _PkCategoryClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkCategoryClass , _pk_reserved3) - 192usize] ; ["Offset of field: _PkCategoryClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkCategoryClass , _pk_reserved4) - 200usize] ; ["Offset of field: _PkCategoryClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkCategoryClass , _pk_reserved5) - 208usize] ; } ; unsafe extern "C" { pub fn pk_category_get_type () -> GType ; } unsafe extern "C" { pub fn pk_category_new () -> * mut PkCategory ; } unsafe extern "C" { pub fn pk_category_get_parent_id (category : * mut PkCategory) -> * const gchar ; } unsafe extern "C" { pub fn pk_category_set_parent_id (category : * mut PkCategory , parent_id : * const gchar) ; } unsafe extern "C" { pub fn pk_category_get_id (category : * mut PkCategory) -> * const gchar ; } unsafe extern "C" { pub fn pk_category_set_id (category : * mut PkCategory , cat_id : * const gchar) ; } unsafe extern "C" { pub fn pk_category_get_name (category : * mut PkCategory) -> * const gchar ; } unsafe extern "C" { pub fn pk_category_set_name (category : * mut PkCategory , name : * const gchar) ; } unsafe extern "C" { pub fn pk_category_get_summary (category : * mut PkCategory) -> * const gchar ; } unsafe extern "C" { pub fn pk_category_set_summary (category : * mut PkCategory , summary : * const gchar) ; } unsafe extern "C" { pub fn pk_category_get_icon (category : * mut PkCategory) -> * const gchar ; } unsafe extern "C" { pub fn pk_category_set_icon (category : * mut PkCategory , icon : * const gchar) ; } pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_NONE : GAppInfoCreateFlags = 0 ; pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_NEEDS_TERMINAL : GAppInfoCreateFlags = 1 ; pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_SUPPORTS_URIS : GAppInfoCreateFlags = 2 ; pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION : GAppInfoCreateFlags = 4 ; pub type GAppInfoCreateFlags = :: std :: os :: raw :: c_uint ; pub const GConverterFlags_G_CONVERTER_NO_FLAGS : GConverterFlags = 0 ; pub const GConverterFlags_G_CONVERTER_INPUT_AT_END : GConverterFlags = 1 ; pub const GConverterFlags_G_CONVERTER_FLUSH : GConverterFlags = 2 ; pub type GConverterFlags = :: std :: os :: raw :: c_uint ; pub const GConverterResult_G_CONVERTER_ERROR : GConverterResult = 0 ; pub const GConverterResult_G_CONVERTER_CONVERTED : GConverterResult = 1 ; pub const GConverterResult_G_CONVERTER_FINISHED : GConverterResult = 2 ; pub const GConverterResult_G_CONVERTER_FLUSHED : GConverterResult = 3 ; pub type GConverterResult = :: std :: os :: raw :: c_uint ; pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN : GDataStreamByteOrder = 0 ; pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN : GDataStreamByteOrder = 1 ; pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN : GDataStreamByteOrder = 2 ; pub type GDataStreamByteOrder = :: std :: os :: raw :: c_uint ; pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_LF : GDataStreamNewlineType = 0 ; pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_CR : GDataStreamNewlineType = 1 ; pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_CR_LF : GDataStreamNewlineType = 2 ; pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_ANY : GDataStreamNewlineType = 3 ; pub type GDataStreamNewlineType = :: std :: os :: raw :: c_uint ; pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INVALID : GFileAttributeType = 0 ; pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_STRING : GFileAttributeType = 1 ; pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_BYTE_STRING : GFileAttributeType = 2 ; pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_BOOLEAN : GFileAttributeType = 3 ; pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_UINT32 : GFileAttributeType = 4 ; pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INT32 : GFileAttributeType = 5 ; pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_UINT64 : GFileAttributeType = 6 ; pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INT64 : GFileAttributeType = 7 ; pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_OBJECT : GFileAttributeType = 8 ; pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_STRINGV : GFileAttributeType = 9 ; pub type GFileAttributeType = :: std :: os :: raw :: c_uint ; pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_NONE : GFileAttributeInfoFlags = 0 ; pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE : GFileAttributeInfoFlags = 1 ; pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED : GFileAttributeInfoFlags = 2 ; pub type GFileAttributeInfoFlags = :: std :: os :: raw :: c_uint ; pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_UNSET : GFileAttributeStatus = 0 ; pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_SET : GFileAttributeStatus = 1 ; pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING : GFileAttributeStatus = 2 ; pub type GFileAttributeStatus = :: std :: os :: raw :: c_uint ; pub const GFileQueryInfoFlags_G_FILE_QUERY_INFO_NONE : GFileQueryInfoFlags = 0 ; pub const GFileQueryInfoFlags_G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS : GFileQueryInfoFlags = 1 ; pub type GFileQueryInfoFlags = :: std :: os :: raw :: c_uint ; pub const GFileCreateFlags_G_FILE_CREATE_NONE : GFileCreateFlags = 0 ; pub const GFileCreateFlags_G_FILE_CREATE_PRIVATE : GFileCreateFlags = 1 ; pub const GFileCreateFlags_G_FILE_CREATE_REPLACE_DESTINATION : GFileCreateFlags = 2 ; pub type GFileCreateFlags = :: std :: os :: raw :: c_uint ; pub const GFileMeasureFlags_G_FILE_MEASURE_NONE : GFileMeasureFlags = 0 ; pub const GFileMeasureFlags_G_FILE_MEASURE_REPORT_ANY_ERROR : GFileMeasureFlags = 2 ; pub const GFileMeasureFlags_G_FILE_MEASURE_APPARENT_SIZE : GFileMeasureFlags = 4 ; pub const GFileMeasureFlags_G_FILE_MEASURE_NO_XDEV : GFileMeasureFlags = 8 ; pub type GFileMeasureFlags = :: std :: os :: raw :: c_uint ; pub const GMountMountFlags_G_MOUNT_MOUNT_NONE : GMountMountFlags = 0 ; pub type GMountMountFlags = :: std :: os :: raw :: c_uint ; pub const GMountUnmountFlags_G_MOUNT_UNMOUNT_NONE : GMountUnmountFlags = 0 ; pub const GMountUnmountFlags_G_MOUNT_UNMOUNT_FORCE : GMountUnmountFlags = 1 ; pub type GMountUnmountFlags = :: std :: os :: raw :: c_uint ; pub const GDriveStartFlags_G_DRIVE_START_NONE : GDriveStartFlags = 0 ; pub type GDriveStartFlags = :: std :: os :: raw :: c_uint ; pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_UNKNOWN : GDriveStartStopType = 0 ; pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_SHUTDOWN : GDriveStartStopType = 1 ; pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_NETWORK : GDriveStartStopType = 2 ; pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_MULTIDISK : GDriveStartStopType = 3 ; pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_PASSWORD : GDriveStartStopType = 4 ; pub type GDriveStartStopType = :: std :: os :: raw :: c_uint ; pub const GFileCopyFlags_G_FILE_COPY_NONE : GFileCopyFlags = 0 ; pub const GFileCopyFlags_G_FILE_COPY_OVERWRITE : GFileCopyFlags = 1 ; pub const GFileCopyFlags_G_FILE_COPY_BACKUP : GFileCopyFlags = 2 ; pub const GFileCopyFlags_G_FILE_COPY_NOFOLLOW_SYMLINKS : GFileCopyFlags = 4 ; pub const GFileCopyFlags_G_FILE_COPY_ALL_METADATA : GFileCopyFlags = 8 ; pub const GFileCopyFlags_G_FILE_COPY_NO_FALLBACK_FOR_MOVE : GFileCopyFlags = 16 ; pub const GFileCopyFlags_G_FILE_COPY_TARGET_DEFAULT_PERMS : GFileCopyFlags = 32 ; pub const GFileCopyFlags_G_FILE_COPY_TARGET_DEFAULT_MODIFIED_TIME : GFileCopyFlags = 64 ; pub type GFileCopyFlags = :: std :: os :: raw :: c_uint ; pub const GFileMonitorFlags_G_FILE_MONITOR_NONE : GFileMonitorFlags = 0 ; pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_MOUNTS : GFileMonitorFlags = 1 ; pub const GFileMonitorFlags_G_FILE_MONITOR_SEND_MOVED : GFileMonitorFlags = 2 ; pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_HARD_LINKS : GFileMonitorFlags = 4 ; pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_MOVES : GFileMonitorFlags = 8 ; pub type GFileMonitorFlags = :: std :: os :: raw :: c_uint ; pub const GFileType_G_FILE_TYPE_UNKNOWN : GFileType = 0 ; pub const GFileType_G_FILE_TYPE_REGULAR : GFileType = 1 ; pub const GFileType_G_FILE_TYPE_DIRECTORY : GFileType = 2 ; pub const GFileType_G_FILE_TYPE_SYMBOLIC_LINK : GFileType = 3 ; pub const GFileType_G_FILE_TYPE_SPECIAL : GFileType = 4 ; pub const GFileType_G_FILE_TYPE_SHORTCUT : GFileType = 5 ; pub const GFileType_G_FILE_TYPE_MOUNTABLE : GFileType = 6 ; pub type GFileType = :: std :: os :: raw :: c_uint ; pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS : GFilesystemPreviewType = 0 ; pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL : GFilesystemPreviewType = 1 ; pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_NEVER : GFilesystemPreviewType = 2 ; pub type GFilesystemPreviewType = :: std :: os :: raw :: c_uint ; pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CHANGED : GFileMonitorEvent = 0 ; pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT : GFileMonitorEvent = 1 ; pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_DELETED : GFileMonitorEvent = 2 ; pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CREATED : GFileMonitorEvent = 3 ; pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED : GFileMonitorEvent = 4 ; pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_PRE_UNMOUNT : GFileMonitorEvent = 5 ; pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_UNMOUNTED : GFileMonitorEvent = 6 ; pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED : GFileMonitorEvent = 7 ; pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_RENAMED : GFileMonitorEvent = 8 ; pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED_IN : GFileMonitorEvent = 9 ; pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED_OUT : GFileMonitorEvent = 10 ; pub type GFileMonitorEvent = :: std :: os :: raw :: c_uint ; pub const GIOErrorEnum_G_IO_ERROR_FAILED : GIOErrorEnum = 0 ; pub const GIOErrorEnum_G_IO_ERROR_NOT_FOUND : GIOErrorEnum = 1 ; pub const GIOErrorEnum_G_IO_ERROR_EXISTS : GIOErrorEnum = 2 ; pub const GIOErrorEnum_G_IO_ERROR_IS_DIRECTORY : GIOErrorEnum = 3 ; pub const GIOErrorEnum_G_IO_ERROR_NOT_DIRECTORY : GIOErrorEnum = 4 ; pub const GIOErrorEnum_G_IO_ERROR_NOT_EMPTY : GIOErrorEnum = 5 ; pub const GIOErrorEnum_G_IO_ERROR_NOT_REGULAR_FILE : GIOErrorEnum = 6 ; pub const GIOErrorEnum_G_IO_ERROR_NOT_SYMBOLIC_LINK : GIOErrorEnum = 7 ; pub const GIOErrorEnum_G_IO_ERROR_NOT_MOUNTABLE_FILE : GIOErrorEnum = 8 ; pub const GIOErrorEnum_G_IO_ERROR_FILENAME_TOO_LONG : GIOErrorEnum = 9 ; pub const GIOErrorEnum_G_IO_ERROR_INVALID_FILENAME : GIOErrorEnum = 10 ; pub const GIOErrorEnum_G_IO_ERROR_TOO_MANY_LINKS : GIOErrorEnum = 11 ; pub const GIOErrorEnum_G_IO_ERROR_NO_SPACE : GIOErrorEnum = 12 ; pub const GIOErrorEnum_G_IO_ERROR_INVALID_ARGUMENT : GIOErrorEnum = 13 ; pub const GIOErrorEnum_G_IO_ERROR_PERMISSION_DENIED : GIOErrorEnum = 14 ; pub const GIOErrorEnum_G_IO_ERROR_NOT_SUPPORTED : GIOErrorEnum = 15 ; pub const GIOErrorEnum_G_IO_ERROR_NOT_MOUNTED : GIOErrorEnum = 16 ; pub const GIOErrorEnum_G_IO_ERROR_ALREADY_MOUNTED : GIOErrorEnum = 17 ; pub const GIOErrorEnum_G_IO_ERROR_CLOSED : GIOErrorEnum = 18 ; pub const GIOErrorEnum_G_IO_ERROR_CANCELLED : GIOErrorEnum = 19 ; pub const GIOErrorEnum_G_IO_ERROR_PENDING : GIOErrorEnum = 20 ; pub const GIOErrorEnum_G_IO_ERROR_READ_ONLY : GIOErrorEnum = 21 ; pub const GIOErrorEnum_G_IO_ERROR_CANT_CREATE_BACKUP : GIOErrorEnum = 22 ; pub const GIOErrorEnum_G_IO_ERROR_WRONG_ETAG : GIOErrorEnum = 23 ; pub const GIOErrorEnum_G_IO_ERROR_TIMED_OUT : GIOErrorEnum = 24 ; pub const GIOErrorEnum_G_IO_ERROR_WOULD_RECURSE : GIOErrorEnum = 25 ; pub const GIOErrorEnum_G_IO_ERROR_BUSY : GIOErrorEnum = 26 ; pub const GIOErrorEnum_G_IO_ERROR_WOULD_BLOCK : GIOErrorEnum = 27 ; pub const GIOErrorEnum_G_IO_ERROR_HOST_NOT_FOUND : GIOErrorEnum = 28 ; pub const GIOErrorEnum_G_IO_ERROR_WOULD_MERGE : GIOErrorEnum = 29 ; pub const GIOErrorEnum_G_IO_ERROR_FAILED_HANDLED : GIOErrorEnum = 30 ; pub const GIOErrorEnum_G_IO_ERROR_TOO_MANY_OPEN_FILES : GIOErrorEnum = 31 ; pub const GIOErrorEnum_G_IO_ERROR_NOT_INITIALIZED : GIOErrorEnum = 32 ; pub const GIOErrorEnum_G_IO_ERROR_ADDRESS_IN_USE : GIOErrorEnum = 33 ; pub const GIOErrorEnum_G_IO_ERROR_PARTIAL_INPUT : GIOErrorEnum = 34 ; pub const GIOErrorEnum_G_IO_ERROR_INVALID_DATA : GIOErrorEnum = 35 ; pub const GIOErrorEnum_G_IO_ERROR_DBUS_ERROR : GIOErrorEnum = 36 ; pub const GIOErrorEnum_G_IO_ERROR_HOST_UNREACHABLE : GIOErrorEnum = 37 ; pub const GIOErrorEnum_G_IO_ERROR_NETWORK_UNREACHABLE : GIOErrorEnum = 38 ; pub const GIOErrorEnum_G_IO_ERROR_CONNECTION_REFUSED : GIOErrorEnum = 39 ; pub const GIOErrorEnum_G_IO_ERROR_PROXY_FAILED : GIOErrorEnum = 40 ; pub const GIOErrorEnum_G_IO_ERROR_PROXY_AUTH_FAILED : GIOErrorEnum = 41 ; pub const GIOErrorEnum_G_IO_ERROR_PROXY_NEED_AUTH : GIOErrorEnum = 42 ; pub const GIOErrorEnum_G_IO_ERROR_PROXY_NOT_ALLOWED : GIOErrorEnum = 43 ; pub const GIOErrorEnum_G_IO_ERROR_BROKEN_PIPE : GIOErrorEnum = 44 ; pub const GIOErrorEnum_G_IO_ERROR_CONNECTION_CLOSED : GIOErrorEnum = 44 ; pub const GIOErrorEnum_G_IO_ERROR_NOT_CONNECTED : GIOErrorEnum = 45 ; pub const GIOErrorEnum_G_IO_ERROR_MESSAGE_TOO_LARGE : GIOErrorEnum = 46 ; pub const GIOErrorEnum_G_IO_ERROR_NO_SUCH_DEVICE : GIOErrorEnum = 47 ; pub const GIOErrorEnum_G_IO_ERROR_DESTINATION_UNSET : GIOErrorEnum = 48 ; pub type GIOErrorEnum = :: std :: os :: raw :: c_uint ; pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_PASSWORD : GAskPasswordFlags = 1 ; pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_USERNAME : GAskPasswordFlags = 2 ; pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_DOMAIN : GAskPasswordFlags = 4 ; pub const GAskPasswordFlags_G_ASK_PASSWORD_SAVING_SUPPORTED : GAskPasswordFlags = 8 ; pub const GAskPasswordFlags_G_ASK_PASSWORD_ANONYMOUS_SUPPORTED : GAskPasswordFlags = 16 ; pub const GAskPasswordFlags_G_ASK_PASSWORD_TCRYPT : GAskPasswordFlags = 32 ; pub type GAskPasswordFlags = :: std :: os :: raw :: c_uint ; pub const GPasswordSave_G_PASSWORD_SAVE_NEVER : GPasswordSave = 0 ; pub const GPasswordSave_G_PASSWORD_SAVE_FOR_SESSION : GPasswordSave = 1 ; pub const GPasswordSave_G_PASSWORD_SAVE_PERMANENTLY : GPasswordSave = 2 ; pub type GPasswordSave = :: std :: os :: raw :: c_uint ; pub const GMountOperationResult_G_MOUNT_OPERATION_HANDLED : GMountOperationResult = 0 ; pub const GMountOperationResult_G_MOUNT_OPERATION_ABORTED : GMountOperationResult = 1 ; pub const GMountOperationResult_G_MOUNT_OPERATION_UNHANDLED : GMountOperationResult = 2 ; pub type GMountOperationResult = :: std :: os :: raw :: c_uint ; pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_NONE : GOutputStreamSpliceFlags = 0 ; pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE : GOutputStreamSpliceFlags = 1 ; pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET : GOutputStreamSpliceFlags = 2 ; pub type GOutputStreamSpliceFlags = :: std :: os :: raw :: c_uint ; pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_NONE : GIOStreamSpliceFlags = 0 ; pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_CLOSE_STREAM1 : GIOStreamSpliceFlags = 1 ; pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_CLOSE_STREAM2 : GIOStreamSpliceFlags = 2 ; pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_WAIT_FOR_BOTH : GIOStreamSpliceFlags = 4 ; pub type GIOStreamSpliceFlags = :: std :: os :: raw :: c_uint ; pub const GEmblemOrigin_G_EMBLEM_ORIGIN_UNKNOWN : GEmblemOrigin = 0 ; pub const GEmblemOrigin_G_EMBLEM_ORIGIN_DEVICE : GEmblemOrigin = 1 ; pub const GEmblemOrigin_G_EMBLEM_ORIGIN_LIVEMETADATA : GEmblemOrigin = 2 ; pub const GEmblemOrigin_G_EMBLEM_ORIGIN_TAG : GEmblemOrigin = 3 ; pub type GEmblemOrigin = :: std :: os :: raw :: c_uint ; pub const GResolverError_G_RESOLVER_ERROR_NOT_FOUND : GResolverError = 0 ; pub const GResolverError_G_RESOLVER_ERROR_TEMPORARY_FAILURE : GResolverError = 1 ; pub const GResolverError_G_RESOLVER_ERROR_INTERNAL : GResolverError = 2 ; pub type GResolverError = :: std :: os :: raw :: c_uint ; pub const GResolverRecordType_G_RESOLVER_RECORD_SRV : GResolverRecordType = 1 ; pub const GResolverRecordType_G_RESOLVER_RECORD_MX : GResolverRecordType = 2 ; pub const GResolverRecordType_G_RESOLVER_RECORD_TXT : GResolverRecordType = 3 ; pub const GResolverRecordType_G_RESOLVER_RECORD_SOA : GResolverRecordType = 4 ; pub const GResolverRecordType_G_RESOLVER_RECORD_NS : GResolverRecordType = 5 ; pub type GResolverRecordType = :: std :: os :: raw :: c_uint ; pub const GResourceError_G_RESOURCE_ERROR_NOT_FOUND : GResourceError = 0 ; pub const GResourceError_G_RESOURCE_ERROR_INTERNAL : GResourceError = 1 ; pub type GResourceError = :: std :: os :: raw :: c_uint ; pub const GResourceFlags_G_RESOURCE_FLAGS_NONE : GResourceFlags = 0 ; pub const GResourceFlags_G_RESOURCE_FLAGS_COMPRESSED : GResourceFlags = 1 ; pub type GResourceFlags = :: std :: os :: raw :: c_uint ; pub const GResourceLookupFlags_G_RESOURCE_LOOKUP_FLAGS_NONE : GResourceLookupFlags = 0 ; pub type GResourceLookupFlags = :: std :: os :: raw :: c_uint ; pub const GSocketFamily_G_SOCKET_FAMILY_INVALID : GSocketFamily = 0 ; pub const GSocketFamily_G_SOCKET_FAMILY_UNIX : GSocketFamily = 1 ; pub const GSocketFamily_G_SOCKET_FAMILY_IPV4 : GSocketFamily = 2 ; pub const GSocketFamily_G_SOCKET_FAMILY_IPV6 : GSocketFamily = 10 ; pub type GSocketFamily = :: std :: os :: raw :: c_uint ; pub const GSocketType_G_SOCKET_TYPE_INVALID : GSocketType = 0 ; pub const GSocketType_G_SOCKET_TYPE_STREAM : GSocketType = 1 ; pub const GSocketType_G_SOCKET_TYPE_DATAGRAM : GSocketType = 2 ; pub const GSocketType_G_SOCKET_TYPE_SEQPACKET : GSocketType = 3 ; pub type GSocketType = :: std :: os :: raw :: c_uint ; pub const GSocketMsgFlags_G_SOCKET_MSG_NONE : GSocketMsgFlags = 0 ; pub const GSocketMsgFlags_G_SOCKET_MSG_OOB : GSocketMsgFlags = 1 ; pub const GSocketMsgFlags_G_SOCKET_MSG_PEEK : GSocketMsgFlags = 2 ; pub const GSocketMsgFlags_G_SOCKET_MSG_DONTROUTE : GSocketMsgFlags = 4 ; pub type GSocketMsgFlags = :: std :: os :: raw :: c_uint ; pub const GSocketProtocol_G_SOCKET_PROTOCOL_UNKNOWN : GSocketProtocol = - 1 ; pub const GSocketProtocol_G_SOCKET_PROTOCOL_DEFAULT : GSocketProtocol = 0 ; pub const GSocketProtocol_G_SOCKET_PROTOCOL_TCP : GSocketProtocol = 6 ; pub const GSocketProtocol_G_SOCKET_PROTOCOL_UDP : GSocketProtocol = 17 ; pub const GSocketProtocol_G_SOCKET_PROTOCOL_SCTP : GSocketProtocol = 132 ; pub type GSocketProtocol = :: std :: os :: raw :: c_int ; pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_ZLIB : GZlibCompressorFormat = 0 ; pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_GZIP : GZlibCompressorFormat = 1 ; pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_RAW : GZlibCompressorFormat = 2 ; pub type GZlibCompressorFormat = :: std :: os :: raw :: c_uint ; pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_INVALID : GUnixSocketAddressType = 0 ; pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ANONYMOUS : GUnixSocketAddressType = 1 ; pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_PATH : GUnixSocketAddressType = 2 ; pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ABSTRACT : GUnixSocketAddressType = 3 ; pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED : GUnixSocketAddressType = 4 ; pub type GUnixSocketAddressType = :: std :: os :: raw :: c_uint ; pub const GBusType_G_BUS_TYPE_STARTER : GBusType = - 1 ; pub const GBusType_G_BUS_TYPE_NONE : GBusType = 0 ; pub const GBusType_G_BUS_TYPE_SYSTEM : GBusType = 1 ; pub const GBusType_G_BUS_TYPE_SESSION : GBusType = 2 ; pub type GBusType = :: std :: os :: raw :: c_int ; pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_NONE : GBusNameOwnerFlags = 0 ; pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT : GBusNameOwnerFlags = 1 ; pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_REPLACE : GBusNameOwnerFlags = 2 ; pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE : GBusNameOwnerFlags = 4 ; pub type GBusNameOwnerFlags = :: std :: os :: raw :: c_uint ; pub const GBusNameWatcherFlags_G_BUS_NAME_WATCHER_FLAGS_NONE : GBusNameWatcherFlags = 0 ; pub const GBusNameWatcherFlags_G_BUS_NAME_WATCHER_FLAGS_AUTO_START : GBusNameWatcherFlags = 1 ; pub type GBusNameWatcherFlags = :: std :: os :: raw :: c_uint ; pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_NONE : GDBusProxyFlags = 0 ; pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES : GDBusProxyFlags = 1 ; pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS : GDBusProxyFlags = 2 ; pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START : GDBusProxyFlags = 4 ; pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES : GDBusProxyFlags = 8 ; pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION : GDBusProxyFlags = 16 ; pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_NO_MATCH_RULE : GDBusProxyFlags = 32 ; pub type GDBusProxyFlags = :: std :: os :: raw :: c_uint ; pub const GDBusError_G_DBUS_ERROR_FAILED : GDBusError = 0 ; pub const GDBusError_G_DBUS_ERROR_NO_MEMORY : GDBusError = 1 ; pub const GDBusError_G_DBUS_ERROR_SERVICE_UNKNOWN : GDBusError = 2 ; pub const GDBusError_G_DBUS_ERROR_NAME_HAS_NO_OWNER : GDBusError = 3 ; pub const GDBusError_G_DBUS_ERROR_NO_REPLY : GDBusError = 4 ; pub const GDBusError_G_DBUS_ERROR_IO_ERROR : GDBusError = 5 ; pub const GDBusError_G_DBUS_ERROR_BAD_ADDRESS : GDBusError = 6 ; pub const GDBusError_G_DBUS_ERROR_NOT_SUPPORTED : GDBusError = 7 ; pub const GDBusError_G_DBUS_ERROR_LIMITS_EXCEEDED : GDBusError = 8 ; pub const GDBusError_G_DBUS_ERROR_ACCESS_DENIED : GDBusError = 9 ; pub const GDBusError_G_DBUS_ERROR_AUTH_FAILED : GDBusError = 10 ; pub const GDBusError_G_DBUS_ERROR_NO_SERVER : GDBusError = 11 ; pub const GDBusError_G_DBUS_ERROR_TIMEOUT : GDBusError = 12 ; pub const GDBusError_G_DBUS_ERROR_NO_NETWORK : GDBusError = 13 ; pub const GDBusError_G_DBUS_ERROR_ADDRESS_IN_USE : GDBusError = 14 ; pub const GDBusError_G_DBUS_ERROR_DISCONNECTED : GDBusError = 15 ; pub const GDBusError_G_DBUS_ERROR_INVALID_ARGS : GDBusError = 16 ; pub const GDBusError_G_DBUS_ERROR_FILE_NOT_FOUND : GDBusError = 17 ; pub const GDBusError_G_DBUS_ERROR_FILE_EXISTS : GDBusError = 18 ; pub const GDBusError_G_DBUS_ERROR_UNKNOWN_METHOD : GDBusError = 19 ; pub const GDBusError_G_DBUS_ERROR_TIMED_OUT : GDBusError = 20 ; pub const GDBusError_G_DBUS_ERROR_MATCH_RULE_NOT_FOUND : GDBusError = 21 ; pub const GDBusError_G_DBUS_ERROR_MATCH_RULE_INVALID : GDBusError = 22 ; pub const GDBusError_G_DBUS_ERROR_SPAWN_EXEC_FAILED : GDBusError = 23 ; pub const GDBusError_G_DBUS_ERROR_SPAWN_FORK_FAILED : GDBusError = 24 ; pub const GDBusError_G_DBUS_ERROR_SPAWN_CHILD_EXITED : GDBusError = 25 ; pub const GDBusError_G_DBUS_ERROR_SPAWN_CHILD_SIGNALED : GDBusError = 26 ; pub const GDBusError_G_DBUS_ERROR_SPAWN_FAILED : GDBusError = 27 ; pub const GDBusError_G_DBUS_ERROR_SPAWN_SETUP_FAILED : GDBusError = 28 ; pub const GDBusError_G_DBUS_ERROR_SPAWN_CONFIG_INVALID : GDBusError = 29 ; pub const GDBusError_G_DBUS_ERROR_SPAWN_SERVICE_INVALID : GDBusError = 30 ; pub const GDBusError_G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND : GDBusError = 31 ; pub const GDBusError_G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID : GDBusError = 32 ; pub const GDBusError_G_DBUS_ERROR_SPAWN_FILE_INVALID : GDBusError = 33 ; pub const GDBusError_G_DBUS_ERROR_SPAWN_NO_MEMORY : GDBusError = 34 ; pub const GDBusError_G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN : GDBusError = 35 ; pub const GDBusError_G_DBUS_ERROR_INVALID_SIGNATURE : GDBusError = 36 ; pub const GDBusError_G_DBUS_ERROR_INVALID_FILE_CONTENT : GDBusError = 37 ; pub const GDBusError_G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN : GDBusError = 38 ; pub const GDBusError_G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN : GDBusError = 39 ; pub const GDBusError_G_DBUS_ERROR_OBJECT_PATH_IN_USE : GDBusError = 40 ; pub const GDBusError_G_DBUS_ERROR_UNKNOWN_OBJECT : GDBusError = 41 ; pub const GDBusError_G_DBUS_ERROR_UNKNOWN_INTERFACE : GDBusError = 42 ; pub const GDBusError_G_DBUS_ERROR_UNKNOWN_PROPERTY : GDBusError = 43 ; pub const GDBusError_G_DBUS_ERROR_PROPERTY_READ_ONLY : GDBusError = 44 ; pub type GDBusError = :: std :: os :: raw :: c_uint ; pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_NONE : GDBusConnectionFlags = 0 ; pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT : GDBusConnectionFlags = 1 ; pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER : GDBusConnectionFlags = 2 ; pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS : GDBusConnectionFlags = 4 ; pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION : GDBusConnectionFlags = 8 ; pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING : GDBusConnectionFlags = 16 ; pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER : GDBusConnectionFlags = 32 ; pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_CROSS_NAMESPACE : GDBusConnectionFlags = 64 ; pub type GDBusConnectionFlags = :: std :: os :: raw :: c_uint ; pub const GDBusCapabilityFlags_G_DBUS_CAPABILITY_FLAGS_NONE : GDBusCapabilityFlags = 0 ; pub const GDBusCapabilityFlags_G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING : GDBusCapabilityFlags = 1 ; pub type GDBusCapabilityFlags = :: std :: os :: raw :: c_uint ; pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_NONE : GDBusCallFlags = 0 ; pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_NO_AUTO_START : GDBusCallFlags = 1 ; pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION : GDBusCallFlags = 2 ; pub type GDBusCallFlags = :: std :: os :: raw :: c_uint ; pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_INVALID : GDBusMessageType = 0 ; pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_METHOD_CALL : GDBusMessageType = 1 ; pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_METHOD_RETURN : GDBusMessageType = 2 ; pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_ERROR : GDBusMessageType = 3 ; pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_SIGNAL : GDBusMessageType = 4 ; pub type GDBusMessageType = :: std :: os :: raw :: c_uint ; pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NONE : GDBusMessageFlags = 0 ; pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED : GDBusMessageFlags = 1 ; pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NO_AUTO_START : GDBusMessageFlags = 2 ; pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION : GDBusMessageFlags = 4 ; pub type GDBusMessageFlags = :: std :: os :: raw :: c_uint ; pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_INVALID : GDBusMessageHeaderField = 0 ; pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_PATH : GDBusMessageHeaderField = 1 ; pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE : GDBusMessageHeaderField = 2 ; pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_MEMBER : GDBusMessageHeaderField = 3 ; pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME : GDBusMessageHeaderField = 4 ; pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL : GDBusMessageHeaderField = 5 ; pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION : GDBusMessageHeaderField = 6 ; pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_SENDER : GDBusMessageHeaderField = 7 ; pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE : GDBusMessageHeaderField = 8 ; pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS : GDBusMessageHeaderField = 9 ; pub type GDBusMessageHeaderField = :: std :: os :: raw :: c_uint ; pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_NONE : GDBusPropertyInfoFlags = 0 ; pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_READABLE : GDBusPropertyInfoFlags = 1 ; pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE : GDBusPropertyInfoFlags = 2 ; pub type GDBusPropertyInfoFlags = :: std :: os :: raw :: c_uint ; pub const GDBusSubtreeFlags_G_DBUS_SUBTREE_FLAGS_NONE : GDBusSubtreeFlags = 0 ; pub const GDBusSubtreeFlags_G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES : GDBusSubtreeFlags = 1 ; pub type GDBusSubtreeFlags = :: std :: os :: raw :: c_uint ; pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_NONE : GDBusServerFlags = 0 ; pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_RUN_IN_THREAD : GDBusServerFlags = 1 ; pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS : GDBusServerFlags = 2 ; pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER : GDBusServerFlags = 4 ; pub type GDBusServerFlags = :: std :: os :: raw :: c_uint ; pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_NONE : GDBusSignalFlags = 0 ; pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE : GDBusSignalFlags = 1 ; pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE : GDBusSignalFlags = 2 ; pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH : GDBusSignalFlags = 4 ; pub type GDBusSignalFlags = :: std :: os :: raw :: c_uint ; pub const GDBusSendMessageFlags_G_DBUS_SEND_MESSAGE_FLAGS_NONE : GDBusSendMessageFlags = 0 ; pub const GDBusSendMessageFlags_G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL : GDBusSendMessageFlags = 1 ; pub type GDBusSendMessageFlags = :: std :: os :: raw :: c_uint ; pub const GCredentialsType_G_CREDENTIALS_TYPE_INVALID : GCredentialsType = 0 ; pub const GCredentialsType_G_CREDENTIALS_TYPE_LINUX_UCRED : GCredentialsType = 1 ; pub const GCredentialsType_G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED : GCredentialsType = 2 ; pub const GCredentialsType_G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED : GCredentialsType = 3 ; pub const GCredentialsType_G_CREDENTIALS_TYPE_SOLARIS_UCRED : GCredentialsType = 4 ; pub const GCredentialsType_G_CREDENTIALS_TYPE_NETBSD_UNPCBID : GCredentialsType = 5 ; pub const GCredentialsType_G_CREDENTIALS_TYPE_APPLE_XUCRED : GCredentialsType = 6 ; pub const GCredentialsType_G_CREDENTIALS_TYPE_WIN32_PID : GCredentialsType = 7 ; pub type GCredentialsType = :: std :: os :: raw :: c_uint ; pub const GDBusMessageByteOrder_G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN : GDBusMessageByteOrder = 66 ; pub const GDBusMessageByteOrder_G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN : GDBusMessageByteOrder = 108 ; pub type GDBusMessageByteOrder = :: std :: os :: raw :: c_uint ; pub const GApplicationFlags_G_APPLICATION_FLAGS_NONE : GApplicationFlags = 0 ; pub const GApplicationFlags_G_APPLICATION_DEFAULT_FLAGS : GApplicationFlags = 0 ; pub const GApplicationFlags_G_APPLICATION_IS_SERVICE : GApplicationFlags = 1 ; pub const GApplicationFlags_G_APPLICATION_IS_LAUNCHER : GApplicationFlags = 2 ; pub const GApplicationFlags_G_APPLICATION_HANDLES_OPEN : GApplicationFlags = 4 ; pub const GApplicationFlags_G_APPLICATION_HANDLES_COMMAND_LINE : GApplicationFlags = 8 ; pub const GApplicationFlags_G_APPLICATION_SEND_ENVIRONMENT : GApplicationFlags = 16 ; pub const GApplicationFlags_G_APPLICATION_NON_UNIQUE : GApplicationFlags = 32 ; pub const GApplicationFlags_G_APPLICATION_CAN_OVERRIDE_APP_ID : GApplicationFlags = 64 ; pub const GApplicationFlags_G_APPLICATION_ALLOW_REPLACEMENT : GApplicationFlags = 128 ; pub const GApplicationFlags_G_APPLICATION_REPLACE : GApplicationFlags = 256 ; pub type GApplicationFlags = :: std :: os :: raw :: c_uint ; pub const GTlsError_G_TLS_ERROR_UNAVAILABLE : GTlsError = 0 ; pub const GTlsError_G_TLS_ERROR_MISC : GTlsError = 1 ; pub const GTlsError_G_TLS_ERROR_BAD_CERTIFICATE : GTlsError = 2 ; pub const GTlsError_G_TLS_ERROR_NOT_TLS : GTlsError = 3 ; pub const GTlsError_G_TLS_ERROR_HANDSHAKE : GTlsError = 4 ; pub const GTlsError_G_TLS_ERROR_CERTIFICATE_REQUIRED : GTlsError = 5 ; pub const GTlsError_G_TLS_ERROR_EOF : GTlsError = 6 ; pub const GTlsError_G_TLS_ERROR_INAPPROPRIATE_FALLBACK : GTlsError = 7 ; pub const GTlsError_G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD : GTlsError = 8 ; pub type GTlsError = :: std :: os :: raw :: c_uint ; pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_NO_FLAGS : GTlsCertificateFlags = 0 ; pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_UNKNOWN_CA : GTlsCertificateFlags = 1 ; pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_BAD_IDENTITY : GTlsCertificateFlags = 2 ; pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_NOT_ACTIVATED : GTlsCertificateFlags = 4 ; pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_EXPIRED : GTlsCertificateFlags = 8 ; pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_REVOKED : GTlsCertificateFlags = 16 ; pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_INSECURE : GTlsCertificateFlags = 32 ; pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_GENERIC_ERROR : GTlsCertificateFlags = 64 ; pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_VALIDATE_ALL : GTlsCertificateFlags = 127 ; pub type GTlsCertificateFlags = :: std :: os :: raw :: c_uint ; pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_NONE : GTlsAuthenticationMode = 0 ; pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_REQUESTED : GTlsAuthenticationMode = 1 ; pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_REQUIRED : GTlsAuthenticationMode = 2 ; pub type GTlsAuthenticationMode = :: std :: os :: raw :: c_uint ; pub const GTlsChannelBindingType_G_TLS_CHANNEL_BINDING_TLS_UNIQUE : GTlsChannelBindingType = 0 ; pub const GTlsChannelBindingType_G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT : GTlsChannelBindingType = 1 ; pub const GTlsChannelBindingType_G_TLS_CHANNEL_BINDING_TLS_EXPORTER : GTlsChannelBindingType = 2 ; pub type GTlsChannelBindingType = :: std :: os :: raw :: c_uint ; pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED : GTlsChannelBindingError = 0 ; pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE : GTlsChannelBindingError = 1 ; pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE : GTlsChannelBindingError = 2 ; pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED : GTlsChannelBindingError = 3 ; pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR : GTlsChannelBindingError = 4 ; pub type GTlsChannelBindingError = :: std :: os :: raw :: c_uint ; pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_NEVER : GTlsRehandshakeMode = 0 ; pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_SAFELY : GTlsRehandshakeMode = 1 ; pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_UNSAFELY : GTlsRehandshakeMode = 2 ; pub type GTlsRehandshakeMode = :: std :: os :: raw :: c_uint ; pub const _GTlsPasswordFlags_G_TLS_PASSWORD_NONE : _GTlsPasswordFlags = 0 ; pub const _GTlsPasswordFlags_G_TLS_PASSWORD_RETRY : _GTlsPasswordFlags = 2 ; pub const _GTlsPasswordFlags_G_TLS_PASSWORD_MANY_TRIES : _GTlsPasswordFlags = 4 ; pub const _GTlsPasswordFlags_G_TLS_PASSWORD_FINAL_TRY : _GTlsPasswordFlags = 8 ; pub const _GTlsPasswordFlags_G_TLS_PASSWORD_PKCS11_USER : _GTlsPasswordFlags = 16 ; pub const _GTlsPasswordFlags_G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER : _GTlsPasswordFlags = 32 ; pub const _GTlsPasswordFlags_G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC : _GTlsPasswordFlags = 64 ; pub type _GTlsPasswordFlags = :: std :: os :: raw :: c_uint ; pub use self :: _GTlsPasswordFlags as GTlsPasswordFlags ; pub const GTlsInteractionResult_G_TLS_INTERACTION_UNHANDLED : GTlsInteractionResult = 0 ; pub const GTlsInteractionResult_G_TLS_INTERACTION_HANDLED : GTlsInteractionResult = 1 ; pub const GTlsInteractionResult_G_TLS_INTERACTION_FAILED : GTlsInteractionResult = 2 ; pub type GTlsInteractionResult = :: std :: os :: raw :: c_uint ; pub const GDBusInterfaceSkeletonFlags_G_DBUS_INTERFACE_SKELETON_FLAGS_NONE : GDBusInterfaceSkeletonFlags = 0 ; pub const GDBusInterfaceSkeletonFlags_G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD : GDBusInterfaceSkeletonFlags = 1 ; pub type GDBusInterfaceSkeletonFlags = :: std :: os :: raw :: c_uint ; pub const GDBusObjectManagerClientFlags_G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE : GDBusObjectManagerClientFlags = 0 ; pub const GDBusObjectManagerClientFlags_G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START : GDBusObjectManagerClientFlags = 1 ; pub type GDBusObjectManagerClientFlags = :: std :: os :: raw :: c_uint ; pub const GTlsDatabaseVerifyFlags_G_TLS_DATABASE_VERIFY_NONE : GTlsDatabaseVerifyFlags = 0 ; pub type GTlsDatabaseVerifyFlags = :: std :: os :: raw :: c_uint ; pub const GTlsDatabaseLookupFlags_G_TLS_DATABASE_LOOKUP_NONE : GTlsDatabaseLookupFlags = 0 ; pub const GTlsDatabaseLookupFlags_G_TLS_DATABASE_LOOKUP_KEYPAIR : GTlsDatabaseLookupFlags = 1 ; pub type GTlsDatabaseLookupFlags = :: std :: os :: raw :: c_uint ; pub const GTlsCertificateRequestFlags_G_TLS_CERTIFICATE_REQUEST_NONE : GTlsCertificateRequestFlags = 0 ; pub type GTlsCertificateRequestFlags = :: std :: os :: raw :: c_uint ; pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_UNKNOWN : GTlsProtocolVersion = 0 ; pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_SSL_3_0 : GTlsProtocolVersion = 1 ; pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_0 : GTlsProtocolVersion = 2 ; pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_1 : GTlsProtocolVersion = 3 ; pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_2 : GTlsProtocolVersion = 4 ; pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_3 : GTlsProtocolVersion = 5 ; pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_DTLS_1_0 : GTlsProtocolVersion = 201 ; pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_DTLS_1_2 : GTlsProtocolVersion = 202 ; pub type GTlsProtocolVersion = :: std :: os :: raw :: c_uint ; pub const GIOModuleScopeFlags_G_IO_MODULE_SCOPE_NONE : GIOModuleScopeFlags = 0 ; pub const GIOModuleScopeFlags_G_IO_MODULE_SCOPE_BLOCK_DUPLICATES : GIOModuleScopeFlags = 1 ; pub type GIOModuleScopeFlags = :: std :: os :: raw :: c_uint ; pub const GSocketClientEvent_G_SOCKET_CLIENT_RESOLVING : GSocketClientEvent = 0 ; pub const GSocketClientEvent_G_SOCKET_CLIENT_RESOLVED : GSocketClientEvent = 1 ; pub const GSocketClientEvent_G_SOCKET_CLIENT_CONNECTING : GSocketClientEvent = 2 ; pub const GSocketClientEvent_G_SOCKET_CLIENT_CONNECTED : GSocketClientEvent = 3 ; pub const GSocketClientEvent_G_SOCKET_CLIENT_PROXY_NEGOTIATING : GSocketClientEvent = 4 ; pub const GSocketClientEvent_G_SOCKET_CLIENT_PROXY_NEGOTIATED : GSocketClientEvent = 5 ; pub const GSocketClientEvent_G_SOCKET_CLIENT_TLS_HANDSHAKING : GSocketClientEvent = 6 ; pub const GSocketClientEvent_G_SOCKET_CLIENT_TLS_HANDSHAKED : GSocketClientEvent = 7 ; pub const GSocketClientEvent_G_SOCKET_CLIENT_COMPLETE : GSocketClientEvent = 8 ; pub type GSocketClientEvent = :: std :: os :: raw :: c_uint ; pub const GSocketListenerEvent_G_SOCKET_LISTENER_BINDING : GSocketListenerEvent = 0 ; pub const GSocketListenerEvent_G_SOCKET_LISTENER_BOUND : GSocketListenerEvent = 1 ; pub const GSocketListenerEvent_G_SOCKET_LISTENER_LISTENING : GSocketListenerEvent = 2 ; pub const GSocketListenerEvent_G_SOCKET_LISTENER_LISTENED : GSocketListenerEvent = 3 ; pub type GSocketListenerEvent = :: std :: os :: raw :: c_uint ; pub const GTestDBusFlags_G_TEST_DBUS_NONE : GTestDBusFlags = 0 ; pub type GTestDBusFlags = :: std :: os :: raw :: c_uint ; pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_NONE : GSubprocessFlags = 0 ; pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDIN_PIPE : GSubprocessFlags = 1 ; pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDIN_INHERIT : GSubprocessFlags = 2 ; pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDOUT_PIPE : GSubprocessFlags = 4 ; pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDOUT_SILENCE : GSubprocessFlags = 8 ; pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_PIPE : GSubprocessFlags = 16 ; pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_SILENCE : GSubprocessFlags = 32 ; pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_MERGE : GSubprocessFlags = 64 ; pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_INHERIT_FDS : GSubprocessFlags = 128 ; pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP : GSubprocessFlags = 256 ; pub type GSubprocessFlags = :: std :: os :: raw :: c_uint ; pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_NORMAL : GNotificationPriority = 0 ; pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_LOW : GNotificationPriority = 1 ; pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_HIGH : GNotificationPriority = 2 ; pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_URGENT : GNotificationPriority = 3 ; pub type GNotificationPriority = :: std :: os :: raw :: c_uint ; pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_LOCAL : GNetworkConnectivity = 1 ; pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_LIMITED : GNetworkConnectivity = 2 ; pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_PORTAL : GNetworkConnectivity = 3 ; pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_FULL : GNetworkConnectivity = 4 ; pub type GNetworkConnectivity = :: std :: os :: raw :: c_uint ; pub const GPollableReturn_G_POLLABLE_RETURN_FAILED : GPollableReturn = 0 ; pub const GPollableReturn_G_POLLABLE_RETURN_OK : GPollableReturn = 1 ; pub const GPollableReturn_G_POLLABLE_RETURN_WOULD_BLOCK : GPollableReturn = - 27 ; pub type GPollableReturn = :: std :: os :: raw :: c_int ; pub const GMemoryMonitorWarningLevel_G_MEMORY_MONITOR_WARNING_LEVEL_LOW : GMemoryMonitorWarningLevel = 50 ; pub const GMemoryMonitorWarningLevel_G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM : GMemoryMonitorWarningLevel = 100 ; pub const GMemoryMonitorWarningLevel_G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL : GMemoryMonitorWarningLevel = 255 ; pub type GMemoryMonitorWarningLevel = :: std :: os :: raw :: c_uint ; pub type GAppLaunchContext = _GAppLaunchContext ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GAppInfo { _unused : [u8 ; 0] , } pub type GAppInfo = _GAppInfo ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GAsyncResult { _unused : [u8 ; 0] , } pub type GAsyncResult = _GAsyncResult ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GAsyncInitable { _unused : [u8 ; 0] , } pub type GAsyncInitable = _GAsyncInitable ; pub type GBufferedInputStream = _GBufferedInputStream ; pub type GBufferedOutputStream = _GBufferedOutputStream ; pub type GCancellable = _GCancellable ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GCharsetConverter { _unused : [u8 ; 0] , } pub type GCharsetConverter = _GCharsetConverter ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GConverter { _unused : [u8 ; 0] , } pub type GConverter = _GConverter ; pub type GConverterInputStream = _GConverterInputStream ; pub type GConverterOutputStream = _GConverterOutputStream ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDatagramBased { _unused : [u8 ; 0] , } pub type GDatagramBased = _GDatagramBased ; pub type GDataInputStream = _GDataInputStream ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSimplePermission { _unused : [u8 ; 0] , } pub type GSimplePermission = _GSimplePermission ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GZlibCompressor { _unused : [u8 ; 0] , } pub type GZlibCompressor = _GZlibCompressor ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GZlibDecompressor { _unused : [u8 ; 0] , } pub type GZlibDecompressor = _GZlibDecompressor ; pub type GSimpleActionGroup = _GSimpleActionGroup ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GRemoteActionGroup { _unused : [u8 ; 0] , } pub type GRemoteActionGroup = _GRemoteActionGroup ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusActionGroup { _unused : [u8 ; 0] , } pub type GDBusActionGroup = _GDBusActionGroup ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GActionMap { _unused : [u8 ; 0] , } pub type GActionMap = _GActionMap ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GActionGroup { _unused : [u8 ; 0] , } pub type GActionGroup = _GActionGroup ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPropertyAction { _unused : [u8 ; 0] , } pub type GPropertyAction = _GPropertyAction ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSimpleAction { _unused : [u8 ; 0] , } pub type GSimpleAction = _GSimpleAction ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GAction { _unused : [u8 ; 0] , } pub type GAction = _GAction ; pub type GApplication = _GApplication ; pub type GApplicationCommandLine = _GApplicationCommandLine ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSettingsBackend { _unused : [u8 ; 0] , } pub type GSettingsBackend = _GSettingsBackend ; pub type GSettings = _GSettings ; pub type GPermission = _GPermission ; pub type GMenuModel = _GMenuModel ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNotification { _unused : [u8 ; 0] , } pub type GNotification = _GNotification ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDrive { _unused : [u8 ; 0] , } pub type GDrive = _GDrive ; pub type GFileEnumerator = _GFileEnumerator ; pub type GFileMonitor = _GFileMonitor ; pub type GFilterInputStream = _GFilterInputStream ; pub type GFilterOutputStream = _GFilterOutputStream ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFile { _unused : [u8 ; 0] , } pub type GFile = _GFile ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileInfo { _unused : [u8 ; 0] , } pub type GFileInfo = _GFileInfo ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileAttributeMatcher { _unused : [u8 ; 0] , } pub type GFileAttributeMatcher = _GFileAttributeMatcher ; pub type GFileAttributeInfo = _GFileAttributeInfo ; pub type GFileAttributeInfoList = _GFileAttributeInfoList ; pub type GFileInputStream = _GFileInputStream ; pub type GFileOutputStream = _GFileOutputStream ; pub type GFileIOStream = _GFileIOStream ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileIcon { _unused : [u8 ; 0] , } pub type GFileIcon = _GFileIcon ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFilenameCompleter { _unused : [u8 ; 0] , } pub type GFilenameCompleter = _GFilenameCompleter ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIcon { _unused : [u8 ; 0] , } pub type GIcon = _GIcon ; pub type GInetAddress = _GInetAddress ; pub type GInetAddressMask = _GInetAddressMask ; pub type GInetSocketAddress = _GInetSocketAddress ; pub type GNativeSocketAddress = _GNativeSocketAddress ; pub type GInputStream = _GInputStream ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInitable { _unused : [u8 ; 0] , } pub type GInitable = _GInitable ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIOModule { _unused : [u8 ; 0] , } pub type GIOModule = _GIOModule ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIOExtensionPoint { _unused : [u8 ; 0] , } pub type GIOExtensionPoint = _GIOExtensionPoint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIOExtension { _unused : [u8 ; 0] , } pub type GIOExtension = _GIOExtension ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIOSchedulerJob { _unused : [u8 ; 0] , } pub type GIOSchedulerJob = _GIOSchedulerJob ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIOStreamAdapter { _unused : [u8 ; 0] , } pub type GIOStreamAdapter = _GIOStreamAdapter ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GLoadableIcon { _unused : [u8 ; 0] , } pub type GLoadableIcon = _GLoadableIcon ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GBytesIcon { _unused : [u8 ; 0] , } pub type GBytesIcon = _GBytesIcon ; pub type GMemoryInputStream = _GMemoryInputStream ; pub type GMemoryOutputStream = _GMemoryOutputStream ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMount { _unused : [u8 ; 0] , } pub type GMount = _GMount ; pub type GMountOperation = _GMountOperation ; pub type GNetworkAddress = _GNetworkAddress ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNetworkMonitor { _unused : [u8 ; 0] , } pub type GNetworkMonitor = _GNetworkMonitor ; pub type GNetworkService = _GNetworkService ; pub type GOutputStream = _GOutputStream ; pub type GIOStream = _GIOStream ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSimpleIOStream { _unused : [u8 ; 0] , } pub type GSimpleIOStream = _GSimpleIOStream ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPollableInputStream { _unused : [u8 ; 0] , } pub type GPollableInputStream = _GPollableInputStream ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPollableOutputStream { _unused : [u8 ; 0] , } pub type GPollableOutputStream = _GPollableOutputStream ; pub type GResolver = _GResolver ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GResource { _unused : [u8 ; 0] , } pub type GResource = _GResource ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSeekable { _unused : [u8 ; 0] , } pub type GSeekable = _GSeekable ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSimpleAsyncResult { _unused : [u8 ; 0] , } pub type GSimpleAsyncResult = _GSimpleAsyncResult ; pub type GSocket = _GSocket ; pub type GSocketControlMessage = _GSocketControlMessage ; pub type GSocketClient = _GSocketClient ; pub type GSocketConnection = _GSocketConnection ; pub type GSocketListener = _GSocketListener ; pub type GSocketService = _GSocketService ; pub type GSocketAddress = _GSocketAddress ; pub type GSocketAddressEnumerator = _GSocketAddressEnumerator ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketConnectable { _unused : [u8 ; 0] , } pub type GSocketConnectable = _GSocketConnectable ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSrvTarget { _unused : [u8 ; 0] , } pub type GSrvTarget = _GSrvTarget ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTask { _unused : [u8 ; 0] , } pub type GTask = _GTask ; pub type GTcpConnection = _GTcpConnection ; pub type GTcpWrapperConnection = _GTcpWrapperConnection ; pub type GThreadedSocketService = _GThreadedSocketService ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDtlsConnection { _unused : [u8 ; 0] , } pub type GDtlsConnection = _GDtlsConnection ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDtlsClientConnection { _unused : [u8 ; 0] , } pub type GDtlsClientConnection = _GDtlsClientConnection ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDtlsServerConnection { _unused : [u8 ; 0] , } pub type GDtlsServerConnection = _GDtlsServerConnection ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GThemedIcon { _unused : [u8 ; 0] , } pub type GThemedIcon = _GThemedIcon ; pub type GTlsCertificate = _GTlsCertificate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsClientConnection { _unused : [u8 ; 0] , } pub type GTlsClientConnection = _GTlsClientConnection ; pub type GTlsConnection = _GTlsConnection ; pub type GTlsDatabase = _GTlsDatabase ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsFileDatabase { _unused : [u8 ; 0] , } pub type GTlsFileDatabase = _GTlsFileDatabase ; pub type GTlsInteraction = _GTlsInteraction ; pub type GTlsPassword = _GTlsPassword ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsServerConnection { _unused : [u8 ; 0] , } pub type GTlsServerConnection = _GTlsServerConnection ; pub type GVfs = _GVfs ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GProxyResolver { _unused : [u8 ; 0] , } pub type GProxyResolver = _GProxyResolver ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GProxy { _unused : [u8 ; 0] , } pub type GProxy = _GProxy ; pub type GProxyAddress = _GProxyAddress ; pub type GProxyAddressEnumerator = _GProxyAddressEnumerator ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GVolume { _unused : [u8 ; 0] , } pub type GVolume = _GVolume ; pub type GVolumeMonitor = _GVolumeMonitor ; pub type GAsyncReadyCallback = :: std :: option :: Option < unsafe extern "C" fn (source_object : * mut GObject , res : * mut GAsyncResult , data : gpointer) > ; pub type GFileProgressCallback = :: std :: option :: Option < unsafe extern "C" fn (current_num_bytes : goffset , total_num_bytes : goffset , data : gpointer) > ; pub type GFileReadMoreCallback = :: std :: option :: Option < unsafe extern "C" fn (file_contents : * const :: std :: os :: raw :: c_char , file_size : goffset , callback_data : gpointer) -> gboolean > ; pub type GFileMeasureProgressCallback = :: std :: option :: Option < unsafe extern "C" fn (reporting : gboolean , current_size : guint64 , num_dirs : guint64 , num_files : guint64 , data : gpointer) > ; pub type GIOSchedulerJobFunc = :: std :: option :: Option < unsafe extern "C" fn (job : * mut GIOSchedulerJob , cancellable : * mut GCancellable , data : gpointer) -> gboolean > ; pub type GSimpleAsyncThreadFunc = :: std :: option :: Option < unsafe extern "C" fn (res : * mut GSimpleAsyncResult , object : * mut GObject , cancellable : * mut GCancellable) > ; pub type GSocketSourceFunc = :: std :: option :: Option < unsafe extern "C" fn (socket : * mut GSocket , condition : GIOCondition , data : gpointer) -> gboolean > ; pub type GDatagramBasedSourceFunc = :: std :: option :: Option < unsafe extern "C" fn (datagram_based : * mut GDatagramBased , condition : GIOCondition , data : gpointer) -> gboolean > ; pub type GInputVector = _GInputVector ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInputVector { pub buffer : gpointer , pub size : gsize , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GInputVector"] [:: std :: mem :: size_of :: < _GInputVector > () - 16usize] ; ["Alignment of _GInputVector"] [:: std :: mem :: align_of :: < _GInputVector > () - 8usize] ; ["Offset of field: _GInputVector::buffer"] [:: std :: mem :: offset_of ! (_GInputVector , buffer) - 0usize] ; ["Offset of field: _GInputVector::size"] [:: std :: mem :: offset_of ! (_GInputVector , size) - 8usize] ; } ; pub type GInputMessage = _GInputMessage ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInputMessage { pub address : * mut * mut GSocketAddress , pub vectors : * mut GInputVector , pub num_vectors : guint , pub bytes_received : gsize , pub flags : gint , pub control_messages : * mut * mut * mut GSocketControlMessage , pub num_control_messages : * mut guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GInputMessage"] [:: std :: mem :: size_of :: < _GInputMessage > () - 56usize] ; ["Alignment of _GInputMessage"] [:: std :: mem :: align_of :: < _GInputMessage > () - 8usize] ; ["Offset of field: _GInputMessage::address"] [:: std :: mem :: offset_of ! (_GInputMessage , address) - 0usize] ; ["Offset of field: _GInputMessage::vectors"] [:: std :: mem :: offset_of ! (_GInputMessage , vectors) - 8usize] ; ["Offset of field: _GInputMessage::num_vectors"] [:: std :: mem :: offset_of ! (_GInputMessage , num_vectors) - 16usize] ; ["Offset of field: _GInputMessage::bytes_received"] [:: std :: mem :: offset_of ! (_GInputMessage , bytes_received) - 24usize] ; ["Offset of field: _GInputMessage::flags"] [:: std :: mem :: offset_of ! (_GInputMessage , flags) - 32usize] ; ["Offset of field: _GInputMessage::control_messages"] [:: std :: mem :: offset_of ! (_GInputMessage , control_messages) - 40usize] ; ["Offset of field: _GInputMessage::num_control_messages"] [:: std :: mem :: offset_of ! (_GInputMessage , num_control_messages) - 48usize] ; } ; pub type GOutputVector = _GOutputVector ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GOutputVector { pub buffer : gconstpointer , pub size : gsize , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GOutputVector"] [:: std :: mem :: size_of :: < _GOutputVector > () - 16usize] ; ["Alignment of _GOutputVector"] [:: std :: mem :: align_of :: < _GOutputVector > () - 8usize] ; ["Offset of field: _GOutputVector::buffer"] [:: std :: mem :: offset_of ! (_GOutputVector , buffer) - 0usize] ; ["Offset of field: _GOutputVector::size"] [:: std :: mem :: offset_of ! (_GOutputVector , size) - 8usize] ; } ; pub type GOutputMessage = _GOutputMessage ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GOutputMessage { pub address : * mut GSocketAddress , pub vectors : * mut GOutputVector , pub num_vectors : guint , pub bytes_sent : guint , pub control_messages : * mut * mut GSocketControlMessage , pub num_control_messages : guint , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GOutputMessage"] [:: std :: mem :: size_of :: < _GOutputMessage > () - 40usize] ; ["Alignment of _GOutputMessage"] [:: std :: mem :: align_of :: < _GOutputMessage > () - 8usize] ; ["Offset of field: _GOutputMessage::address"] [:: std :: mem :: offset_of ! (_GOutputMessage , address) - 0usize] ; ["Offset of field: _GOutputMessage::vectors"] [:: std :: mem :: offset_of ! (_GOutputMessage , vectors) - 8usize] ; ["Offset of field: _GOutputMessage::num_vectors"] [:: std :: mem :: offset_of ! (_GOutputMessage , num_vectors) - 16usize] ; ["Offset of field: _GOutputMessage::bytes_sent"] [:: std :: mem :: offset_of ! (_GOutputMessage , bytes_sent) - 20usize] ; ["Offset of field: _GOutputMessage::control_messages"] [:: std :: mem :: offset_of ! (_GOutputMessage , control_messages) - 24usize] ; ["Offset of field: _GOutputMessage::num_control_messages"] [:: std :: mem :: offset_of ! (_GOutputMessage , num_control_messages) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GCredentials { _unused : [u8 ; 0] , } pub type GCredentials = _GCredentials ; pub type GUnixCredentialsMessage = _GUnixCredentialsMessage ; pub type GUnixFDList = _GUnixFDList ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusMessage { _unused : [u8 ; 0] , } pub type GDBusMessage = _GDBusMessage ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusConnection { _unused : [u8 ; 0] , } pub type GDBusConnection = _GDBusConnection ; pub type GDBusProxy = _GDBusProxy ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusMethodInvocation { _unused : [u8 ; 0] , } pub type GDBusMethodInvocation = _GDBusMethodInvocation ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusServer { _unused : [u8 ; 0] , } pub type GDBusServer = _GDBusServer ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusAuthObserver { _unused : [u8 ; 0] , } pub type GDBusAuthObserver = _GDBusAuthObserver ; pub type GDBusErrorEntry = _GDBusErrorEntry ; pub type GDBusInterfaceVTable = _GDBusInterfaceVTable ; pub type GDBusSubtreeVTable = _GDBusSubtreeVTable ; pub type GDBusAnnotationInfo = _GDBusAnnotationInfo ; pub type GDBusArgInfo = _GDBusArgInfo ; pub type GDBusMethodInfo = _GDBusMethodInfo ; pub type GDBusSignalInfo = _GDBusSignalInfo ; pub type GDBusPropertyInfo = _GDBusPropertyInfo ; pub type GDBusInterfaceInfo = _GDBusInterfaceInfo ; pub type GDBusNodeInfo = _GDBusNodeInfo ; pub type GCancellableSourceFunc = :: std :: option :: Option < unsafe extern "C" fn (cancellable : * mut GCancellable , data : gpointer) -> gboolean > ; pub type GPollableSourceFunc = :: std :: option :: Option < unsafe extern "C" fn (pollable_stream : * mut GObject , data : gpointer) -> gboolean > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusInterface { _unused : [u8 ; 0] , } pub type GDBusInterface = _GDBusInterface ; pub type GDBusInterfaceSkeleton = _GDBusInterfaceSkeleton ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObject { _unused : [u8 ; 0] , } pub type GDBusObject = _GDBusObject ; pub type GDBusObjectSkeleton = _GDBusObjectSkeleton ; pub type GDBusObjectProxy = _GDBusObjectProxy ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectManager { _unused : [u8 ; 0] , } pub type GDBusObjectManager = _GDBusObjectManager ; pub type GDBusObjectManagerClient = _GDBusObjectManagerClient ; pub type GDBusObjectManagerServer = _GDBusObjectManagerServer ; pub type GDBusProxyTypeFunc = :: std :: option :: Option < unsafe extern "C" fn (manager : * mut GDBusObjectManagerClient , object_path : * const gchar , interface_name : * const gchar , data : gpointer) -> GType > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTestDBus { _unused : [u8 ; 0] , } pub type GTestDBus = _GTestDBus ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSubprocess { _unused : [u8 ; 0] , } pub type GSubprocess = _GSubprocess ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSubprocessLauncher { _unused : [u8 ; 0] , } pub type GSubprocessLauncher = _GSubprocessLauncher ; pub type GActionInterface = _GActionInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GActionInterface { pub g_iface : GTypeInterface , pub get_name : :: std :: option :: Option < unsafe extern "C" fn (action : * mut GAction) -> * const gchar > , pub get_parameter_type : :: std :: option :: Option < unsafe extern "C" fn (action : * mut GAction) -> * const GVariantType > , pub get_state_type : :: std :: option :: Option < unsafe extern "C" fn (action : * mut GAction) -> * const GVariantType > , pub get_state_hint : :: std :: option :: Option < unsafe extern "C" fn (action : * mut GAction) -> * mut GVariant > , pub get_enabled : :: std :: option :: Option < unsafe extern "C" fn (action : * mut GAction) -> gboolean > , pub get_state : :: std :: option :: Option < unsafe extern "C" fn (action : * mut GAction) -> * mut GVariant > , pub change_state : :: std :: option :: Option < unsafe extern "C" fn (action : * mut GAction , value : * mut GVariant) > , pub activate : :: std :: option :: Option < unsafe extern "C" fn (action : * mut GAction , parameter : * mut GVariant) > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GActionInterface"] [:: std :: mem :: size_of :: < _GActionInterface > () - 80usize] ; ["Alignment of _GActionInterface"] [:: std :: mem :: align_of :: < _GActionInterface > () - 8usize] ; ["Offset of field: _GActionInterface::g_iface"] [:: std :: mem :: offset_of ! (_GActionInterface , g_iface) - 0usize] ; ["Offset of field: _GActionInterface::get_name"] [:: std :: mem :: offset_of ! (_GActionInterface , get_name) - 16usize] ; ["Offset of field: _GActionInterface::get_parameter_type"] [:: std :: mem :: offset_of ! (_GActionInterface , get_parameter_type) - 24usize] ; ["Offset of field: _GActionInterface::get_state_type"] [:: std :: mem :: offset_of ! (_GActionInterface , get_state_type) - 32usize] ; ["Offset of field: _GActionInterface::get_state_hint"] [:: std :: mem :: offset_of ! (_GActionInterface , get_state_hint) - 40usize] ; ["Offset of field: _GActionInterface::get_enabled"] [:: std :: mem :: offset_of ! (_GActionInterface , get_enabled) - 48usize] ; ["Offset of field: _GActionInterface::get_state"] [:: std :: mem :: offset_of ! (_GActionInterface , get_state) - 56usize] ; ["Offset of field: _GActionInterface::change_state"] [:: std :: mem :: offset_of ! (_GActionInterface , change_state) - 64usize] ; ["Offset of field: _GActionInterface::activate"] [:: std :: mem :: offset_of ! (_GActionInterface , activate) - 72usize] ; } ; unsafe extern "C" { pub fn g_action_get_type () -> GType ; } unsafe extern "C" { pub fn g_action_get_name (action : * mut GAction) -> * const gchar ; } unsafe extern "C" { pub fn g_action_get_parameter_type (action : * mut GAction) -> * const GVariantType ; } unsafe extern "C" { pub fn g_action_get_state_type (action : * mut GAction) -> * const GVariantType ; } unsafe extern "C" { pub fn g_action_get_state_hint (action : * mut GAction) -> * mut GVariant ; } unsafe extern "C" { pub fn g_action_get_enabled (action : * mut GAction) -> gboolean ; } unsafe extern "C" { pub fn g_action_get_state (action : * mut GAction) -> * mut GVariant ; } unsafe extern "C" { pub fn g_action_change_state (action : * mut GAction , value : * mut GVariant) ; } unsafe extern "C" { pub fn g_action_activate (action : * mut GAction , parameter : * mut GVariant) ; } unsafe extern "C" { pub fn g_action_name_is_valid (action_name : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_action_parse_detailed_name (detailed_name : * const gchar , action_name : * mut * mut gchar , target_value : * mut * mut GVariant , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_action_print_detailed_name (action_name : * const gchar , target_value : * mut GVariant) -> * mut gchar ; } pub type GActionGroupInterface = _GActionGroupInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GActionGroupInterface { pub g_iface : GTypeInterface , pub has_action : :: std :: option :: Option < unsafe extern "C" fn (action_group : * mut GActionGroup , action_name : * const gchar) -> gboolean > , pub list_actions : :: std :: option :: Option < unsafe extern "C" fn (action_group : * mut GActionGroup) -> * mut * mut gchar > , pub get_action_enabled : :: std :: option :: Option < unsafe extern "C" fn (action_group : * mut GActionGroup , action_name : * const gchar) -> gboolean > , pub get_action_parameter_type : :: std :: option :: Option < unsafe extern "C" fn (action_group : * mut GActionGroup , action_name : * const gchar) -> * const GVariantType > , pub get_action_state_type : :: std :: option :: Option < unsafe extern "C" fn (action_group : * mut GActionGroup , action_name : * const gchar) -> * const GVariantType > , pub get_action_state_hint : :: std :: option :: Option < unsafe extern "C" fn (action_group : * mut GActionGroup , action_name : * const gchar) -> * mut GVariant > , pub get_action_state : :: std :: option :: Option < unsafe extern "C" fn (action_group : * mut GActionGroup , action_name : * const gchar) -> * mut GVariant > , pub change_action_state : :: std :: option :: Option < unsafe extern "C" fn (action_group : * mut GActionGroup , action_name : * const gchar , value : * mut GVariant) > , pub activate_action : :: std :: option :: Option < unsafe extern "C" fn (action_group : * mut GActionGroup , action_name : * const gchar , parameter : * mut GVariant) > , pub action_added : :: std :: option :: Option < unsafe extern "C" fn (action_group : * mut GActionGroup , action_name : * const gchar) > , pub action_removed : :: std :: option :: Option < unsafe extern "C" fn (action_group : * mut GActionGroup , action_name : * const gchar) > , pub action_enabled_changed : :: std :: option :: Option < unsafe extern "C" fn (action_group : * mut GActionGroup , action_name : * const gchar , enabled : gboolean) > , pub action_state_changed : :: std :: option :: Option < unsafe extern "C" fn (action_group : * mut GActionGroup , action_name : * const gchar , state : * mut GVariant) > , pub query_action : :: std :: option :: Option < unsafe extern "C" fn (action_group : * mut GActionGroup , action_name : * const gchar , enabled : * mut gboolean , parameter_type : * mut * const GVariantType , state_type : * mut * const GVariantType , state_hint : * mut * mut GVariant , state : * mut * mut GVariant) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GActionGroupInterface"] [:: std :: mem :: size_of :: < _GActionGroupInterface > () - 128usize] ; ["Alignment of _GActionGroupInterface"] [:: std :: mem :: align_of :: < _GActionGroupInterface > () - 8usize] ; ["Offset of field: _GActionGroupInterface::g_iface"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , g_iface) - 0usize] ; ["Offset of field: _GActionGroupInterface::has_action"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , has_action) - 16usize] ; ["Offset of field: _GActionGroupInterface::list_actions"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , list_actions) - 24usize] ; ["Offset of field: _GActionGroupInterface::get_action_enabled"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , get_action_enabled) - 32usize] ; ["Offset of field: _GActionGroupInterface::get_action_parameter_type"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , get_action_parameter_type) - 40usize] ; ["Offset of field: _GActionGroupInterface::get_action_state_type"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , get_action_state_type) - 48usize] ; ["Offset of field: _GActionGroupInterface::get_action_state_hint"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , get_action_state_hint) - 56usize] ; ["Offset of field: _GActionGroupInterface::get_action_state"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , get_action_state) - 64usize] ; ["Offset of field: _GActionGroupInterface::change_action_state"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , change_action_state) - 72usize] ; ["Offset of field: _GActionGroupInterface::activate_action"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , activate_action) - 80usize] ; ["Offset of field: _GActionGroupInterface::action_added"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , action_added) - 88usize] ; ["Offset of field: _GActionGroupInterface::action_removed"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , action_removed) - 96usize] ; ["Offset of field: _GActionGroupInterface::action_enabled_changed"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , action_enabled_changed) - 104usize] ; ["Offset of field: _GActionGroupInterface::action_state_changed"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , action_state_changed) - 112usize] ; ["Offset of field: _GActionGroupInterface::query_action"] [:: std :: mem :: offset_of ! (_GActionGroupInterface , query_action) - 120usize] ; } ; unsafe extern "C" { pub fn g_action_group_get_type () -> GType ; } unsafe extern "C" { pub fn g_action_group_has_action (action_group : * mut GActionGroup , action_name : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_action_group_list_actions (action_group : * mut GActionGroup) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_action_group_get_action_parameter_type (action_group : * mut GActionGroup , action_name : * const gchar) -> * const GVariantType ; } unsafe extern "C" { pub fn g_action_group_get_action_state_type (action_group : * mut GActionGroup , action_name : * const gchar) -> * const GVariantType ; } unsafe extern "C" { pub fn g_action_group_get_action_state_hint (action_group : * mut GActionGroup , action_name : * const gchar) -> * mut GVariant ; } unsafe extern "C" { pub fn g_action_group_get_action_enabled (action_group : * mut GActionGroup , action_name : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_action_group_get_action_state (action_group : * mut GActionGroup , action_name : * const gchar) -> * mut GVariant ; } unsafe extern "C" { pub fn g_action_group_change_action_state (action_group : * mut GActionGroup , action_name : * const gchar , value : * mut GVariant) ; } unsafe extern "C" { pub fn g_action_group_activate_action (action_group : * mut GActionGroup , action_name : * const gchar , parameter : * mut GVariant) ; } unsafe extern "C" { pub fn g_action_group_action_added (action_group : * mut GActionGroup , action_name : * const gchar) ; } unsafe extern "C" { pub fn g_action_group_action_removed (action_group : * mut GActionGroup , action_name : * const gchar) ; } unsafe extern "C" { pub fn g_action_group_action_enabled_changed (action_group : * mut GActionGroup , action_name : * const gchar , enabled : gboolean) ; } unsafe extern "C" { pub fn g_action_group_action_state_changed (action_group : * mut GActionGroup , action_name : * const gchar , state : * mut GVariant) ; } unsafe extern "C" { pub fn g_action_group_query_action (action_group : * mut GActionGroup , action_name : * const gchar , enabled : * mut gboolean , parameter_type : * mut * const GVariantType , state_type : * mut * const GVariantType , state_hint : * mut * mut GVariant , state : * mut * mut GVariant) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_connection_export_action_group (connection : * mut GDBusConnection , object_path : * const gchar , action_group : * mut GActionGroup , error : * mut * mut GError) -> guint ; } unsafe extern "C" { pub fn g_dbus_connection_unexport_action_group (connection : * mut GDBusConnection , export_id : guint) ; } pub type GActionMapInterface = _GActionMapInterface ; pub type GActionEntry = _GActionEntry ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GActionMapInterface { pub g_iface : GTypeInterface , pub lookup_action : :: std :: option :: Option < unsafe extern "C" fn (action_map : * mut GActionMap , action_name : * const gchar) -> * mut GAction > , pub add_action : :: std :: option :: Option < unsafe extern "C" fn (action_map : * mut GActionMap , action : * mut GAction) > , pub remove_action : :: std :: option :: Option < unsafe extern "C" fn (action_map : * mut GActionMap , action_name : * const gchar) > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GActionMapInterface"] [:: std :: mem :: size_of :: < _GActionMapInterface > () - 40usize] ; ["Alignment of _GActionMapInterface"] [:: std :: mem :: align_of :: < _GActionMapInterface > () - 8usize] ; ["Offset of field: _GActionMapInterface::g_iface"] [:: std :: mem :: offset_of ! (_GActionMapInterface , g_iface) - 0usize] ; ["Offset of field: _GActionMapInterface::lookup_action"] [:: std :: mem :: offset_of ! (_GActionMapInterface , lookup_action) - 16usize] ; ["Offset of field: _GActionMapInterface::add_action"] [:: std :: mem :: offset_of ! (_GActionMapInterface , add_action) - 24usize] ; ["Offset of field: _GActionMapInterface::remove_action"] [:: std :: mem :: offset_of ! (_GActionMapInterface , remove_action) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GActionEntry { pub name : * const gchar , pub activate : :: std :: option :: Option < unsafe extern "C" fn (action : * mut GSimpleAction , parameter : * mut GVariant , user_data : gpointer) > , pub parameter_type : * const gchar , pub state : * const gchar , pub change_state : :: std :: option :: Option < unsafe extern "C" fn (action : * mut GSimpleAction , value : * mut GVariant , user_data : gpointer) > , pub padding : [gsize ; 3usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GActionEntry"] [:: std :: mem :: size_of :: < _GActionEntry > () - 64usize] ; ["Alignment of _GActionEntry"] [:: std :: mem :: align_of :: < _GActionEntry > () - 8usize] ; ["Offset of field: _GActionEntry::name"] [:: std :: mem :: offset_of ! (_GActionEntry , name) - 0usize] ; ["Offset of field: _GActionEntry::activate"] [:: std :: mem :: offset_of ! (_GActionEntry , activate) - 8usize] ; ["Offset of field: _GActionEntry::parameter_type"] [:: std :: mem :: offset_of ! (_GActionEntry , parameter_type) - 16usize] ; ["Offset of field: _GActionEntry::state"] [:: std :: mem :: offset_of ! (_GActionEntry , state) - 24usize] ; ["Offset of field: _GActionEntry::change_state"] [:: std :: mem :: offset_of ! (_GActionEntry , change_state) - 32usize] ; ["Offset of field: _GActionEntry::padding"] [:: std :: mem :: offset_of ! (_GActionEntry , padding) - 40usize] ; } ; unsafe extern "C" { pub fn g_action_map_get_type () -> GType ; } unsafe extern "C" { pub fn g_action_map_lookup_action (action_map : * mut GActionMap , action_name : * const gchar) -> * mut GAction ; } unsafe extern "C" { pub fn g_action_map_add_action (action_map : * mut GActionMap , action : * mut GAction) ; } unsafe extern "C" { pub fn g_action_map_remove_action (action_map : * mut GActionMap , action_name : * const gchar) ; } unsafe extern "C" { pub fn g_action_map_add_action_entries (action_map : * mut GActionMap , entries : * const GActionEntry , n_entries : gint , user_data : gpointer) ; } unsafe extern "C" { pub fn g_action_map_remove_action_entries (action_map : * mut GActionMap , entries : * const GActionEntry , n_entries : gint) ; } pub type GAppLaunchContextClass = _GAppLaunchContextClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GAppLaunchContextPrivate { _unused : [u8 ; 0] , } pub type GAppLaunchContextPrivate = _GAppLaunchContextPrivate ; pub type GAppInfoIface = _GAppInfoIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GAppInfoIface { pub g_iface : GTypeInterface , pub dup : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> * mut GAppInfo > , pub equal : :: std :: option :: Option < unsafe extern "C" fn (appinfo1 : * mut GAppInfo , appinfo2 : * mut GAppInfo) -> gboolean > , pub get_id : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> * const :: std :: os :: raw :: c_char > , pub get_name : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> * const :: std :: os :: raw :: c_char > , pub get_description : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> * const :: std :: os :: raw :: c_char > , pub get_executable : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> * const :: std :: os :: raw :: c_char > , pub get_icon : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> * mut GIcon > , pub launch : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo , files : * mut GList , context : * mut GAppLaunchContext , error : * mut * mut GError) -> gboolean > , pub supports_uris : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> gboolean > , pub supports_files : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> gboolean > , pub launch_uris : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo , uris : * mut GList , context : * mut GAppLaunchContext , error : * mut * mut GError) -> gboolean > , pub should_show : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> gboolean > , pub set_as_default_for_type : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo , content_type : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean > , pub set_as_default_for_extension : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo , extension : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean > , pub add_supports_type : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo , content_type : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean > , pub can_remove_supports_type : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> gboolean > , pub remove_supports_type : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo , content_type : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean > , pub can_delete : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> gboolean > , pub do_delete : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> gboolean > , pub get_commandline : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> * const :: std :: os :: raw :: c_char > , pub get_display_name : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> * const :: std :: os :: raw :: c_char > , pub set_as_last_used_for_type : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo , content_type : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean > , pub get_supported_types : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo) -> * mut * const :: std :: os :: raw :: c_char > , pub launch_uris_async : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo , uris : * mut GList , context : * mut GAppLaunchContext , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub launch_uris_finish : :: std :: option :: Option < unsafe extern "C" fn (appinfo : * mut GAppInfo , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GAppInfoIface"] [:: std :: mem :: size_of :: < _GAppInfoIface > () - 216usize] ; ["Alignment of _GAppInfoIface"] [:: std :: mem :: align_of :: < _GAppInfoIface > () - 8usize] ; ["Offset of field: _GAppInfoIface::g_iface"] [:: std :: mem :: offset_of ! (_GAppInfoIface , g_iface) - 0usize] ; ["Offset of field: _GAppInfoIface::dup"] [:: std :: mem :: offset_of ! (_GAppInfoIface , dup) - 16usize] ; ["Offset of field: _GAppInfoIface::equal"] [:: std :: mem :: offset_of ! (_GAppInfoIface , equal) - 24usize] ; ["Offset of field: _GAppInfoIface::get_id"] [:: std :: mem :: offset_of ! (_GAppInfoIface , get_id) - 32usize] ; ["Offset of field: _GAppInfoIface::get_name"] [:: std :: mem :: offset_of ! (_GAppInfoIface , get_name) - 40usize] ; ["Offset of field: _GAppInfoIface::get_description"] [:: std :: mem :: offset_of ! (_GAppInfoIface , get_description) - 48usize] ; ["Offset of field: _GAppInfoIface::get_executable"] [:: std :: mem :: offset_of ! (_GAppInfoIface , get_executable) - 56usize] ; ["Offset of field: _GAppInfoIface::get_icon"] [:: std :: mem :: offset_of ! (_GAppInfoIface , get_icon) - 64usize] ; ["Offset of field: _GAppInfoIface::launch"] [:: std :: mem :: offset_of ! (_GAppInfoIface , launch) - 72usize] ; ["Offset of field: _GAppInfoIface::supports_uris"] [:: std :: mem :: offset_of ! (_GAppInfoIface , supports_uris) - 80usize] ; ["Offset of field: _GAppInfoIface::supports_files"] [:: std :: mem :: offset_of ! (_GAppInfoIface , supports_files) - 88usize] ; ["Offset of field: _GAppInfoIface::launch_uris"] [:: std :: mem :: offset_of ! (_GAppInfoIface , launch_uris) - 96usize] ; ["Offset of field: _GAppInfoIface::should_show"] [:: std :: mem :: offset_of ! (_GAppInfoIface , should_show) - 104usize] ; ["Offset of field: _GAppInfoIface::set_as_default_for_type"] [:: std :: mem :: offset_of ! (_GAppInfoIface , set_as_default_for_type) - 112usize] ; ["Offset of field: _GAppInfoIface::set_as_default_for_extension"] [:: std :: mem :: offset_of ! (_GAppInfoIface , set_as_default_for_extension) - 120usize] ; ["Offset of field: _GAppInfoIface::add_supports_type"] [:: std :: mem :: offset_of ! (_GAppInfoIface , add_supports_type) - 128usize] ; ["Offset of field: _GAppInfoIface::can_remove_supports_type"] [:: std :: mem :: offset_of ! (_GAppInfoIface , can_remove_supports_type) - 136usize] ; ["Offset of field: _GAppInfoIface::remove_supports_type"] [:: std :: mem :: offset_of ! (_GAppInfoIface , remove_supports_type) - 144usize] ; ["Offset of field: _GAppInfoIface::can_delete"] [:: std :: mem :: offset_of ! (_GAppInfoIface , can_delete) - 152usize] ; ["Offset of field: _GAppInfoIface::do_delete"] [:: std :: mem :: offset_of ! (_GAppInfoIface , do_delete) - 160usize] ; ["Offset of field: _GAppInfoIface::get_commandline"] [:: std :: mem :: offset_of ! (_GAppInfoIface , get_commandline) - 168usize] ; ["Offset of field: _GAppInfoIface::get_display_name"] [:: std :: mem :: offset_of ! (_GAppInfoIface , get_display_name) - 176usize] ; ["Offset of field: _GAppInfoIface::set_as_last_used_for_type"] [:: std :: mem :: offset_of ! (_GAppInfoIface , set_as_last_used_for_type) - 184usize] ; ["Offset of field: _GAppInfoIface::get_supported_types"] [:: std :: mem :: offset_of ! (_GAppInfoIface , get_supported_types) - 192usize] ; ["Offset of field: _GAppInfoIface::launch_uris_async"] [:: std :: mem :: offset_of ! (_GAppInfoIface , launch_uris_async) - 200usize] ; ["Offset of field: _GAppInfoIface::launch_uris_finish"] [:: std :: mem :: offset_of ! (_GAppInfoIface , launch_uris_finish) - 208usize] ; } ; unsafe extern "C" { pub fn g_app_info_get_type () -> GType ; } unsafe extern "C" { pub fn g_app_info_create_from_commandline (commandline : * const :: std :: os :: raw :: c_char , application_name : * const :: std :: os :: raw :: c_char , flags : GAppInfoCreateFlags , error : * mut * mut GError) -> * mut GAppInfo ; } unsafe extern "C" { pub fn g_app_info_dup (appinfo : * mut GAppInfo) -> * mut GAppInfo ; } unsafe extern "C" { pub fn g_app_info_equal (appinfo1 : * mut GAppInfo , appinfo2 : * mut GAppInfo) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_get_id (appinfo : * mut GAppInfo) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_app_info_get_name (appinfo : * mut GAppInfo) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_app_info_get_display_name (appinfo : * mut GAppInfo) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_app_info_get_description (appinfo : * mut GAppInfo) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_app_info_get_executable (appinfo : * mut GAppInfo) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_app_info_get_commandline (appinfo : * mut GAppInfo) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_app_info_get_icon (appinfo : * mut GAppInfo) -> * mut GIcon ; } unsafe extern "C" { pub fn g_app_info_launch (appinfo : * mut GAppInfo , files : * mut GList , context : * mut GAppLaunchContext , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_supports_uris (appinfo : * mut GAppInfo) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_supports_files (appinfo : * mut GAppInfo) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_launch_uris (appinfo : * mut GAppInfo , uris : * mut GList , context : * mut GAppLaunchContext , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_launch_uris_async (appinfo : * mut GAppInfo , uris : * mut GList , context : * mut GAppLaunchContext , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_app_info_launch_uris_finish (appinfo : * mut GAppInfo , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_should_show (appinfo : * mut GAppInfo) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_set_as_default_for_type (appinfo : * mut GAppInfo , content_type : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_set_as_default_for_extension (appinfo : * mut GAppInfo , extension : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_add_supports_type (appinfo : * mut GAppInfo , content_type : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_can_remove_supports_type (appinfo : * mut GAppInfo) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_remove_supports_type (appinfo : * mut GAppInfo , content_type : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_get_supported_types (appinfo : * mut GAppInfo) -> * mut * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_app_info_can_delete (appinfo : * mut GAppInfo) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_delete (appinfo : * mut GAppInfo) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_set_as_last_used_for_type (appinfo : * mut GAppInfo , content_type : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_get_all () -> * mut GList ; } unsafe extern "C" { pub fn g_app_info_get_all_for_type (content_type : * const :: std :: os :: raw :: c_char) -> * mut GList ; } unsafe extern "C" { pub fn g_app_info_get_recommended_for_type (content_type : * const gchar) -> * mut GList ; } unsafe extern "C" { pub fn g_app_info_get_fallback_for_type (content_type : * const gchar) -> * mut GList ; } unsafe extern "C" { pub fn g_app_info_reset_type_associations (content_type : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_app_info_get_default_for_type (content_type : * const :: std :: os :: raw :: c_char , must_support_uris : gboolean) -> * mut GAppInfo ; } unsafe extern "C" { pub fn g_app_info_get_default_for_type_async (content_type : * const :: std :: os :: raw :: c_char , must_support_uris : gboolean , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_app_info_get_default_for_type_finish (result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GAppInfo ; } unsafe extern "C" { pub fn g_app_info_get_default_for_uri_scheme (uri_scheme : * const :: std :: os :: raw :: c_char) -> * mut GAppInfo ; } unsafe extern "C" { pub fn g_app_info_get_default_for_uri_scheme_async (uri_scheme : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_app_info_get_default_for_uri_scheme_finish (result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GAppInfo ; } unsafe extern "C" { pub fn g_app_info_launch_default_for_uri (uri : * const :: std :: os :: raw :: c_char , context : * mut GAppLaunchContext , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_app_info_launch_default_for_uri_async (uri : * const :: std :: os :: raw :: c_char , context : * mut GAppLaunchContext , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_app_info_launch_default_for_uri_finish (result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GAppLaunchContext { pub parent_instance : GObject , pub priv_ : * mut GAppLaunchContextPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GAppLaunchContext"] [:: std :: mem :: size_of :: < _GAppLaunchContext > () - 32usize] ; ["Alignment of _GAppLaunchContext"] [:: std :: mem :: align_of :: < _GAppLaunchContext > () - 8usize] ; ["Offset of field: _GAppLaunchContext::parent_instance"] [:: std :: mem :: offset_of ! (_GAppLaunchContext , parent_instance) - 0usize] ; ["Offset of field: _GAppLaunchContext::priv_"] [:: std :: mem :: offset_of ! (_GAppLaunchContext , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GAppLaunchContextClass { pub parent_class : GObjectClass , pub get_display : :: std :: option :: Option < unsafe extern "C" fn (context : * mut GAppLaunchContext , info : * mut GAppInfo , files : * mut GList) -> * mut :: std :: os :: raw :: c_char > , pub get_startup_notify_id : :: std :: option :: Option < unsafe extern "C" fn (context : * mut GAppLaunchContext , info : * mut GAppInfo , files : * mut GList) -> * mut :: std :: os :: raw :: c_char > , pub launch_failed : :: std :: option :: Option < unsafe extern "C" fn (context : * mut GAppLaunchContext , startup_notify_id : * const :: std :: os :: raw :: c_char) > , pub launched : :: std :: option :: Option < unsafe extern "C" fn (context : * mut GAppLaunchContext , info : * mut GAppInfo , platform_data : * mut GVariant) > , pub launch_started : :: std :: option :: Option < unsafe extern "C" fn (context : * mut GAppLaunchContext , info : * mut GAppInfo , platform_data : * mut GVariant) > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GAppLaunchContextClass"] [:: std :: mem :: size_of :: < _GAppLaunchContextClass > () - 200usize] ; ["Alignment of _GAppLaunchContextClass"] [:: std :: mem :: align_of :: < _GAppLaunchContextClass > () - 8usize] ; ["Offset of field: _GAppLaunchContextClass::parent_class"] [:: std :: mem :: offset_of ! (_GAppLaunchContextClass , parent_class) - 0usize] ; ["Offset of field: _GAppLaunchContextClass::get_display"] [:: std :: mem :: offset_of ! (_GAppLaunchContextClass , get_display) - 136usize] ; ["Offset of field: _GAppLaunchContextClass::get_startup_notify_id"] [:: std :: mem :: offset_of ! (_GAppLaunchContextClass , get_startup_notify_id) - 144usize] ; ["Offset of field: _GAppLaunchContextClass::launch_failed"] [:: std :: mem :: offset_of ! (_GAppLaunchContextClass , launch_failed) - 152usize] ; ["Offset of field: _GAppLaunchContextClass::launched"] [:: std :: mem :: offset_of ! (_GAppLaunchContextClass , launched) - 160usize] ; ["Offset of field: _GAppLaunchContextClass::launch_started"] [:: std :: mem :: offset_of ! (_GAppLaunchContextClass , launch_started) - 168usize] ; ["Offset of field: _GAppLaunchContextClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GAppLaunchContextClass , _g_reserved1) - 176usize] ; ["Offset of field: _GAppLaunchContextClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GAppLaunchContextClass , _g_reserved2) - 184usize] ; ["Offset of field: _GAppLaunchContextClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GAppLaunchContextClass , _g_reserved3) - 192usize] ; } ; unsafe extern "C" { pub fn g_app_launch_context_get_type () -> GType ; } unsafe extern "C" { pub fn g_app_launch_context_new () -> * mut GAppLaunchContext ; } unsafe extern "C" { pub fn g_app_launch_context_setenv (context : * mut GAppLaunchContext , variable : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_app_launch_context_unsetenv (context : * mut GAppLaunchContext , variable : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_app_launch_context_get_environment (context : * mut GAppLaunchContext) -> * mut * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_app_launch_context_get_display (context : * mut GAppLaunchContext , info : * mut GAppInfo , files : * mut GList) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_app_launch_context_get_startup_notify_id (context : * mut GAppLaunchContext , info : * mut GAppInfo , files : * mut GList) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_app_launch_context_launch_failed (context : * mut GAppLaunchContext , startup_notify_id : * const :: std :: os :: raw :: c_char) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GAppInfoMonitor { _unused : [u8 ; 0] , } pub type GAppInfoMonitor = _GAppInfoMonitor ; unsafe extern "C" { pub fn g_app_info_monitor_get_type () -> GType ; } unsafe extern "C" { pub fn g_app_info_monitor_get () -> * mut GAppInfoMonitor ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GApplicationPrivate { _unused : [u8 ; 0] , } pub type GApplicationPrivate = _GApplicationPrivate ; pub type GApplicationClass = _GApplicationClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GApplication { pub parent_instance : GObject , pub priv_ : * mut GApplicationPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GApplication"] [:: std :: mem :: size_of :: < _GApplication > () - 32usize] ; ["Alignment of _GApplication"] [:: std :: mem :: align_of :: < _GApplication > () - 8usize] ; ["Offset of field: _GApplication::parent_instance"] [:: std :: mem :: offset_of ! (_GApplication , parent_instance) - 0usize] ; ["Offset of field: _GApplication::priv_"] [:: std :: mem :: offset_of ! (_GApplication , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GApplicationClass { pub parent_class : GObjectClass , pub startup : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication) > , pub activate : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication) > , pub open : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication , files : * mut * mut GFile , n_files : gint , hint : * const gchar) > , pub command_line : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication , command_line : * mut GApplicationCommandLine) -> :: std :: os :: raw :: c_int > , pub local_command_line : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication , arguments : * mut * mut * mut gchar , exit_status : * mut :: std :: os :: raw :: c_int) -> gboolean > , pub before_emit : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication , platform_data : * mut GVariant) > , pub after_emit : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication , platform_data : * mut GVariant) > , pub add_platform_data : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication , builder : * mut GVariantBuilder) > , pub quit_mainloop : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication) > , pub run_mainloop : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication) > , pub shutdown : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication) > , pub dbus_register : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication , connection : * mut GDBusConnection , object_path : * const gchar , error : * mut * mut GError) -> gboolean > , pub dbus_unregister : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication , connection : * mut GDBusConnection , object_path : * const gchar) > , pub handle_local_options : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication , options : * mut GVariantDict) -> gint > , pub name_lost : :: std :: option :: Option < unsafe extern "C" fn (application : * mut GApplication) -> gboolean > , pub padding : [gpointer ; 7usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GApplicationClass"] [:: std :: mem :: size_of :: < _GApplicationClass > () - 312usize] ; ["Alignment of _GApplicationClass"] [:: std :: mem :: align_of :: < _GApplicationClass > () - 8usize] ; ["Offset of field: _GApplicationClass::parent_class"] [:: std :: mem :: offset_of ! (_GApplicationClass , parent_class) - 0usize] ; ["Offset of field: _GApplicationClass::startup"] [:: std :: mem :: offset_of ! (_GApplicationClass , startup) - 136usize] ; ["Offset of field: _GApplicationClass::activate"] [:: std :: mem :: offset_of ! (_GApplicationClass , activate) - 144usize] ; ["Offset of field: _GApplicationClass::open"] [:: std :: mem :: offset_of ! (_GApplicationClass , open) - 152usize] ; ["Offset of field: _GApplicationClass::command_line"] [:: std :: mem :: offset_of ! (_GApplicationClass , command_line) - 160usize] ; ["Offset of field: _GApplicationClass::local_command_line"] [:: std :: mem :: offset_of ! (_GApplicationClass , local_command_line) - 168usize] ; ["Offset of field: _GApplicationClass::before_emit"] [:: std :: mem :: offset_of ! (_GApplicationClass , before_emit) - 176usize] ; ["Offset of field: _GApplicationClass::after_emit"] [:: std :: mem :: offset_of ! (_GApplicationClass , after_emit) - 184usize] ; ["Offset of field: _GApplicationClass::add_platform_data"] [:: std :: mem :: offset_of ! (_GApplicationClass , add_platform_data) - 192usize] ; ["Offset of field: _GApplicationClass::quit_mainloop"] [:: std :: mem :: offset_of ! (_GApplicationClass , quit_mainloop) - 200usize] ; ["Offset of field: _GApplicationClass::run_mainloop"] [:: std :: mem :: offset_of ! (_GApplicationClass , run_mainloop) - 208usize] ; ["Offset of field: _GApplicationClass::shutdown"] [:: std :: mem :: offset_of ! (_GApplicationClass , shutdown) - 216usize] ; ["Offset of field: _GApplicationClass::dbus_register"] [:: std :: mem :: offset_of ! (_GApplicationClass , dbus_register) - 224usize] ; ["Offset of field: _GApplicationClass::dbus_unregister"] [:: std :: mem :: offset_of ! (_GApplicationClass , dbus_unregister) - 232usize] ; ["Offset of field: _GApplicationClass::handle_local_options"] [:: std :: mem :: offset_of ! (_GApplicationClass , handle_local_options) - 240usize] ; ["Offset of field: _GApplicationClass::name_lost"] [:: std :: mem :: offset_of ! (_GApplicationClass , name_lost) - 248usize] ; ["Offset of field: _GApplicationClass::padding"] [:: std :: mem :: offset_of ! (_GApplicationClass , padding) - 256usize] ; } ; unsafe extern "C" { pub fn g_application_get_type () -> GType ; } unsafe extern "C" { pub fn g_application_id_is_valid (application_id : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_application_new (application_id : * const gchar , flags : GApplicationFlags) -> * mut GApplication ; } unsafe extern "C" { pub fn g_application_get_application_id (application : * mut GApplication) -> * const gchar ; } unsafe extern "C" { pub fn g_application_set_application_id (application : * mut GApplication , application_id : * const gchar) ; } unsafe extern "C" { pub fn g_application_get_version (application : * mut GApplication) -> * const gchar ; } unsafe extern "C" { pub fn g_application_set_version (application : * mut GApplication , version : * const gchar) ; } unsafe extern "C" { pub fn g_application_get_dbus_connection (application : * mut GApplication) -> * mut GDBusConnection ; } unsafe extern "C" { pub fn g_application_get_dbus_object_path (application : * mut GApplication) -> * const gchar ; } unsafe extern "C" { pub fn g_application_get_inactivity_timeout (application : * mut GApplication) -> guint ; } unsafe extern "C" { pub fn g_application_set_inactivity_timeout (application : * mut GApplication , inactivity_timeout : guint) ; } unsafe extern "C" { pub fn g_application_get_flags (application : * mut GApplication) -> GApplicationFlags ; } unsafe extern "C" { pub fn g_application_set_flags (application : * mut GApplication , flags : GApplicationFlags) ; } unsafe extern "C" { pub fn g_application_get_resource_base_path (application : * mut GApplication) -> * const gchar ; } unsafe extern "C" { pub fn g_application_set_resource_base_path (application : * mut GApplication , resource_path : * const gchar) ; } unsafe extern "C" { pub fn g_application_set_action_group (application : * mut GApplication , action_group : * mut GActionGroup) ; } unsafe extern "C" { pub fn g_application_add_main_option_entries (application : * mut GApplication , entries : * const GOptionEntry) ; } unsafe extern "C" { pub fn g_application_add_main_option (application : * mut GApplication , long_name : * const :: std :: os :: raw :: c_char , short_name : :: std :: os :: raw :: c_char , flags : GOptionFlags , arg : GOptionArg , description : * const :: std :: os :: raw :: c_char , arg_description : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_application_add_option_group (application : * mut GApplication , group : * mut GOptionGroup) ; } unsafe extern "C" { pub fn g_application_set_option_context_parameter_string (application : * mut GApplication , parameter_string : * const gchar) ; } unsafe extern "C" { pub fn g_application_set_option_context_summary (application : * mut GApplication , summary : * const gchar) ; } unsafe extern "C" { pub fn g_application_set_option_context_description (application : * mut GApplication , description : * const gchar) ; } unsafe extern "C" { pub fn g_application_get_is_registered (application : * mut GApplication) -> gboolean ; } unsafe extern "C" { pub fn g_application_get_is_remote (application : * mut GApplication) -> gboolean ; } unsafe extern "C" { pub fn g_application_register (application : * mut GApplication , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_application_hold (application : * mut GApplication) ; } unsafe extern "C" { pub fn g_application_release (application : * mut GApplication) ; } unsafe extern "C" { pub fn g_application_activate (application : * mut GApplication) ; } unsafe extern "C" { pub fn g_application_open (application : * mut GApplication , files : * mut * mut GFile , n_files : gint , hint : * const gchar) ; } unsafe extern "C" { pub fn g_application_run (application : * mut GApplication , argc : :: std :: os :: raw :: c_int , argv : * mut * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn g_application_quit (application : * mut GApplication) ; } unsafe extern "C" { pub fn g_application_get_default () -> * mut GApplication ; } unsafe extern "C" { pub fn g_application_set_default (application : * mut GApplication) ; } unsafe extern "C" { pub fn g_application_mark_busy (application : * mut GApplication) ; } unsafe extern "C" { pub fn g_application_unmark_busy (application : * mut GApplication) ; } unsafe extern "C" { pub fn g_application_get_is_busy (application : * mut GApplication) -> gboolean ; } unsafe extern "C" { pub fn g_application_send_notification (application : * mut GApplication , id : * const gchar , notification : * mut GNotification) ; } unsafe extern "C" { pub fn g_application_withdraw_notification (application : * mut GApplication , id : * const gchar) ; } unsafe extern "C" { pub fn g_application_bind_busy_property (application : * mut GApplication , object : gpointer , property : * const gchar) ; } unsafe extern "C" { pub fn g_application_unbind_busy_property (application : * mut GApplication , object : gpointer , property : * const gchar) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GApplicationCommandLinePrivate { _unused : [u8 ; 0] , } pub type GApplicationCommandLinePrivate = _GApplicationCommandLinePrivate ; pub type GApplicationCommandLineClass = _GApplicationCommandLineClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GApplicationCommandLine { pub parent_instance : GObject , pub priv_ : * mut GApplicationCommandLinePrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GApplicationCommandLine"] [:: std :: mem :: size_of :: < _GApplicationCommandLine > () - 32usize] ; ["Alignment of _GApplicationCommandLine"] [:: std :: mem :: align_of :: < _GApplicationCommandLine > () - 8usize] ; ["Offset of field: _GApplicationCommandLine::parent_instance"] [:: std :: mem :: offset_of ! (_GApplicationCommandLine , parent_instance) - 0usize] ; ["Offset of field: _GApplicationCommandLine::priv_"] [:: std :: mem :: offset_of ! (_GApplicationCommandLine , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GApplicationCommandLineClass { pub parent_class : GObjectClass , pub print_literal : :: std :: option :: Option < unsafe extern "C" fn (cmdline : * mut GApplicationCommandLine , message : * const gchar) > , pub printerr_literal : :: std :: option :: Option < unsafe extern "C" fn (cmdline : * mut GApplicationCommandLine , message : * const gchar) > , pub get_stdin : :: std :: option :: Option < unsafe extern "C" fn (cmdline : * mut GApplicationCommandLine) -> * mut GInputStream > , pub done : :: std :: option :: Option < unsafe extern "C" fn (cmdline : * mut GApplicationCommandLine) > , pub padding : [gpointer ; 10usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GApplicationCommandLineClass"] [:: std :: mem :: size_of :: < _GApplicationCommandLineClass > () - 248usize] ; ["Alignment of _GApplicationCommandLineClass"] [:: std :: mem :: align_of :: < _GApplicationCommandLineClass > () - 8usize] ; ["Offset of field: _GApplicationCommandLineClass::parent_class"] [:: std :: mem :: offset_of ! (_GApplicationCommandLineClass , parent_class) - 0usize] ; ["Offset of field: _GApplicationCommandLineClass::print_literal"] [:: std :: mem :: offset_of ! (_GApplicationCommandLineClass , print_literal) - 136usize] ; ["Offset of field: _GApplicationCommandLineClass::printerr_literal"] [:: std :: mem :: offset_of ! (_GApplicationCommandLineClass , printerr_literal) - 144usize] ; ["Offset of field: _GApplicationCommandLineClass::get_stdin"] [:: std :: mem :: offset_of ! (_GApplicationCommandLineClass , get_stdin) - 152usize] ; ["Offset of field: _GApplicationCommandLineClass::done"] [:: std :: mem :: offset_of ! (_GApplicationCommandLineClass , done) - 160usize] ; ["Offset of field: _GApplicationCommandLineClass::padding"] [:: std :: mem :: offset_of ! (_GApplicationCommandLineClass , padding) - 168usize] ; } ; unsafe extern "C" { pub fn g_application_command_line_get_type () -> GType ; } unsafe extern "C" { pub fn g_application_command_line_get_arguments (cmdline : * mut GApplicationCommandLine , argc : * mut :: std :: os :: raw :: c_int) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_application_command_line_get_options_dict (cmdline : * mut GApplicationCommandLine) -> * mut GVariantDict ; } unsafe extern "C" { pub fn g_application_command_line_get_stdin (cmdline : * mut GApplicationCommandLine) -> * mut GInputStream ; } unsafe extern "C" { pub fn g_application_command_line_get_environ (cmdline : * mut GApplicationCommandLine) -> * const * const gchar ; } unsafe extern "C" { pub fn g_application_command_line_getenv (cmdline : * mut GApplicationCommandLine , name : * const gchar) -> * const gchar ; } unsafe extern "C" { pub fn g_application_command_line_get_cwd (cmdline : * mut GApplicationCommandLine) -> * const gchar ; } unsafe extern "C" { pub fn g_application_command_line_get_is_remote (cmdline : * mut GApplicationCommandLine) -> gboolean ; } unsafe extern "C" { pub fn g_application_command_line_print_literal (cmdline : * mut GApplicationCommandLine , message : * const gchar) ; } unsafe extern "C" { pub fn g_application_command_line_printerr_literal (cmdline : * mut GApplicationCommandLine , message : * const gchar) ; } unsafe extern "C" { pub fn g_application_command_line_print (cmdline : * mut GApplicationCommandLine , format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_application_command_line_printerr (cmdline : * mut GApplicationCommandLine , format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_application_command_line_get_exit_status (cmdline : * mut GApplicationCommandLine) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn g_application_command_line_set_exit_status (cmdline : * mut GApplicationCommandLine , exit_status : :: std :: os :: raw :: c_int) ; } unsafe extern "C" { pub fn g_application_command_line_get_platform_data (cmdline : * mut GApplicationCommandLine) -> * mut GVariant ; } unsafe extern "C" { pub fn g_application_command_line_create_file_for_arg (cmdline : * mut GApplicationCommandLine , arg : * const gchar) -> * mut GFile ; } unsafe extern "C" { pub fn g_application_command_line_done (cmdline : * mut GApplicationCommandLine) ; } pub type GInitableIface = _GInitableIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInitableIface { pub g_iface : GTypeInterface , pub init : :: std :: option :: Option < unsafe extern "C" fn (initable : * mut GInitable , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GInitableIface"] [:: std :: mem :: size_of :: < _GInitableIface > () - 24usize] ; ["Alignment of _GInitableIface"] [:: std :: mem :: align_of :: < _GInitableIface > () - 8usize] ; ["Offset of field: _GInitableIface::g_iface"] [:: std :: mem :: offset_of ! (_GInitableIface , g_iface) - 0usize] ; ["Offset of field: _GInitableIface::init"] [:: std :: mem :: offset_of ! (_GInitableIface , init) - 16usize] ; } ; unsafe extern "C" { pub fn g_initable_get_type () -> GType ; } unsafe extern "C" { pub fn g_initable_init (initable : * mut GInitable , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_initable_new (object_type : GType , cancellable : * mut GCancellable , error : * mut * mut GError , first_property_name : * const gchar , ...) -> gpointer ; } unsafe extern "C" { pub fn g_initable_newv (object_type : GType , n_parameters : guint , parameters : * mut GParameter , cancellable : * mut GCancellable , error : * mut * mut GError) -> gpointer ; } unsafe extern "C" { pub fn g_initable_new_valist (object_type : GType , first_property_name : * const gchar , var_args : * mut __va_list_tag , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GObject ; } pub type GAsyncInitableIface = _GAsyncInitableIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GAsyncInitableIface { pub g_iface : GTypeInterface , pub init_async : :: std :: option :: Option < unsafe extern "C" fn (initable : * mut GAsyncInitable , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub init_finish : :: std :: option :: Option < unsafe extern "C" fn (initable : * mut GAsyncInitable , res : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GAsyncInitableIface"] [:: std :: mem :: size_of :: < _GAsyncInitableIface > () - 32usize] ; ["Alignment of _GAsyncInitableIface"] [:: std :: mem :: align_of :: < _GAsyncInitableIface > () - 8usize] ; ["Offset of field: _GAsyncInitableIface::g_iface"] [:: std :: mem :: offset_of ! (_GAsyncInitableIface , g_iface) - 0usize] ; ["Offset of field: _GAsyncInitableIface::init_async"] [:: std :: mem :: offset_of ! (_GAsyncInitableIface , init_async) - 16usize] ; ["Offset of field: _GAsyncInitableIface::init_finish"] [:: std :: mem :: offset_of ! (_GAsyncInitableIface , init_finish) - 24usize] ; } ; unsafe extern "C" { pub fn g_async_initable_get_type () -> GType ; } unsafe extern "C" { pub fn g_async_initable_init_async (initable : * mut GAsyncInitable , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_async_initable_init_finish (initable : * mut GAsyncInitable , res : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_async_initable_new_async (object_type : GType , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer , first_property_name : * const gchar , ...) ; } unsafe extern "C" { pub fn g_async_initable_newv_async (object_type : GType , n_parameters : guint , parameters : * mut GParameter , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_async_initable_new_valist_async (object_type : GType , first_property_name : * const gchar , var_args : * mut __va_list_tag , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_async_initable_new_finish (initable : * mut GAsyncInitable , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GObject ; } pub type GAsyncResultIface = _GAsyncResultIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GAsyncResultIface { pub g_iface : GTypeInterface , pub get_user_data : :: std :: option :: Option < unsafe extern "C" fn (res : * mut GAsyncResult) -> gpointer > , pub get_source_object : :: std :: option :: Option < unsafe extern "C" fn (res : * mut GAsyncResult) -> * mut GObject > , pub is_tagged : :: std :: option :: Option < unsafe extern "C" fn (res : * mut GAsyncResult , source_tag : gpointer) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GAsyncResultIface"] [:: std :: mem :: size_of :: < _GAsyncResultIface > () - 40usize] ; ["Alignment of _GAsyncResultIface"] [:: std :: mem :: align_of :: < _GAsyncResultIface > () - 8usize] ; ["Offset of field: _GAsyncResultIface::g_iface"] [:: std :: mem :: offset_of ! (_GAsyncResultIface , g_iface) - 0usize] ; ["Offset of field: _GAsyncResultIface::get_user_data"] [:: std :: mem :: offset_of ! (_GAsyncResultIface , get_user_data) - 16usize] ; ["Offset of field: _GAsyncResultIface::get_source_object"] [:: std :: mem :: offset_of ! (_GAsyncResultIface , get_source_object) - 24usize] ; ["Offset of field: _GAsyncResultIface::is_tagged"] [:: std :: mem :: offset_of ! (_GAsyncResultIface , is_tagged) - 32usize] ; } ; unsafe extern "C" { pub fn g_async_result_get_type () -> GType ; } unsafe extern "C" { pub fn g_async_result_get_user_data (res : * mut GAsyncResult) -> gpointer ; } unsafe extern "C" { pub fn g_async_result_get_source_object (res : * mut GAsyncResult) -> * mut GObject ; } unsafe extern "C" { pub fn g_async_result_legacy_propagate_error (res : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_async_result_is_tagged (res : * mut GAsyncResult , source_tag : gpointer) -> gboolean ; } pub type GInputStreamClass = _GInputStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInputStreamPrivate { _unused : [u8 ; 0] , } pub type GInputStreamPrivate = _GInputStreamPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInputStream { pub parent_instance : GObject , pub priv_ : * mut GInputStreamPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GInputStream"] [:: std :: mem :: size_of :: < _GInputStream > () - 32usize] ; ["Alignment of _GInputStream"] [:: std :: mem :: align_of :: < _GInputStream > () - 8usize] ; ["Offset of field: _GInputStream::parent_instance"] [:: std :: mem :: offset_of ! (_GInputStream , parent_instance) - 0usize] ; ["Offset of field: _GInputStream::priv_"] [:: std :: mem :: offset_of ! (_GInputStream , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInputStreamClass { pub parent_class : GObjectClass , pub read_fn : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GInputStream , buffer : * mut :: std :: os :: raw :: c_void , count : gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize > , pub skip : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GInputStream , count : gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize > , pub close_fn : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GInputStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub read_async : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GInputStream , buffer : * mut :: std :: os :: raw :: c_void , count : gsize , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub read_finish : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GInputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gssize > , pub skip_async : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GInputStream , count : gsize , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub skip_finish : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GInputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gssize > , pub close_async : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GInputStream , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub close_finish : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GInputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GInputStreamClass"] [:: std :: mem :: size_of :: < _GInputStreamClass > () - 248usize] ; ["Alignment of _GInputStreamClass"] [:: std :: mem :: align_of :: < _GInputStreamClass > () - 8usize] ; ["Offset of field: _GInputStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GInputStreamClass , parent_class) - 0usize] ; ["Offset of field: _GInputStreamClass::read_fn"] [:: std :: mem :: offset_of ! (_GInputStreamClass , read_fn) - 136usize] ; ["Offset of field: _GInputStreamClass::skip"] [:: std :: mem :: offset_of ! (_GInputStreamClass , skip) - 144usize] ; ["Offset of field: _GInputStreamClass::close_fn"] [:: std :: mem :: offset_of ! (_GInputStreamClass , close_fn) - 152usize] ; ["Offset of field: _GInputStreamClass::read_async"] [:: std :: mem :: offset_of ! (_GInputStreamClass , read_async) - 160usize] ; ["Offset of field: _GInputStreamClass::read_finish"] [:: std :: mem :: offset_of ! (_GInputStreamClass , read_finish) - 168usize] ; ["Offset of field: _GInputStreamClass::skip_async"] [:: std :: mem :: offset_of ! (_GInputStreamClass , skip_async) - 176usize] ; ["Offset of field: _GInputStreamClass::skip_finish"] [:: std :: mem :: offset_of ! (_GInputStreamClass , skip_finish) - 184usize] ; ["Offset of field: _GInputStreamClass::close_async"] [:: std :: mem :: offset_of ! (_GInputStreamClass , close_async) - 192usize] ; ["Offset of field: _GInputStreamClass::close_finish"] [:: std :: mem :: offset_of ! (_GInputStreamClass , close_finish) - 200usize] ; ["Offset of field: _GInputStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GInputStreamClass , _g_reserved1) - 208usize] ; ["Offset of field: _GInputStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GInputStreamClass , _g_reserved2) - 216usize] ; ["Offset of field: _GInputStreamClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GInputStreamClass , _g_reserved3) - 224usize] ; ["Offset of field: _GInputStreamClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GInputStreamClass , _g_reserved4) - 232usize] ; ["Offset of field: _GInputStreamClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GInputStreamClass , _g_reserved5) - 240usize] ; } ; unsafe extern "C" { pub fn g_input_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_input_stream_read (stream : * mut GInputStream , buffer : * mut :: std :: os :: raw :: c_void , count : gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_input_stream_read_all (stream : * mut GInputStream , buffer : * mut :: std :: os :: raw :: c_void , count : gsize , bytes_read : * mut gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_input_stream_read_bytes (stream : * mut GInputStream , count : gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GBytes ; } unsafe extern "C" { pub fn g_input_stream_skip (stream : * mut GInputStream , count : gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_input_stream_close (stream : * mut GInputStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_input_stream_read_async (stream : * mut GInputStream , buffer : * mut :: std :: os :: raw :: c_void , count : gsize , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_input_stream_read_finish (stream : * mut GInputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_input_stream_read_all_async (stream : * mut GInputStream , buffer : * mut :: std :: os :: raw :: c_void , count : gsize , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_input_stream_read_all_finish (stream : * mut GInputStream , result : * mut GAsyncResult , bytes_read : * mut gsize , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_input_stream_read_bytes_async (stream : * mut GInputStream , count : gsize , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_input_stream_read_bytes_finish (stream : * mut GInputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GBytes ; } unsafe extern "C" { pub fn g_input_stream_skip_async (stream : * mut GInputStream , count : gsize , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_input_stream_skip_finish (stream : * mut GInputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_input_stream_close_async (stream : * mut GInputStream , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_input_stream_close_finish (stream : * mut GInputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_input_stream_is_closed (stream : * mut GInputStream) -> gboolean ; } unsafe extern "C" { pub fn g_input_stream_has_pending (stream : * mut GInputStream) -> gboolean ; } unsafe extern "C" { pub fn g_input_stream_set_pending (stream : * mut GInputStream , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_input_stream_clear_pending (stream : * mut GInputStream) ; } pub type GFilterInputStreamClass = _GFilterInputStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFilterInputStream { pub parent_instance : GInputStream , pub base_stream : * mut GInputStream , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFilterInputStream"] [:: std :: mem :: size_of :: < _GFilterInputStream > () - 40usize] ; ["Alignment of _GFilterInputStream"] [:: std :: mem :: align_of :: < _GFilterInputStream > () - 8usize] ; ["Offset of field: _GFilterInputStream::parent_instance"] [:: std :: mem :: offset_of ! (_GFilterInputStream , parent_instance) - 0usize] ; ["Offset of field: _GFilterInputStream::base_stream"] [:: std :: mem :: offset_of ! (_GFilterInputStream , base_stream) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFilterInputStreamClass { pub parent_class : GInputStreamClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFilterInputStreamClass"] [:: std :: mem :: size_of :: < _GFilterInputStreamClass > () - 272usize] ; ["Alignment of _GFilterInputStreamClass"] [:: std :: mem :: align_of :: < _GFilterInputStreamClass > () - 8usize] ; ["Offset of field: _GFilterInputStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GFilterInputStreamClass , parent_class) - 0usize] ; ["Offset of field: _GFilterInputStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GFilterInputStreamClass , _g_reserved1) - 248usize] ; ["Offset of field: _GFilterInputStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GFilterInputStreamClass , _g_reserved2) - 256usize] ; ["Offset of field: _GFilterInputStreamClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GFilterInputStreamClass , _g_reserved3) - 264usize] ; } ; unsafe extern "C" { pub fn g_filter_input_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_filter_input_stream_get_base_stream (stream : * mut GFilterInputStream) -> * mut GInputStream ; } unsafe extern "C" { pub fn g_filter_input_stream_get_close_base_stream (stream : * mut GFilterInputStream) -> gboolean ; } unsafe extern "C" { pub fn g_filter_input_stream_set_close_base_stream (stream : * mut GFilterInputStream , close_base : gboolean) ; } pub type GBufferedInputStreamClass = _GBufferedInputStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GBufferedInputStreamPrivate { _unused : [u8 ; 0] , } pub type GBufferedInputStreamPrivate = _GBufferedInputStreamPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GBufferedInputStream { pub parent_instance : GFilterInputStream , pub priv_ : * mut GBufferedInputStreamPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GBufferedInputStream"] [:: std :: mem :: size_of :: < _GBufferedInputStream > () - 48usize] ; ["Alignment of _GBufferedInputStream"] [:: std :: mem :: align_of :: < _GBufferedInputStream > () - 8usize] ; ["Offset of field: _GBufferedInputStream::parent_instance"] [:: std :: mem :: offset_of ! (_GBufferedInputStream , parent_instance) - 0usize] ; ["Offset of field: _GBufferedInputStream::priv_"] [:: std :: mem :: offset_of ! (_GBufferedInputStream , priv_) - 40usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GBufferedInputStreamClass { pub parent_class : GFilterInputStreamClass , pub fill : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GBufferedInputStream , count : gssize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize > , pub fill_async : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GBufferedInputStream , count : gssize , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub fill_finish : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GBufferedInputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gssize > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GBufferedInputStreamClass"] [:: std :: mem :: size_of :: < _GBufferedInputStreamClass > () - 336usize] ; ["Alignment of _GBufferedInputStreamClass"] [:: std :: mem :: align_of :: < _GBufferedInputStreamClass > () - 8usize] ; ["Offset of field: _GBufferedInputStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GBufferedInputStreamClass , parent_class) - 0usize] ; ["Offset of field: _GBufferedInputStreamClass::fill"] [:: std :: mem :: offset_of ! (_GBufferedInputStreamClass , fill) - 272usize] ; ["Offset of field: _GBufferedInputStreamClass::fill_async"] [:: std :: mem :: offset_of ! (_GBufferedInputStreamClass , fill_async) - 280usize] ; ["Offset of field: _GBufferedInputStreamClass::fill_finish"] [:: std :: mem :: offset_of ! (_GBufferedInputStreamClass , fill_finish) - 288usize] ; ["Offset of field: _GBufferedInputStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GBufferedInputStreamClass , _g_reserved1) - 296usize] ; ["Offset of field: _GBufferedInputStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GBufferedInputStreamClass , _g_reserved2) - 304usize] ; ["Offset of field: _GBufferedInputStreamClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GBufferedInputStreamClass , _g_reserved3) - 312usize] ; ["Offset of field: _GBufferedInputStreamClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GBufferedInputStreamClass , _g_reserved4) - 320usize] ; ["Offset of field: _GBufferedInputStreamClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GBufferedInputStreamClass , _g_reserved5) - 328usize] ; } ; unsafe extern "C" { pub fn g_buffered_input_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_buffered_input_stream_new (base_stream : * mut GInputStream) -> * mut GInputStream ; } unsafe extern "C" { pub fn g_buffered_input_stream_new_sized (base_stream : * mut GInputStream , size : gsize) -> * mut GInputStream ; } unsafe extern "C" { pub fn g_buffered_input_stream_get_buffer_size (stream : * mut GBufferedInputStream) -> gsize ; } unsafe extern "C" { pub fn g_buffered_input_stream_set_buffer_size (stream : * mut GBufferedInputStream , size : gsize) ; } unsafe extern "C" { pub fn g_buffered_input_stream_get_available (stream : * mut GBufferedInputStream) -> gsize ; } unsafe extern "C" { pub fn g_buffered_input_stream_peek (stream : * mut GBufferedInputStream , buffer : * mut :: std :: os :: raw :: c_void , offset : gsize , count : gsize) -> gsize ; } unsafe extern "C" { pub fn g_buffered_input_stream_peek_buffer (stream : * mut GBufferedInputStream , count : * mut gsize) -> * const :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn g_buffered_input_stream_fill (stream : * mut GBufferedInputStream , count : gssize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_buffered_input_stream_fill_async (stream : * mut GBufferedInputStream , count : gssize , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_buffered_input_stream_fill_finish (stream : * mut GBufferedInputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_buffered_input_stream_read_byte (stream : * mut GBufferedInputStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> :: std :: os :: raw :: c_int ; } pub type GOutputStreamClass = _GOutputStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GOutputStreamPrivate { _unused : [u8 ; 0] , } pub type GOutputStreamPrivate = _GOutputStreamPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GOutputStream { pub parent_instance : GObject , pub priv_ : * mut GOutputStreamPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GOutputStream"] [:: std :: mem :: size_of :: < _GOutputStream > () - 32usize] ; ["Alignment of _GOutputStream"] [:: std :: mem :: align_of :: < _GOutputStream > () - 8usize] ; ["Offset of field: _GOutputStream::parent_instance"] [:: std :: mem :: offset_of ! (_GOutputStream , parent_instance) - 0usize] ; ["Offset of field: _GOutputStream::priv_"] [:: std :: mem :: offset_of ! (_GOutputStream , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GOutputStreamClass { pub parent_class : GObjectClass , pub write_fn : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , buffer : * const :: std :: os :: raw :: c_void , count : gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize > , pub splice : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , source : * mut GInputStream , flags : GOutputStreamSpliceFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize > , pub flush : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub close_fn : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub write_async : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , buffer : * const :: std :: os :: raw :: c_void , count : gsize , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub write_finish : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gssize > , pub splice_async : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , source : * mut GInputStream , flags : GOutputStreamSpliceFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub splice_finish : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gssize > , pub flush_async : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub flush_finish : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub close_async : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub close_finish : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub writev_fn : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , vectors : * const GOutputVector , n_vectors : gsize , bytes_written : * mut gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub writev_async : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , vectors : * const GOutputVector , n_vectors : gsize , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub writev_finish : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GOutputStream , result : * mut GAsyncResult , bytes_written : * mut gsize , error : * mut * mut GError) -> gboolean > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved6 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved7 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved8 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GOutputStreamClass"] [:: std :: mem :: size_of :: < _GOutputStreamClass > () - 296usize] ; ["Alignment of _GOutputStreamClass"] [:: std :: mem :: align_of :: < _GOutputStreamClass > () - 8usize] ; ["Offset of field: _GOutputStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , parent_class) - 0usize] ; ["Offset of field: _GOutputStreamClass::write_fn"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , write_fn) - 136usize] ; ["Offset of field: _GOutputStreamClass::splice"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , splice) - 144usize] ; ["Offset of field: _GOutputStreamClass::flush"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , flush) - 152usize] ; ["Offset of field: _GOutputStreamClass::close_fn"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , close_fn) - 160usize] ; ["Offset of field: _GOutputStreamClass::write_async"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , write_async) - 168usize] ; ["Offset of field: _GOutputStreamClass::write_finish"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , write_finish) - 176usize] ; ["Offset of field: _GOutputStreamClass::splice_async"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , splice_async) - 184usize] ; ["Offset of field: _GOutputStreamClass::splice_finish"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , splice_finish) - 192usize] ; ["Offset of field: _GOutputStreamClass::flush_async"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , flush_async) - 200usize] ; ["Offset of field: _GOutputStreamClass::flush_finish"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , flush_finish) - 208usize] ; ["Offset of field: _GOutputStreamClass::close_async"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , close_async) - 216usize] ; ["Offset of field: _GOutputStreamClass::close_finish"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , close_finish) - 224usize] ; ["Offset of field: _GOutputStreamClass::writev_fn"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , writev_fn) - 232usize] ; ["Offset of field: _GOutputStreamClass::writev_async"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , writev_async) - 240usize] ; ["Offset of field: _GOutputStreamClass::writev_finish"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , writev_finish) - 248usize] ; ["Offset of field: _GOutputStreamClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , _g_reserved4) - 256usize] ; ["Offset of field: _GOutputStreamClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , _g_reserved5) - 264usize] ; ["Offset of field: _GOutputStreamClass::_g_reserved6"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , _g_reserved6) - 272usize] ; ["Offset of field: _GOutputStreamClass::_g_reserved7"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , _g_reserved7) - 280usize] ; ["Offset of field: _GOutputStreamClass::_g_reserved8"] [:: std :: mem :: offset_of ! (_GOutputStreamClass , _g_reserved8) - 288usize] ; } ; unsafe extern "C" { pub fn g_output_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_output_stream_write (stream : * mut GOutputStream , buffer : * const :: std :: os :: raw :: c_void , count : gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_output_stream_write_all (stream : * mut GOutputStream , buffer : * const :: std :: os :: raw :: c_void , count : gsize , bytes_written : * mut gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_writev (stream : * mut GOutputStream , vectors : * const GOutputVector , n_vectors : gsize , bytes_written : * mut gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_writev_all (stream : * mut GOutputStream , vectors : * mut GOutputVector , n_vectors : gsize , bytes_written : * mut gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_printf (stream : * mut GOutputStream , bytes_written : * mut gsize , cancellable : * mut GCancellable , error : * mut * mut GError , format : * const gchar , ...) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_vprintf (stream : * mut GOutputStream , bytes_written : * mut gsize , cancellable : * mut GCancellable , error : * mut * mut GError , format : * const gchar , args : * mut __va_list_tag) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_write_bytes (stream : * mut GOutputStream , bytes : * mut GBytes , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_output_stream_splice (stream : * mut GOutputStream , source : * mut GInputStream , flags : GOutputStreamSpliceFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_output_stream_flush (stream : * mut GOutputStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_close (stream : * mut GOutputStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_write_async (stream : * mut GOutputStream , buffer : * const :: std :: os :: raw :: c_void , count : gsize , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_output_stream_write_finish (stream : * mut GOutputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_output_stream_write_all_async (stream : * mut GOutputStream , buffer : * const :: std :: os :: raw :: c_void , count : gsize , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_output_stream_write_all_finish (stream : * mut GOutputStream , result : * mut GAsyncResult , bytes_written : * mut gsize , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_writev_async (stream : * mut GOutputStream , vectors : * const GOutputVector , n_vectors : gsize , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_output_stream_writev_finish (stream : * mut GOutputStream , result : * mut GAsyncResult , bytes_written : * mut gsize , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_writev_all_async (stream : * mut GOutputStream , vectors : * mut GOutputVector , n_vectors : gsize , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_output_stream_writev_all_finish (stream : * mut GOutputStream , result : * mut GAsyncResult , bytes_written : * mut gsize , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_write_bytes_async (stream : * mut GOutputStream , bytes : * mut GBytes , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_output_stream_write_bytes_finish (stream : * mut GOutputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_output_stream_splice_async (stream : * mut GOutputStream , source : * mut GInputStream , flags : GOutputStreamSpliceFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_output_stream_splice_finish (stream : * mut GOutputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_output_stream_flush_async (stream : * mut GOutputStream , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_output_stream_flush_finish (stream : * mut GOutputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_close_async (stream : * mut GOutputStream , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_output_stream_close_finish (stream : * mut GOutputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_is_closed (stream : * mut GOutputStream) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_is_closing (stream : * mut GOutputStream) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_has_pending (stream : * mut GOutputStream) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_set_pending (stream : * mut GOutputStream , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_output_stream_clear_pending (stream : * mut GOutputStream) ; } pub type GFilterOutputStreamClass = _GFilterOutputStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFilterOutputStream { pub parent_instance : GOutputStream , pub base_stream : * mut GOutputStream , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFilterOutputStream"] [:: std :: mem :: size_of :: < _GFilterOutputStream > () - 40usize] ; ["Alignment of _GFilterOutputStream"] [:: std :: mem :: align_of :: < _GFilterOutputStream > () - 8usize] ; ["Offset of field: _GFilterOutputStream::parent_instance"] [:: std :: mem :: offset_of ! (_GFilterOutputStream , parent_instance) - 0usize] ; ["Offset of field: _GFilterOutputStream::base_stream"] [:: std :: mem :: offset_of ! (_GFilterOutputStream , base_stream) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFilterOutputStreamClass { pub parent_class : GOutputStreamClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFilterOutputStreamClass"] [:: std :: mem :: size_of :: < _GFilterOutputStreamClass > () - 320usize] ; ["Alignment of _GFilterOutputStreamClass"] [:: std :: mem :: align_of :: < _GFilterOutputStreamClass > () - 8usize] ; ["Offset of field: _GFilterOutputStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GFilterOutputStreamClass , parent_class) - 0usize] ; ["Offset of field: _GFilterOutputStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GFilterOutputStreamClass , _g_reserved1) - 296usize] ; ["Offset of field: _GFilterOutputStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GFilterOutputStreamClass , _g_reserved2) - 304usize] ; ["Offset of field: _GFilterOutputStreamClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GFilterOutputStreamClass , _g_reserved3) - 312usize] ; } ; unsafe extern "C" { pub fn g_filter_output_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_filter_output_stream_get_base_stream (stream : * mut GFilterOutputStream) -> * mut GOutputStream ; } unsafe extern "C" { pub fn g_filter_output_stream_get_close_base_stream (stream : * mut GFilterOutputStream) -> gboolean ; } unsafe extern "C" { pub fn g_filter_output_stream_set_close_base_stream (stream : * mut GFilterOutputStream , close_base : gboolean) ; } pub type GBufferedOutputStreamClass = _GBufferedOutputStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GBufferedOutputStreamPrivate { _unused : [u8 ; 0] , } pub type GBufferedOutputStreamPrivate = _GBufferedOutputStreamPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GBufferedOutputStream { pub parent_instance : GFilterOutputStream , pub priv_ : * mut GBufferedOutputStreamPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GBufferedOutputStream"] [:: std :: mem :: size_of :: < _GBufferedOutputStream > () - 48usize] ; ["Alignment of _GBufferedOutputStream"] [:: std :: mem :: align_of :: < _GBufferedOutputStream > () - 8usize] ; ["Offset of field: _GBufferedOutputStream::parent_instance"] [:: std :: mem :: offset_of ! (_GBufferedOutputStream , parent_instance) - 0usize] ; ["Offset of field: _GBufferedOutputStream::priv_"] [:: std :: mem :: offset_of ! (_GBufferedOutputStream , priv_) - 40usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GBufferedOutputStreamClass { pub parent_class : GFilterOutputStreamClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GBufferedOutputStreamClass"] [:: std :: mem :: size_of :: < _GBufferedOutputStreamClass > () - 336usize] ; ["Alignment of _GBufferedOutputStreamClass"] [:: std :: mem :: align_of :: < _GBufferedOutputStreamClass > () - 8usize] ; ["Offset of field: _GBufferedOutputStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GBufferedOutputStreamClass , parent_class) - 0usize] ; ["Offset of field: _GBufferedOutputStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GBufferedOutputStreamClass , _g_reserved1) - 320usize] ; ["Offset of field: _GBufferedOutputStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GBufferedOutputStreamClass , _g_reserved2) - 328usize] ; } ; unsafe extern "C" { pub fn g_buffered_output_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_buffered_output_stream_new (base_stream : * mut GOutputStream) -> * mut GOutputStream ; } unsafe extern "C" { pub fn g_buffered_output_stream_new_sized (base_stream : * mut GOutputStream , size : gsize) -> * mut GOutputStream ; } unsafe extern "C" { pub fn g_buffered_output_stream_get_buffer_size (stream : * mut GBufferedOutputStream) -> gsize ; } unsafe extern "C" { pub fn g_buffered_output_stream_set_buffer_size (stream : * mut GBufferedOutputStream , size : gsize) ; } unsafe extern "C" { pub fn g_buffered_output_stream_get_auto_grow (stream : * mut GBufferedOutputStream) -> gboolean ; } unsafe extern "C" { pub fn g_buffered_output_stream_set_auto_grow (stream : * mut GBufferedOutputStream , auto_grow : gboolean) ; } unsafe extern "C" { pub fn g_bytes_icon_get_type () -> GType ; } unsafe extern "C" { pub fn g_bytes_icon_new (bytes : * mut GBytes) -> * mut GIcon ; } unsafe extern "C" { pub fn g_bytes_icon_get_bytes (icon : * mut GBytesIcon) -> * mut GBytes ; } pub type GCancellableClass = _GCancellableClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GCancellablePrivate { _unused : [u8 ; 0] , } pub type GCancellablePrivate = _GCancellablePrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GCancellable { pub parent_instance : GObject , pub priv_ : * mut GCancellablePrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GCancellable"] [:: std :: mem :: size_of :: < _GCancellable > () - 32usize] ; ["Alignment of _GCancellable"] [:: std :: mem :: align_of :: < _GCancellable > () - 8usize] ; ["Offset of field: _GCancellable::parent_instance"] [:: std :: mem :: offset_of ! (_GCancellable , parent_instance) - 0usize] ; ["Offset of field: _GCancellable::priv_"] [:: std :: mem :: offset_of ! (_GCancellable , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GCancellableClass { pub parent_class : GObjectClass , pub cancelled : :: std :: option :: Option < unsafe extern "C" fn (cancellable : * mut GCancellable) > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GCancellableClass"] [:: std :: mem :: size_of :: < _GCancellableClass > () - 184usize] ; ["Alignment of _GCancellableClass"] [:: std :: mem :: align_of :: < _GCancellableClass > () - 8usize] ; ["Offset of field: _GCancellableClass::parent_class"] [:: std :: mem :: offset_of ! (_GCancellableClass , parent_class) - 0usize] ; ["Offset of field: _GCancellableClass::cancelled"] [:: std :: mem :: offset_of ! (_GCancellableClass , cancelled) - 136usize] ; ["Offset of field: _GCancellableClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GCancellableClass , _g_reserved1) - 144usize] ; ["Offset of field: _GCancellableClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GCancellableClass , _g_reserved2) - 152usize] ; ["Offset of field: _GCancellableClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GCancellableClass , _g_reserved3) - 160usize] ; ["Offset of field: _GCancellableClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GCancellableClass , _g_reserved4) - 168usize] ; ["Offset of field: _GCancellableClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GCancellableClass , _g_reserved5) - 176usize] ; } ; unsafe extern "C" { pub fn g_cancellable_get_type () -> GType ; } unsafe extern "C" { pub fn g_cancellable_new () -> * mut GCancellable ; } unsafe extern "C" { pub fn g_cancellable_is_cancelled (cancellable : * mut GCancellable) -> gboolean ; } unsafe extern "C" { pub fn g_cancellable_set_error_if_cancelled (cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_cancellable_get_fd (cancellable : * mut GCancellable) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn g_cancellable_make_pollfd (cancellable : * mut GCancellable , pollfd : * mut GPollFD) -> gboolean ; } unsafe extern "C" { pub fn g_cancellable_release_fd (cancellable : * mut GCancellable) ; } unsafe extern "C" { pub fn g_cancellable_source_new (cancellable : * mut GCancellable) -> * mut GSource ; } unsafe extern "C" { pub fn g_cancellable_get_current () -> * mut GCancellable ; } unsafe extern "C" { pub fn g_cancellable_push_current (cancellable : * mut GCancellable) ; } unsafe extern "C" { pub fn g_cancellable_pop_current (cancellable : * mut GCancellable) ; } unsafe extern "C" { pub fn g_cancellable_reset (cancellable : * mut GCancellable) ; } unsafe extern "C" { pub fn g_cancellable_connect (cancellable : * mut GCancellable , callback : GCallback , data : gpointer , data_destroy_func : GDestroyNotify) -> gulong ; } unsafe extern "C" { pub fn g_cancellable_disconnect (cancellable : * mut GCancellable , handler_id : gulong) ; } unsafe extern "C" { pub fn g_cancellable_cancel (cancellable : * mut GCancellable) ; } pub type GConverterIface = _GConverterIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GConverterIface { pub g_iface : GTypeInterface , pub convert : :: std :: option :: Option < unsafe extern "C" fn (converter : * mut GConverter , inbuf : * const :: std :: os :: raw :: c_void , inbuf_size : gsize , outbuf : * mut :: std :: os :: raw :: c_void , outbuf_size : gsize , flags : GConverterFlags , bytes_read : * mut gsize , bytes_written : * mut gsize , error : * mut * mut GError) -> GConverterResult > , pub reset : :: std :: option :: Option < unsafe extern "C" fn (converter : * mut GConverter) > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GConverterIface"] [:: std :: mem :: size_of :: < _GConverterIface > () - 32usize] ; ["Alignment of _GConverterIface"] [:: std :: mem :: align_of :: < _GConverterIface > () - 8usize] ; ["Offset of field: _GConverterIface::g_iface"] [:: std :: mem :: offset_of ! (_GConverterIface , g_iface) - 0usize] ; ["Offset of field: _GConverterIface::convert"] [:: std :: mem :: offset_of ! (_GConverterIface , convert) - 16usize] ; ["Offset of field: _GConverterIface::reset"] [:: std :: mem :: offset_of ! (_GConverterIface , reset) - 24usize] ; } ; unsafe extern "C" { pub fn g_converter_get_type () -> GType ; } unsafe extern "C" { pub fn g_converter_convert (converter : * mut GConverter , inbuf : * const :: std :: os :: raw :: c_void , inbuf_size : gsize , outbuf : * mut :: std :: os :: raw :: c_void , outbuf_size : gsize , flags : GConverterFlags , bytes_read : * mut gsize , bytes_written : * mut gsize , error : * mut * mut GError) -> GConverterResult ; } unsafe extern "C" { pub fn g_converter_reset (converter : * mut GConverter) ; } unsafe extern "C" { pub fn g_converter_convert_bytes (converter : * mut GConverter , bytes : * mut GBytes , error : * mut * mut GError) -> * mut GBytes ; } pub type GCharsetConverterClass = _GCharsetConverterClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GCharsetConverterClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GCharsetConverterClass"] [:: std :: mem :: size_of :: < _GCharsetConverterClass > () - 136usize] ; ["Alignment of _GCharsetConverterClass"] [:: std :: mem :: align_of :: < _GCharsetConverterClass > () - 8usize] ; ["Offset of field: _GCharsetConverterClass::parent_class"] [:: std :: mem :: offset_of ! (_GCharsetConverterClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn g_charset_converter_get_type () -> GType ; } unsafe extern "C" { pub fn g_charset_converter_new (to_charset : * const gchar , from_charset : * const gchar , error : * mut * mut GError) -> * mut GCharsetConverter ; } unsafe extern "C" { pub fn g_charset_converter_set_use_fallback (converter : * mut GCharsetConverter , use_fallback : gboolean) ; } unsafe extern "C" { pub fn g_charset_converter_get_use_fallback (converter : * mut GCharsetConverter) -> gboolean ; } unsafe extern "C" { pub fn g_charset_converter_get_num_fallbacks (converter : * mut GCharsetConverter) -> guint ; } unsafe extern "C" { pub fn g_content_type_equals (type1 : * const gchar , type2 : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_content_type_is_a (type_ : * const gchar , supertype : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_content_type_is_mime_type (type_ : * const gchar , mime_type : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_content_type_is_unknown (type_ : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_content_type_get_description (type_ : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_content_type_get_mime_type (type_ : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_content_type_get_icon (type_ : * const gchar) -> * mut GIcon ; } unsafe extern "C" { pub fn g_content_type_get_symbolic_icon (type_ : * const gchar) -> * mut GIcon ; } unsafe extern "C" { pub fn g_content_type_get_generic_icon_name (type_ : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_content_type_can_be_executable (type_ : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_content_type_from_mime_type (mime_type : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_content_type_guess (filename : * const gchar , data : * const guchar , data_size : gsize , result_uncertain : * mut gboolean) -> * mut gchar ; } unsafe extern "C" { pub fn g_content_type_guess_for_tree (root : * mut GFile) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_content_types_get_registered () -> * mut GList ; } unsafe extern "C" { pub fn g_content_type_get_mime_dirs () -> * const * const gchar ; } unsafe extern "C" { pub fn g_content_type_set_mime_dirs (dirs : * const * const gchar) ; } pub type GConverterInputStreamClass = _GConverterInputStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GConverterInputStreamPrivate { _unused : [u8 ; 0] , } pub type GConverterInputStreamPrivate = _GConverterInputStreamPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GConverterInputStream { pub parent_instance : GFilterInputStream , pub priv_ : * mut GConverterInputStreamPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GConverterInputStream"] [:: std :: mem :: size_of :: < _GConverterInputStream > () - 48usize] ; ["Alignment of _GConverterInputStream"] [:: std :: mem :: align_of :: < _GConverterInputStream > () - 8usize] ; ["Offset of field: _GConverterInputStream::parent_instance"] [:: std :: mem :: offset_of ! (_GConverterInputStream , parent_instance) - 0usize] ; ["Offset of field: _GConverterInputStream::priv_"] [:: std :: mem :: offset_of ! (_GConverterInputStream , priv_) - 40usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GConverterInputStreamClass { pub parent_class : GFilterInputStreamClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GConverterInputStreamClass"] [:: std :: mem :: size_of :: < _GConverterInputStreamClass > () - 312usize] ; ["Alignment of _GConverterInputStreamClass"] [:: std :: mem :: align_of :: < _GConverterInputStreamClass > () - 8usize] ; ["Offset of field: _GConverterInputStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GConverterInputStreamClass , parent_class) - 0usize] ; ["Offset of field: _GConverterInputStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GConverterInputStreamClass , _g_reserved1) - 272usize] ; ["Offset of field: _GConverterInputStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GConverterInputStreamClass , _g_reserved2) - 280usize] ; ["Offset of field: _GConverterInputStreamClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GConverterInputStreamClass , _g_reserved3) - 288usize] ; ["Offset of field: _GConverterInputStreamClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GConverterInputStreamClass , _g_reserved4) - 296usize] ; ["Offset of field: _GConverterInputStreamClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GConverterInputStreamClass , _g_reserved5) - 304usize] ; } ; unsafe extern "C" { pub fn g_converter_input_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_converter_input_stream_new (base_stream : * mut GInputStream , converter : * mut GConverter) -> * mut GInputStream ; } unsafe extern "C" { pub fn g_converter_input_stream_get_converter (converter_stream : * mut GConverterInputStream) -> * mut GConverter ; } pub type GConverterOutputStreamClass = _GConverterOutputStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GConverterOutputStreamPrivate { _unused : [u8 ; 0] , } pub type GConverterOutputStreamPrivate = _GConverterOutputStreamPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GConverterOutputStream { pub parent_instance : GFilterOutputStream , pub priv_ : * mut GConverterOutputStreamPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GConverterOutputStream"] [:: std :: mem :: size_of :: < _GConverterOutputStream > () - 48usize] ; ["Alignment of _GConverterOutputStream"] [:: std :: mem :: align_of :: < _GConverterOutputStream > () - 8usize] ; ["Offset of field: _GConverterOutputStream::parent_instance"] [:: std :: mem :: offset_of ! (_GConverterOutputStream , parent_instance) - 0usize] ; ["Offset of field: _GConverterOutputStream::priv_"] [:: std :: mem :: offset_of ! (_GConverterOutputStream , priv_) - 40usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GConverterOutputStreamClass { pub parent_class : GFilterOutputStreamClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GConverterOutputStreamClass"] [:: std :: mem :: size_of :: < _GConverterOutputStreamClass > () - 360usize] ; ["Alignment of _GConverterOutputStreamClass"] [:: std :: mem :: align_of :: < _GConverterOutputStreamClass > () - 8usize] ; ["Offset of field: _GConverterOutputStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GConverterOutputStreamClass , parent_class) - 0usize] ; ["Offset of field: _GConverterOutputStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GConverterOutputStreamClass , _g_reserved1) - 320usize] ; ["Offset of field: _GConverterOutputStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GConverterOutputStreamClass , _g_reserved2) - 328usize] ; ["Offset of field: _GConverterOutputStreamClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GConverterOutputStreamClass , _g_reserved3) - 336usize] ; ["Offset of field: _GConverterOutputStreamClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GConverterOutputStreamClass , _g_reserved4) - 344usize] ; ["Offset of field: _GConverterOutputStreamClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GConverterOutputStreamClass , _g_reserved5) - 352usize] ; } ; unsafe extern "C" { pub fn g_converter_output_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_converter_output_stream_new (base_stream : * mut GOutputStream , converter : * mut GConverter) -> * mut GOutputStream ; } unsafe extern "C" { pub fn g_converter_output_stream_get_converter (converter_stream : * mut GConverterOutputStream) -> * mut GConverter ; } pub type useconds_t = __useconds_t ; pub type socklen_t = __socklen_t ; unsafe extern "C" { pub fn access (__name : * const :: std :: os :: raw :: c_char , __type : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn faccessat (__fd : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __type : :: std :: os :: raw :: c_int , __flag : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn lseek (__fd : :: std :: os :: raw :: c_int , __offset : __off_t , __whence : :: std :: os :: raw :: c_int) -> __off_t ; } unsafe extern "C" { pub fn close (__fd : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn closefrom (__lowfd : :: std :: os :: raw :: c_int) ; } unsafe extern "C" { pub fn read (__fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_void , __nbytes : usize) -> isize ; } unsafe extern "C" { pub fn write (__fd : :: std :: os :: raw :: c_int , __buf : * const :: std :: os :: raw :: c_void , __n : usize) -> isize ; } unsafe extern "C" { pub fn pread (__fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_void , __nbytes : usize , __offset : __off_t) -> isize ; } unsafe extern "C" { pub fn pwrite (__fd : :: std :: os :: raw :: c_int , __buf : * const :: std :: os :: raw :: c_void , __n : usize , __offset : __off_t) -> isize ; } unsafe extern "C" { pub fn pipe (__pipedes : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn alarm (__seconds : :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_uint ; } unsafe extern "C" { pub fn sleep (__seconds : :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_uint ; } unsafe extern "C" { pub fn ualarm (__value : __useconds_t , __interval : __useconds_t) -> __useconds_t ; } unsafe extern "C" { pub fn usleep (__useconds : __useconds_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pause () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn chown (__file : * const :: std :: os :: raw :: c_char , __owner : __uid_t , __group : __gid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn fchown (__fd : :: std :: os :: raw :: c_int , __owner : __uid_t , __group : __gid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn lchown (__file : * const :: std :: os :: raw :: c_char , __owner : __uid_t , __group : __gid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn fchownat (__fd : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __owner : __uid_t , __group : __gid_t , __flag : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn chdir (__path : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn fchdir (__fd : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn getcwd (__buf : * mut :: std :: os :: raw :: c_char , __size : usize) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn getwd (__buf : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn dup (__fd : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn dup2 (__fd : :: std :: os :: raw :: c_int , __fd2 : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub static mut __environ : * mut * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn execve (__path : * const :: std :: os :: raw :: c_char , __argv : * const * mut :: std :: os :: raw :: c_char , __envp : * const * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn fexecve (__fd : :: std :: os :: raw :: c_int , __argv : * const * mut :: std :: os :: raw :: c_char , __envp : * const * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn execv (__path : * const :: std :: os :: raw :: c_char , __argv : * const * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn execle (__path : * const :: std :: os :: raw :: c_char , __arg : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn execl (__path : * const :: std :: os :: raw :: c_char , __arg : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn execvp (__file : * const :: std :: os :: raw :: c_char , __argv : * const * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn execlp (__file : * const :: std :: os :: raw :: c_char , __arg : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn nice (__inc : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn _exit (__status : :: std :: os :: raw :: c_int) -> ! ; } pub const _PC_LINK_MAX : _bindgen_ty_21 = 0 ; pub const _PC_MAX_CANON : _bindgen_ty_21 = 1 ; pub const _PC_MAX_INPUT : _bindgen_ty_21 = 2 ; pub const _PC_NAME_MAX : _bindgen_ty_21 = 3 ; pub const _PC_PATH_MAX : _bindgen_ty_21 = 4 ; pub const _PC_PIPE_BUF : _bindgen_ty_21 = 5 ; pub const _PC_CHOWN_RESTRICTED : _bindgen_ty_21 = 6 ; pub const _PC_NO_TRUNC : _bindgen_ty_21 = 7 ; pub const _PC_VDISABLE : _bindgen_ty_21 = 8 ; pub const _PC_SYNC_IO : _bindgen_ty_21 = 9 ; pub const _PC_ASYNC_IO : _bindgen_ty_21 = 10 ; pub const _PC_PRIO_IO : _bindgen_ty_21 = 11 ; pub const _PC_SOCK_MAXBUF : _bindgen_ty_21 = 12 ; pub const _PC_FILESIZEBITS : _bindgen_ty_21 = 13 ; pub const _PC_REC_INCR_XFER_SIZE : _bindgen_ty_21 = 14 ; pub const _PC_REC_MAX_XFER_SIZE : _bindgen_ty_21 = 15 ; pub const _PC_REC_MIN_XFER_SIZE : _bindgen_ty_21 = 16 ; pub const _PC_REC_XFER_ALIGN : _bindgen_ty_21 = 17 ; pub const _PC_ALLOC_SIZE_MIN : _bindgen_ty_21 = 18 ; pub const _PC_SYMLINK_MAX : _bindgen_ty_21 = 19 ; pub const _PC_2_SYMLINKS : _bindgen_ty_21 = 20 ; pub type _bindgen_ty_21 = :: std :: os :: raw :: c_uint ; pub const _SC_ARG_MAX : _bindgen_ty_22 = 0 ; pub const _SC_CHILD_MAX : _bindgen_ty_22 = 1 ; pub const _SC_CLK_TCK : _bindgen_ty_22 = 2 ; pub const _SC_NGROUPS_MAX : _bindgen_ty_22 = 3 ; pub const _SC_OPEN_MAX : _bindgen_ty_22 = 4 ; pub const _SC_STREAM_MAX : _bindgen_ty_22 = 5 ; pub const _SC_TZNAME_MAX : _bindgen_ty_22 = 6 ; pub const _SC_JOB_CONTROL : _bindgen_ty_22 = 7 ; pub const _SC_SAVED_IDS : _bindgen_ty_22 = 8 ; pub const _SC_REALTIME_SIGNALS : _bindgen_ty_22 = 9 ; pub const _SC_PRIORITY_SCHEDULING : _bindgen_ty_22 = 10 ; pub const _SC_TIMERS : _bindgen_ty_22 = 11 ; pub const _SC_ASYNCHRONOUS_IO : _bindgen_ty_22 = 12 ; pub const _SC_PRIORITIZED_IO : _bindgen_ty_22 = 13 ; pub const _SC_SYNCHRONIZED_IO : _bindgen_ty_22 = 14 ; pub const _SC_FSYNC : _bindgen_ty_22 = 15 ; pub const _SC_MAPPED_FILES : _bindgen_ty_22 = 16 ; pub const _SC_MEMLOCK : _bindgen_ty_22 = 17 ; pub const _SC_MEMLOCK_RANGE : _bindgen_ty_22 = 18 ; pub const _SC_MEMORY_PROTECTION : _bindgen_ty_22 = 19 ; pub const _SC_MESSAGE_PASSING : _bindgen_ty_22 = 20 ; pub const _SC_SEMAPHORES : _bindgen_ty_22 = 21 ; pub const _SC_SHARED_MEMORY_OBJECTS : _bindgen_ty_22 = 22 ; pub const _SC_AIO_LISTIO_MAX : _bindgen_ty_22 = 23 ; pub const _SC_AIO_MAX : _bindgen_ty_22 = 24 ; pub const _SC_AIO_PRIO_DELTA_MAX : _bindgen_ty_22 = 25 ; pub const _SC_DELAYTIMER_MAX : _bindgen_ty_22 = 26 ; pub const _SC_MQ_OPEN_MAX : _bindgen_ty_22 = 27 ; pub const _SC_MQ_PRIO_MAX : _bindgen_ty_22 = 28 ; pub const _SC_VERSION : _bindgen_ty_22 = 29 ; pub const _SC_PAGESIZE : _bindgen_ty_22 = 30 ; pub const _SC_RTSIG_MAX : _bindgen_ty_22 = 31 ; pub const _SC_SEM_NSEMS_MAX : _bindgen_ty_22 = 32 ; pub const _SC_SEM_VALUE_MAX : _bindgen_ty_22 = 33 ; pub const _SC_SIGQUEUE_MAX : _bindgen_ty_22 = 34 ; pub const _SC_TIMER_MAX : _bindgen_ty_22 = 35 ; pub const _SC_BC_BASE_MAX : _bindgen_ty_22 = 36 ; pub const _SC_BC_DIM_MAX : _bindgen_ty_22 = 37 ; pub const _SC_BC_SCALE_MAX : _bindgen_ty_22 = 38 ; pub const _SC_BC_STRING_MAX : _bindgen_ty_22 = 39 ; pub const _SC_COLL_WEIGHTS_MAX : _bindgen_ty_22 = 40 ; pub const _SC_EQUIV_CLASS_MAX : _bindgen_ty_22 = 41 ; pub const _SC_EXPR_NEST_MAX : _bindgen_ty_22 = 42 ; pub const _SC_LINE_MAX : _bindgen_ty_22 = 43 ; pub const _SC_RE_DUP_MAX : _bindgen_ty_22 = 44 ; pub const _SC_CHARCLASS_NAME_MAX : _bindgen_ty_22 = 45 ; pub const _SC_2_VERSION : _bindgen_ty_22 = 46 ; pub const _SC_2_C_BIND : _bindgen_ty_22 = 47 ; pub const _SC_2_C_DEV : _bindgen_ty_22 = 48 ; pub const _SC_2_FORT_DEV : _bindgen_ty_22 = 49 ; pub const _SC_2_FORT_RUN : _bindgen_ty_22 = 50 ; pub const _SC_2_SW_DEV : _bindgen_ty_22 = 51 ; pub const _SC_2_LOCALEDEF : _bindgen_ty_22 = 52 ; pub const _SC_PII : _bindgen_ty_22 = 53 ; pub const _SC_PII_XTI : _bindgen_ty_22 = 54 ; pub const _SC_PII_SOCKET : _bindgen_ty_22 = 55 ; pub const _SC_PII_INTERNET : _bindgen_ty_22 = 56 ; pub const _SC_PII_OSI : _bindgen_ty_22 = 57 ; pub const _SC_POLL : _bindgen_ty_22 = 58 ; pub const _SC_SELECT : _bindgen_ty_22 = 59 ; pub const _SC_UIO_MAXIOV : _bindgen_ty_22 = 60 ; pub const _SC_IOV_MAX : _bindgen_ty_22 = 60 ; pub const _SC_PII_INTERNET_STREAM : _bindgen_ty_22 = 61 ; pub const _SC_PII_INTERNET_DGRAM : _bindgen_ty_22 = 62 ; pub const _SC_PII_OSI_COTS : _bindgen_ty_22 = 63 ; pub const _SC_PII_OSI_CLTS : _bindgen_ty_22 = 64 ; pub const _SC_PII_OSI_M : _bindgen_ty_22 = 65 ; pub const _SC_T_IOV_MAX : _bindgen_ty_22 = 66 ; pub const _SC_THREADS : _bindgen_ty_22 = 67 ; pub const _SC_THREAD_SAFE_FUNCTIONS : _bindgen_ty_22 = 68 ; pub const _SC_GETGR_R_SIZE_MAX : _bindgen_ty_22 = 69 ; pub const _SC_GETPW_R_SIZE_MAX : _bindgen_ty_22 = 70 ; pub const _SC_LOGIN_NAME_MAX : _bindgen_ty_22 = 71 ; pub const _SC_TTY_NAME_MAX : _bindgen_ty_22 = 72 ; pub const _SC_THREAD_DESTRUCTOR_ITERATIONS : _bindgen_ty_22 = 73 ; pub const _SC_THREAD_KEYS_MAX : _bindgen_ty_22 = 74 ; pub const _SC_THREAD_STACK_MIN : _bindgen_ty_22 = 75 ; pub const _SC_THREAD_THREADS_MAX : _bindgen_ty_22 = 76 ; pub const _SC_THREAD_ATTR_STACKADDR : _bindgen_ty_22 = 77 ; pub const _SC_THREAD_ATTR_STACKSIZE : _bindgen_ty_22 = 78 ; pub const _SC_THREAD_PRIORITY_SCHEDULING : _bindgen_ty_22 = 79 ; pub const _SC_THREAD_PRIO_INHERIT : _bindgen_ty_22 = 80 ; pub const _SC_THREAD_PRIO_PROTECT : _bindgen_ty_22 = 81 ; pub const _SC_THREAD_PROCESS_SHARED : _bindgen_ty_22 = 82 ; pub const _SC_NPROCESSORS_CONF : _bindgen_ty_22 = 83 ; pub const _SC_NPROCESSORS_ONLN : _bindgen_ty_22 = 84 ; pub const _SC_PHYS_PAGES : _bindgen_ty_22 = 85 ; pub const _SC_AVPHYS_PAGES : _bindgen_ty_22 = 86 ; pub const _SC_ATEXIT_MAX : _bindgen_ty_22 = 87 ; pub const _SC_PASS_MAX : _bindgen_ty_22 = 88 ; pub const _SC_XOPEN_VERSION : _bindgen_ty_22 = 89 ; pub const _SC_XOPEN_XCU_VERSION : _bindgen_ty_22 = 90 ; pub const _SC_XOPEN_UNIX : _bindgen_ty_22 = 91 ; pub const _SC_XOPEN_CRYPT : _bindgen_ty_22 = 92 ; pub const _SC_XOPEN_ENH_I18N : _bindgen_ty_22 = 93 ; pub const _SC_XOPEN_SHM : _bindgen_ty_22 = 94 ; pub const _SC_2_CHAR_TERM : _bindgen_ty_22 = 95 ; pub const _SC_2_C_VERSION : _bindgen_ty_22 = 96 ; pub const _SC_2_UPE : _bindgen_ty_22 = 97 ; pub const _SC_XOPEN_XPG2 : _bindgen_ty_22 = 98 ; pub const _SC_XOPEN_XPG3 : _bindgen_ty_22 = 99 ; pub const _SC_XOPEN_XPG4 : _bindgen_ty_22 = 100 ; pub const _SC_CHAR_BIT : _bindgen_ty_22 = 101 ; pub const _SC_CHAR_MAX : _bindgen_ty_22 = 102 ; pub const _SC_CHAR_MIN : _bindgen_ty_22 = 103 ; pub const _SC_INT_MAX : _bindgen_ty_22 = 104 ; pub const _SC_INT_MIN : _bindgen_ty_22 = 105 ; pub const _SC_LONG_BIT : _bindgen_ty_22 = 106 ; pub const _SC_WORD_BIT : _bindgen_ty_22 = 107 ; pub const _SC_MB_LEN_MAX : _bindgen_ty_22 = 108 ; pub const _SC_NZERO : _bindgen_ty_22 = 109 ; pub const _SC_SSIZE_MAX : _bindgen_ty_22 = 110 ; pub const _SC_SCHAR_MAX : _bindgen_ty_22 = 111 ; pub const _SC_SCHAR_MIN : _bindgen_ty_22 = 112 ; pub const _SC_SHRT_MAX : _bindgen_ty_22 = 113 ; pub const _SC_SHRT_MIN : _bindgen_ty_22 = 114 ; pub const _SC_UCHAR_MAX : _bindgen_ty_22 = 115 ; pub const _SC_UINT_MAX : _bindgen_ty_22 = 116 ; pub const _SC_ULONG_MAX : _bindgen_ty_22 = 117 ; pub const _SC_USHRT_MAX : _bindgen_ty_22 = 118 ; pub const _SC_NL_ARGMAX : _bindgen_ty_22 = 119 ; pub const _SC_NL_LANGMAX : _bindgen_ty_22 = 120 ; pub const _SC_NL_MSGMAX : _bindgen_ty_22 = 121 ; pub const _SC_NL_NMAX : _bindgen_ty_22 = 122 ; pub const _SC_NL_SETMAX : _bindgen_ty_22 = 123 ; pub const _SC_NL_TEXTMAX : _bindgen_ty_22 = 124 ; pub const _SC_XBS5_ILP32_OFF32 : _bindgen_ty_22 = 125 ; pub const _SC_XBS5_ILP32_OFFBIG : _bindgen_ty_22 = 126 ; pub const _SC_XBS5_LP64_OFF64 : _bindgen_ty_22 = 127 ; pub const _SC_XBS5_LPBIG_OFFBIG : _bindgen_ty_22 = 128 ; pub const _SC_XOPEN_LEGACY : _bindgen_ty_22 = 129 ; pub const _SC_XOPEN_REALTIME : _bindgen_ty_22 = 130 ; pub const _SC_XOPEN_REALTIME_THREADS : _bindgen_ty_22 = 131 ; pub const _SC_ADVISORY_INFO : _bindgen_ty_22 = 132 ; pub const _SC_BARRIERS : _bindgen_ty_22 = 133 ; pub const _SC_BASE : _bindgen_ty_22 = 134 ; pub const _SC_C_LANG_SUPPORT : _bindgen_ty_22 = 135 ; pub const _SC_C_LANG_SUPPORT_R : _bindgen_ty_22 = 136 ; pub const _SC_CLOCK_SELECTION : _bindgen_ty_22 = 137 ; pub const _SC_CPUTIME : _bindgen_ty_22 = 138 ; pub const _SC_THREAD_CPUTIME : _bindgen_ty_22 = 139 ; pub const _SC_DEVICE_IO : _bindgen_ty_22 = 140 ; pub const _SC_DEVICE_SPECIFIC : _bindgen_ty_22 = 141 ; pub const _SC_DEVICE_SPECIFIC_R : _bindgen_ty_22 = 142 ; pub const _SC_FD_MGMT : _bindgen_ty_22 = 143 ; pub const _SC_FIFO : _bindgen_ty_22 = 144 ; pub const _SC_PIPE : _bindgen_ty_22 = 145 ; pub const _SC_FILE_ATTRIBUTES : _bindgen_ty_22 = 146 ; pub const _SC_FILE_LOCKING : _bindgen_ty_22 = 147 ; pub const _SC_FILE_SYSTEM : _bindgen_ty_22 = 148 ; pub const _SC_MONOTONIC_CLOCK : _bindgen_ty_22 = 149 ; pub const _SC_MULTI_PROCESS : _bindgen_ty_22 = 150 ; pub const _SC_SINGLE_PROCESS : _bindgen_ty_22 = 151 ; pub const _SC_NETWORKING : _bindgen_ty_22 = 152 ; pub const _SC_READER_WRITER_LOCKS : _bindgen_ty_22 = 153 ; pub const _SC_SPIN_LOCKS : _bindgen_ty_22 = 154 ; pub const _SC_REGEXP : _bindgen_ty_22 = 155 ; pub const _SC_REGEX_VERSION : _bindgen_ty_22 = 156 ; pub const _SC_SHELL : _bindgen_ty_22 = 157 ; pub const _SC_SIGNALS : _bindgen_ty_22 = 158 ; pub const _SC_SPAWN : _bindgen_ty_22 = 159 ; pub const _SC_SPORADIC_SERVER : _bindgen_ty_22 = 160 ; pub const _SC_THREAD_SPORADIC_SERVER : _bindgen_ty_22 = 161 ; pub const _SC_SYSTEM_DATABASE : _bindgen_ty_22 = 162 ; pub const _SC_SYSTEM_DATABASE_R : _bindgen_ty_22 = 163 ; pub const _SC_TIMEOUTS : _bindgen_ty_22 = 164 ; pub const _SC_TYPED_MEMORY_OBJECTS : _bindgen_ty_22 = 165 ; pub const _SC_USER_GROUPS : _bindgen_ty_22 = 166 ; pub const _SC_USER_GROUPS_R : _bindgen_ty_22 = 167 ; pub const _SC_2_PBS : _bindgen_ty_22 = 168 ; pub const _SC_2_PBS_ACCOUNTING : _bindgen_ty_22 = 169 ; pub const _SC_2_PBS_LOCATE : _bindgen_ty_22 = 170 ; pub const _SC_2_PBS_MESSAGE : _bindgen_ty_22 = 171 ; pub const _SC_2_PBS_TRACK : _bindgen_ty_22 = 172 ; pub const _SC_SYMLOOP_MAX : _bindgen_ty_22 = 173 ; pub const _SC_STREAMS : _bindgen_ty_22 = 174 ; pub const _SC_2_PBS_CHECKPOINT : _bindgen_ty_22 = 175 ; pub const _SC_V6_ILP32_OFF32 : _bindgen_ty_22 = 176 ; pub const _SC_V6_ILP32_OFFBIG : _bindgen_ty_22 = 177 ; pub const _SC_V6_LP64_OFF64 : _bindgen_ty_22 = 178 ; pub const _SC_V6_LPBIG_OFFBIG : _bindgen_ty_22 = 179 ; pub const _SC_HOST_NAME_MAX : _bindgen_ty_22 = 180 ; pub const _SC_TRACE : _bindgen_ty_22 = 181 ; pub const _SC_TRACE_EVENT_FILTER : _bindgen_ty_22 = 182 ; pub const _SC_TRACE_INHERIT : _bindgen_ty_22 = 183 ; pub const _SC_TRACE_LOG : _bindgen_ty_22 = 184 ; pub const _SC_LEVEL1_ICACHE_SIZE : _bindgen_ty_22 = 185 ; pub const _SC_LEVEL1_ICACHE_ASSOC : _bindgen_ty_22 = 186 ; pub const _SC_LEVEL1_ICACHE_LINESIZE : _bindgen_ty_22 = 187 ; pub const _SC_LEVEL1_DCACHE_SIZE : _bindgen_ty_22 = 188 ; pub const _SC_LEVEL1_DCACHE_ASSOC : _bindgen_ty_22 = 189 ; pub const _SC_LEVEL1_DCACHE_LINESIZE : _bindgen_ty_22 = 190 ; pub const _SC_LEVEL2_CACHE_SIZE : _bindgen_ty_22 = 191 ; pub const _SC_LEVEL2_CACHE_ASSOC : _bindgen_ty_22 = 192 ; pub const _SC_LEVEL2_CACHE_LINESIZE : _bindgen_ty_22 = 193 ; pub const _SC_LEVEL3_CACHE_SIZE : _bindgen_ty_22 = 194 ; pub const _SC_LEVEL3_CACHE_ASSOC : _bindgen_ty_22 = 195 ; pub const _SC_LEVEL3_CACHE_LINESIZE : _bindgen_ty_22 = 196 ; pub const _SC_LEVEL4_CACHE_SIZE : _bindgen_ty_22 = 197 ; pub const _SC_LEVEL4_CACHE_ASSOC : _bindgen_ty_22 = 198 ; pub const _SC_LEVEL4_CACHE_LINESIZE : _bindgen_ty_22 = 199 ; pub const _SC_IPV6 : _bindgen_ty_22 = 235 ; pub const _SC_RAW_SOCKETS : _bindgen_ty_22 = 236 ; pub const _SC_V7_ILP32_OFF32 : _bindgen_ty_22 = 237 ; pub const _SC_V7_ILP32_OFFBIG : _bindgen_ty_22 = 238 ; pub const _SC_V7_LP64_OFF64 : _bindgen_ty_22 = 239 ; pub const _SC_V7_LPBIG_OFFBIG : _bindgen_ty_22 = 240 ; pub const _SC_SS_REPL_MAX : _bindgen_ty_22 = 241 ; pub const _SC_TRACE_EVENT_NAME_MAX : _bindgen_ty_22 = 242 ; pub const _SC_TRACE_NAME_MAX : _bindgen_ty_22 = 243 ; pub const _SC_TRACE_SYS_MAX : _bindgen_ty_22 = 244 ; pub const _SC_TRACE_USER_EVENT_MAX : _bindgen_ty_22 = 245 ; pub const _SC_XOPEN_STREAMS : _bindgen_ty_22 = 246 ; pub const _SC_THREAD_ROBUST_PRIO_INHERIT : _bindgen_ty_22 = 247 ; pub const _SC_THREAD_ROBUST_PRIO_PROTECT : _bindgen_ty_22 = 248 ; pub const _SC_MINSIGSTKSZ : _bindgen_ty_22 = 249 ; pub const _SC_SIGSTKSZ : _bindgen_ty_22 = 250 ; pub type _bindgen_ty_22 = :: std :: os :: raw :: c_uint ; pub const _CS_PATH : _bindgen_ty_23 = 0 ; pub const _CS_V6_WIDTH_RESTRICTED_ENVS : _bindgen_ty_23 = 1 ; pub const _CS_GNU_LIBC_VERSION : _bindgen_ty_23 = 2 ; pub const _CS_GNU_LIBPTHREAD_VERSION : _bindgen_ty_23 = 3 ; pub const _CS_V5_WIDTH_RESTRICTED_ENVS : _bindgen_ty_23 = 4 ; pub const _CS_V7_WIDTH_RESTRICTED_ENVS : _bindgen_ty_23 = 5 ; pub const _CS_LFS_CFLAGS : _bindgen_ty_23 = 1000 ; pub const _CS_LFS_LDFLAGS : _bindgen_ty_23 = 1001 ; pub const _CS_LFS_LIBS : _bindgen_ty_23 = 1002 ; pub const _CS_LFS_LINTFLAGS : _bindgen_ty_23 = 1003 ; pub const _CS_LFS64_CFLAGS : _bindgen_ty_23 = 1004 ; pub const _CS_LFS64_LDFLAGS : _bindgen_ty_23 = 1005 ; pub const _CS_LFS64_LIBS : _bindgen_ty_23 = 1006 ; pub const _CS_LFS64_LINTFLAGS : _bindgen_ty_23 = 1007 ; pub const _CS_XBS5_ILP32_OFF32_CFLAGS : _bindgen_ty_23 = 1100 ; pub const _CS_XBS5_ILP32_OFF32_LDFLAGS : _bindgen_ty_23 = 1101 ; pub const _CS_XBS5_ILP32_OFF32_LIBS : _bindgen_ty_23 = 1102 ; pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS : _bindgen_ty_23 = 1103 ; pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS : _bindgen_ty_23 = 1104 ; pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_23 = 1105 ; pub const _CS_XBS5_ILP32_OFFBIG_LIBS : _bindgen_ty_23 = 1106 ; pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_23 = 1107 ; pub const _CS_XBS5_LP64_OFF64_CFLAGS : _bindgen_ty_23 = 1108 ; pub const _CS_XBS5_LP64_OFF64_LDFLAGS : _bindgen_ty_23 = 1109 ; pub const _CS_XBS5_LP64_OFF64_LIBS : _bindgen_ty_23 = 1110 ; pub const _CS_XBS5_LP64_OFF64_LINTFLAGS : _bindgen_ty_23 = 1111 ; pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_23 = 1112 ; pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_23 = 1113 ; pub const _CS_XBS5_LPBIG_OFFBIG_LIBS : _bindgen_ty_23 = 1114 ; pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_23 = 1115 ; pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS : _bindgen_ty_23 = 1116 ; pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS : _bindgen_ty_23 = 1117 ; pub const _CS_POSIX_V6_ILP32_OFF32_LIBS : _bindgen_ty_23 = 1118 ; pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS : _bindgen_ty_23 = 1119 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS : _bindgen_ty_23 = 1120 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_23 = 1121 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS : _bindgen_ty_23 = 1122 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_23 = 1123 ; pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS : _bindgen_ty_23 = 1124 ; pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS : _bindgen_ty_23 = 1125 ; pub const _CS_POSIX_V6_LP64_OFF64_LIBS : _bindgen_ty_23 = 1126 ; pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS : _bindgen_ty_23 = 1127 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_23 = 1128 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_23 = 1129 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS : _bindgen_ty_23 = 1130 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_23 = 1131 ; pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS : _bindgen_ty_23 = 1132 ; pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS : _bindgen_ty_23 = 1133 ; pub const _CS_POSIX_V7_ILP32_OFF32_LIBS : _bindgen_ty_23 = 1134 ; pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS : _bindgen_ty_23 = 1135 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS : _bindgen_ty_23 = 1136 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_23 = 1137 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS : _bindgen_ty_23 = 1138 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_23 = 1139 ; pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS : _bindgen_ty_23 = 1140 ; pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS : _bindgen_ty_23 = 1141 ; pub const _CS_POSIX_V7_LP64_OFF64_LIBS : _bindgen_ty_23 = 1142 ; pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS : _bindgen_ty_23 = 1143 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_23 = 1144 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_23 = 1145 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS : _bindgen_ty_23 = 1146 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_23 = 1147 ; pub const _CS_V6_ENV : _bindgen_ty_23 = 1148 ; pub const _CS_V7_ENV : _bindgen_ty_23 = 1149 ; pub type _bindgen_ty_23 = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn pathconf (__path : * const :: std :: os :: raw :: c_char , __name : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn fpathconf (__fd : :: std :: os :: raw :: c_int , __name : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn sysconf (__name : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn confstr (__name : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize) -> usize ; } unsafe extern "C" { pub fn getpid () -> __pid_t ; } unsafe extern "C" { pub fn getppid () -> __pid_t ; } unsafe extern "C" { pub fn getpgrp () -> __pid_t ; } unsafe extern "C" { pub fn __getpgid (__pid : __pid_t) -> __pid_t ; } unsafe extern "C" { pub fn getpgid (__pid : __pid_t) -> __pid_t ; } unsafe extern "C" { pub fn setpgid (__pid : __pid_t , __pgid : __pid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn setpgrp () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn setsid () -> __pid_t ; } unsafe extern "C" { pub fn getsid (__pid : __pid_t) -> __pid_t ; } unsafe extern "C" { pub fn getuid () -> __uid_t ; } unsafe extern "C" { pub fn geteuid () -> __uid_t ; } unsafe extern "C" { pub fn getgid () -> __gid_t ; } unsafe extern "C" { pub fn getegid () -> __gid_t ; } unsafe extern "C" { pub fn getgroups (__size : :: std :: os :: raw :: c_int , __list : * mut __gid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn setuid (__uid : __uid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn setreuid (__ruid : __uid_t , __euid : __uid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn seteuid (__uid : __uid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn setgid (__gid : __gid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn setregid (__rgid : __gid_t , __egid : __gid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn setegid (__gid : __gid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn fork () -> __pid_t ; } unsafe extern "C" { pub fn vfork () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ttyname (__fd : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ttyname_r (__fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn isatty (__fd : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ttyslot () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn link (__from : * const :: std :: os :: raw :: c_char , __to : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn linkat (__fromfd : :: std :: os :: raw :: c_int , __from : * const :: std :: os :: raw :: c_char , __tofd : :: std :: os :: raw :: c_int , __to : * const :: std :: os :: raw :: c_char , __flags : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn symlink (__from : * const :: std :: os :: raw :: c_char , __to : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn readlink (__path : * const :: std :: os :: raw :: c_char , __buf : * mut :: std :: os :: raw :: c_char , __len : usize) -> isize ; } unsafe extern "C" { pub fn symlinkat (__from : * const :: std :: os :: raw :: c_char , __tofd : :: std :: os :: raw :: c_int , __to : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn readlinkat (__fd : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __buf : * mut :: std :: os :: raw :: c_char , __len : usize) -> isize ; } unsafe extern "C" { pub fn unlink (__name : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn unlinkat (__fd : :: std :: os :: raw :: c_int , __name : * const :: std :: os :: raw :: c_char , __flag : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn rmdir (__path : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn tcgetpgrp (__fd : :: std :: os :: raw :: c_int) -> __pid_t ; } unsafe extern "C" { pub fn tcsetpgrp (__fd : :: std :: os :: raw :: c_int , __pgrp_id : __pid_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn getlogin () -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn getlogin_r (__name : * mut :: std :: os :: raw :: c_char , __name_len : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn setlogin (__name : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub static mut optarg : * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub static mut optind : :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub static mut opterr : :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub static mut optopt : :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn getopt (___argc : :: std :: os :: raw :: c_int , ___argv : * const * mut :: std :: os :: raw :: c_char , __shortopts : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn gethostname (__name : * mut :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sethostname (__name : * const :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sethostid (__id : :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn getdomainname (__name : * mut :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn setdomainname (__name : * const :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn vhangup () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn revoke (__file : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn profil (__sample_buffer : * mut :: std :: os :: raw :: c_ushort , __size : usize , __offset : usize , __scale : :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn acct (__name : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn getusershell () -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn endusershell () ; } unsafe extern "C" { pub fn setusershell () ; } unsafe extern "C" { pub fn daemon (__nochdir : :: std :: os :: raw :: c_int , __noclose : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn chroot (__path : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn getpass (__prompt : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn fsync (__fd : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn gethostid () -> :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn sync () ; } unsafe extern "C" { pub fn getpagesize () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn getdtablesize () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn truncate (__file : * const :: std :: os :: raw :: c_char , __length : __off_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ftruncate (__fd : :: std :: os :: raw :: c_int , __length : __off_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn brk (__addr : * mut :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn sbrk (__delta : isize) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn syscall (__sysno : :: std :: os :: raw :: c_long , ...) -> :: std :: os :: raw :: c_long ; } unsafe extern "C" { pub fn lockf (__fd : :: std :: os :: raw :: c_int , __cmd : :: std :: os :: raw :: c_int , __len : __off_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn fdatasync (__fildes : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn crypt (__key : * const :: std :: os :: raw :: c_char , __salt : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn getentropy (__buffer : * mut :: std :: os :: raw :: c_void , __length : usize) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GCredentialsClass { _unused : [u8 ; 0] , } pub type GCredentialsClass = _GCredentialsClass ; unsafe extern "C" { pub fn g_credentials_get_type () -> GType ; } unsafe extern "C" { pub fn g_credentials_new () -> * mut GCredentials ; } unsafe extern "C" { pub fn g_credentials_to_string (credentials : * mut GCredentials) -> * mut gchar ; } unsafe extern "C" { pub fn g_credentials_get_native (credentials : * mut GCredentials , native_type : GCredentialsType) -> gpointer ; } unsafe extern "C" { pub fn g_credentials_set_native (credentials : * mut GCredentials , native_type : GCredentialsType , native : gpointer) ; } unsafe extern "C" { pub fn g_credentials_is_same_user (credentials : * mut GCredentials , other_credentials : * mut GCredentials , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_credentials_get_unix_pid (credentials : * mut GCredentials , error : * mut * mut GError) -> pid_t ; } unsafe extern "C" { pub fn g_credentials_get_unix_user (credentials : * mut GCredentials , error : * mut * mut GError) -> uid_t ; } unsafe extern "C" { pub fn g_credentials_set_unix_user (credentials : * mut GCredentials , uid : uid_t , error : * mut * mut GError) -> gboolean ; } pub type GDatagramBasedInterface = _GDatagramBasedInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDatagramBasedInterface { pub g_iface : GTypeInterface , pub receive_messages : :: std :: option :: Option < unsafe extern "C" fn (datagram_based : * mut GDatagramBased , messages : * mut GInputMessage , num_messages : guint , flags : gint , timeout : gint64 , cancellable : * mut GCancellable , error : * mut * mut GError) -> gint > , pub send_messages : :: std :: option :: Option < unsafe extern "C" fn (datagram_based : * mut GDatagramBased , messages : * mut GOutputMessage , num_messages : guint , flags : gint , timeout : gint64 , cancellable : * mut GCancellable , error : * mut * mut GError) -> gint > , pub create_source : :: std :: option :: Option < unsafe extern "C" fn (datagram_based : * mut GDatagramBased , condition : GIOCondition , cancellable : * mut GCancellable) -> * mut GSource > , pub condition_check : :: std :: option :: Option < unsafe extern "C" fn (datagram_based : * mut GDatagramBased , condition : GIOCondition) -> GIOCondition > , pub condition_wait : :: std :: option :: Option < unsafe extern "C" fn (datagram_based : * mut GDatagramBased , condition : GIOCondition , timeout : gint64 , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDatagramBasedInterface"] [:: std :: mem :: size_of :: < _GDatagramBasedInterface > () - 56usize] ; ["Alignment of _GDatagramBasedInterface"] [:: std :: mem :: align_of :: < _GDatagramBasedInterface > () - 8usize] ; ["Offset of field: _GDatagramBasedInterface::g_iface"] [:: std :: mem :: offset_of ! (_GDatagramBasedInterface , g_iface) - 0usize] ; ["Offset of field: _GDatagramBasedInterface::receive_messages"] [:: std :: mem :: offset_of ! (_GDatagramBasedInterface , receive_messages) - 16usize] ; ["Offset of field: _GDatagramBasedInterface::send_messages"] [:: std :: mem :: offset_of ! (_GDatagramBasedInterface , send_messages) - 24usize] ; ["Offset of field: _GDatagramBasedInterface::create_source"] [:: std :: mem :: offset_of ! (_GDatagramBasedInterface , create_source) - 32usize] ; ["Offset of field: _GDatagramBasedInterface::condition_check"] [:: std :: mem :: offset_of ! (_GDatagramBasedInterface , condition_check) - 40usize] ; ["Offset of field: _GDatagramBasedInterface::condition_wait"] [:: std :: mem :: offset_of ! (_GDatagramBasedInterface , condition_wait) - 48usize] ; } ; unsafe extern "C" { pub fn g_datagram_based_get_type () -> GType ; } unsafe extern "C" { pub fn g_datagram_based_receive_messages (datagram_based : * mut GDatagramBased , messages : * mut GInputMessage , num_messages : guint , flags : gint , timeout : gint64 , cancellable : * mut GCancellable , error : * mut * mut GError) -> gint ; } unsafe extern "C" { pub fn g_datagram_based_send_messages (datagram_based : * mut GDatagramBased , messages : * mut GOutputMessage , num_messages : guint , flags : gint , timeout : gint64 , cancellable : * mut GCancellable , error : * mut * mut GError) -> gint ; } unsafe extern "C" { pub fn g_datagram_based_create_source (datagram_based : * mut GDatagramBased , condition : GIOCondition , cancellable : * mut GCancellable) -> * mut GSource ; } unsafe extern "C" { pub fn g_datagram_based_condition_check (datagram_based : * mut GDatagramBased , condition : GIOCondition) -> GIOCondition ; } unsafe extern "C" { pub fn g_datagram_based_condition_wait (datagram_based : * mut GDatagramBased , condition : GIOCondition , timeout : gint64 , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } pub type GDataInputStreamClass = _GDataInputStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDataInputStreamPrivate { _unused : [u8 ; 0] , } pub type GDataInputStreamPrivate = _GDataInputStreamPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDataInputStream { pub parent_instance : GBufferedInputStream , pub priv_ : * mut GDataInputStreamPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDataInputStream"] [:: std :: mem :: size_of :: < _GDataInputStream > () - 56usize] ; ["Alignment of _GDataInputStream"] [:: std :: mem :: align_of :: < _GDataInputStream > () - 8usize] ; ["Offset of field: _GDataInputStream::parent_instance"] [:: std :: mem :: offset_of ! (_GDataInputStream , parent_instance) - 0usize] ; ["Offset of field: _GDataInputStream::priv_"] [:: std :: mem :: offset_of ! (_GDataInputStream , priv_) - 48usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDataInputStreamClass { pub parent_class : GBufferedInputStreamClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDataInputStreamClass"] [:: std :: mem :: size_of :: < _GDataInputStreamClass > () - 376usize] ; ["Alignment of _GDataInputStreamClass"] [:: std :: mem :: align_of :: < _GDataInputStreamClass > () - 8usize] ; ["Offset of field: _GDataInputStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GDataInputStreamClass , parent_class) - 0usize] ; ["Offset of field: _GDataInputStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GDataInputStreamClass , _g_reserved1) - 336usize] ; ["Offset of field: _GDataInputStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GDataInputStreamClass , _g_reserved2) - 344usize] ; ["Offset of field: _GDataInputStreamClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GDataInputStreamClass , _g_reserved3) - 352usize] ; ["Offset of field: _GDataInputStreamClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GDataInputStreamClass , _g_reserved4) - 360usize] ; ["Offset of field: _GDataInputStreamClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GDataInputStreamClass , _g_reserved5) - 368usize] ; } ; unsafe extern "C" { pub fn g_data_input_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_data_input_stream_new (base_stream : * mut GInputStream) -> * mut GDataInputStream ; } unsafe extern "C" { pub fn g_data_input_stream_set_byte_order (stream : * mut GDataInputStream , order : GDataStreamByteOrder) ; } unsafe extern "C" { pub fn g_data_input_stream_get_byte_order (stream : * mut GDataInputStream) -> GDataStreamByteOrder ; } unsafe extern "C" { pub fn g_data_input_stream_set_newline_type (stream : * mut GDataInputStream , type_ : GDataStreamNewlineType) ; } unsafe extern "C" { pub fn g_data_input_stream_get_newline_type (stream : * mut GDataInputStream) -> GDataStreamNewlineType ; } unsafe extern "C" { pub fn g_data_input_stream_read_byte (stream : * mut GDataInputStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> guchar ; } unsafe extern "C" { pub fn g_data_input_stream_read_int16 (stream : * mut GDataInputStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> gint16 ; } unsafe extern "C" { pub fn g_data_input_stream_read_uint16 (stream : * mut GDataInputStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> guint16 ; } unsafe extern "C" { pub fn g_data_input_stream_read_int32 (stream : * mut GDataInputStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> gint32 ; } unsafe extern "C" { pub fn g_data_input_stream_read_uint32 (stream : * mut GDataInputStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> guint32 ; } unsafe extern "C" { pub fn g_data_input_stream_read_int64 (stream : * mut GDataInputStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> gint64 ; } unsafe extern "C" { pub fn g_data_input_stream_read_uint64 (stream : * mut GDataInputStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> guint64 ; } unsafe extern "C" { pub fn g_data_input_stream_read_line (stream : * mut GDataInputStream , length : * mut gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_data_input_stream_read_line_utf8 (stream : * mut GDataInputStream , length : * mut gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_data_input_stream_read_line_async (stream : * mut GDataInputStream , io_priority : gint , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_data_input_stream_read_line_finish (stream : * mut GDataInputStream , result : * mut GAsyncResult , length : * mut gsize , error : * mut * mut GError) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_data_input_stream_read_line_finish_utf8 (stream : * mut GDataInputStream , result : * mut GAsyncResult , length : * mut gsize , error : * mut * mut GError) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_data_input_stream_read_until (stream : * mut GDataInputStream , stop_chars : * const gchar , length : * mut gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_data_input_stream_read_until_async (stream : * mut GDataInputStream , stop_chars : * const gchar , io_priority : gint , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_data_input_stream_read_until_finish (stream : * mut GDataInputStream , result : * mut GAsyncResult , length : * mut gsize , error : * mut * mut GError) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_data_input_stream_read_upto (stream : * mut GDataInputStream , stop_chars : * const gchar , stop_chars_len : gssize , length : * mut gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_data_input_stream_read_upto_async (stream : * mut GDataInputStream , stop_chars : * const gchar , stop_chars_len : gssize , io_priority : gint , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_data_input_stream_read_upto_finish (stream : * mut GDataInputStream , result : * mut GAsyncResult , length : * mut gsize , error : * mut * mut GError) -> * mut :: std :: os :: raw :: c_char ; } pub type GDataOutputStream = _GDataOutputStream ; pub type GDataOutputStreamClass = _GDataOutputStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDataOutputStreamPrivate { _unused : [u8 ; 0] , } pub type GDataOutputStreamPrivate = _GDataOutputStreamPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDataOutputStream { pub parent_instance : GFilterOutputStream , pub priv_ : * mut GDataOutputStreamPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDataOutputStream"] [:: std :: mem :: size_of :: < _GDataOutputStream > () - 48usize] ; ["Alignment of _GDataOutputStream"] [:: std :: mem :: align_of :: < _GDataOutputStream > () - 8usize] ; ["Offset of field: _GDataOutputStream::parent_instance"] [:: std :: mem :: offset_of ! (_GDataOutputStream , parent_instance) - 0usize] ; ["Offset of field: _GDataOutputStream::priv_"] [:: std :: mem :: offset_of ! (_GDataOutputStream , priv_) - 40usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDataOutputStreamClass { pub parent_class : GFilterOutputStreamClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDataOutputStreamClass"] [:: std :: mem :: size_of :: < _GDataOutputStreamClass > () - 360usize] ; ["Alignment of _GDataOutputStreamClass"] [:: std :: mem :: align_of :: < _GDataOutputStreamClass > () - 8usize] ; ["Offset of field: _GDataOutputStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GDataOutputStreamClass , parent_class) - 0usize] ; ["Offset of field: _GDataOutputStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GDataOutputStreamClass , _g_reserved1) - 320usize] ; ["Offset of field: _GDataOutputStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GDataOutputStreamClass , _g_reserved2) - 328usize] ; ["Offset of field: _GDataOutputStreamClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GDataOutputStreamClass , _g_reserved3) - 336usize] ; ["Offset of field: _GDataOutputStreamClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GDataOutputStreamClass , _g_reserved4) - 344usize] ; ["Offset of field: _GDataOutputStreamClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GDataOutputStreamClass , _g_reserved5) - 352usize] ; } ; unsafe extern "C" { pub fn g_data_output_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_data_output_stream_new (base_stream : * mut GOutputStream) -> * mut GDataOutputStream ; } unsafe extern "C" { pub fn g_data_output_stream_set_byte_order (stream : * mut GDataOutputStream , order : GDataStreamByteOrder) ; } unsafe extern "C" { pub fn g_data_output_stream_get_byte_order (stream : * mut GDataOutputStream) -> GDataStreamByteOrder ; } unsafe extern "C" { pub fn g_data_output_stream_put_byte (stream : * mut GDataOutputStream , data : guchar , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_data_output_stream_put_int16 (stream : * mut GDataOutputStream , data : gint16 , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_data_output_stream_put_uint16 (stream : * mut GDataOutputStream , data : guint16 , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_data_output_stream_put_int32 (stream : * mut GDataOutputStream , data : gint32 , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_data_output_stream_put_uint32 (stream : * mut GDataOutputStream , data : guint32 , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_data_output_stream_put_int64 (stream : * mut GDataOutputStream , data : gint64 , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_data_output_stream_put_uint64 (stream : * mut GDataOutputStream , data : guint64 , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_data_output_stream_put_string (stream : * mut GDataOutputStream , str_ : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_action_group_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_action_group_get (connection : * mut GDBusConnection , bus_name : * const gchar , object_path : * const gchar) -> * mut GDBusActionGroup ; } unsafe extern "C" { pub fn g_dbus_address_escape_value (string : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_dbus_is_address (string : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_is_supported_address (string : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_address_get_stream (address : * const gchar , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dbus_address_get_stream_finish (res : * mut GAsyncResult , out_guid : * mut * mut gchar , error : * mut * mut GError) -> * mut GIOStream ; } unsafe extern "C" { pub fn g_dbus_address_get_stream_sync (address : * const gchar , out_guid : * mut * mut gchar , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GIOStream ; } unsafe extern "C" { pub fn g_dbus_address_get_for_bus_sync (bus_type : GBusType , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_dbus_auth_observer_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_auth_observer_new () -> * mut GDBusAuthObserver ; } unsafe extern "C" { pub fn g_dbus_auth_observer_authorize_authenticated_peer (observer : * mut GDBusAuthObserver , stream : * mut GIOStream , credentials : * mut GCredentials) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_auth_observer_allow_mechanism (observer : * mut GDBusAuthObserver , mechanism : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_connection_get_type () -> GType ; } unsafe extern "C" { pub fn g_bus_get (bus_type : GBusType , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_bus_get_finish (res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GDBusConnection ; } unsafe extern "C" { pub fn g_bus_get_sync (bus_type : GBusType , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GDBusConnection ; } unsafe extern "C" { pub fn g_dbus_connection_new (stream : * mut GIOStream , guid : * const gchar , flags : GDBusConnectionFlags , observer : * mut GDBusAuthObserver , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dbus_connection_new_finish (res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GDBusConnection ; } unsafe extern "C" { pub fn g_dbus_connection_new_sync (stream : * mut GIOStream , guid : * const gchar , flags : GDBusConnectionFlags , observer : * mut GDBusAuthObserver , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GDBusConnection ; } unsafe extern "C" { pub fn g_dbus_connection_new_for_address (address : * const gchar , flags : GDBusConnectionFlags , observer : * mut GDBusAuthObserver , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dbus_connection_new_for_address_finish (res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GDBusConnection ; } unsafe extern "C" { pub fn g_dbus_connection_new_for_address_sync (address : * const gchar , flags : GDBusConnectionFlags , observer : * mut GDBusAuthObserver , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GDBusConnection ; } unsafe extern "C" { pub fn g_dbus_connection_start_message_processing (connection : * mut GDBusConnection) ; } unsafe extern "C" { pub fn g_dbus_connection_is_closed (connection : * mut GDBusConnection) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_connection_get_stream (connection : * mut GDBusConnection) -> * mut GIOStream ; } unsafe extern "C" { pub fn g_dbus_connection_get_guid (connection : * mut GDBusConnection) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_connection_get_unique_name (connection : * mut GDBusConnection) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_connection_get_peer_credentials (connection : * mut GDBusConnection) -> * mut GCredentials ; } unsafe extern "C" { pub fn g_dbus_connection_get_last_serial (connection : * mut GDBusConnection) -> guint32 ; } unsafe extern "C" { pub fn g_dbus_connection_get_exit_on_close (connection : * mut GDBusConnection) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_connection_set_exit_on_close (connection : * mut GDBusConnection , exit_on_close : gboolean) ; } unsafe extern "C" { pub fn g_dbus_connection_get_capabilities (connection : * mut GDBusConnection) -> GDBusCapabilityFlags ; } unsafe extern "C" { pub fn g_dbus_connection_get_flags (connection : * mut GDBusConnection) -> GDBusConnectionFlags ; } unsafe extern "C" { pub fn g_dbus_connection_close (connection : * mut GDBusConnection , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dbus_connection_close_finish (connection : * mut GDBusConnection , res : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_connection_close_sync (connection : * mut GDBusConnection , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_connection_flush (connection : * mut GDBusConnection , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dbus_connection_flush_finish (connection : * mut GDBusConnection , res : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_connection_flush_sync (connection : * mut GDBusConnection , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_connection_send_message (connection : * mut GDBusConnection , message : * mut GDBusMessage , flags : GDBusSendMessageFlags , out_serial : * mut guint32 , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_connection_send_message_with_reply (connection : * mut GDBusConnection , message : * mut GDBusMessage , flags : GDBusSendMessageFlags , timeout_msec : gint , out_serial : * mut guint32 , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dbus_connection_send_message_with_reply_finish (connection : * mut GDBusConnection , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GDBusMessage ; } unsafe extern "C" { pub fn g_dbus_connection_send_message_with_reply_sync (connection : * mut GDBusConnection , message : * mut GDBusMessage , flags : GDBusSendMessageFlags , timeout_msec : gint , out_serial : * mut guint32 , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GDBusMessage ; } unsafe extern "C" { pub fn g_dbus_connection_emit_signal (connection : * mut GDBusConnection , destination_bus_name : * const gchar , object_path : * const gchar , interface_name : * const gchar , signal_name : * const gchar , parameters : * mut GVariant , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_connection_call (connection : * mut GDBusConnection , bus_name : * const gchar , object_path : * const gchar , interface_name : * const gchar , method_name : * const gchar , parameters : * mut GVariant , reply_type : * const GVariantType , flags : GDBusCallFlags , timeout_msec : gint , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dbus_connection_call_finish (connection : * mut GDBusConnection , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GVariant ; } unsafe extern "C" { pub fn g_dbus_connection_call_sync (connection : * mut GDBusConnection , bus_name : * const gchar , object_path : * const gchar , interface_name : * const gchar , method_name : * const gchar , parameters : * mut GVariant , reply_type : * const GVariantType , flags : GDBusCallFlags , timeout_msec : gint , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GVariant ; } unsafe extern "C" { pub fn g_dbus_connection_call_with_unix_fd_list (connection : * mut GDBusConnection , bus_name : * const gchar , object_path : * const gchar , interface_name : * const gchar , method_name : * const gchar , parameters : * mut GVariant , reply_type : * const GVariantType , flags : GDBusCallFlags , timeout_msec : gint , fd_list : * mut GUnixFDList , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dbus_connection_call_with_unix_fd_list_finish (connection : * mut GDBusConnection , out_fd_list : * mut * mut GUnixFDList , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GVariant ; } unsafe extern "C" { pub fn g_dbus_connection_call_with_unix_fd_list_sync (connection : * mut GDBusConnection , bus_name : * const gchar , object_path : * const gchar , interface_name : * const gchar , method_name : * const gchar , parameters : * mut GVariant , reply_type : * const GVariantType , flags : GDBusCallFlags , timeout_msec : gint , fd_list : * mut GUnixFDList , out_fd_list : * mut * mut GUnixFDList , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GVariant ; } pub type GDBusInterfaceMethodCallFunc = :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GDBusConnection , sender : * const gchar , object_path : * const gchar , interface_name : * const gchar , method_name : * const gchar , parameters : * mut GVariant , invocation : * mut GDBusMethodInvocation , user_data : gpointer) > ; pub type GDBusInterfaceGetPropertyFunc = :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GDBusConnection , sender : * const gchar , object_path : * const gchar , interface_name : * const gchar , property_name : * const gchar , error : * mut * mut GError , user_data : gpointer) -> * mut GVariant > ; pub type GDBusInterfaceSetPropertyFunc = :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GDBusConnection , sender : * const gchar , object_path : * const gchar , interface_name : * const gchar , property_name : * const gchar , value : * mut GVariant , error : * mut * mut GError , user_data : gpointer) -> gboolean > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusInterfaceVTable { pub method_call : GDBusInterfaceMethodCallFunc , pub get_property : GDBusInterfaceGetPropertyFunc , pub set_property : GDBusInterfaceSetPropertyFunc , pub padding : [gpointer ; 8usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusInterfaceVTable"] [:: std :: mem :: size_of :: < _GDBusInterfaceVTable > () - 88usize] ; ["Alignment of _GDBusInterfaceVTable"] [:: std :: mem :: align_of :: < _GDBusInterfaceVTable > () - 8usize] ; ["Offset of field: _GDBusInterfaceVTable::method_call"] [:: std :: mem :: offset_of ! (_GDBusInterfaceVTable , method_call) - 0usize] ; ["Offset of field: _GDBusInterfaceVTable::get_property"] [:: std :: mem :: offset_of ! (_GDBusInterfaceVTable , get_property) - 8usize] ; ["Offset of field: _GDBusInterfaceVTable::set_property"] [:: std :: mem :: offset_of ! (_GDBusInterfaceVTable , set_property) - 16usize] ; ["Offset of field: _GDBusInterfaceVTable::padding"] [:: std :: mem :: offset_of ! (_GDBusInterfaceVTable , padding) - 24usize] ; } ; unsafe extern "C" { pub fn g_dbus_connection_register_object (connection : * mut GDBusConnection , object_path : * const gchar , interface_info : * mut GDBusInterfaceInfo , vtable : * const GDBusInterfaceVTable , user_data : gpointer , user_data_free_func : GDestroyNotify , error : * mut * mut GError) -> guint ; } unsafe extern "C" { pub fn g_dbus_connection_register_object_with_closures (connection : * mut GDBusConnection , object_path : * const gchar , interface_info : * mut GDBusInterfaceInfo , method_call_closure : * mut GClosure , get_property_closure : * mut GClosure , set_property_closure : * mut GClosure , error : * mut * mut GError) -> guint ; } unsafe extern "C" { pub fn g_dbus_connection_register_object_with_closures2 (connection : * mut GDBusConnection , object_path : * const gchar , interface_info : * mut GDBusInterfaceInfo , method_call_closure : * mut GClosure , get_property_closure : * mut GClosure , set_property_closure : * mut GClosure , error : * mut * mut GError) -> guint ; } unsafe extern "C" { pub fn g_dbus_connection_unregister_object (connection : * mut GDBusConnection , registration_id : guint) -> gboolean ; } pub type GDBusSubtreeEnumerateFunc = :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GDBusConnection , sender : * const gchar , object_path : * const gchar , user_data : gpointer) -> * mut * mut gchar > ; pub type GDBusSubtreeIntrospectFunc = :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GDBusConnection , sender : * const gchar , object_path : * const gchar , node : * const gchar , user_data : gpointer) -> * mut * mut GDBusInterfaceInfo > ; pub type GDBusSubtreeDispatchFunc = :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GDBusConnection , sender : * const gchar , object_path : * const gchar , interface_name : * const gchar , node : * const gchar , out_user_data : * mut gpointer , user_data : gpointer) -> * const GDBusInterfaceVTable > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusSubtreeVTable { pub enumerate : GDBusSubtreeEnumerateFunc , pub introspect : GDBusSubtreeIntrospectFunc , pub dispatch : GDBusSubtreeDispatchFunc , pub padding : [gpointer ; 8usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusSubtreeVTable"] [:: std :: mem :: size_of :: < _GDBusSubtreeVTable > () - 88usize] ; ["Alignment of _GDBusSubtreeVTable"] [:: std :: mem :: align_of :: < _GDBusSubtreeVTable > () - 8usize] ; ["Offset of field: _GDBusSubtreeVTable::enumerate"] [:: std :: mem :: offset_of ! (_GDBusSubtreeVTable , enumerate) - 0usize] ; ["Offset of field: _GDBusSubtreeVTable::introspect"] [:: std :: mem :: offset_of ! (_GDBusSubtreeVTable , introspect) - 8usize] ; ["Offset of field: _GDBusSubtreeVTable::dispatch"] [:: std :: mem :: offset_of ! (_GDBusSubtreeVTable , dispatch) - 16usize] ; ["Offset of field: _GDBusSubtreeVTable::padding"] [:: std :: mem :: offset_of ! (_GDBusSubtreeVTable , padding) - 24usize] ; } ; unsafe extern "C" { pub fn g_dbus_connection_register_subtree (connection : * mut GDBusConnection , object_path : * const gchar , vtable : * const GDBusSubtreeVTable , flags : GDBusSubtreeFlags , user_data : gpointer , user_data_free_func : GDestroyNotify , error : * mut * mut GError) -> guint ; } unsafe extern "C" { pub fn g_dbus_connection_unregister_subtree (connection : * mut GDBusConnection , registration_id : guint) -> gboolean ; } pub type GDBusSignalCallback = :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GDBusConnection , sender_name : * const gchar , object_path : * const gchar , interface_name : * const gchar , signal_name : * const gchar , parameters : * mut GVariant , user_data : gpointer) > ; unsafe extern "C" { pub fn g_dbus_connection_signal_subscribe (connection : * mut GDBusConnection , sender : * const gchar , interface_name : * const gchar , member : * const gchar , object_path : * const gchar , arg0 : * const gchar , flags : GDBusSignalFlags , callback : GDBusSignalCallback , user_data : gpointer , user_data_free_func : GDestroyNotify) -> guint ; } unsafe extern "C" { pub fn g_dbus_connection_signal_unsubscribe (connection : * mut GDBusConnection , subscription_id : guint) ; } pub type GDBusMessageFilterFunction = :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GDBusConnection , message : * mut GDBusMessage , incoming : gboolean , user_data : gpointer) -> * mut GDBusMessage > ; unsafe extern "C" { pub fn g_dbus_connection_add_filter (connection : * mut GDBusConnection , filter_function : GDBusMessageFilterFunction , user_data : gpointer , user_data_free_func : GDestroyNotify) -> guint ; } unsafe extern "C" { pub fn g_dbus_connection_remove_filter (connection : * mut GDBusConnection , filter_id : guint) ; } unsafe extern "C" { pub fn g_dbus_error_quark () -> GQuark ; } unsafe extern "C" { pub fn g_dbus_error_is_remote_error (error : * const GError) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_error_get_remote_error (error : * const GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_dbus_error_strip_remote_error (error : * mut GError) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusErrorEntry { pub error_code : gint , pub dbus_error_name : * const gchar , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusErrorEntry"] [:: std :: mem :: size_of :: < _GDBusErrorEntry > () - 16usize] ; ["Alignment of _GDBusErrorEntry"] [:: std :: mem :: align_of :: < _GDBusErrorEntry > () - 8usize] ; ["Offset of field: _GDBusErrorEntry::error_code"] [:: std :: mem :: offset_of ! (_GDBusErrorEntry , error_code) - 0usize] ; ["Offset of field: _GDBusErrorEntry::dbus_error_name"] [:: std :: mem :: offset_of ! (_GDBusErrorEntry , dbus_error_name) - 8usize] ; } ; unsafe extern "C" { pub fn g_dbus_error_register_error (error_domain : GQuark , error_code : gint , dbus_error_name : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_error_unregister_error (error_domain : GQuark , error_code : gint , dbus_error_name : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_error_register_error_domain (error_domain_quark_name : * const gchar , quark_volatile : * mut gsize , entries : * const GDBusErrorEntry , num_entries : guint) ; } unsafe extern "C" { pub fn g_dbus_error_new_for_dbus_error (dbus_error_name : * const gchar , dbus_error_message : * const gchar) -> * mut GError ; } unsafe extern "C" { pub fn g_dbus_error_set_dbus_error (error : * mut * mut GError , dbus_error_name : * const gchar , dbus_error_message : * const gchar , format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_dbus_error_set_dbus_error_valist (error : * mut * mut GError , dbus_error_name : * const gchar , dbus_error_message : * const gchar , format : * const gchar , var_args : * mut __va_list_tag) ; } unsafe extern "C" { pub fn g_dbus_error_encode_gerror (error : * const GError) -> * mut gchar ; } pub type GDBusInterfaceIface = _GDBusInterfaceIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusInterfaceIface { pub parent_iface : GTypeInterface , pub get_info : :: std :: option :: Option < unsafe extern "C" fn (interface_ : * mut GDBusInterface) -> * mut GDBusInterfaceInfo > , pub get_object : :: std :: option :: Option < unsafe extern "C" fn (interface_ : * mut GDBusInterface) -> * mut GDBusObject > , pub set_object : :: std :: option :: Option < unsafe extern "C" fn (interface_ : * mut GDBusInterface , object : * mut GDBusObject) > , pub dup_object : :: std :: option :: Option < unsafe extern "C" fn (interface_ : * mut GDBusInterface) -> * mut GDBusObject > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusInterfaceIface"] [:: std :: mem :: size_of :: < _GDBusInterfaceIface > () - 48usize] ; ["Alignment of _GDBusInterfaceIface"] [:: std :: mem :: align_of :: < _GDBusInterfaceIface > () - 8usize] ; ["Offset of field: _GDBusInterfaceIface::parent_iface"] [:: std :: mem :: offset_of ! (_GDBusInterfaceIface , parent_iface) - 0usize] ; ["Offset of field: _GDBusInterfaceIface::get_info"] [:: std :: mem :: offset_of ! (_GDBusInterfaceIface , get_info) - 16usize] ; ["Offset of field: _GDBusInterfaceIface::get_object"] [:: std :: mem :: offset_of ! (_GDBusInterfaceIface , get_object) - 24usize] ; ["Offset of field: _GDBusInterfaceIface::set_object"] [:: std :: mem :: offset_of ! (_GDBusInterfaceIface , set_object) - 32usize] ; ["Offset of field: _GDBusInterfaceIface::dup_object"] [:: std :: mem :: offset_of ! (_GDBusInterfaceIface , dup_object) - 40usize] ; } ; unsafe extern "C" { pub fn g_dbus_interface_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_interface_get_info (interface_ : * mut GDBusInterface) -> * mut GDBusInterfaceInfo ; } unsafe extern "C" { pub fn g_dbus_interface_get_object (interface_ : * mut GDBusInterface) -> * mut GDBusObject ; } unsafe extern "C" { pub fn g_dbus_interface_set_object (interface_ : * mut GDBusInterface , object : * mut GDBusObject) ; } unsafe extern "C" { pub fn g_dbus_interface_dup_object (interface_ : * mut GDBusInterface) -> * mut GDBusObject ; } pub type GDBusInterfaceSkeletonClass = _GDBusInterfaceSkeletonClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusInterfaceSkeletonPrivate { _unused : [u8 ; 0] , } pub type GDBusInterfaceSkeletonPrivate = _GDBusInterfaceSkeletonPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusInterfaceSkeleton { pub parent_instance : GObject , pub priv_ : * mut GDBusInterfaceSkeletonPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusInterfaceSkeleton"] [:: std :: mem :: size_of :: < _GDBusInterfaceSkeleton > () - 32usize] ; ["Alignment of _GDBusInterfaceSkeleton"] [:: std :: mem :: align_of :: < _GDBusInterfaceSkeleton > () - 8usize] ; ["Offset of field: _GDBusInterfaceSkeleton::parent_instance"] [:: std :: mem :: offset_of ! (_GDBusInterfaceSkeleton , parent_instance) - 0usize] ; ["Offset of field: _GDBusInterfaceSkeleton::priv_"] [:: std :: mem :: offset_of ! (_GDBusInterfaceSkeleton , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusInterfaceSkeletonClass { pub parent_class : GObjectClass , pub get_info : :: std :: option :: Option < unsafe extern "C" fn (interface_ : * mut GDBusInterfaceSkeleton) -> * mut GDBusInterfaceInfo > , pub get_vtable : :: std :: option :: Option < unsafe extern "C" fn (interface_ : * mut GDBusInterfaceSkeleton) -> * mut GDBusInterfaceVTable > , pub get_properties : :: std :: option :: Option < unsafe extern "C" fn (interface_ : * mut GDBusInterfaceSkeleton) -> * mut GVariant > , pub flush : :: std :: option :: Option < unsafe extern "C" fn (interface_ : * mut GDBusInterfaceSkeleton) > , pub vfunc_padding : [gpointer ; 8usize] , pub g_authorize_method : :: std :: option :: Option < unsafe extern "C" fn (interface_ : * mut GDBusInterfaceSkeleton , invocation : * mut GDBusMethodInvocation) -> gboolean > , pub signal_padding : [gpointer ; 8usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusInterfaceSkeletonClass"] [:: std :: mem :: size_of :: < _GDBusInterfaceSkeletonClass > () - 304usize] ; ["Alignment of _GDBusInterfaceSkeletonClass"] [:: std :: mem :: align_of :: < _GDBusInterfaceSkeletonClass > () - 8usize] ; ["Offset of field: _GDBusInterfaceSkeletonClass::parent_class"] [:: std :: mem :: offset_of ! (_GDBusInterfaceSkeletonClass , parent_class) - 0usize] ; ["Offset of field: _GDBusInterfaceSkeletonClass::get_info"] [:: std :: mem :: offset_of ! (_GDBusInterfaceSkeletonClass , get_info) - 136usize] ; ["Offset of field: _GDBusInterfaceSkeletonClass::get_vtable"] [:: std :: mem :: offset_of ! (_GDBusInterfaceSkeletonClass , get_vtable) - 144usize] ; ["Offset of field: _GDBusInterfaceSkeletonClass::get_properties"] [:: std :: mem :: offset_of ! (_GDBusInterfaceSkeletonClass , get_properties) - 152usize] ; ["Offset of field: _GDBusInterfaceSkeletonClass::flush"] [:: std :: mem :: offset_of ! (_GDBusInterfaceSkeletonClass , flush) - 160usize] ; ["Offset of field: _GDBusInterfaceSkeletonClass::vfunc_padding"] [:: std :: mem :: offset_of ! (_GDBusInterfaceSkeletonClass , vfunc_padding) - 168usize] ; ["Offset of field: _GDBusInterfaceSkeletonClass::g_authorize_method"] [:: std :: mem :: offset_of ! (_GDBusInterfaceSkeletonClass , g_authorize_method) - 232usize] ; ["Offset of field: _GDBusInterfaceSkeletonClass::signal_padding"] [:: std :: mem :: offset_of ! (_GDBusInterfaceSkeletonClass , signal_padding) - 240usize] ; } ; unsafe extern "C" { pub fn g_dbus_interface_skeleton_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_interface_skeleton_get_flags (interface_ : * mut GDBusInterfaceSkeleton) -> GDBusInterfaceSkeletonFlags ; } unsafe extern "C" { pub fn g_dbus_interface_skeleton_set_flags (interface_ : * mut GDBusInterfaceSkeleton , flags : GDBusInterfaceSkeletonFlags) ; } unsafe extern "C" { pub fn g_dbus_interface_skeleton_get_info (interface_ : * mut GDBusInterfaceSkeleton) -> * mut GDBusInterfaceInfo ; } unsafe extern "C" { pub fn g_dbus_interface_skeleton_get_vtable (interface_ : * mut GDBusInterfaceSkeleton) -> * mut GDBusInterfaceVTable ; } unsafe extern "C" { pub fn g_dbus_interface_skeleton_get_properties (interface_ : * mut GDBusInterfaceSkeleton) -> * mut GVariant ; } unsafe extern "C" { pub fn g_dbus_interface_skeleton_flush (interface_ : * mut GDBusInterfaceSkeleton) ; } unsafe extern "C" { pub fn g_dbus_interface_skeleton_export (interface_ : * mut GDBusInterfaceSkeleton , connection : * mut GDBusConnection , object_path : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_interface_skeleton_unexport (interface_ : * mut GDBusInterfaceSkeleton) ; } unsafe extern "C" { pub fn g_dbus_interface_skeleton_unexport_from_connection (interface_ : * mut GDBusInterfaceSkeleton , connection : * mut GDBusConnection) ; } unsafe extern "C" { pub fn g_dbus_interface_skeleton_get_connection (interface_ : * mut GDBusInterfaceSkeleton) -> * mut GDBusConnection ; } unsafe extern "C" { pub fn g_dbus_interface_skeleton_get_connections (interface_ : * mut GDBusInterfaceSkeleton) -> * mut GList ; } unsafe extern "C" { pub fn g_dbus_interface_skeleton_has_connection (interface_ : * mut GDBusInterfaceSkeleton , connection : * mut GDBusConnection) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_interface_skeleton_get_object_path (interface_ : * mut GDBusInterfaceSkeleton) -> * const gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusAnnotationInfo { pub ref_count : gint , pub key : * mut gchar , pub value : * mut gchar , pub annotations : * mut * mut GDBusAnnotationInfo , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusAnnotationInfo"] [:: std :: mem :: size_of :: < _GDBusAnnotationInfo > () - 32usize] ; ["Alignment of _GDBusAnnotationInfo"] [:: std :: mem :: align_of :: < _GDBusAnnotationInfo > () - 8usize] ; ["Offset of field: _GDBusAnnotationInfo::ref_count"] [:: std :: mem :: offset_of ! (_GDBusAnnotationInfo , ref_count) - 0usize] ; ["Offset of field: _GDBusAnnotationInfo::key"] [:: std :: mem :: offset_of ! (_GDBusAnnotationInfo , key) - 8usize] ; ["Offset of field: _GDBusAnnotationInfo::value"] [:: std :: mem :: offset_of ! (_GDBusAnnotationInfo , value) - 16usize] ; ["Offset of field: _GDBusAnnotationInfo::annotations"] [:: std :: mem :: offset_of ! (_GDBusAnnotationInfo , annotations) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusArgInfo { pub ref_count : gint , pub name : * mut gchar , pub signature : * mut gchar , pub annotations : * mut * mut GDBusAnnotationInfo , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusArgInfo"] [:: std :: mem :: size_of :: < _GDBusArgInfo > () - 32usize] ; ["Alignment of _GDBusArgInfo"] [:: std :: mem :: align_of :: < _GDBusArgInfo > () - 8usize] ; ["Offset of field: _GDBusArgInfo::ref_count"] [:: std :: mem :: offset_of ! (_GDBusArgInfo , ref_count) - 0usize] ; ["Offset of field: _GDBusArgInfo::name"] [:: std :: mem :: offset_of ! (_GDBusArgInfo , name) - 8usize] ; ["Offset of field: _GDBusArgInfo::signature"] [:: std :: mem :: offset_of ! (_GDBusArgInfo , signature) - 16usize] ; ["Offset of field: _GDBusArgInfo::annotations"] [:: std :: mem :: offset_of ! (_GDBusArgInfo , annotations) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusMethodInfo { pub ref_count : gint , pub name : * mut gchar , pub in_args : * mut * mut GDBusArgInfo , pub out_args : * mut * mut GDBusArgInfo , pub annotations : * mut * mut GDBusAnnotationInfo , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusMethodInfo"] [:: std :: mem :: size_of :: < _GDBusMethodInfo > () - 40usize] ; ["Alignment of _GDBusMethodInfo"] [:: std :: mem :: align_of :: < _GDBusMethodInfo > () - 8usize] ; ["Offset of field: _GDBusMethodInfo::ref_count"] [:: std :: mem :: offset_of ! (_GDBusMethodInfo , ref_count) - 0usize] ; ["Offset of field: _GDBusMethodInfo::name"] [:: std :: mem :: offset_of ! (_GDBusMethodInfo , name) - 8usize] ; ["Offset of field: _GDBusMethodInfo::in_args"] [:: std :: mem :: offset_of ! (_GDBusMethodInfo , in_args) - 16usize] ; ["Offset of field: _GDBusMethodInfo::out_args"] [:: std :: mem :: offset_of ! (_GDBusMethodInfo , out_args) - 24usize] ; ["Offset of field: _GDBusMethodInfo::annotations"] [:: std :: mem :: offset_of ! (_GDBusMethodInfo , annotations) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusSignalInfo { pub ref_count : gint , pub name : * mut gchar , pub args : * mut * mut GDBusArgInfo , pub annotations : * mut * mut GDBusAnnotationInfo , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusSignalInfo"] [:: std :: mem :: size_of :: < _GDBusSignalInfo > () - 32usize] ; ["Alignment of _GDBusSignalInfo"] [:: std :: mem :: align_of :: < _GDBusSignalInfo > () - 8usize] ; ["Offset of field: _GDBusSignalInfo::ref_count"] [:: std :: mem :: offset_of ! (_GDBusSignalInfo , ref_count) - 0usize] ; ["Offset of field: _GDBusSignalInfo::name"] [:: std :: mem :: offset_of ! (_GDBusSignalInfo , name) - 8usize] ; ["Offset of field: _GDBusSignalInfo::args"] [:: std :: mem :: offset_of ! (_GDBusSignalInfo , args) - 16usize] ; ["Offset of field: _GDBusSignalInfo::annotations"] [:: std :: mem :: offset_of ! (_GDBusSignalInfo , annotations) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusPropertyInfo { pub ref_count : gint , pub name : * mut gchar , pub signature : * mut gchar , pub flags : GDBusPropertyInfoFlags , pub annotations : * mut * mut GDBusAnnotationInfo , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusPropertyInfo"] [:: std :: mem :: size_of :: < _GDBusPropertyInfo > () - 40usize] ; ["Alignment of _GDBusPropertyInfo"] [:: std :: mem :: align_of :: < _GDBusPropertyInfo > () - 8usize] ; ["Offset of field: _GDBusPropertyInfo::ref_count"] [:: std :: mem :: offset_of ! (_GDBusPropertyInfo , ref_count) - 0usize] ; ["Offset of field: _GDBusPropertyInfo::name"] [:: std :: mem :: offset_of ! (_GDBusPropertyInfo , name) - 8usize] ; ["Offset of field: _GDBusPropertyInfo::signature"] [:: std :: mem :: offset_of ! (_GDBusPropertyInfo , signature) - 16usize] ; ["Offset of field: _GDBusPropertyInfo::flags"] [:: std :: mem :: offset_of ! (_GDBusPropertyInfo , flags) - 24usize] ; ["Offset of field: _GDBusPropertyInfo::annotations"] [:: std :: mem :: offset_of ! (_GDBusPropertyInfo , annotations) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusInterfaceInfo { pub ref_count : gint , pub name : * mut gchar , pub methods : * mut * mut GDBusMethodInfo , pub signals : * mut * mut GDBusSignalInfo , pub properties : * mut * mut GDBusPropertyInfo , pub annotations : * mut * mut GDBusAnnotationInfo , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusInterfaceInfo"] [:: std :: mem :: size_of :: < _GDBusInterfaceInfo > () - 48usize] ; ["Alignment of _GDBusInterfaceInfo"] [:: std :: mem :: align_of :: < _GDBusInterfaceInfo > () - 8usize] ; ["Offset of field: _GDBusInterfaceInfo::ref_count"] [:: std :: mem :: offset_of ! (_GDBusInterfaceInfo , ref_count) - 0usize] ; ["Offset of field: _GDBusInterfaceInfo::name"] [:: std :: mem :: offset_of ! (_GDBusInterfaceInfo , name) - 8usize] ; ["Offset of field: _GDBusInterfaceInfo::methods"] [:: std :: mem :: offset_of ! (_GDBusInterfaceInfo , methods) - 16usize] ; ["Offset of field: _GDBusInterfaceInfo::signals"] [:: std :: mem :: offset_of ! (_GDBusInterfaceInfo , signals) - 24usize] ; ["Offset of field: _GDBusInterfaceInfo::properties"] [:: std :: mem :: offset_of ! (_GDBusInterfaceInfo , properties) - 32usize] ; ["Offset of field: _GDBusInterfaceInfo::annotations"] [:: std :: mem :: offset_of ! (_GDBusInterfaceInfo , annotations) - 40usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusNodeInfo { pub ref_count : gint , pub path : * mut gchar , pub interfaces : * mut * mut GDBusInterfaceInfo , pub nodes : * mut * mut GDBusNodeInfo , pub annotations : * mut * mut GDBusAnnotationInfo , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusNodeInfo"] [:: std :: mem :: size_of :: < _GDBusNodeInfo > () - 40usize] ; ["Alignment of _GDBusNodeInfo"] [:: std :: mem :: align_of :: < _GDBusNodeInfo > () - 8usize] ; ["Offset of field: _GDBusNodeInfo::ref_count"] [:: std :: mem :: offset_of ! (_GDBusNodeInfo , ref_count) - 0usize] ; ["Offset of field: _GDBusNodeInfo::path"] [:: std :: mem :: offset_of ! (_GDBusNodeInfo , path) - 8usize] ; ["Offset of field: _GDBusNodeInfo::interfaces"] [:: std :: mem :: offset_of ! (_GDBusNodeInfo , interfaces) - 16usize] ; ["Offset of field: _GDBusNodeInfo::nodes"] [:: std :: mem :: offset_of ! (_GDBusNodeInfo , nodes) - 24usize] ; ["Offset of field: _GDBusNodeInfo::annotations"] [:: std :: mem :: offset_of ! (_GDBusNodeInfo , annotations) - 32usize] ; } ; unsafe extern "C" { pub fn g_dbus_annotation_info_lookup (annotations : * mut * mut GDBusAnnotationInfo , name : * const gchar) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_interface_info_lookup_method (info : * mut GDBusInterfaceInfo , name : * const gchar) -> * mut GDBusMethodInfo ; } unsafe extern "C" { pub fn g_dbus_interface_info_lookup_signal (info : * mut GDBusInterfaceInfo , name : * const gchar) -> * mut GDBusSignalInfo ; } unsafe extern "C" { pub fn g_dbus_interface_info_lookup_property (info : * mut GDBusInterfaceInfo , name : * const gchar) -> * mut GDBusPropertyInfo ; } unsafe extern "C" { pub fn g_dbus_interface_info_cache_build (info : * mut GDBusInterfaceInfo) ; } unsafe extern "C" { pub fn g_dbus_interface_info_cache_release (info : * mut GDBusInterfaceInfo) ; } unsafe extern "C" { pub fn g_dbus_interface_info_generate_xml (info : * mut GDBusInterfaceInfo , indent : guint , string_builder : * mut GString) ; } unsafe extern "C" { pub fn g_dbus_node_info_new_for_xml (xml_data : * const gchar , error : * mut * mut GError) -> * mut GDBusNodeInfo ; } unsafe extern "C" { pub fn g_dbus_node_info_lookup_interface (info : * mut GDBusNodeInfo , name : * const gchar) -> * mut GDBusInterfaceInfo ; } unsafe extern "C" { pub fn g_dbus_node_info_generate_xml (info : * mut GDBusNodeInfo , indent : guint , string_builder : * mut GString) ; } unsafe extern "C" { pub fn g_dbus_node_info_ref (info : * mut GDBusNodeInfo) -> * mut GDBusNodeInfo ; } unsafe extern "C" { pub fn g_dbus_interface_info_ref (info : * mut GDBusInterfaceInfo) -> * mut GDBusInterfaceInfo ; } unsafe extern "C" { pub fn g_dbus_method_info_ref (info : * mut GDBusMethodInfo) -> * mut GDBusMethodInfo ; } unsafe extern "C" { pub fn g_dbus_signal_info_ref (info : * mut GDBusSignalInfo) -> * mut GDBusSignalInfo ; } unsafe extern "C" { pub fn g_dbus_property_info_ref (info : * mut GDBusPropertyInfo) -> * mut GDBusPropertyInfo ; } unsafe extern "C" { pub fn g_dbus_arg_info_ref (info : * mut GDBusArgInfo) -> * mut GDBusArgInfo ; } unsafe extern "C" { pub fn g_dbus_annotation_info_ref (info : * mut GDBusAnnotationInfo) -> * mut GDBusAnnotationInfo ; } unsafe extern "C" { pub fn g_dbus_node_info_unref (info : * mut GDBusNodeInfo) ; } unsafe extern "C" { pub fn g_dbus_interface_info_unref (info : * mut GDBusInterfaceInfo) ; } unsafe extern "C" { pub fn g_dbus_method_info_unref (info : * mut GDBusMethodInfo) ; } unsafe extern "C" { pub fn g_dbus_signal_info_unref (info : * mut GDBusSignalInfo) ; } unsafe extern "C" { pub fn g_dbus_property_info_unref (info : * mut GDBusPropertyInfo) ; } unsafe extern "C" { pub fn g_dbus_arg_info_unref (info : * mut GDBusArgInfo) ; } unsafe extern "C" { pub fn g_dbus_annotation_info_unref (info : * mut GDBusAnnotationInfo) ; } unsafe extern "C" { pub fn g_dbus_node_info_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_interface_info_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_method_info_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_signal_info_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_property_info_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_arg_info_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_annotation_info_get_type () -> GType ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusMenuModel { _unused : [u8 ; 0] , } pub type GDBusMenuModel = _GDBusMenuModel ; unsafe extern "C" { pub fn g_dbus_menu_model_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_menu_model_get (connection : * mut GDBusConnection , bus_name : * const gchar , object_path : * const gchar) -> * mut GDBusMenuModel ; } unsafe extern "C" { pub fn g_dbus_message_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_message_new () -> * mut GDBusMessage ; } unsafe extern "C" { pub fn g_dbus_message_new_signal (path : * const gchar , interface_ : * const gchar , signal : * const gchar) -> * mut GDBusMessage ; } unsafe extern "C" { pub fn g_dbus_message_new_method_call (name : * const gchar , path : * const gchar , interface_ : * const gchar , method : * const gchar) -> * mut GDBusMessage ; } unsafe extern "C" { pub fn g_dbus_message_new_method_reply (method_call_message : * mut GDBusMessage) -> * mut GDBusMessage ; } unsafe extern "C" { pub fn g_dbus_message_new_method_error (method_call_message : * mut GDBusMessage , error_name : * const gchar , error_message_format : * const gchar , ...) -> * mut GDBusMessage ; } unsafe extern "C" { pub fn g_dbus_message_new_method_error_valist (method_call_message : * mut GDBusMessage , error_name : * const gchar , error_message_format : * const gchar , var_args : * mut __va_list_tag) -> * mut GDBusMessage ; } unsafe extern "C" { pub fn g_dbus_message_new_method_error_literal (method_call_message : * mut GDBusMessage , error_name : * const gchar , error_message : * const gchar) -> * mut GDBusMessage ; } unsafe extern "C" { pub fn g_dbus_message_print (message : * mut GDBusMessage , indent : guint) -> * mut gchar ; } unsafe extern "C" { pub fn g_dbus_message_get_locked (message : * mut GDBusMessage) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_message_lock (message : * mut GDBusMessage) ; } unsafe extern "C" { pub fn g_dbus_message_copy (message : * mut GDBusMessage , error : * mut * mut GError) -> * mut GDBusMessage ; } unsafe extern "C" { pub fn g_dbus_message_get_byte_order (message : * mut GDBusMessage) -> GDBusMessageByteOrder ; } unsafe extern "C" { pub fn g_dbus_message_set_byte_order (message : * mut GDBusMessage , byte_order : GDBusMessageByteOrder) ; } unsafe extern "C" { pub fn g_dbus_message_get_message_type (message : * mut GDBusMessage) -> GDBusMessageType ; } unsafe extern "C" { pub fn g_dbus_message_set_message_type (message : * mut GDBusMessage , type_ : GDBusMessageType) ; } unsafe extern "C" { pub fn g_dbus_message_get_flags (message : * mut GDBusMessage) -> GDBusMessageFlags ; } unsafe extern "C" { pub fn g_dbus_message_set_flags (message : * mut GDBusMessage , flags : GDBusMessageFlags) ; } unsafe extern "C" { pub fn g_dbus_message_get_serial (message : * mut GDBusMessage) -> guint32 ; } unsafe extern "C" { pub fn g_dbus_message_set_serial (message : * mut GDBusMessage , serial : guint32) ; } unsafe extern "C" { pub fn g_dbus_message_get_header (message : * mut GDBusMessage , header_field : GDBusMessageHeaderField) -> * mut GVariant ; } unsafe extern "C" { pub fn g_dbus_message_set_header (message : * mut GDBusMessage , header_field : GDBusMessageHeaderField , value : * mut GVariant) ; } unsafe extern "C" { pub fn g_dbus_message_get_header_fields (message : * mut GDBusMessage) -> * mut guchar ; } unsafe extern "C" { pub fn g_dbus_message_get_body (message : * mut GDBusMessage) -> * mut GVariant ; } unsafe extern "C" { pub fn g_dbus_message_set_body (message : * mut GDBusMessage , body : * mut GVariant) ; } unsafe extern "C" { pub fn g_dbus_message_get_unix_fd_list (message : * mut GDBusMessage) -> * mut GUnixFDList ; } unsafe extern "C" { pub fn g_dbus_message_set_unix_fd_list (message : * mut GDBusMessage , fd_list : * mut GUnixFDList) ; } unsafe extern "C" { pub fn g_dbus_message_get_reply_serial (message : * mut GDBusMessage) -> guint32 ; } unsafe extern "C" { pub fn g_dbus_message_set_reply_serial (message : * mut GDBusMessage , value : guint32) ; } unsafe extern "C" { pub fn g_dbus_message_get_interface (message : * mut GDBusMessage) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_message_set_interface (message : * mut GDBusMessage , value : * const gchar) ; } unsafe extern "C" { pub fn g_dbus_message_get_member (message : * mut GDBusMessage) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_message_set_member (message : * mut GDBusMessage , value : * const gchar) ; } unsafe extern "C" { pub fn g_dbus_message_get_path (message : * mut GDBusMessage) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_message_set_path (message : * mut GDBusMessage , value : * const gchar) ; } unsafe extern "C" { pub fn g_dbus_message_get_sender (message : * mut GDBusMessage) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_message_set_sender (message : * mut GDBusMessage , value : * const gchar) ; } unsafe extern "C" { pub fn g_dbus_message_get_destination (message : * mut GDBusMessage) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_message_set_destination (message : * mut GDBusMessage , value : * const gchar) ; } unsafe extern "C" { pub fn g_dbus_message_get_error_name (message : * mut GDBusMessage) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_message_set_error_name (message : * mut GDBusMessage , value : * const gchar) ; } unsafe extern "C" { pub fn g_dbus_message_get_signature (message : * mut GDBusMessage) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_message_set_signature (message : * mut GDBusMessage , value : * const gchar) ; } unsafe extern "C" { pub fn g_dbus_message_get_num_unix_fds (message : * mut GDBusMessage) -> guint32 ; } unsafe extern "C" { pub fn g_dbus_message_set_num_unix_fds (message : * mut GDBusMessage , value : guint32) ; } unsafe extern "C" { pub fn g_dbus_message_get_arg0 (message : * mut GDBusMessage) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_message_get_arg0_path (message : * mut GDBusMessage) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_message_new_from_blob (blob : * mut guchar , blob_len : gsize , capabilities : GDBusCapabilityFlags , error : * mut * mut GError) -> * mut GDBusMessage ; } unsafe extern "C" { pub fn g_dbus_message_bytes_needed (blob : * mut guchar , blob_len : gsize , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_dbus_message_to_blob (message : * mut GDBusMessage , out_size : * mut gsize , capabilities : GDBusCapabilityFlags , error : * mut * mut GError) -> * mut guchar ; } unsafe extern "C" { pub fn g_dbus_message_to_gerror (message : * mut GDBusMessage , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_method_invocation_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_method_invocation_get_sender (invocation : * mut GDBusMethodInvocation) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_method_invocation_get_object_path (invocation : * mut GDBusMethodInvocation) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_method_invocation_get_interface_name (invocation : * mut GDBusMethodInvocation) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_method_invocation_get_method_name (invocation : * mut GDBusMethodInvocation) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_method_invocation_get_method_info (invocation : * mut GDBusMethodInvocation) -> * const GDBusMethodInfo ; } unsafe extern "C" { pub fn g_dbus_method_invocation_get_property_info (invocation : * mut GDBusMethodInvocation) -> * const GDBusPropertyInfo ; } unsafe extern "C" { pub fn g_dbus_method_invocation_get_connection (invocation : * mut GDBusMethodInvocation) -> * mut GDBusConnection ; } unsafe extern "C" { pub fn g_dbus_method_invocation_get_message (invocation : * mut GDBusMethodInvocation) -> * mut GDBusMessage ; } unsafe extern "C" { pub fn g_dbus_method_invocation_get_parameters (invocation : * mut GDBusMethodInvocation) -> * mut GVariant ; } unsafe extern "C" { pub fn g_dbus_method_invocation_get_user_data (invocation : * mut GDBusMethodInvocation) -> gpointer ; } unsafe extern "C" { pub fn g_dbus_method_invocation_return_value (invocation : * mut GDBusMethodInvocation , parameters : * mut GVariant) ; } unsafe extern "C" { pub fn g_dbus_method_invocation_return_value_with_unix_fd_list (invocation : * mut GDBusMethodInvocation , parameters : * mut GVariant , fd_list : * mut GUnixFDList) ; } unsafe extern "C" { pub fn g_dbus_method_invocation_return_error (invocation : * mut GDBusMethodInvocation , domain : GQuark , code : gint , format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_dbus_method_invocation_return_error_valist (invocation : * mut GDBusMethodInvocation , domain : GQuark , code : gint , format : * const gchar , var_args : * mut __va_list_tag) ; } unsafe extern "C" { pub fn g_dbus_method_invocation_return_error_literal (invocation : * mut GDBusMethodInvocation , domain : GQuark , code : gint , message : * const gchar) ; } unsafe extern "C" { pub fn g_dbus_method_invocation_return_gerror (invocation : * mut GDBusMethodInvocation , error : * const GError) ; } unsafe extern "C" { pub fn g_dbus_method_invocation_take_error (invocation : * mut GDBusMethodInvocation , error : * mut GError) ; } unsafe extern "C" { pub fn g_dbus_method_invocation_return_dbus_error (invocation : * mut GDBusMethodInvocation , error_name : * const gchar , error_message : * const gchar) ; } pub type GBusAcquiredCallback = :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GDBusConnection , name : * const gchar , user_data : gpointer) > ; pub type GBusNameAcquiredCallback = :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GDBusConnection , name : * const gchar , user_data : gpointer) > ; pub type GBusNameLostCallback = :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GDBusConnection , name : * const gchar , user_data : gpointer) > ; unsafe extern "C" { pub fn g_bus_own_name (bus_type : GBusType , name : * const gchar , flags : GBusNameOwnerFlags , bus_acquired_handler : GBusAcquiredCallback , name_acquired_handler : GBusNameAcquiredCallback , name_lost_handler : GBusNameLostCallback , user_data : gpointer , user_data_free_func : GDestroyNotify) -> guint ; } unsafe extern "C" { pub fn g_bus_own_name_on_connection (connection : * mut GDBusConnection , name : * const gchar , flags : GBusNameOwnerFlags , name_acquired_handler : GBusNameAcquiredCallback , name_lost_handler : GBusNameLostCallback , user_data : gpointer , user_data_free_func : GDestroyNotify) -> guint ; } unsafe extern "C" { pub fn g_bus_own_name_with_closures (bus_type : GBusType , name : * const gchar , flags : GBusNameOwnerFlags , bus_acquired_closure : * mut GClosure , name_acquired_closure : * mut GClosure , name_lost_closure : * mut GClosure) -> guint ; } unsafe extern "C" { pub fn g_bus_own_name_on_connection_with_closures (connection : * mut GDBusConnection , name : * const gchar , flags : GBusNameOwnerFlags , name_acquired_closure : * mut GClosure , name_lost_closure : * mut GClosure) -> guint ; } unsafe extern "C" { pub fn g_bus_unown_name (owner_id : guint) ; } pub type GBusNameAppearedCallback = :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GDBusConnection , name : * const gchar , name_owner : * const gchar , user_data : gpointer) > ; pub type GBusNameVanishedCallback = :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GDBusConnection , name : * const gchar , user_data : gpointer) > ; unsafe extern "C" { pub fn g_bus_watch_name (bus_type : GBusType , name : * const gchar , flags : GBusNameWatcherFlags , name_appeared_handler : GBusNameAppearedCallback , name_vanished_handler : GBusNameVanishedCallback , user_data : gpointer , user_data_free_func : GDestroyNotify) -> guint ; } unsafe extern "C" { pub fn g_bus_watch_name_on_connection (connection : * mut GDBusConnection , name : * const gchar , flags : GBusNameWatcherFlags , name_appeared_handler : GBusNameAppearedCallback , name_vanished_handler : GBusNameVanishedCallback , user_data : gpointer , user_data_free_func : GDestroyNotify) -> guint ; } unsafe extern "C" { pub fn g_bus_watch_name_with_closures (bus_type : GBusType , name : * const gchar , flags : GBusNameWatcherFlags , name_appeared_closure : * mut GClosure , name_vanished_closure : * mut GClosure) -> guint ; } unsafe extern "C" { pub fn g_bus_watch_name_on_connection_with_closures (connection : * mut GDBusConnection , name : * const gchar , flags : GBusNameWatcherFlags , name_appeared_closure : * mut GClosure , name_vanished_closure : * mut GClosure) -> guint ; } unsafe extern "C" { pub fn g_bus_unwatch_name (watcher_id : guint) ; } pub type GDBusObjectIface = _GDBusObjectIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectIface { pub parent_iface : GTypeInterface , pub get_object_path : :: std :: option :: Option < unsafe extern "C" fn (object : * mut GDBusObject) -> * const gchar > , pub get_interfaces : :: std :: option :: Option < unsafe extern "C" fn (object : * mut GDBusObject) -> * mut GList > , pub get_interface : :: std :: option :: Option < unsafe extern "C" fn (object : * mut GDBusObject , interface_name : * const gchar) -> * mut GDBusInterface > , pub interface_added : :: std :: option :: Option < unsafe extern "C" fn (object : * mut GDBusObject , interface_ : * mut GDBusInterface) > , pub interface_removed : :: std :: option :: Option < unsafe extern "C" fn (object : * mut GDBusObject , interface_ : * mut GDBusInterface) > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusObjectIface"] [:: std :: mem :: size_of :: < _GDBusObjectIface > () - 56usize] ; ["Alignment of _GDBusObjectIface"] [:: std :: mem :: align_of :: < _GDBusObjectIface > () - 8usize] ; ["Offset of field: _GDBusObjectIface::parent_iface"] [:: std :: mem :: offset_of ! (_GDBusObjectIface , parent_iface) - 0usize] ; ["Offset of field: _GDBusObjectIface::get_object_path"] [:: std :: mem :: offset_of ! (_GDBusObjectIface , get_object_path) - 16usize] ; ["Offset of field: _GDBusObjectIface::get_interfaces"] [:: std :: mem :: offset_of ! (_GDBusObjectIface , get_interfaces) - 24usize] ; ["Offset of field: _GDBusObjectIface::get_interface"] [:: std :: mem :: offset_of ! (_GDBusObjectIface , get_interface) - 32usize] ; ["Offset of field: _GDBusObjectIface::interface_added"] [:: std :: mem :: offset_of ! (_GDBusObjectIface , interface_added) - 40usize] ; ["Offset of field: _GDBusObjectIface::interface_removed"] [:: std :: mem :: offset_of ! (_GDBusObjectIface , interface_removed) - 48usize] ; } ; unsafe extern "C" { pub fn g_dbus_object_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_object_get_object_path (object : * mut GDBusObject) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_object_get_interfaces (object : * mut GDBusObject) -> * mut GList ; } unsafe extern "C" { pub fn g_dbus_object_get_interface (object : * mut GDBusObject , interface_name : * const gchar) -> * mut GDBusInterface ; } pub type GDBusObjectManagerIface = _GDBusObjectManagerIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectManagerIface { pub parent_iface : GTypeInterface , pub get_object_path : :: std :: option :: Option < unsafe extern "C" fn (manager : * mut GDBusObjectManager) -> * const gchar > , pub get_objects : :: std :: option :: Option < unsafe extern "C" fn (manager : * mut GDBusObjectManager) -> * mut GList > , pub get_object : :: std :: option :: Option < unsafe extern "C" fn (manager : * mut GDBusObjectManager , object_path : * const gchar) -> * mut GDBusObject > , pub get_interface : :: std :: option :: Option < unsafe extern "C" fn (manager : * mut GDBusObjectManager , object_path : * const gchar , interface_name : * const gchar) -> * mut GDBusInterface > , pub object_added : :: std :: option :: Option < unsafe extern "C" fn (manager : * mut GDBusObjectManager , object : * mut GDBusObject) > , pub object_removed : :: std :: option :: Option < unsafe extern "C" fn (manager : * mut GDBusObjectManager , object : * mut GDBusObject) > , pub interface_added : :: std :: option :: Option < unsafe extern "C" fn (manager : * mut GDBusObjectManager , object : * mut GDBusObject , interface_ : * mut GDBusInterface) > , pub interface_removed : :: std :: option :: Option < unsafe extern "C" fn (manager : * mut GDBusObjectManager , object : * mut GDBusObject , interface_ : * mut GDBusInterface) > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusObjectManagerIface"] [:: std :: mem :: size_of :: < _GDBusObjectManagerIface > () - 80usize] ; ["Alignment of _GDBusObjectManagerIface"] [:: std :: mem :: align_of :: < _GDBusObjectManagerIface > () - 8usize] ; ["Offset of field: _GDBusObjectManagerIface::parent_iface"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerIface , parent_iface) - 0usize] ; ["Offset of field: _GDBusObjectManagerIface::get_object_path"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerIface , get_object_path) - 16usize] ; ["Offset of field: _GDBusObjectManagerIface::get_objects"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerIface , get_objects) - 24usize] ; ["Offset of field: _GDBusObjectManagerIface::get_object"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerIface , get_object) - 32usize] ; ["Offset of field: _GDBusObjectManagerIface::get_interface"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerIface , get_interface) - 40usize] ; ["Offset of field: _GDBusObjectManagerIface::object_added"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerIface , object_added) - 48usize] ; ["Offset of field: _GDBusObjectManagerIface::object_removed"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerIface , object_removed) - 56usize] ; ["Offset of field: _GDBusObjectManagerIface::interface_added"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerIface , interface_added) - 64usize] ; ["Offset of field: _GDBusObjectManagerIface::interface_removed"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerIface , interface_removed) - 72usize] ; } ; unsafe extern "C" { pub fn g_dbus_object_manager_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_object_manager_get_object_path (manager : * mut GDBusObjectManager) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_object_manager_get_objects (manager : * mut GDBusObjectManager) -> * mut GList ; } unsafe extern "C" { pub fn g_dbus_object_manager_get_object (manager : * mut GDBusObjectManager , object_path : * const gchar) -> * mut GDBusObject ; } unsafe extern "C" { pub fn g_dbus_object_manager_get_interface (manager : * mut GDBusObjectManager , object_path : * const gchar , interface_name : * const gchar) -> * mut GDBusInterface ; } pub type GDBusObjectManagerClientClass = _GDBusObjectManagerClientClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectManagerClientPrivate { _unused : [u8 ; 0] , } pub type GDBusObjectManagerClientPrivate = _GDBusObjectManagerClientPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectManagerClient { pub parent_instance : GObject , pub priv_ : * mut GDBusObjectManagerClientPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusObjectManagerClient"] [:: std :: mem :: size_of :: < _GDBusObjectManagerClient > () - 32usize] ; ["Alignment of _GDBusObjectManagerClient"] [:: std :: mem :: align_of :: < _GDBusObjectManagerClient > () - 8usize] ; ["Offset of field: _GDBusObjectManagerClient::parent_instance"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerClient , parent_instance) - 0usize] ; ["Offset of field: _GDBusObjectManagerClient::priv_"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerClient , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectManagerClientClass { pub parent_class : GObjectClass , pub interface_proxy_signal : :: std :: option :: Option < unsafe extern "C" fn (manager : * mut GDBusObjectManagerClient , object_proxy : * mut GDBusObjectProxy , interface_proxy : * mut GDBusProxy , sender_name : * const gchar , signal_name : * const gchar , parameters : * mut GVariant) > , pub interface_proxy_properties_changed : :: std :: option :: Option < unsafe extern "C" fn (manager : * mut GDBusObjectManagerClient , object_proxy : * mut GDBusObjectProxy , interface_proxy : * mut GDBusProxy , changed_properties : * mut GVariant , invalidated_properties : * const * const gchar) > , pub padding : [gpointer ; 8usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusObjectManagerClientClass"] [:: std :: mem :: size_of :: < _GDBusObjectManagerClientClass > () - 216usize] ; ["Alignment of _GDBusObjectManagerClientClass"] [:: std :: mem :: align_of :: < _GDBusObjectManagerClientClass > () - 8usize] ; ["Offset of field: _GDBusObjectManagerClientClass::parent_class"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerClientClass , parent_class) - 0usize] ; ["Offset of field: _GDBusObjectManagerClientClass::interface_proxy_signal"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerClientClass , interface_proxy_signal) - 136usize] ; ["Offset of field: _GDBusObjectManagerClientClass::interface_proxy_properties_changed"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerClientClass , interface_proxy_properties_changed) - 144usize] ; ["Offset of field: _GDBusObjectManagerClientClass::padding"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerClientClass , padding) - 152usize] ; } ; unsafe extern "C" { pub fn g_dbus_object_manager_client_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_object_manager_client_new (connection : * mut GDBusConnection , flags : GDBusObjectManagerClientFlags , name : * const gchar , object_path : * const gchar , get_proxy_type_func : GDBusProxyTypeFunc , get_proxy_type_user_data : gpointer , get_proxy_type_destroy_notify : GDestroyNotify , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dbus_object_manager_client_new_finish (res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GDBusObjectManager ; } unsafe extern "C" { pub fn g_dbus_object_manager_client_new_sync (connection : * mut GDBusConnection , flags : GDBusObjectManagerClientFlags , name : * const gchar , object_path : * const gchar , get_proxy_type_func : GDBusProxyTypeFunc , get_proxy_type_user_data : gpointer , get_proxy_type_destroy_notify : GDestroyNotify , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GDBusObjectManager ; } unsafe extern "C" { pub fn g_dbus_object_manager_client_new_for_bus (bus_type : GBusType , flags : GDBusObjectManagerClientFlags , name : * const gchar , object_path : * const gchar , get_proxy_type_func : GDBusProxyTypeFunc , get_proxy_type_user_data : gpointer , get_proxy_type_destroy_notify : GDestroyNotify , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dbus_object_manager_client_new_for_bus_finish (res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GDBusObjectManager ; } unsafe extern "C" { pub fn g_dbus_object_manager_client_new_for_bus_sync (bus_type : GBusType , flags : GDBusObjectManagerClientFlags , name : * const gchar , object_path : * const gchar , get_proxy_type_func : GDBusProxyTypeFunc , get_proxy_type_user_data : gpointer , get_proxy_type_destroy_notify : GDestroyNotify , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GDBusObjectManager ; } unsafe extern "C" { pub fn g_dbus_object_manager_client_get_connection (manager : * mut GDBusObjectManagerClient) -> * mut GDBusConnection ; } unsafe extern "C" { pub fn g_dbus_object_manager_client_get_flags (manager : * mut GDBusObjectManagerClient) -> GDBusObjectManagerClientFlags ; } unsafe extern "C" { pub fn g_dbus_object_manager_client_get_name (manager : * mut GDBusObjectManagerClient) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_object_manager_client_get_name_owner (manager : * mut GDBusObjectManagerClient) -> * mut gchar ; } pub type GDBusObjectManagerServerClass = _GDBusObjectManagerServerClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectManagerServerPrivate { _unused : [u8 ; 0] , } pub type GDBusObjectManagerServerPrivate = _GDBusObjectManagerServerPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectManagerServer { pub parent_instance : GObject , pub priv_ : * mut GDBusObjectManagerServerPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusObjectManagerServer"] [:: std :: mem :: size_of :: < _GDBusObjectManagerServer > () - 32usize] ; ["Alignment of _GDBusObjectManagerServer"] [:: std :: mem :: align_of :: < _GDBusObjectManagerServer > () - 8usize] ; ["Offset of field: _GDBusObjectManagerServer::parent_instance"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerServer , parent_instance) - 0usize] ; ["Offset of field: _GDBusObjectManagerServer::priv_"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerServer , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectManagerServerClass { pub parent_class : GObjectClass , pub padding : [gpointer ; 8usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusObjectManagerServerClass"] [:: std :: mem :: size_of :: < _GDBusObjectManagerServerClass > () - 200usize] ; ["Alignment of _GDBusObjectManagerServerClass"] [:: std :: mem :: align_of :: < _GDBusObjectManagerServerClass > () - 8usize] ; ["Offset of field: _GDBusObjectManagerServerClass::parent_class"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerServerClass , parent_class) - 0usize] ; ["Offset of field: _GDBusObjectManagerServerClass::padding"] [:: std :: mem :: offset_of ! (_GDBusObjectManagerServerClass , padding) - 136usize] ; } ; unsafe extern "C" { pub fn g_dbus_object_manager_server_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_object_manager_server_new (object_path : * const gchar) -> * mut GDBusObjectManagerServer ; } unsafe extern "C" { pub fn g_dbus_object_manager_server_get_connection (manager : * mut GDBusObjectManagerServer) -> * mut GDBusConnection ; } unsafe extern "C" { pub fn g_dbus_object_manager_server_set_connection (manager : * mut GDBusObjectManagerServer , connection : * mut GDBusConnection) ; } unsafe extern "C" { pub fn g_dbus_object_manager_server_export (manager : * mut GDBusObjectManagerServer , object : * mut GDBusObjectSkeleton) ; } unsafe extern "C" { pub fn g_dbus_object_manager_server_export_uniquely (manager : * mut GDBusObjectManagerServer , object : * mut GDBusObjectSkeleton) ; } unsafe extern "C" { pub fn g_dbus_object_manager_server_is_exported (manager : * mut GDBusObjectManagerServer , object : * mut GDBusObjectSkeleton) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_object_manager_server_unexport (manager : * mut GDBusObjectManagerServer , object_path : * const gchar) -> gboolean ; } pub type GDBusObjectProxyClass = _GDBusObjectProxyClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectProxyPrivate { _unused : [u8 ; 0] , } pub type GDBusObjectProxyPrivate = _GDBusObjectProxyPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectProxy { pub parent_instance : GObject , pub priv_ : * mut GDBusObjectProxyPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusObjectProxy"] [:: std :: mem :: size_of :: < _GDBusObjectProxy > () - 32usize] ; ["Alignment of _GDBusObjectProxy"] [:: std :: mem :: align_of :: < _GDBusObjectProxy > () - 8usize] ; ["Offset of field: _GDBusObjectProxy::parent_instance"] [:: std :: mem :: offset_of ! (_GDBusObjectProxy , parent_instance) - 0usize] ; ["Offset of field: _GDBusObjectProxy::priv_"] [:: std :: mem :: offset_of ! (_GDBusObjectProxy , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectProxyClass { pub parent_class : GObjectClass , pub padding : [gpointer ; 8usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusObjectProxyClass"] [:: std :: mem :: size_of :: < _GDBusObjectProxyClass > () - 200usize] ; ["Alignment of _GDBusObjectProxyClass"] [:: std :: mem :: align_of :: < _GDBusObjectProxyClass > () - 8usize] ; ["Offset of field: _GDBusObjectProxyClass::parent_class"] [:: std :: mem :: offset_of ! (_GDBusObjectProxyClass , parent_class) - 0usize] ; ["Offset of field: _GDBusObjectProxyClass::padding"] [:: std :: mem :: offset_of ! (_GDBusObjectProxyClass , padding) - 136usize] ; } ; unsafe extern "C" { pub fn g_dbus_object_proxy_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_object_proxy_new (connection : * mut GDBusConnection , object_path : * const gchar) -> * mut GDBusObjectProxy ; } unsafe extern "C" { pub fn g_dbus_object_proxy_get_connection (proxy : * mut GDBusObjectProxy) -> * mut GDBusConnection ; } pub type GDBusObjectSkeletonClass = _GDBusObjectSkeletonClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectSkeletonPrivate { _unused : [u8 ; 0] , } pub type GDBusObjectSkeletonPrivate = _GDBusObjectSkeletonPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectSkeleton { pub parent_instance : GObject , pub priv_ : * mut GDBusObjectSkeletonPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusObjectSkeleton"] [:: std :: mem :: size_of :: < _GDBusObjectSkeleton > () - 32usize] ; ["Alignment of _GDBusObjectSkeleton"] [:: std :: mem :: align_of :: < _GDBusObjectSkeleton > () - 8usize] ; ["Offset of field: _GDBusObjectSkeleton::parent_instance"] [:: std :: mem :: offset_of ! (_GDBusObjectSkeleton , parent_instance) - 0usize] ; ["Offset of field: _GDBusObjectSkeleton::priv_"] [:: std :: mem :: offset_of ! (_GDBusObjectSkeleton , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusObjectSkeletonClass { pub parent_class : GObjectClass , pub authorize_method : :: std :: option :: Option < unsafe extern "C" fn (object : * mut GDBusObjectSkeleton , interface_ : * mut GDBusInterfaceSkeleton , invocation : * mut GDBusMethodInvocation) -> gboolean > , pub padding : [gpointer ; 8usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusObjectSkeletonClass"] [:: std :: mem :: size_of :: < _GDBusObjectSkeletonClass > () - 208usize] ; ["Alignment of _GDBusObjectSkeletonClass"] [:: std :: mem :: align_of :: < _GDBusObjectSkeletonClass > () - 8usize] ; ["Offset of field: _GDBusObjectSkeletonClass::parent_class"] [:: std :: mem :: offset_of ! (_GDBusObjectSkeletonClass , parent_class) - 0usize] ; ["Offset of field: _GDBusObjectSkeletonClass::authorize_method"] [:: std :: mem :: offset_of ! (_GDBusObjectSkeletonClass , authorize_method) - 136usize] ; ["Offset of field: _GDBusObjectSkeletonClass::padding"] [:: std :: mem :: offset_of ! (_GDBusObjectSkeletonClass , padding) - 144usize] ; } ; unsafe extern "C" { pub fn g_dbus_object_skeleton_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_object_skeleton_new (object_path : * const gchar) -> * mut GDBusObjectSkeleton ; } unsafe extern "C" { pub fn g_dbus_object_skeleton_flush (object : * mut GDBusObjectSkeleton) ; } unsafe extern "C" { pub fn g_dbus_object_skeleton_add_interface (object : * mut GDBusObjectSkeleton , interface_ : * mut GDBusInterfaceSkeleton) ; } unsafe extern "C" { pub fn g_dbus_object_skeleton_remove_interface (object : * mut GDBusObjectSkeleton , interface_ : * mut GDBusInterfaceSkeleton) ; } unsafe extern "C" { pub fn g_dbus_object_skeleton_remove_interface_by_name (object : * mut GDBusObjectSkeleton , interface_name : * const gchar) ; } unsafe extern "C" { pub fn g_dbus_object_skeleton_set_object_path (object : * mut GDBusObjectSkeleton , object_path : * const gchar) ; } pub type GDBusProxyClass = _GDBusProxyClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusProxyPrivate { _unused : [u8 ; 0] , } pub type GDBusProxyPrivate = _GDBusProxyPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusProxy { pub parent_instance : GObject , pub priv_ : * mut GDBusProxyPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusProxy"] [:: std :: mem :: size_of :: < _GDBusProxy > () - 32usize] ; ["Alignment of _GDBusProxy"] [:: std :: mem :: align_of :: < _GDBusProxy > () - 8usize] ; ["Offset of field: _GDBusProxy::parent_instance"] [:: std :: mem :: offset_of ! (_GDBusProxy , parent_instance) - 0usize] ; ["Offset of field: _GDBusProxy::priv_"] [:: std :: mem :: offset_of ! (_GDBusProxy , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDBusProxyClass { pub parent_class : GObjectClass , pub g_properties_changed : :: std :: option :: Option < unsafe extern "C" fn (proxy : * mut GDBusProxy , changed_properties : * mut GVariant , invalidated_properties : * const * const gchar) > , pub g_signal : :: std :: option :: Option < unsafe extern "C" fn (proxy : * mut GDBusProxy , sender_name : * const gchar , signal_name : * const gchar , parameters : * mut GVariant) > , pub padding : [gpointer ; 32usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDBusProxyClass"] [:: std :: mem :: size_of :: < _GDBusProxyClass > () - 408usize] ; ["Alignment of _GDBusProxyClass"] [:: std :: mem :: align_of :: < _GDBusProxyClass > () - 8usize] ; ["Offset of field: _GDBusProxyClass::parent_class"] [:: std :: mem :: offset_of ! (_GDBusProxyClass , parent_class) - 0usize] ; ["Offset of field: _GDBusProxyClass::g_properties_changed"] [:: std :: mem :: offset_of ! (_GDBusProxyClass , g_properties_changed) - 136usize] ; ["Offset of field: _GDBusProxyClass::g_signal"] [:: std :: mem :: offset_of ! (_GDBusProxyClass , g_signal) - 144usize] ; ["Offset of field: _GDBusProxyClass::padding"] [:: std :: mem :: offset_of ! (_GDBusProxyClass , padding) - 152usize] ; } ; unsafe extern "C" { pub fn g_dbus_proxy_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_proxy_new (connection : * mut GDBusConnection , flags : GDBusProxyFlags , info : * mut GDBusInterfaceInfo , name : * const gchar , object_path : * const gchar , interface_name : * const gchar , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dbus_proxy_new_finish (res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GDBusProxy ; } unsafe extern "C" { pub fn g_dbus_proxy_new_sync (connection : * mut GDBusConnection , flags : GDBusProxyFlags , info : * mut GDBusInterfaceInfo , name : * const gchar , object_path : * const gchar , interface_name : * const gchar , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GDBusProxy ; } unsafe extern "C" { pub fn g_dbus_proxy_new_for_bus (bus_type : GBusType , flags : GDBusProxyFlags , info : * mut GDBusInterfaceInfo , name : * const gchar , object_path : * const gchar , interface_name : * const gchar , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dbus_proxy_new_for_bus_finish (res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GDBusProxy ; } unsafe extern "C" { pub fn g_dbus_proxy_new_for_bus_sync (bus_type : GBusType , flags : GDBusProxyFlags , info : * mut GDBusInterfaceInfo , name : * const gchar , object_path : * const gchar , interface_name : * const gchar , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GDBusProxy ; } unsafe extern "C" { pub fn g_dbus_proxy_get_connection (proxy : * mut GDBusProxy) -> * mut GDBusConnection ; } unsafe extern "C" { pub fn g_dbus_proxy_get_flags (proxy : * mut GDBusProxy) -> GDBusProxyFlags ; } unsafe extern "C" { pub fn g_dbus_proxy_get_name (proxy : * mut GDBusProxy) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_proxy_get_name_owner (proxy : * mut GDBusProxy) -> * mut gchar ; } unsafe extern "C" { pub fn g_dbus_proxy_get_object_path (proxy : * mut GDBusProxy) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_proxy_get_interface_name (proxy : * mut GDBusProxy) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_proxy_get_default_timeout (proxy : * mut GDBusProxy) -> gint ; } unsafe extern "C" { pub fn g_dbus_proxy_set_default_timeout (proxy : * mut GDBusProxy , timeout_msec : gint) ; } unsafe extern "C" { pub fn g_dbus_proxy_get_interface_info (proxy : * mut GDBusProxy) -> * mut GDBusInterfaceInfo ; } unsafe extern "C" { pub fn g_dbus_proxy_set_interface_info (proxy : * mut GDBusProxy , info : * mut GDBusInterfaceInfo) ; } unsafe extern "C" { pub fn g_dbus_proxy_get_cached_property (proxy : * mut GDBusProxy , property_name : * const gchar) -> * mut GVariant ; } unsafe extern "C" { pub fn g_dbus_proxy_set_cached_property (proxy : * mut GDBusProxy , property_name : * const gchar , value : * mut GVariant) ; } unsafe extern "C" { pub fn g_dbus_proxy_get_cached_property_names (proxy : * mut GDBusProxy) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_dbus_proxy_call (proxy : * mut GDBusProxy , method_name : * const gchar , parameters : * mut GVariant , flags : GDBusCallFlags , timeout_msec : gint , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dbus_proxy_call_finish (proxy : * mut GDBusProxy , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GVariant ; } unsafe extern "C" { pub fn g_dbus_proxy_call_sync (proxy : * mut GDBusProxy , method_name : * const gchar , parameters : * mut GVariant , flags : GDBusCallFlags , timeout_msec : gint , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GVariant ; } unsafe extern "C" { pub fn g_dbus_proxy_call_with_unix_fd_list (proxy : * mut GDBusProxy , method_name : * const gchar , parameters : * mut GVariant , flags : GDBusCallFlags , timeout_msec : gint , fd_list : * mut GUnixFDList , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dbus_proxy_call_with_unix_fd_list_finish (proxy : * mut GDBusProxy , out_fd_list : * mut * mut GUnixFDList , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GVariant ; } unsafe extern "C" { pub fn g_dbus_proxy_call_with_unix_fd_list_sync (proxy : * mut GDBusProxy , method_name : * const gchar , parameters : * mut GVariant , flags : GDBusCallFlags , timeout_msec : gint , fd_list : * mut GUnixFDList , out_fd_list : * mut * mut GUnixFDList , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GVariant ; } unsafe extern "C" { pub fn g_dbus_server_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_server_new_sync (address : * const gchar , flags : GDBusServerFlags , guid : * const gchar , observer : * mut GDBusAuthObserver , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GDBusServer ; } unsafe extern "C" { pub fn g_dbus_server_get_client_address (server : * mut GDBusServer) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_server_get_guid (server : * mut GDBusServer) -> * const gchar ; } unsafe extern "C" { pub fn g_dbus_server_get_flags (server : * mut GDBusServer) -> GDBusServerFlags ; } unsafe extern "C" { pub fn g_dbus_server_start (server : * mut GDBusServer) ; } unsafe extern "C" { pub fn g_dbus_server_stop (server : * mut GDBusServer) ; } unsafe extern "C" { pub fn g_dbus_server_is_active (server : * mut GDBusServer) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_is_guid (string : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_generate_guid () -> * mut gchar ; } unsafe extern "C" { pub fn g_dbus_is_name (string : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_is_unique_name (string : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_is_member_name (string : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_is_interface_name (string : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_is_error_name (string : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_dbus_gvariant_to_gvalue (value : * mut GVariant , out_gvalue : * mut GValue) ; } unsafe extern "C" { pub fn g_dbus_gvalue_to_gvariant (gvalue : * const GValue , type_ : * const GVariantType) -> * mut GVariant ; } unsafe extern "C" { pub fn g_dbus_escape_object_path_bytestring (bytes : * const guint8) -> * mut gchar ; } unsafe extern "C" { pub fn g_dbus_escape_object_path (s : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_dbus_unescape_object_path (s : * const gchar) -> * mut guint8 ; } unsafe extern "C" { pub fn g_debug_controller_get_type () -> GType ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDebugController { _unused : [u8 ; 0] , } pub type GDebugController = _GDebugController ; pub type GDebugControllerInterface = _GDebugControllerInterface ; pub type GDebugController_autoptr = * mut GDebugController ; pub type GDebugController_listautoptr = * mut GList ; pub type GDebugController_slistautoptr = * mut GSList ; pub type GDebugController_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDebugControllerInterface { pub g_iface : GTypeInterface , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDebugControllerInterface"] [:: std :: mem :: size_of :: < _GDebugControllerInterface > () - 16usize] ; ["Alignment of _GDebugControllerInterface"] [:: std :: mem :: align_of :: < _GDebugControllerInterface > () - 8usize] ; ["Offset of field: _GDebugControllerInterface::g_iface"] [:: std :: mem :: offset_of ! (_GDebugControllerInterface , g_iface) - 0usize] ; } ; unsafe extern "C" { pub fn g_debug_controller_get_debug_enabled (self_ : * mut GDebugController) -> gboolean ; } unsafe extern "C" { pub fn g_debug_controller_set_debug_enabled (self_ : * mut GDebugController , debug_enabled : gboolean) ; } unsafe extern "C" { pub fn g_debug_controller_dbus_get_type () -> GType ; } pub type GDebugControllerDBus = _GDebugControllerDBus ; pub type GDebugControllerDBusClass = _GDebugControllerDBusClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDebugControllerDBus { pub parent_instance : GObject , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDebugControllerDBus"] [:: std :: mem :: size_of :: < _GDebugControllerDBus > () - 24usize] ; ["Alignment of _GDebugControllerDBus"] [:: std :: mem :: align_of :: < _GDebugControllerDBus > () - 8usize] ; ["Offset of field: _GDebugControllerDBus::parent_instance"] [:: std :: mem :: offset_of ! (_GDebugControllerDBus , parent_instance) - 0usize] ; } ; pub type GDebugControllerDBus_autoptr = * mut GDebugControllerDBus ; pub type GDebugControllerDBus_listautoptr = * mut GList ; pub type GDebugControllerDBus_slistautoptr = * mut GSList ; pub type GDebugControllerDBus_queueautoptr = * mut GQueue ; pub type GDebugControllerDBusClass_autoptr = * mut GDebugControllerDBusClass ; pub type GDebugControllerDBusClass_listautoptr = * mut GList ; pub type GDebugControllerDBusClass_slistautoptr = * mut GSList ; pub type GDebugControllerDBusClass_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDebugControllerDBusClass { pub parent_class : GObjectClass , pub authorize : :: std :: option :: Option < unsafe extern "C" fn (controller : * mut GDebugControllerDBus , invocation : * mut GDBusMethodInvocation) -> gboolean > , pub padding : [gpointer ; 12usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDebugControllerDBusClass"] [:: std :: mem :: size_of :: < _GDebugControllerDBusClass > () - 240usize] ; ["Alignment of _GDebugControllerDBusClass"] [:: std :: mem :: align_of :: < _GDebugControllerDBusClass > () - 8usize] ; ["Offset of field: _GDebugControllerDBusClass::parent_class"] [:: std :: mem :: offset_of ! (_GDebugControllerDBusClass , parent_class) - 0usize] ; ["Offset of field: _GDebugControllerDBusClass::authorize"] [:: std :: mem :: offset_of ! (_GDebugControllerDBusClass , authorize) - 136usize] ; ["Offset of field: _GDebugControllerDBusClass::padding"] [:: std :: mem :: offset_of ! (_GDebugControllerDBusClass , padding) - 144usize] ; } ; unsafe extern "C" { pub fn g_debug_controller_dbus_new (connection : * mut GDBusConnection , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GDebugControllerDBus ; } unsafe extern "C" { pub fn g_debug_controller_dbus_stop (self_ : * mut GDebugControllerDBus) ; } pub type GDriveIface = _GDriveIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDriveIface { pub g_iface : GTypeInterface , pub changed : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) > , pub disconnected : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) > , pub eject_button : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) > , pub get_name : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> * mut :: std :: os :: raw :: c_char > , pub get_icon : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> * mut GIcon > , pub has_volumes : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> gboolean > , pub get_volumes : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> * mut GList > , pub is_media_removable : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> gboolean > , pub has_media : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> gboolean > , pub is_media_check_automatic : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> gboolean > , pub can_eject : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> gboolean > , pub can_poll_for_media : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> gboolean > , pub eject : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive , flags : GMountUnmountFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub eject_finish : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub poll_for_media : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub poll_for_media_finish : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub get_identifier : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive , kind : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char > , pub enumerate_identifiers : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> * mut * mut :: std :: os :: raw :: c_char > , pub get_start_stop_type : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> GDriveStartStopType > , pub can_start : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> gboolean > , pub can_start_degraded : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> gboolean > , pub start : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive , flags : GDriveStartFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub start_finish : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub can_stop : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> gboolean > , pub stop : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub stop_finish : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub stop_button : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) > , pub eject_with_operation : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub eject_with_operation_finish : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub get_sort_key : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> * const gchar > , pub get_symbolic_icon : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> * mut GIcon > , pub is_removable : :: std :: option :: Option < unsafe extern "C" fn (drive : * mut GDrive) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDriveIface"] [:: std :: mem :: size_of :: < _GDriveIface > () - 272usize] ; ["Alignment of _GDriveIface"] [:: std :: mem :: align_of :: < _GDriveIface > () - 8usize] ; ["Offset of field: _GDriveIface::g_iface"] [:: std :: mem :: offset_of ! (_GDriveIface , g_iface) - 0usize] ; ["Offset of field: _GDriveIface::changed"] [:: std :: mem :: offset_of ! (_GDriveIface , changed) - 16usize] ; ["Offset of field: _GDriveIface::disconnected"] [:: std :: mem :: offset_of ! (_GDriveIface , disconnected) - 24usize] ; ["Offset of field: _GDriveIface::eject_button"] [:: std :: mem :: offset_of ! (_GDriveIface , eject_button) - 32usize] ; ["Offset of field: _GDriveIface::get_name"] [:: std :: mem :: offset_of ! (_GDriveIface , get_name) - 40usize] ; ["Offset of field: _GDriveIface::get_icon"] [:: std :: mem :: offset_of ! (_GDriveIface , get_icon) - 48usize] ; ["Offset of field: _GDriveIface::has_volumes"] [:: std :: mem :: offset_of ! (_GDriveIface , has_volumes) - 56usize] ; ["Offset of field: _GDriveIface::get_volumes"] [:: std :: mem :: offset_of ! (_GDriveIface , get_volumes) - 64usize] ; ["Offset of field: _GDriveIface::is_media_removable"] [:: std :: mem :: offset_of ! (_GDriveIface , is_media_removable) - 72usize] ; ["Offset of field: _GDriveIface::has_media"] [:: std :: mem :: offset_of ! (_GDriveIface , has_media) - 80usize] ; ["Offset of field: _GDriveIface::is_media_check_automatic"] [:: std :: mem :: offset_of ! (_GDriveIface , is_media_check_automatic) - 88usize] ; ["Offset of field: _GDriveIface::can_eject"] [:: std :: mem :: offset_of ! (_GDriveIface , can_eject) - 96usize] ; ["Offset of field: _GDriveIface::can_poll_for_media"] [:: std :: mem :: offset_of ! (_GDriveIface , can_poll_for_media) - 104usize] ; ["Offset of field: _GDriveIface::eject"] [:: std :: mem :: offset_of ! (_GDriveIface , eject) - 112usize] ; ["Offset of field: _GDriveIface::eject_finish"] [:: std :: mem :: offset_of ! (_GDriveIface , eject_finish) - 120usize] ; ["Offset of field: _GDriveIface::poll_for_media"] [:: std :: mem :: offset_of ! (_GDriveIface , poll_for_media) - 128usize] ; ["Offset of field: _GDriveIface::poll_for_media_finish"] [:: std :: mem :: offset_of ! (_GDriveIface , poll_for_media_finish) - 136usize] ; ["Offset of field: _GDriveIface::get_identifier"] [:: std :: mem :: offset_of ! (_GDriveIface , get_identifier) - 144usize] ; ["Offset of field: _GDriveIface::enumerate_identifiers"] [:: std :: mem :: offset_of ! (_GDriveIface , enumerate_identifiers) - 152usize] ; ["Offset of field: _GDriveIface::get_start_stop_type"] [:: std :: mem :: offset_of ! (_GDriveIface , get_start_stop_type) - 160usize] ; ["Offset of field: _GDriveIface::can_start"] [:: std :: mem :: offset_of ! (_GDriveIface , can_start) - 168usize] ; ["Offset of field: _GDriveIface::can_start_degraded"] [:: std :: mem :: offset_of ! (_GDriveIface , can_start_degraded) - 176usize] ; ["Offset of field: _GDriveIface::start"] [:: std :: mem :: offset_of ! (_GDriveIface , start) - 184usize] ; ["Offset of field: _GDriveIface::start_finish"] [:: std :: mem :: offset_of ! (_GDriveIface , start_finish) - 192usize] ; ["Offset of field: _GDriveIface::can_stop"] [:: std :: mem :: offset_of ! (_GDriveIface , can_stop) - 200usize] ; ["Offset of field: _GDriveIface::stop"] [:: std :: mem :: offset_of ! (_GDriveIface , stop) - 208usize] ; ["Offset of field: _GDriveIface::stop_finish"] [:: std :: mem :: offset_of ! (_GDriveIface , stop_finish) - 216usize] ; ["Offset of field: _GDriveIface::stop_button"] [:: std :: mem :: offset_of ! (_GDriveIface , stop_button) - 224usize] ; ["Offset of field: _GDriveIface::eject_with_operation"] [:: std :: mem :: offset_of ! (_GDriveIface , eject_with_operation) - 232usize] ; ["Offset of field: _GDriveIface::eject_with_operation_finish"] [:: std :: mem :: offset_of ! (_GDriveIface , eject_with_operation_finish) - 240usize] ; ["Offset of field: _GDriveIface::get_sort_key"] [:: std :: mem :: offset_of ! (_GDriveIface , get_sort_key) - 248usize] ; ["Offset of field: _GDriveIface::get_symbolic_icon"] [:: std :: mem :: offset_of ! (_GDriveIface , get_symbolic_icon) - 256usize] ; ["Offset of field: _GDriveIface::is_removable"] [:: std :: mem :: offset_of ! (_GDriveIface , is_removable) - 264usize] ; } ; unsafe extern "C" { pub fn g_drive_get_type () -> GType ; } unsafe extern "C" { pub fn g_drive_get_name (drive : * mut GDrive) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_drive_get_icon (drive : * mut GDrive) -> * mut GIcon ; } unsafe extern "C" { pub fn g_drive_get_symbolic_icon (drive : * mut GDrive) -> * mut GIcon ; } unsafe extern "C" { pub fn g_drive_has_volumes (drive : * mut GDrive) -> gboolean ; } unsafe extern "C" { pub fn g_drive_get_volumes (drive : * mut GDrive) -> * mut GList ; } unsafe extern "C" { pub fn g_drive_is_removable (drive : * mut GDrive) -> gboolean ; } unsafe extern "C" { pub fn g_drive_is_media_removable (drive : * mut GDrive) -> gboolean ; } unsafe extern "C" { pub fn g_drive_has_media (drive : * mut GDrive) -> gboolean ; } unsafe extern "C" { pub fn g_drive_is_media_check_automatic (drive : * mut GDrive) -> gboolean ; } unsafe extern "C" { pub fn g_drive_can_poll_for_media (drive : * mut GDrive) -> gboolean ; } unsafe extern "C" { pub fn g_drive_can_eject (drive : * mut GDrive) -> gboolean ; } unsafe extern "C" { pub fn g_drive_eject (drive : * mut GDrive , flags : GMountUnmountFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_drive_eject_finish (drive : * mut GDrive , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_drive_poll_for_media (drive : * mut GDrive , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_drive_poll_for_media_finish (drive : * mut GDrive , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_drive_get_identifier (drive : * mut GDrive , kind : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_drive_enumerate_identifiers (drive : * mut GDrive) -> * mut * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_drive_get_start_stop_type (drive : * mut GDrive) -> GDriveStartStopType ; } unsafe extern "C" { pub fn g_drive_can_start (drive : * mut GDrive) -> gboolean ; } unsafe extern "C" { pub fn g_drive_can_start_degraded (drive : * mut GDrive) -> gboolean ; } unsafe extern "C" { pub fn g_drive_start (drive : * mut GDrive , flags : GDriveStartFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_drive_start_finish (drive : * mut GDrive , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_drive_can_stop (drive : * mut GDrive) -> gboolean ; } unsafe extern "C" { pub fn g_drive_stop (drive : * mut GDrive , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_drive_stop_finish (drive : * mut GDrive , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_drive_eject_with_operation (drive : * mut GDrive , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_drive_eject_with_operation_finish (drive : * mut GDrive , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_drive_get_sort_key (drive : * mut GDrive) -> * const gchar ; } pub type GDtlsConnectionInterface = _GDtlsConnectionInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDtlsConnectionInterface { pub g_iface : GTypeInterface , pub accept_certificate : :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GDtlsConnection , peer_cert : * mut GTlsCertificate , errors : GTlsCertificateFlags) -> gboolean > , pub handshake : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GDtlsConnection , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub handshake_async : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GDtlsConnection , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub handshake_finish : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GDtlsConnection , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub shutdown : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GDtlsConnection , shutdown_read : gboolean , shutdown_write : gboolean , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub shutdown_async : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GDtlsConnection , shutdown_read : gboolean , shutdown_write : gboolean , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub shutdown_finish : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GDtlsConnection , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub set_advertised_protocols : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GDtlsConnection , protocols : * const * const gchar) > , pub get_negotiated_protocol : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GDtlsConnection) -> * const gchar > , pub get_binding_data : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GDtlsConnection , type_ : GTlsChannelBindingType , data : * mut GByteArray , error : * mut * mut GError) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDtlsConnectionInterface"] [:: std :: mem :: size_of :: < _GDtlsConnectionInterface > () - 96usize] ; ["Alignment of _GDtlsConnectionInterface"] [:: std :: mem :: align_of :: < _GDtlsConnectionInterface > () - 8usize] ; ["Offset of field: _GDtlsConnectionInterface::g_iface"] [:: std :: mem :: offset_of ! (_GDtlsConnectionInterface , g_iface) - 0usize] ; ["Offset of field: _GDtlsConnectionInterface::accept_certificate"] [:: std :: mem :: offset_of ! (_GDtlsConnectionInterface , accept_certificate) - 16usize] ; ["Offset of field: _GDtlsConnectionInterface::handshake"] [:: std :: mem :: offset_of ! (_GDtlsConnectionInterface , handshake) - 24usize] ; ["Offset of field: _GDtlsConnectionInterface::handshake_async"] [:: std :: mem :: offset_of ! (_GDtlsConnectionInterface , handshake_async) - 32usize] ; ["Offset of field: _GDtlsConnectionInterface::handshake_finish"] [:: std :: mem :: offset_of ! (_GDtlsConnectionInterface , handshake_finish) - 40usize] ; ["Offset of field: _GDtlsConnectionInterface::shutdown"] [:: std :: mem :: offset_of ! (_GDtlsConnectionInterface , shutdown) - 48usize] ; ["Offset of field: _GDtlsConnectionInterface::shutdown_async"] [:: std :: mem :: offset_of ! (_GDtlsConnectionInterface , shutdown_async) - 56usize] ; ["Offset of field: _GDtlsConnectionInterface::shutdown_finish"] [:: std :: mem :: offset_of ! (_GDtlsConnectionInterface , shutdown_finish) - 64usize] ; ["Offset of field: _GDtlsConnectionInterface::set_advertised_protocols"] [:: std :: mem :: offset_of ! (_GDtlsConnectionInterface , set_advertised_protocols) - 72usize] ; ["Offset of field: _GDtlsConnectionInterface::get_negotiated_protocol"] [:: std :: mem :: offset_of ! (_GDtlsConnectionInterface , get_negotiated_protocol) - 80usize] ; ["Offset of field: _GDtlsConnectionInterface::get_binding_data"] [:: std :: mem :: offset_of ! (_GDtlsConnectionInterface , get_binding_data) - 88usize] ; } ; unsafe extern "C" { pub fn g_dtls_connection_get_type () -> GType ; } unsafe extern "C" { pub fn g_dtls_connection_set_database (conn : * mut GDtlsConnection , database : * mut GTlsDatabase) ; } unsafe extern "C" { pub fn g_dtls_connection_get_database (conn : * mut GDtlsConnection) -> * mut GTlsDatabase ; } unsafe extern "C" { pub fn g_dtls_connection_set_certificate (conn : * mut GDtlsConnection , certificate : * mut GTlsCertificate) ; } unsafe extern "C" { pub fn g_dtls_connection_get_certificate (conn : * mut GDtlsConnection) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_dtls_connection_set_interaction (conn : * mut GDtlsConnection , interaction : * mut GTlsInteraction) ; } unsafe extern "C" { pub fn g_dtls_connection_get_interaction (conn : * mut GDtlsConnection) -> * mut GTlsInteraction ; } unsafe extern "C" { pub fn g_dtls_connection_get_peer_certificate (conn : * mut GDtlsConnection) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_dtls_connection_get_peer_certificate_errors (conn : * mut GDtlsConnection) -> GTlsCertificateFlags ; } unsafe extern "C" { pub fn g_dtls_connection_set_require_close_notify (conn : * mut GDtlsConnection , require_close_notify : gboolean) ; } unsafe extern "C" { pub fn g_dtls_connection_get_require_close_notify (conn : * mut GDtlsConnection) -> gboolean ; } unsafe extern "C" { pub fn g_dtls_connection_set_rehandshake_mode (conn : * mut GDtlsConnection , mode : GTlsRehandshakeMode) ; } unsafe extern "C" { pub fn g_dtls_connection_get_rehandshake_mode (conn : * mut GDtlsConnection) -> GTlsRehandshakeMode ; } unsafe extern "C" { pub fn g_dtls_connection_handshake (conn : * mut GDtlsConnection , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dtls_connection_handshake_async (conn : * mut GDtlsConnection , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dtls_connection_handshake_finish (conn : * mut GDtlsConnection , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dtls_connection_shutdown (conn : * mut GDtlsConnection , shutdown_read : gboolean , shutdown_write : gboolean , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dtls_connection_shutdown_async (conn : * mut GDtlsConnection , shutdown_read : gboolean , shutdown_write : gboolean , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dtls_connection_shutdown_finish (conn : * mut GDtlsConnection , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dtls_connection_close (conn : * mut GDtlsConnection , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dtls_connection_close_async (conn : * mut GDtlsConnection , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_dtls_connection_close_finish (conn : * mut GDtlsConnection , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dtls_connection_emit_accept_certificate (conn : * mut GDtlsConnection , peer_cert : * mut GTlsCertificate , errors : GTlsCertificateFlags) -> gboolean ; } unsafe extern "C" { pub fn g_dtls_connection_set_advertised_protocols (conn : * mut GDtlsConnection , protocols : * const * const gchar) ; } unsafe extern "C" { pub fn g_dtls_connection_get_negotiated_protocol (conn : * mut GDtlsConnection) -> * const gchar ; } unsafe extern "C" { pub fn g_dtls_connection_get_channel_binding_data (conn : * mut GDtlsConnection , type_ : GTlsChannelBindingType , data : * mut GByteArray , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_dtls_connection_get_protocol_version (conn : * mut GDtlsConnection) -> GTlsProtocolVersion ; } unsafe extern "C" { pub fn g_dtls_connection_get_ciphersuite_name (conn : * mut GDtlsConnection) -> * mut gchar ; } pub type GDtlsClientConnectionInterface = _GDtlsClientConnectionInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDtlsClientConnectionInterface { pub g_iface : GTypeInterface , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDtlsClientConnectionInterface"] [:: std :: mem :: size_of :: < _GDtlsClientConnectionInterface > () - 16usize] ; ["Alignment of _GDtlsClientConnectionInterface"] [:: std :: mem :: align_of :: < _GDtlsClientConnectionInterface > () - 8usize] ; ["Offset of field: _GDtlsClientConnectionInterface::g_iface"] [:: std :: mem :: offset_of ! (_GDtlsClientConnectionInterface , g_iface) - 0usize] ; } ; unsafe extern "C" { pub fn g_dtls_client_connection_get_type () -> GType ; } unsafe extern "C" { pub fn g_dtls_client_connection_new (base_socket : * mut GDatagramBased , server_identity : * mut GSocketConnectable , error : * mut * mut GError) -> * mut GDatagramBased ; } unsafe extern "C" { pub fn g_dtls_client_connection_get_validation_flags (conn : * mut GDtlsClientConnection) -> GTlsCertificateFlags ; } unsafe extern "C" { pub fn g_dtls_client_connection_set_validation_flags (conn : * mut GDtlsClientConnection , flags : GTlsCertificateFlags) ; } unsafe extern "C" { pub fn g_dtls_client_connection_get_server_identity (conn : * mut GDtlsClientConnection) -> * mut GSocketConnectable ; } unsafe extern "C" { pub fn g_dtls_client_connection_set_server_identity (conn : * mut GDtlsClientConnection , identity : * mut GSocketConnectable) ; } unsafe extern "C" { pub fn g_dtls_client_connection_get_accepted_cas (conn : * mut GDtlsClientConnection) -> * mut GList ; } pub type GDtlsServerConnectionInterface = _GDtlsServerConnectionInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GDtlsServerConnectionInterface { pub g_iface : GTypeInterface , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GDtlsServerConnectionInterface"] [:: std :: mem :: size_of :: < _GDtlsServerConnectionInterface > () - 16usize] ; ["Alignment of _GDtlsServerConnectionInterface"] [:: std :: mem :: align_of :: < _GDtlsServerConnectionInterface > () - 8usize] ; ["Offset of field: _GDtlsServerConnectionInterface::g_iface"] [:: std :: mem :: offset_of ! (_GDtlsServerConnectionInterface , g_iface) - 0usize] ; } ; unsafe extern "C" { pub fn g_dtls_server_connection_get_type () -> GType ; } unsafe extern "C" { pub fn g_dtls_server_connection_new (base_socket : * mut GDatagramBased , certificate : * mut GTlsCertificate , error : * mut * mut GError) -> * mut GDatagramBased ; } pub type GIconIface = _GIconIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIconIface { pub g_iface : GTypeInterface , pub hash : :: std :: option :: Option < unsafe extern "C" fn (icon : * mut GIcon) -> guint > , pub equal : :: std :: option :: Option < unsafe extern "C" fn (icon1 : * mut GIcon , icon2 : * mut GIcon) -> gboolean > , pub to_tokens : :: std :: option :: Option < unsafe extern "C" fn (icon : * mut GIcon , tokens : * mut GPtrArray , out_version : * mut gint) -> gboolean > , pub from_tokens : :: std :: option :: Option < unsafe extern "C" fn (tokens : * mut * mut gchar , num_tokens : gint , version : gint , error : * mut * mut GError) -> * mut GIcon > , pub serialize : :: std :: option :: Option < unsafe extern "C" fn (icon : * mut GIcon) -> * mut GVariant > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GIconIface"] [:: std :: mem :: size_of :: < _GIconIface > () - 56usize] ; ["Alignment of _GIconIface"] [:: std :: mem :: align_of :: < _GIconIface > () - 8usize] ; ["Offset of field: _GIconIface::g_iface"] [:: std :: mem :: offset_of ! (_GIconIface , g_iface) - 0usize] ; ["Offset of field: _GIconIface::hash"] [:: std :: mem :: offset_of ! (_GIconIface , hash) - 16usize] ; ["Offset of field: _GIconIface::equal"] [:: std :: mem :: offset_of ! (_GIconIface , equal) - 24usize] ; ["Offset of field: _GIconIface::to_tokens"] [:: std :: mem :: offset_of ! (_GIconIface , to_tokens) - 32usize] ; ["Offset of field: _GIconIface::from_tokens"] [:: std :: mem :: offset_of ! (_GIconIface , from_tokens) - 40usize] ; ["Offset of field: _GIconIface::serialize"] [:: std :: mem :: offset_of ! (_GIconIface , serialize) - 48usize] ; } ; unsafe extern "C" { pub fn g_icon_get_type () -> GType ; } unsafe extern "C" { pub fn g_icon_hash (icon : gconstpointer) -> guint ; } unsafe extern "C" { pub fn g_icon_equal (icon1 : * mut GIcon , icon2 : * mut GIcon) -> gboolean ; } unsafe extern "C" { pub fn g_icon_to_string (icon : * mut GIcon) -> * mut gchar ; } unsafe extern "C" { pub fn g_icon_new_for_string (str_ : * const gchar , error : * mut * mut GError) -> * mut GIcon ; } unsafe extern "C" { pub fn g_icon_serialize (icon : * mut GIcon) -> * mut GVariant ; } unsafe extern "C" { pub fn g_icon_deserialize (value : * mut GVariant) -> * mut GIcon ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GEmblem { _unused : [u8 ; 0] , } pub type GEmblem = _GEmblem ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GEmblemClass { _unused : [u8 ; 0] , } pub type GEmblemClass = _GEmblemClass ; unsafe extern "C" { pub fn g_emblem_get_type () -> GType ; } unsafe extern "C" { pub fn g_emblem_new (icon : * mut GIcon) -> * mut GEmblem ; } unsafe extern "C" { pub fn g_emblem_new_with_origin (icon : * mut GIcon , origin : GEmblemOrigin) -> * mut GEmblem ; } unsafe extern "C" { pub fn g_emblem_get_icon (emblem : * mut GEmblem) -> * mut GIcon ; } unsafe extern "C" { pub fn g_emblem_get_origin (emblem : * mut GEmblem) -> GEmblemOrigin ; } pub type GEmblemedIcon = _GEmblemedIcon ; pub type GEmblemedIconClass = _GEmblemedIconClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GEmblemedIconPrivate { _unused : [u8 ; 0] , } pub type GEmblemedIconPrivate = _GEmblemedIconPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GEmblemedIcon { pub parent_instance : GObject , pub priv_ : * mut GEmblemedIconPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GEmblemedIcon"] [:: std :: mem :: size_of :: < _GEmblemedIcon > () - 32usize] ; ["Alignment of _GEmblemedIcon"] [:: std :: mem :: align_of :: < _GEmblemedIcon > () - 8usize] ; ["Offset of field: _GEmblemedIcon::parent_instance"] [:: std :: mem :: offset_of ! (_GEmblemedIcon , parent_instance) - 0usize] ; ["Offset of field: _GEmblemedIcon::priv_"] [:: std :: mem :: offset_of ! (_GEmblemedIcon , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GEmblemedIconClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GEmblemedIconClass"] [:: std :: mem :: size_of :: < _GEmblemedIconClass > () - 136usize] ; ["Alignment of _GEmblemedIconClass"] [:: std :: mem :: align_of :: < _GEmblemedIconClass > () - 8usize] ; ["Offset of field: _GEmblemedIconClass::parent_class"] [:: std :: mem :: offset_of ! (_GEmblemedIconClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn g_emblemed_icon_get_type () -> GType ; } unsafe extern "C" { pub fn g_emblemed_icon_new (icon : * mut GIcon , emblem : * mut GEmblem) -> * mut GIcon ; } unsafe extern "C" { pub fn g_emblemed_icon_get_icon (emblemed : * mut GEmblemedIcon) -> * mut GIcon ; } unsafe extern "C" { pub fn g_emblemed_icon_get_emblems (emblemed : * mut GEmblemedIcon) -> * mut GList ; } unsafe extern "C" { pub fn g_emblemed_icon_add_emblem (emblemed : * mut GEmblemedIcon , emblem : * mut GEmblem) ; } unsafe extern "C" { pub fn g_emblemed_icon_clear_emblems (emblemed : * mut GEmblemedIcon) ; } pub type GFileIface = _GFileIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileIface { pub g_iface : GTypeInterface , pub dup : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile) -> * mut GFile > , pub hash : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile) -> guint > , pub equal : :: std :: option :: Option < unsafe extern "C" fn (file1 : * mut GFile , file2 : * mut GFile) -> gboolean > , pub is_native : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile) -> gboolean > , pub has_uri_scheme : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , uri_scheme : * const :: std :: os :: raw :: c_char) -> gboolean > , pub get_uri_scheme : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile) -> * mut :: std :: os :: raw :: c_char > , pub get_basename : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile) -> * mut :: std :: os :: raw :: c_char > , pub get_path : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile) -> * mut :: std :: os :: raw :: c_char > , pub get_uri : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile) -> * mut :: std :: os :: raw :: c_char > , pub get_parse_name : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile) -> * mut :: std :: os :: raw :: c_char > , pub get_parent : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile) -> * mut GFile > , pub prefix_matches : :: std :: option :: Option < unsafe extern "C" fn (prefix : * mut GFile , file : * mut GFile) -> gboolean > , pub get_relative_path : :: std :: option :: Option < unsafe extern "C" fn (parent : * mut GFile , descendant : * mut GFile) -> * mut :: std :: os :: raw :: c_char > , pub resolve_relative_path : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , relative_path : * const :: std :: os :: raw :: c_char) -> * mut GFile > , pub get_child_for_display_name : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , display_name : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> * mut GFile > , pub enumerate_children : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , attributes : * const :: std :: os :: raw :: c_char , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileEnumerator > , pub enumerate_children_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , attributes : * const :: std :: os :: raw :: c_char , flags : GFileQueryInfoFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub enumerate_children_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileEnumerator > , pub query_info : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , attributes : * const :: std :: os :: raw :: c_char , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileInfo > , pub query_info_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , attributes : * const :: std :: os :: raw :: c_char , flags : GFileQueryInfoFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub query_info_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileInfo > , pub query_filesystem_info : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , attributes : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileInfo > , pub query_filesystem_info_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , attributes : * const :: std :: os :: raw :: c_char , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub query_filesystem_info_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileInfo > , pub find_enclosing_mount : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GMount > , pub find_enclosing_mount_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub find_enclosing_mount_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GMount > , pub set_display_name : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , display_name : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFile > , pub set_display_name_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , display_name : * const :: std :: os :: raw :: c_char , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub set_display_name_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFile > , pub query_settable_attributes : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileAttributeInfoList > , pub _query_settable_attributes_async : :: std :: option :: Option < unsafe extern "C" fn () > , pub _query_settable_attributes_finish : :: std :: option :: Option < unsafe extern "C" fn () > , pub query_writable_namespaces : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileAttributeInfoList > , pub _query_writable_namespaces_async : :: std :: option :: Option < unsafe extern "C" fn () > , pub _query_writable_namespaces_finish : :: std :: option :: Option < unsafe extern "C" fn () > , pub set_attribute : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , attribute : * const :: std :: os :: raw :: c_char , type_ : GFileAttributeType , value_p : gpointer , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub set_attributes_from_info : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , info : * mut GFileInfo , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub set_attributes_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , info : * mut GFileInfo , flags : GFileQueryInfoFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub set_attributes_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , info : * mut * mut GFileInfo , error : * mut * mut GError) -> gboolean > , pub read_fn : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileInputStream > , pub read_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub read_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileInputStream > , pub append_to : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GFileCreateFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileOutputStream > , pub append_to_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GFileCreateFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub append_to_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileOutputStream > , pub create : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GFileCreateFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileOutputStream > , pub create_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GFileCreateFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub create_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileOutputStream > , pub replace : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , etag : * const :: std :: os :: raw :: c_char , make_backup : gboolean , flags : GFileCreateFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileOutputStream > , pub replace_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , etag : * const :: std :: os :: raw :: c_char , make_backup : gboolean , flags : GFileCreateFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub replace_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileOutputStream > , pub delete_file : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub delete_file_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub delete_file_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub trash : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub trash_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub trash_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub make_directory : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub make_directory_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub make_directory_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub make_symbolic_link : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , symlink_value : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub make_symbolic_link_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , symlink_value : * const :: std :: os :: raw :: c_char , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub make_symbolic_link_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub copy : :: std :: option :: Option < unsafe extern "C" fn (source : * mut GFile , destination : * mut GFile , flags : GFileCopyFlags , cancellable : * mut GCancellable , progress_callback : GFileProgressCallback , progress_callback_data : gpointer , error : * mut * mut GError) -> gboolean > , pub copy_async : :: std :: option :: Option < unsafe extern "C" fn (source : * mut GFile , destination : * mut GFile , flags : GFileCopyFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , progress_callback : GFileProgressCallback , progress_callback_data : gpointer , callback : GAsyncReadyCallback , user_data : gpointer) > , pub copy_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub move_ : :: std :: option :: Option < unsafe extern "C" fn (source : * mut GFile , destination : * mut GFile , flags : GFileCopyFlags , cancellable : * mut GCancellable , progress_callback : GFileProgressCallback , progress_callback_data : gpointer , error : * mut * mut GError) -> gboolean > , pub move_async : :: std :: option :: Option < unsafe extern "C" fn (source : * mut GFile , destination : * mut GFile , flags : GFileCopyFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , progress_callback : GFileProgressCallback , progress_callback_data : gpointer , callback : GAsyncReadyCallback , user_data : gpointer) > , pub move_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub mount_mountable : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GMountMountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub mount_mountable_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFile > , pub unmount_mountable : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GMountUnmountFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub unmount_mountable_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub eject_mountable : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GMountUnmountFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub eject_mountable_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub mount_enclosing_volume : :: std :: option :: Option < unsafe extern "C" fn (location : * mut GFile , flags : GMountMountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub mount_enclosing_volume_finish : :: std :: option :: Option < unsafe extern "C" fn (location : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub monitor_dir : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GFileMonitorFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileMonitor > , pub monitor_file : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GFileMonitorFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileMonitor > , pub open_readwrite : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileIOStream > , pub open_readwrite_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub open_readwrite_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileIOStream > , pub create_readwrite : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GFileCreateFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileIOStream > , pub create_readwrite_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GFileCreateFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub create_readwrite_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileIOStream > , pub replace_readwrite : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , etag : * const :: std :: os :: raw :: c_char , make_backup : gboolean , flags : GFileCreateFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileIOStream > , pub replace_readwrite_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , etag : * const :: std :: os :: raw :: c_char , make_backup : gboolean , flags : GFileCreateFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub replace_readwrite_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileIOStream > , pub start_mountable : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GDriveStartFlags , start_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub start_mountable_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub stop_mountable : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub stop_mountable_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub supports_thread_contexts : gboolean , pub unmount_mountable_with_operation : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub unmount_mountable_with_operation_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub eject_mountable_with_operation : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub eject_mountable_with_operation_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub poll_mountable : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub poll_mountable_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub measure_disk_usage : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GFileMeasureFlags , cancellable : * mut GCancellable , progress_callback : GFileMeasureProgressCallback , progress_data : gpointer , disk_usage : * mut guint64 , num_dirs : * mut guint64 , num_files : * mut guint64 , error : * mut * mut GError) -> gboolean > , pub measure_disk_usage_async : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , flags : GFileMeasureFlags , io_priority : gint , cancellable : * mut GCancellable , progress_callback : GFileMeasureProgressCallback , progress_data : gpointer , callback : GAsyncReadyCallback , user_data : gpointer) > , pub measure_disk_usage_finish : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , result : * mut GAsyncResult , disk_usage : * mut guint64 , num_dirs : * mut guint64 , num_files : * mut guint64 , error : * mut * mut GError) -> gboolean > , pub query_exists : :: std :: option :: Option < unsafe extern "C" fn (file : * mut GFile , cancellable : * mut GCancellable) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFileIface"] [:: std :: mem :: size_of :: < _GFileIface > () - 848usize] ; ["Alignment of _GFileIface"] [:: std :: mem :: align_of :: < _GFileIface > () - 8usize] ; ["Offset of field: _GFileIface::g_iface"] [:: std :: mem :: offset_of ! (_GFileIface , g_iface) - 0usize] ; ["Offset of field: _GFileIface::dup"] [:: std :: mem :: offset_of ! (_GFileIface , dup) - 16usize] ; ["Offset of field: _GFileIface::hash"] [:: std :: mem :: offset_of ! (_GFileIface , hash) - 24usize] ; ["Offset of field: _GFileIface::equal"] [:: std :: mem :: offset_of ! (_GFileIface , equal) - 32usize] ; ["Offset of field: _GFileIface::is_native"] [:: std :: mem :: offset_of ! (_GFileIface , is_native) - 40usize] ; ["Offset of field: _GFileIface::has_uri_scheme"] [:: std :: mem :: offset_of ! (_GFileIface , has_uri_scheme) - 48usize] ; ["Offset of field: _GFileIface::get_uri_scheme"] [:: std :: mem :: offset_of ! (_GFileIface , get_uri_scheme) - 56usize] ; ["Offset of field: _GFileIface::get_basename"] [:: std :: mem :: offset_of ! (_GFileIface , get_basename) - 64usize] ; ["Offset of field: _GFileIface::get_path"] [:: std :: mem :: offset_of ! (_GFileIface , get_path) - 72usize] ; ["Offset of field: _GFileIface::get_uri"] [:: std :: mem :: offset_of ! (_GFileIface , get_uri) - 80usize] ; ["Offset of field: _GFileIface::get_parse_name"] [:: std :: mem :: offset_of ! (_GFileIface , get_parse_name) - 88usize] ; ["Offset of field: _GFileIface::get_parent"] [:: std :: mem :: offset_of ! (_GFileIface , get_parent) - 96usize] ; ["Offset of field: _GFileIface::prefix_matches"] [:: std :: mem :: offset_of ! (_GFileIface , prefix_matches) - 104usize] ; ["Offset of field: _GFileIface::get_relative_path"] [:: std :: mem :: offset_of ! (_GFileIface , get_relative_path) - 112usize] ; ["Offset of field: _GFileIface::resolve_relative_path"] [:: std :: mem :: offset_of ! (_GFileIface , resolve_relative_path) - 120usize] ; ["Offset of field: _GFileIface::get_child_for_display_name"] [:: std :: mem :: offset_of ! (_GFileIface , get_child_for_display_name) - 128usize] ; ["Offset of field: _GFileIface::enumerate_children"] [:: std :: mem :: offset_of ! (_GFileIface , enumerate_children) - 136usize] ; ["Offset of field: _GFileIface::enumerate_children_async"] [:: std :: mem :: offset_of ! (_GFileIface , enumerate_children_async) - 144usize] ; ["Offset of field: _GFileIface::enumerate_children_finish"] [:: std :: mem :: offset_of ! (_GFileIface , enumerate_children_finish) - 152usize] ; ["Offset of field: _GFileIface::query_info"] [:: std :: mem :: offset_of ! (_GFileIface , query_info) - 160usize] ; ["Offset of field: _GFileIface::query_info_async"] [:: std :: mem :: offset_of ! (_GFileIface , query_info_async) - 168usize] ; ["Offset of field: _GFileIface::query_info_finish"] [:: std :: mem :: offset_of ! (_GFileIface , query_info_finish) - 176usize] ; ["Offset of field: _GFileIface::query_filesystem_info"] [:: std :: mem :: offset_of ! (_GFileIface , query_filesystem_info) - 184usize] ; ["Offset of field: _GFileIface::query_filesystem_info_async"] [:: std :: mem :: offset_of ! (_GFileIface , query_filesystem_info_async) - 192usize] ; ["Offset of field: _GFileIface::query_filesystem_info_finish"] [:: std :: mem :: offset_of ! (_GFileIface , query_filesystem_info_finish) - 200usize] ; ["Offset of field: _GFileIface::find_enclosing_mount"] [:: std :: mem :: offset_of ! (_GFileIface , find_enclosing_mount) - 208usize] ; ["Offset of field: _GFileIface::find_enclosing_mount_async"] [:: std :: mem :: offset_of ! (_GFileIface , find_enclosing_mount_async) - 216usize] ; ["Offset of field: _GFileIface::find_enclosing_mount_finish"] [:: std :: mem :: offset_of ! (_GFileIface , find_enclosing_mount_finish) - 224usize] ; ["Offset of field: _GFileIface::set_display_name"] [:: std :: mem :: offset_of ! (_GFileIface , set_display_name) - 232usize] ; ["Offset of field: _GFileIface::set_display_name_async"] [:: std :: mem :: offset_of ! (_GFileIface , set_display_name_async) - 240usize] ; ["Offset of field: _GFileIface::set_display_name_finish"] [:: std :: mem :: offset_of ! (_GFileIface , set_display_name_finish) - 248usize] ; ["Offset of field: _GFileIface::query_settable_attributes"] [:: std :: mem :: offset_of ! (_GFileIface , query_settable_attributes) - 256usize] ; ["Offset of field: _GFileIface::_query_settable_attributes_async"] [:: std :: mem :: offset_of ! (_GFileIface , _query_settable_attributes_async) - 264usize] ; ["Offset of field: _GFileIface::_query_settable_attributes_finish"] [:: std :: mem :: offset_of ! (_GFileIface , _query_settable_attributes_finish) - 272usize] ; ["Offset of field: _GFileIface::query_writable_namespaces"] [:: std :: mem :: offset_of ! (_GFileIface , query_writable_namespaces) - 280usize] ; ["Offset of field: _GFileIface::_query_writable_namespaces_async"] [:: std :: mem :: offset_of ! (_GFileIface , _query_writable_namespaces_async) - 288usize] ; ["Offset of field: _GFileIface::_query_writable_namespaces_finish"] [:: std :: mem :: offset_of ! (_GFileIface , _query_writable_namespaces_finish) - 296usize] ; ["Offset of field: _GFileIface::set_attribute"] [:: std :: mem :: offset_of ! (_GFileIface , set_attribute) - 304usize] ; ["Offset of field: _GFileIface::set_attributes_from_info"] [:: std :: mem :: offset_of ! (_GFileIface , set_attributes_from_info) - 312usize] ; ["Offset of field: _GFileIface::set_attributes_async"] [:: std :: mem :: offset_of ! (_GFileIface , set_attributes_async) - 320usize] ; ["Offset of field: _GFileIface::set_attributes_finish"] [:: std :: mem :: offset_of ! (_GFileIface , set_attributes_finish) - 328usize] ; ["Offset of field: _GFileIface::read_fn"] [:: std :: mem :: offset_of ! (_GFileIface , read_fn) - 336usize] ; ["Offset of field: _GFileIface::read_async"] [:: std :: mem :: offset_of ! (_GFileIface , read_async) - 344usize] ; ["Offset of field: _GFileIface::read_finish"] [:: std :: mem :: offset_of ! (_GFileIface , read_finish) - 352usize] ; ["Offset of field: _GFileIface::append_to"] [:: std :: mem :: offset_of ! (_GFileIface , append_to) - 360usize] ; ["Offset of field: _GFileIface::append_to_async"] [:: std :: mem :: offset_of ! (_GFileIface , append_to_async) - 368usize] ; ["Offset of field: _GFileIface::append_to_finish"] [:: std :: mem :: offset_of ! (_GFileIface , append_to_finish) - 376usize] ; ["Offset of field: _GFileIface::create"] [:: std :: mem :: offset_of ! (_GFileIface , create) - 384usize] ; ["Offset of field: _GFileIface::create_async"] [:: std :: mem :: offset_of ! (_GFileIface , create_async) - 392usize] ; ["Offset of field: _GFileIface::create_finish"] [:: std :: mem :: offset_of ! (_GFileIface , create_finish) - 400usize] ; ["Offset of field: _GFileIface::replace"] [:: std :: mem :: offset_of ! (_GFileIface , replace) - 408usize] ; ["Offset of field: _GFileIface::replace_async"] [:: std :: mem :: offset_of ! (_GFileIface , replace_async) - 416usize] ; ["Offset of field: _GFileIface::replace_finish"] [:: std :: mem :: offset_of ! (_GFileIface , replace_finish) - 424usize] ; ["Offset of field: _GFileIface::delete_file"] [:: std :: mem :: offset_of ! (_GFileIface , delete_file) - 432usize] ; ["Offset of field: _GFileIface::delete_file_async"] [:: std :: mem :: offset_of ! (_GFileIface , delete_file_async) - 440usize] ; ["Offset of field: _GFileIface::delete_file_finish"] [:: std :: mem :: offset_of ! (_GFileIface , delete_file_finish) - 448usize] ; ["Offset of field: _GFileIface::trash"] [:: std :: mem :: offset_of ! (_GFileIface , trash) - 456usize] ; ["Offset of field: _GFileIface::trash_async"] [:: std :: mem :: offset_of ! (_GFileIface , trash_async) - 464usize] ; ["Offset of field: _GFileIface::trash_finish"] [:: std :: mem :: offset_of ! (_GFileIface , trash_finish) - 472usize] ; ["Offset of field: _GFileIface::make_directory"] [:: std :: mem :: offset_of ! (_GFileIface , make_directory) - 480usize] ; ["Offset of field: _GFileIface::make_directory_async"] [:: std :: mem :: offset_of ! (_GFileIface , make_directory_async) - 488usize] ; ["Offset of field: _GFileIface::make_directory_finish"] [:: std :: mem :: offset_of ! (_GFileIface , make_directory_finish) - 496usize] ; ["Offset of field: _GFileIface::make_symbolic_link"] [:: std :: mem :: offset_of ! (_GFileIface , make_symbolic_link) - 504usize] ; ["Offset of field: _GFileIface::make_symbolic_link_async"] [:: std :: mem :: offset_of ! (_GFileIface , make_symbolic_link_async) - 512usize] ; ["Offset of field: _GFileIface::make_symbolic_link_finish"] [:: std :: mem :: offset_of ! (_GFileIface , make_symbolic_link_finish) - 520usize] ; ["Offset of field: _GFileIface::copy"] [:: std :: mem :: offset_of ! (_GFileIface , copy) - 528usize] ; ["Offset of field: _GFileIface::copy_async"] [:: std :: mem :: offset_of ! (_GFileIface , copy_async) - 536usize] ; ["Offset of field: _GFileIface::copy_finish"] [:: std :: mem :: offset_of ! (_GFileIface , copy_finish) - 544usize] ; ["Offset of field: _GFileIface::move_"] [:: std :: mem :: offset_of ! (_GFileIface , move_) - 552usize] ; ["Offset of field: _GFileIface::move_async"] [:: std :: mem :: offset_of ! (_GFileIface , move_async) - 560usize] ; ["Offset of field: _GFileIface::move_finish"] [:: std :: mem :: offset_of ! (_GFileIface , move_finish) - 568usize] ; ["Offset of field: _GFileIface::mount_mountable"] [:: std :: mem :: offset_of ! (_GFileIface , mount_mountable) - 576usize] ; ["Offset of field: _GFileIface::mount_mountable_finish"] [:: std :: mem :: offset_of ! (_GFileIface , mount_mountable_finish) - 584usize] ; ["Offset of field: _GFileIface::unmount_mountable"] [:: std :: mem :: offset_of ! (_GFileIface , unmount_mountable) - 592usize] ; ["Offset of field: _GFileIface::unmount_mountable_finish"] [:: std :: mem :: offset_of ! (_GFileIface , unmount_mountable_finish) - 600usize] ; ["Offset of field: _GFileIface::eject_mountable"] [:: std :: mem :: offset_of ! (_GFileIface , eject_mountable) - 608usize] ; ["Offset of field: _GFileIface::eject_mountable_finish"] [:: std :: mem :: offset_of ! (_GFileIface , eject_mountable_finish) - 616usize] ; ["Offset of field: _GFileIface::mount_enclosing_volume"] [:: std :: mem :: offset_of ! (_GFileIface , mount_enclosing_volume) - 624usize] ; ["Offset of field: _GFileIface::mount_enclosing_volume_finish"] [:: std :: mem :: offset_of ! (_GFileIface , mount_enclosing_volume_finish) - 632usize] ; ["Offset of field: _GFileIface::monitor_dir"] [:: std :: mem :: offset_of ! (_GFileIface , monitor_dir) - 640usize] ; ["Offset of field: _GFileIface::monitor_file"] [:: std :: mem :: offset_of ! (_GFileIface , monitor_file) - 648usize] ; ["Offset of field: _GFileIface::open_readwrite"] [:: std :: mem :: offset_of ! (_GFileIface , open_readwrite) - 656usize] ; ["Offset of field: _GFileIface::open_readwrite_async"] [:: std :: mem :: offset_of ! (_GFileIface , open_readwrite_async) - 664usize] ; ["Offset of field: _GFileIface::open_readwrite_finish"] [:: std :: mem :: offset_of ! (_GFileIface , open_readwrite_finish) - 672usize] ; ["Offset of field: _GFileIface::create_readwrite"] [:: std :: mem :: offset_of ! (_GFileIface , create_readwrite) - 680usize] ; ["Offset of field: _GFileIface::create_readwrite_async"] [:: std :: mem :: offset_of ! (_GFileIface , create_readwrite_async) - 688usize] ; ["Offset of field: _GFileIface::create_readwrite_finish"] [:: std :: mem :: offset_of ! (_GFileIface , create_readwrite_finish) - 696usize] ; ["Offset of field: _GFileIface::replace_readwrite"] [:: std :: mem :: offset_of ! (_GFileIface , replace_readwrite) - 704usize] ; ["Offset of field: _GFileIface::replace_readwrite_async"] [:: std :: mem :: offset_of ! (_GFileIface , replace_readwrite_async) - 712usize] ; ["Offset of field: _GFileIface::replace_readwrite_finish"] [:: std :: mem :: offset_of ! (_GFileIface , replace_readwrite_finish) - 720usize] ; ["Offset of field: _GFileIface::start_mountable"] [:: std :: mem :: offset_of ! (_GFileIface , start_mountable) - 728usize] ; ["Offset of field: _GFileIface::start_mountable_finish"] [:: std :: mem :: offset_of ! (_GFileIface , start_mountable_finish) - 736usize] ; ["Offset of field: _GFileIface::stop_mountable"] [:: std :: mem :: offset_of ! (_GFileIface , stop_mountable) - 744usize] ; ["Offset of field: _GFileIface::stop_mountable_finish"] [:: std :: mem :: offset_of ! (_GFileIface , stop_mountable_finish) - 752usize] ; ["Offset of field: _GFileIface::supports_thread_contexts"] [:: std :: mem :: offset_of ! (_GFileIface , supports_thread_contexts) - 760usize] ; ["Offset of field: _GFileIface::unmount_mountable_with_operation"] [:: std :: mem :: offset_of ! (_GFileIface , unmount_mountable_with_operation) - 768usize] ; ["Offset of field: _GFileIface::unmount_mountable_with_operation_finish"] [:: std :: mem :: offset_of ! (_GFileIface , unmount_mountable_with_operation_finish) - 776usize] ; ["Offset of field: _GFileIface::eject_mountable_with_operation"] [:: std :: mem :: offset_of ! (_GFileIface , eject_mountable_with_operation) - 784usize] ; ["Offset of field: _GFileIface::eject_mountable_with_operation_finish"] [:: std :: mem :: offset_of ! (_GFileIface , eject_mountable_with_operation_finish) - 792usize] ; ["Offset of field: _GFileIface::poll_mountable"] [:: std :: mem :: offset_of ! (_GFileIface , poll_mountable) - 800usize] ; ["Offset of field: _GFileIface::poll_mountable_finish"] [:: std :: mem :: offset_of ! (_GFileIface , poll_mountable_finish) - 808usize] ; ["Offset of field: _GFileIface::measure_disk_usage"] [:: std :: mem :: offset_of ! (_GFileIface , measure_disk_usage) - 816usize] ; ["Offset of field: _GFileIface::measure_disk_usage_async"] [:: std :: mem :: offset_of ! (_GFileIface , measure_disk_usage_async) - 824usize] ; ["Offset of field: _GFileIface::measure_disk_usage_finish"] [:: std :: mem :: offset_of ! (_GFileIface , measure_disk_usage_finish) - 832usize] ; ["Offset of field: _GFileIface::query_exists"] [:: std :: mem :: offset_of ! (_GFileIface , query_exists) - 840usize] ; } ; unsafe extern "C" { pub fn g_file_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_new_for_path (path : * const :: std :: os :: raw :: c_char) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_new_for_uri (uri : * const :: std :: os :: raw :: c_char) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_new_for_commandline_arg (arg : * const :: std :: os :: raw :: c_char) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_new_for_commandline_arg_and_cwd (arg : * const gchar , cwd : * const gchar) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_new_tmp (tmpl : * const :: std :: os :: raw :: c_char , iostream : * mut * mut GFileIOStream , error : * mut * mut GError) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_new_tmp_async (tmpl : * const :: std :: os :: raw :: c_char , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_new_tmp_finish (result : * mut GAsyncResult , iostream : * mut * mut GFileIOStream , error : * mut * mut GError) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_new_tmp_dir_async (tmpl : * const :: std :: os :: raw :: c_char , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_new_tmp_dir_finish (result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_parse_name (parse_name : * const :: std :: os :: raw :: c_char) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_new_build_filename (first_element : * const gchar , ...) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_new_build_filenamev (args : * const * const gchar) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_dup (file : * mut GFile) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_hash (file : gconstpointer) -> guint ; } unsafe extern "C" { pub fn g_file_equal (file1 : * mut GFile , file2 : * mut GFile) -> gboolean ; } unsafe extern "C" { pub fn g_file_get_basename (file : * mut GFile) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_get_path (file : * mut GFile) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_peek_path (file : * mut GFile) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_get_uri (file : * mut GFile) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_get_parse_name (file : * mut GFile) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_get_parent (file : * mut GFile) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_has_parent (file : * mut GFile , parent : * mut GFile) -> gboolean ; } unsafe extern "C" { pub fn g_file_get_child (file : * mut GFile , name : * const :: std :: os :: raw :: c_char) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_get_child_for_display_name (file : * mut GFile , display_name : * const :: std :: os :: raw :: c_char , error : * mut * mut GError) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_has_prefix (file : * mut GFile , prefix : * mut GFile) -> gboolean ; } unsafe extern "C" { pub fn g_file_get_relative_path (parent : * mut GFile , descendant : * mut GFile) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_resolve_relative_path (file : * mut GFile , relative_path : * const :: std :: os :: raw :: c_char) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_is_native (file : * mut GFile) -> gboolean ; } unsafe extern "C" { pub fn g_file_has_uri_scheme (file : * mut GFile , uri_scheme : * const :: std :: os :: raw :: c_char) -> gboolean ; } unsafe extern "C" { pub fn g_file_get_uri_scheme (file : * mut GFile) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_read (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileInputStream ; } unsafe extern "C" { pub fn g_file_read_async (file : * mut GFile , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_read_finish (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileInputStream ; } unsafe extern "C" { pub fn g_file_append_to (file : * mut GFile , flags : GFileCreateFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileOutputStream ; } unsafe extern "C" { pub fn g_file_create (file : * mut GFile , flags : GFileCreateFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileOutputStream ; } unsafe extern "C" { pub fn g_file_replace (file : * mut GFile , etag : * const :: std :: os :: raw :: c_char , make_backup : gboolean , flags : GFileCreateFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileOutputStream ; } unsafe extern "C" { pub fn g_file_append_to_async (file : * mut GFile , flags : GFileCreateFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_append_to_finish (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileOutputStream ; } unsafe extern "C" { pub fn g_file_create_async (file : * mut GFile , flags : GFileCreateFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_create_finish (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileOutputStream ; } unsafe extern "C" { pub fn g_file_replace_async (file : * mut GFile , etag : * const :: std :: os :: raw :: c_char , make_backup : gboolean , flags : GFileCreateFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_replace_finish (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileOutputStream ; } unsafe extern "C" { pub fn g_file_open_readwrite (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileIOStream ; } unsafe extern "C" { pub fn g_file_open_readwrite_async (file : * mut GFile , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_open_readwrite_finish (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileIOStream ; } unsafe extern "C" { pub fn g_file_create_readwrite (file : * mut GFile , flags : GFileCreateFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileIOStream ; } unsafe extern "C" { pub fn g_file_create_readwrite_async (file : * mut GFile , flags : GFileCreateFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_create_readwrite_finish (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileIOStream ; } unsafe extern "C" { pub fn g_file_replace_readwrite (file : * mut GFile , etag : * const :: std :: os :: raw :: c_char , make_backup : gboolean , flags : GFileCreateFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileIOStream ; } unsafe extern "C" { pub fn g_file_replace_readwrite_async (file : * mut GFile , etag : * const :: std :: os :: raw :: c_char , make_backup : gboolean , flags : GFileCreateFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_replace_readwrite_finish (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileIOStream ; } unsafe extern "C" { pub fn g_file_query_exists (file : * mut GFile , cancellable : * mut GCancellable) -> gboolean ; } unsafe extern "C" { pub fn g_file_query_file_type (file : * mut GFile , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable) -> GFileType ; } unsafe extern "C" { pub fn g_file_query_info (file : * mut GFile , attributes : * const :: std :: os :: raw :: c_char , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileInfo ; } unsafe extern "C" { pub fn g_file_query_info_async (file : * mut GFile , attributes : * const :: std :: os :: raw :: c_char , flags : GFileQueryInfoFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_query_info_finish (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileInfo ; } unsafe extern "C" { pub fn g_file_query_filesystem_info (file : * mut GFile , attributes : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileInfo ; } unsafe extern "C" { pub fn g_file_query_filesystem_info_async (file : * mut GFile , attributes : * const :: std :: os :: raw :: c_char , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_query_filesystem_info_finish (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileInfo ; } unsafe extern "C" { pub fn g_file_find_enclosing_mount (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GMount ; } unsafe extern "C" { pub fn g_file_find_enclosing_mount_async (file : * mut GFile , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_find_enclosing_mount_finish (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GMount ; } unsafe extern "C" { pub fn g_file_enumerate_children (file : * mut GFile , attributes : * const :: std :: os :: raw :: c_char , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileEnumerator ; } unsafe extern "C" { pub fn g_file_enumerate_children_async (file : * mut GFile , attributes : * const :: std :: os :: raw :: c_char , flags : GFileQueryInfoFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_enumerate_children_finish (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileEnumerator ; } unsafe extern "C" { pub fn g_file_set_display_name (file : * mut GFile , display_name : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_set_display_name_async (file : * mut GFile , display_name : * const :: std :: os :: raw :: c_char , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_set_display_name_finish (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_delete (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_delete_async (file : * mut GFile , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_delete_finish (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_trash (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_trash_async (file : * mut GFile , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_trash_finish (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_copy (source : * mut GFile , destination : * mut GFile , flags : GFileCopyFlags , cancellable : * mut GCancellable , progress_callback : GFileProgressCallback , progress_callback_data : gpointer , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_copy_async (source : * mut GFile , destination : * mut GFile , flags : GFileCopyFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , progress_callback : GFileProgressCallback , progress_callback_data : gpointer , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_copy_async_with_closures (source : * mut GFile , destination : * mut GFile , flags : GFileCopyFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , progress_callback_closure : * mut GClosure , ready_callback_closure : * mut GClosure) ; } unsafe extern "C" { pub fn g_file_copy_finish (file : * mut GFile , res : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_move (source : * mut GFile , destination : * mut GFile , flags : GFileCopyFlags , cancellable : * mut GCancellable , progress_callback : GFileProgressCallback , progress_callback_data : gpointer , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_move_async (source : * mut GFile , destination : * mut GFile , flags : GFileCopyFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , progress_callback : GFileProgressCallback , progress_callback_data : gpointer , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_move_async_with_closures (source : * mut GFile , destination : * mut GFile , flags : GFileCopyFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , progress_callback_closure : * mut GClosure , ready_callback_closure : * mut GClosure) ; } unsafe extern "C" { pub fn g_file_move_finish (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_make_directory (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_make_directory_async (file : * mut GFile , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_make_directory_finish (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_make_directory_with_parents (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_make_symbolic_link (file : * mut GFile , symlink_value : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_make_symbolic_link_async (file : * mut GFile , symlink_value : * const :: std :: os :: raw :: c_char , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_make_symbolic_link_finish (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_query_settable_attributes (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileAttributeInfoList ; } unsafe extern "C" { pub fn g_file_query_writable_namespaces (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileAttributeInfoList ; } unsafe extern "C" { pub fn g_file_set_attribute (file : * mut GFile , attribute : * const :: std :: os :: raw :: c_char , type_ : GFileAttributeType , value_p : gpointer , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_set_attributes_from_info (file : * mut GFile , info : * mut GFileInfo , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_set_attributes_async (file : * mut GFile , info : * mut GFileInfo , flags : GFileQueryInfoFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_set_attributes_finish (file : * mut GFile , result : * mut GAsyncResult , info : * mut * mut GFileInfo , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_set_attribute_string (file : * mut GFile , attribute : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_set_attribute_byte_string (file : * mut GFile , attribute : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_set_attribute_uint32 (file : * mut GFile , attribute : * const :: std :: os :: raw :: c_char , value : guint32 , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_set_attribute_int32 (file : * mut GFile , attribute : * const :: std :: os :: raw :: c_char , value : gint32 , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_set_attribute_uint64 (file : * mut GFile , attribute : * const :: std :: os :: raw :: c_char , value : guint64 , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_set_attribute_int64 (file : * mut GFile , attribute : * const :: std :: os :: raw :: c_char , value : gint64 , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_mount_enclosing_volume (location : * mut GFile , flags : GMountMountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_mount_enclosing_volume_finish (location : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_mount_mountable (file : * mut GFile , flags : GMountMountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_mount_mountable_finish (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_unmount_mountable (file : * mut GFile , flags : GMountUnmountFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_unmount_mountable_finish (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_unmount_mountable_with_operation (file : * mut GFile , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_unmount_mountable_with_operation_finish (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_eject_mountable (file : * mut GFile , flags : GMountUnmountFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_eject_mountable_finish (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_eject_mountable_with_operation (file : * mut GFile , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_eject_mountable_with_operation_finish (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_build_attribute_list_for_copy (file : * mut GFile , flags : GFileCopyFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_copy_attributes (source : * mut GFile , destination : * mut GFile , flags : GFileCopyFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_monitor_directory (file : * mut GFile , flags : GFileMonitorFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileMonitor ; } unsafe extern "C" { pub fn g_file_monitor_file (file : * mut GFile , flags : GFileMonitorFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileMonitor ; } unsafe extern "C" { pub fn g_file_monitor (file : * mut GFile , flags : GFileMonitorFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileMonitor ; } unsafe extern "C" { pub fn g_file_measure_disk_usage (file : * mut GFile , flags : GFileMeasureFlags , cancellable : * mut GCancellable , progress_callback : GFileMeasureProgressCallback , progress_data : gpointer , disk_usage : * mut guint64 , num_dirs : * mut guint64 , num_files : * mut guint64 , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_measure_disk_usage_async (file : * mut GFile , flags : GFileMeasureFlags , io_priority : gint , cancellable : * mut GCancellable , progress_callback : GFileMeasureProgressCallback , progress_data : gpointer , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_measure_disk_usage_finish (file : * mut GFile , result : * mut GAsyncResult , disk_usage : * mut guint64 , num_dirs : * mut guint64 , num_files : * mut guint64 , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_start_mountable (file : * mut GFile , flags : GDriveStartFlags , start_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_start_mountable_finish (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_stop_mountable (file : * mut GFile , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_stop_mountable_finish (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_poll_mountable (file : * mut GFile , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_poll_mountable_finish (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_query_default_handler (file : * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GAppInfo ; } unsafe extern "C" { pub fn g_file_query_default_handler_async (file : * mut GFile , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_query_default_handler_finish (file : * mut GFile , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GAppInfo ; } unsafe extern "C" { pub fn g_file_load_contents (file : * mut GFile , cancellable : * mut GCancellable , contents : * mut * mut :: std :: os :: raw :: c_char , length : * mut gsize , etag_out : * mut * mut :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_load_contents_async (file : * mut GFile , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_load_contents_finish (file : * mut GFile , res : * mut GAsyncResult , contents : * mut * mut :: std :: os :: raw :: c_char , length : * mut gsize , etag_out : * mut * mut :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_load_partial_contents_async (file : * mut GFile , cancellable : * mut GCancellable , read_more_callback : GFileReadMoreCallback , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_load_partial_contents_finish (file : * mut GFile , res : * mut GAsyncResult , contents : * mut * mut :: std :: os :: raw :: c_char , length : * mut gsize , etag_out : * mut * mut :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_replace_contents (file : * mut GFile , contents : * const :: std :: os :: raw :: c_char , length : gsize , etag : * const :: std :: os :: raw :: c_char , make_backup : gboolean , flags : GFileCreateFlags , new_etag : * mut * mut :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_replace_contents_async (file : * mut GFile , contents : * const :: std :: os :: raw :: c_char , length : gsize , etag : * const :: std :: os :: raw :: c_char , make_backup : gboolean , flags : GFileCreateFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_replace_contents_bytes_async (file : * mut GFile , contents : * mut GBytes , etag : * const :: std :: os :: raw :: c_char , make_backup : gboolean , flags : GFileCreateFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_replace_contents_finish (file : * mut GFile , res : * mut GAsyncResult , new_etag : * mut * mut :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_supports_thread_contexts (file : * mut GFile) -> gboolean ; } unsafe extern "C" { pub fn g_file_load_bytes (file : * mut GFile , cancellable : * mut GCancellable , etag_out : * mut * mut gchar , error : * mut * mut GError) -> * mut GBytes ; } unsafe extern "C" { pub fn g_file_load_bytes_async (file : * mut GFile , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_load_bytes_finish (file : * mut GFile , result : * mut GAsyncResult , etag_out : * mut * mut gchar , error : * mut * mut GError) -> * mut GBytes ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileAttributeInfo { pub name : * mut :: std :: os :: raw :: c_char , pub type_ : GFileAttributeType , pub flags : GFileAttributeInfoFlags , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFileAttributeInfo"] [:: std :: mem :: size_of :: < _GFileAttributeInfo > () - 16usize] ; ["Alignment of _GFileAttributeInfo"] [:: std :: mem :: align_of :: < _GFileAttributeInfo > () - 8usize] ; ["Offset of field: _GFileAttributeInfo::name"] [:: std :: mem :: offset_of ! (_GFileAttributeInfo , name) - 0usize] ; ["Offset of field: _GFileAttributeInfo::type_"] [:: std :: mem :: offset_of ! (_GFileAttributeInfo , type_) - 8usize] ; ["Offset of field: _GFileAttributeInfo::flags"] [:: std :: mem :: offset_of ! (_GFileAttributeInfo , flags) - 12usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileAttributeInfoList { pub infos : * mut GFileAttributeInfo , pub n_infos : :: std :: os :: raw :: c_int , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFileAttributeInfoList"] [:: std :: mem :: size_of :: < _GFileAttributeInfoList > () - 16usize] ; ["Alignment of _GFileAttributeInfoList"] [:: std :: mem :: align_of :: < _GFileAttributeInfoList > () - 8usize] ; ["Offset of field: _GFileAttributeInfoList::infos"] [:: std :: mem :: offset_of ! (_GFileAttributeInfoList , infos) - 0usize] ; ["Offset of field: _GFileAttributeInfoList::n_infos"] [:: std :: mem :: offset_of ! (_GFileAttributeInfoList , n_infos) - 8usize] ; } ; unsafe extern "C" { pub fn g_file_attribute_info_list_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_attribute_info_list_new () -> * mut GFileAttributeInfoList ; } unsafe extern "C" { pub fn g_file_attribute_info_list_ref (list : * mut GFileAttributeInfoList) -> * mut GFileAttributeInfoList ; } unsafe extern "C" { pub fn g_file_attribute_info_list_unref (list : * mut GFileAttributeInfoList) ; } unsafe extern "C" { pub fn g_file_attribute_info_list_dup (list : * mut GFileAttributeInfoList) -> * mut GFileAttributeInfoList ; } unsafe extern "C" { pub fn g_file_attribute_info_list_lookup (list : * mut GFileAttributeInfoList , name : * const :: std :: os :: raw :: c_char) -> * const GFileAttributeInfo ; } unsafe extern "C" { pub fn g_file_attribute_info_list_add (list : * mut GFileAttributeInfoList , name : * const :: std :: os :: raw :: c_char , type_ : GFileAttributeType , flags : GFileAttributeInfoFlags) ; } pub type GFileEnumeratorClass = _GFileEnumeratorClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileEnumeratorPrivate { _unused : [u8 ; 0] , } pub type GFileEnumeratorPrivate = _GFileEnumeratorPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileEnumerator { pub parent_instance : GObject , pub priv_ : * mut GFileEnumeratorPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFileEnumerator"] [:: std :: mem :: size_of :: < _GFileEnumerator > () - 32usize] ; ["Alignment of _GFileEnumerator"] [:: std :: mem :: align_of :: < _GFileEnumerator > () - 8usize] ; ["Offset of field: _GFileEnumerator::parent_instance"] [:: std :: mem :: offset_of ! (_GFileEnumerator , parent_instance) - 0usize] ; ["Offset of field: _GFileEnumerator::priv_"] [:: std :: mem :: offset_of ! (_GFileEnumerator , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileEnumeratorClass { pub parent_class : GObjectClass , pub next_file : :: std :: option :: Option < unsafe extern "C" fn (enumerator : * mut GFileEnumerator , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileInfo > , pub close_fn : :: std :: option :: Option < unsafe extern "C" fn (enumerator : * mut GFileEnumerator , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub next_files_async : :: std :: option :: Option < unsafe extern "C" fn (enumerator : * mut GFileEnumerator , num_files : :: std :: os :: raw :: c_int , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub next_files_finish : :: std :: option :: Option < unsafe extern "C" fn (enumerator : * mut GFileEnumerator , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GList > , pub close_async : :: std :: option :: Option < unsafe extern "C" fn (enumerator : * mut GFileEnumerator , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub close_finish : :: std :: option :: Option < unsafe extern "C" fn (enumerator : * mut GFileEnumerator , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved6 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved7 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFileEnumeratorClass"] [:: std :: mem :: size_of :: < _GFileEnumeratorClass > () - 240usize] ; ["Alignment of _GFileEnumeratorClass"] [:: std :: mem :: align_of :: < _GFileEnumeratorClass > () - 8usize] ; ["Offset of field: _GFileEnumeratorClass::parent_class"] [:: std :: mem :: offset_of ! (_GFileEnumeratorClass , parent_class) - 0usize] ; ["Offset of field: _GFileEnumeratorClass::next_file"] [:: std :: mem :: offset_of ! (_GFileEnumeratorClass , next_file) - 136usize] ; ["Offset of field: _GFileEnumeratorClass::close_fn"] [:: std :: mem :: offset_of ! (_GFileEnumeratorClass , close_fn) - 144usize] ; ["Offset of field: _GFileEnumeratorClass::next_files_async"] [:: std :: mem :: offset_of ! (_GFileEnumeratorClass , next_files_async) - 152usize] ; ["Offset of field: _GFileEnumeratorClass::next_files_finish"] [:: std :: mem :: offset_of ! (_GFileEnumeratorClass , next_files_finish) - 160usize] ; ["Offset of field: _GFileEnumeratorClass::close_async"] [:: std :: mem :: offset_of ! (_GFileEnumeratorClass , close_async) - 168usize] ; ["Offset of field: _GFileEnumeratorClass::close_finish"] [:: std :: mem :: offset_of ! (_GFileEnumeratorClass , close_finish) - 176usize] ; ["Offset of field: _GFileEnumeratorClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GFileEnumeratorClass , _g_reserved1) - 184usize] ; ["Offset of field: _GFileEnumeratorClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GFileEnumeratorClass , _g_reserved2) - 192usize] ; ["Offset of field: _GFileEnumeratorClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GFileEnumeratorClass , _g_reserved3) - 200usize] ; ["Offset of field: _GFileEnumeratorClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GFileEnumeratorClass , _g_reserved4) - 208usize] ; ["Offset of field: _GFileEnumeratorClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GFileEnumeratorClass , _g_reserved5) - 216usize] ; ["Offset of field: _GFileEnumeratorClass::_g_reserved6"] [:: std :: mem :: offset_of ! (_GFileEnumeratorClass , _g_reserved6) - 224usize] ; ["Offset of field: _GFileEnumeratorClass::_g_reserved7"] [:: std :: mem :: offset_of ! (_GFileEnumeratorClass , _g_reserved7) - 232usize] ; } ; unsafe extern "C" { pub fn g_file_enumerator_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_enumerator_next_file (enumerator : * mut GFileEnumerator , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileInfo ; } unsafe extern "C" { pub fn g_file_enumerator_close (enumerator : * mut GFileEnumerator , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_enumerator_next_files_async (enumerator : * mut GFileEnumerator , num_files : :: std :: os :: raw :: c_int , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_enumerator_next_files_finish (enumerator : * mut GFileEnumerator , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GList ; } unsafe extern "C" { pub fn g_file_enumerator_close_async (enumerator : * mut GFileEnumerator , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_enumerator_close_finish (enumerator : * mut GFileEnumerator , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_file_enumerator_is_closed (enumerator : * mut GFileEnumerator) -> gboolean ; } unsafe extern "C" { pub fn g_file_enumerator_has_pending (enumerator : * mut GFileEnumerator) -> gboolean ; } unsafe extern "C" { pub fn g_file_enumerator_set_pending (enumerator : * mut GFileEnumerator , pending : gboolean) ; } unsafe extern "C" { pub fn g_file_enumerator_get_container (enumerator : * mut GFileEnumerator) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_enumerator_get_child (enumerator : * mut GFileEnumerator , info : * mut GFileInfo) -> * mut GFile ; } unsafe extern "C" { pub fn g_file_enumerator_iterate (direnum : * mut GFileEnumerator , out_info : * mut * mut GFileInfo , out_child : * mut * mut GFile , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileIconClass { _unused : [u8 ; 0] , } pub type GFileIconClass = _GFileIconClass ; unsafe extern "C" { pub fn g_file_icon_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_icon_new (file : * mut GFile) -> * mut GIcon ; } unsafe extern "C" { pub fn g_file_icon_get_file (icon : * mut GFileIcon) -> * mut GFile ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileInfoClass { _unused : [u8 ; 0] , } pub type GFileInfoClass = _GFileInfoClass ; unsafe extern "C" { pub fn g_file_info_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_info_new () -> * mut GFileInfo ; } unsafe extern "C" { pub fn g_file_info_dup (other : * mut GFileInfo) -> * mut GFileInfo ; } unsafe extern "C" { pub fn g_file_info_copy_into (src_info : * mut GFileInfo , dest_info : * mut GFileInfo) ; } unsafe extern "C" { pub fn g_file_info_has_attribute (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) -> gboolean ; } unsafe extern "C" { pub fn g_file_info_has_namespace (info : * mut GFileInfo , name_space : * const :: std :: os :: raw :: c_char) -> gboolean ; } unsafe extern "C" { pub fn g_file_info_list_attributes (info : * mut GFileInfo , name_space : * const :: std :: os :: raw :: c_char) -> * mut * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_info_get_attribute_data (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char , type_ : * mut GFileAttributeType , value_pp : * mut gpointer , status : * mut GFileAttributeStatus) -> gboolean ; } unsafe extern "C" { pub fn g_file_info_get_attribute_type (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) -> GFileAttributeType ; } unsafe extern "C" { pub fn g_file_info_remove_attribute (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_file_info_get_attribute_status (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) -> GFileAttributeStatus ; } unsafe extern "C" { pub fn g_file_info_set_attribute_status (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char , status : GFileAttributeStatus) -> gboolean ; } unsafe extern "C" { pub fn g_file_info_get_attribute_as_string (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_info_get_attribute_string (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_info_get_attribute_byte_string (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_info_get_attribute_boolean (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) -> gboolean ; } unsafe extern "C" { pub fn g_file_info_get_attribute_uint32 (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) -> guint32 ; } unsafe extern "C" { pub fn g_file_info_get_attribute_int32 (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) -> gint32 ; } unsafe extern "C" { pub fn g_file_info_get_attribute_uint64 (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) -> guint64 ; } unsafe extern "C" { pub fn g_file_info_get_attribute_int64 (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) -> gint64 ; } unsafe extern "C" { pub fn g_file_info_get_attribute_object (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) -> * mut GObject ; } unsafe extern "C" { pub fn g_file_info_get_attribute_stringv (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) -> * mut * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_info_get_attribute_file_path (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_info_set_attribute (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char , type_ : GFileAttributeType , value_p : gpointer) ; } unsafe extern "C" { pub fn g_file_info_set_attribute_string (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char , attr_value : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_file_info_set_attribute_byte_string (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char , attr_value : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_file_info_set_attribute_boolean (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char , attr_value : gboolean) ; } unsafe extern "C" { pub fn g_file_info_set_attribute_uint32 (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char , attr_value : guint32) ; } unsafe extern "C" { pub fn g_file_info_set_attribute_int32 (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char , attr_value : gint32) ; } unsafe extern "C" { pub fn g_file_info_set_attribute_uint64 (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char , attr_value : guint64) ; } unsafe extern "C" { pub fn g_file_info_set_attribute_int64 (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char , attr_value : gint64) ; } unsafe extern "C" { pub fn g_file_info_set_attribute_object (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char , attr_value : * mut GObject) ; } unsafe extern "C" { pub fn g_file_info_set_attribute_stringv (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char , attr_value : * mut * mut :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_file_info_set_attribute_file_path (info : * mut GFileInfo , attribute : * const :: std :: os :: raw :: c_char , attr_value : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_file_info_clear_status (info : * mut GFileInfo) ; } unsafe extern "C" { pub fn g_file_info_get_deletion_date (info : * mut GFileInfo) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_file_info_get_file_type (info : * mut GFileInfo) -> GFileType ; } unsafe extern "C" { pub fn g_file_info_get_is_hidden (info : * mut GFileInfo) -> gboolean ; } unsafe extern "C" { pub fn g_file_info_get_is_backup (info : * mut GFileInfo) -> gboolean ; } unsafe extern "C" { pub fn g_file_info_get_is_symlink (info : * mut GFileInfo) -> gboolean ; } unsafe extern "C" { pub fn g_file_info_get_name (info : * mut GFileInfo) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_info_get_display_name (info : * mut GFileInfo) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_info_get_edit_name (info : * mut GFileInfo) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_info_get_icon (info : * mut GFileInfo) -> * mut GIcon ; } unsafe extern "C" { pub fn g_file_info_get_symbolic_icon (info : * mut GFileInfo) -> * mut GIcon ; } unsafe extern "C" { pub fn g_file_info_get_content_type (info : * mut GFileInfo) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_info_get_size (info : * mut GFileInfo) -> goffset ; } unsafe extern "C" { pub fn g_file_info_get_modification_time (info : * mut GFileInfo , result : * mut GTimeVal) ; } unsafe extern "C" { pub fn g_file_info_get_modification_date_time (info : * mut GFileInfo) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_file_info_get_access_date_time (info : * mut GFileInfo) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_file_info_get_creation_date_time (info : * mut GFileInfo) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_file_info_get_symlink_target (info : * mut GFileInfo) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_info_get_etag (info : * mut GFileInfo) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_info_get_sort_order (info : * mut GFileInfo) -> gint32 ; } unsafe extern "C" { pub fn g_file_info_set_attribute_mask (info : * mut GFileInfo , mask : * mut GFileAttributeMatcher) ; } unsafe extern "C" { pub fn g_file_info_unset_attribute_mask (info : * mut GFileInfo) ; } unsafe extern "C" { pub fn g_file_info_set_file_type (info : * mut GFileInfo , type_ : GFileType) ; } unsafe extern "C" { pub fn g_file_info_set_is_hidden (info : * mut GFileInfo , is_hidden : gboolean) ; } unsafe extern "C" { pub fn g_file_info_set_is_symlink (info : * mut GFileInfo , is_symlink : gboolean) ; } unsafe extern "C" { pub fn g_file_info_set_name (info : * mut GFileInfo , name : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_file_info_set_display_name (info : * mut GFileInfo , display_name : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_file_info_set_edit_name (info : * mut GFileInfo , edit_name : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_file_info_set_icon (info : * mut GFileInfo , icon : * mut GIcon) ; } unsafe extern "C" { pub fn g_file_info_set_symbolic_icon (info : * mut GFileInfo , icon : * mut GIcon) ; } unsafe extern "C" { pub fn g_file_info_set_content_type (info : * mut GFileInfo , content_type : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_file_info_set_size (info : * mut GFileInfo , size : goffset) ; } unsafe extern "C" { pub fn g_file_info_set_modification_time (info : * mut GFileInfo , mtime : * mut GTimeVal) ; } unsafe extern "C" { pub fn g_file_info_set_modification_date_time (info : * mut GFileInfo , mtime : * mut GDateTime) ; } unsafe extern "C" { pub fn g_file_info_set_access_date_time (info : * mut GFileInfo , atime : * mut GDateTime) ; } unsafe extern "C" { pub fn g_file_info_set_creation_date_time (info : * mut GFileInfo , creation_time : * mut GDateTime) ; } unsafe extern "C" { pub fn g_file_info_set_symlink_target (info : * mut GFileInfo , symlink_target : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_file_info_set_sort_order (info : * mut GFileInfo , sort_order : gint32) ; } unsafe extern "C" { pub fn g_file_attribute_matcher_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_attribute_matcher_new (attributes : * const :: std :: os :: raw :: c_char) -> * mut GFileAttributeMatcher ; } unsafe extern "C" { pub fn g_file_attribute_matcher_ref (matcher : * mut GFileAttributeMatcher) -> * mut GFileAttributeMatcher ; } unsafe extern "C" { pub fn g_file_attribute_matcher_unref (matcher : * mut GFileAttributeMatcher) ; } unsafe extern "C" { pub fn g_file_attribute_matcher_subtract (matcher : * mut GFileAttributeMatcher , subtract : * mut GFileAttributeMatcher) -> * mut GFileAttributeMatcher ; } unsafe extern "C" { pub fn g_file_attribute_matcher_matches (matcher : * mut GFileAttributeMatcher , attribute : * const :: std :: os :: raw :: c_char) -> gboolean ; } unsafe extern "C" { pub fn g_file_attribute_matcher_matches_only (matcher : * mut GFileAttributeMatcher , attribute : * const :: std :: os :: raw :: c_char) -> gboolean ; } unsafe extern "C" { pub fn g_file_attribute_matcher_enumerate_namespace (matcher : * mut GFileAttributeMatcher , ns : * const :: std :: os :: raw :: c_char) -> gboolean ; } unsafe extern "C" { pub fn g_file_attribute_matcher_enumerate_next (matcher : * mut GFileAttributeMatcher) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_file_attribute_matcher_to_string (matcher : * mut GFileAttributeMatcher) -> * mut :: std :: os :: raw :: c_char ; } pub type GFileInputStreamClass = _GFileInputStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileInputStreamPrivate { _unused : [u8 ; 0] , } pub type GFileInputStreamPrivate = _GFileInputStreamPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileInputStream { pub parent_instance : GInputStream , pub priv_ : * mut GFileInputStreamPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFileInputStream"] [:: std :: mem :: size_of :: < _GFileInputStream > () - 40usize] ; ["Alignment of _GFileInputStream"] [:: std :: mem :: align_of :: < _GFileInputStream > () - 8usize] ; ["Offset of field: _GFileInputStream::parent_instance"] [:: std :: mem :: offset_of ! (_GFileInputStream , parent_instance) - 0usize] ; ["Offset of field: _GFileInputStream::priv_"] [:: std :: mem :: offset_of ! (_GFileInputStream , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileInputStreamClass { pub parent_class : GInputStreamClass , pub tell : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileInputStream) -> goffset > , pub can_seek : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileInputStream) -> gboolean > , pub seek : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileInputStream , offset : goffset , type_ : GSeekType , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub query_info : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileInputStream , attributes : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileInfo > , pub query_info_async : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileInputStream , attributes : * const :: std :: os :: raw :: c_char , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub query_info_finish : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileInputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileInfo > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFileInputStreamClass"] [:: std :: mem :: size_of :: < _GFileInputStreamClass > () - 336usize] ; ["Alignment of _GFileInputStreamClass"] [:: std :: mem :: align_of :: < _GFileInputStreamClass > () - 8usize] ; ["Offset of field: _GFileInputStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GFileInputStreamClass , parent_class) - 0usize] ; ["Offset of field: _GFileInputStreamClass::tell"] [:: std :: mem :: offset_of ! (_GFileInputStreamClass , tell) - 248usize] ; ["Offset of field: _GFileInputStreamClass::can_seek"] [:: std :: mem :: offset_of ! (_GFileInputStreamClass , can_seek) - 256usize] ; ["Offset of field: _GFileInputStreamClass::seek"] [:: std :: mem :: offset_of ! (_GFileInputStreamClass , seek) - 264usize] ; ["Offset of field: _GFileInputStreamClass::query_info"] [:: std :: mem :: offset_of ! (_GFileInputStreamClass , query_info) - 272usize] ; ["Offset of field: _GFileInputStreamClass::query_info_async"] [:: std :: mem :: offset_of ! (_GFileInputStreamClass , query_info_async) - 280usize] ; ["Offset of field: _GFileInputStreamClass::query_info_finish"] [:: std :: mem :: offset_of ! (_GFileInputStreamClass , query_info_finish) - 288usize] ; ["Offset of field: _GFileInputStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GFileInputStreamClass , _g_reserved1) - 296usize] ; ["Offset of field: _GFileInputStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GFileInputStreamClass , _g_reserved2) - 304usize] ; ["Offset of field: _GFileInputStreamClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GFileInputStreamClass , _g_reserved3) - 312usize] ; ["Offset of field: _GFileInputStreamClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GFileInputStreamClass , _g_reserved4) - 320usize] ; ["Offset of field: _GFileInputStreamClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GFileInputStreamClass , _g_reserved5) - 328usize] ; } ; unsafe extern "C" { pub fn g_file_input_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_input_stream_query_info (stream : * mut GFileInputStream , attributes : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileInfo ; } unsafe extern "C" { pub fn g_file_input_stream_query_info_async (stream : * mut GFileInputStream , attributes : * const :: std :: os :: raw :: c_char , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_input_stream_query_info_finish (stream : * mut GFileInputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileInfo ; } unsafe extern "C" { pub fn g_io_error_quark () -> GQuark ; } unsafe extern "C" { pub fn g_io_error_from_errno (err_no : gint) -> GIOErrorEnum ; } unsafe extern "C" { pub fn g_io_error_from_file_error (file_error : GFileError) -> GIOErrorEnum ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIOStreamPrivate { _unused : [u8 ; 0] , } pub type GIOStreamPrivate = _GIOStreamPrivate ; pub type GIOStreamClass = _GIOStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIOStream { pub parent_instance : GObject , pub priv_ : * mut GIOStreamPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GIOStream"] [:: std :: mem :: size_of :: < _GIOStream > () - 32usize] ; ["Alignment of _GIOStream"] [:: std :: mem :: align_of :: < _GIOStream > () - 8usize] ; ["Offset of field: _GIOStream::parent_instance"] [:: std :: mem :: offset_of ! (_GIOStream , parent_instance) - 0usize] ; ["Offset of field: _GIOStream::priv_"] [:: std :: mem :: offset_of ! (_GIOStream , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIOStreamClass { pub parent_class : GObjectClass , pub get_input_stream : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GIOStream) -> * mut GInputStream > , pub get_output_stream : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GIOStream) -> * mut GOutputStream > , pub close_fn : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GIOStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub close_async : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GIOStream , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub close_finish : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GIOStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved6 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved7 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved8 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved9 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved10 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GIOStreamClass"] [:: std :: mem :: size_of :: < _GIOStreamClass > () - 256usize] ; ["Alignment of _GIOStreamClass"] [:: std :: mem :: align_of :: < _GIOStreamClass > () - 8usize] ; ["Offset of field: _GIOStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GIOStreamClass , parent_class) - 0usize] ; ["Offset of field: _GIOStreamClass::get_input_stream"] [:: std :: mem :: offset_of ! (_GIOStreamClass , get_input_stream) - 136usize] ; ["Offset of field: _GIOStreamClass::get_output_stream"] [:: std :: mem :: offset_of ! (_GIOStreamClass , get_output_stream) - 144usize] ; ["Offset of field: _GIOStreamClass::close_fn"] [:: std :: mem :: offset_of ! (_GIOStreamClass , close_fn) - 152usize] ; ["Offset of field: _GIOStreamClass::close_async"] [:: std :: mem :: offset_of ! (_GIOStreamClass , close_async) - 160usize] ; ["Offset of field: _GIOStreamClass::close_finish"] [:: std :: mem :: offset_of ! (_GIOStreamClass , close_finish) - 168usize] ; ["Offset of field: _GIOStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GIOStreamClass , _g_reserved1) - 176usize] ; ["Offset of field: _GIOStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GIOStreamClass , _g_reserved2) - 184usize] ; ["Offset of field: _GIOStreamClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GIOStreamClass , _g_reserved3) - 192usize] ; ["Offset of field: _GIOStreamClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GIOStreamClass , _g_reserved4) - 200usize] ; ["Offset of field: _GIOStreamClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GIOStreamClass , _g_reserved5) - 208usize] ; ["Offset of field: _GIOStreamClass::_g_reserved6"] [:: std :: mem :: offset_of ! (_GIOStreamClass , _g_reserved6) - 216usize] ; ["Offset of field: _GIOStreamClass::_g_reserved7"] [:: std :: mem :: offset_of ! (_GIOStreamClass , _g_reserved7) - 224usize] ; ["Offset of field: _GIOStreamClass::_g_reserved8"] [:: std :: mem :: offset_of ! (_GIOStreamClass , _g_reserved8) - 232usize] ; ["Offset of field: _GIOStreamClass::_g_reserved9"] [:: std :: mem :: offset_of ! (_GIOStreamClass , _g_reserved9) - 240usize] ; ["Offset of field: _GIOStreamClass::_g_reserved10"] [:: std :: mem :: offset_of ! (_GIOStreamClass , _g_reserved10) - 248usize] ; } ; unsafe extern "C" { pub fn g_io_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_io_stream_get_input_stream (stream : * mut GIOStream) -> * mut GInputStream ; } unsafe extern "C" { pub fn g_io_stream_get_output_stream (stream : * mut GIOStream) -> * mut GOutputStream ; } unsafe extern "C" { pub fn g_io_stream_splice_async (stream1 : * mut GIOStream , stream2 : * mut GIOStream , flags : GIOStreamSpliceFlags , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_io_stream_splice_finish (result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_io_stream_close (stream : * mut GIOStream , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_io_stream_close_async (stream : * mut GIOStream , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_io_stream_close_finish (stream : * mut GIOStream , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_io_stream_is_closed (stream : * mut GIOStream) -> gboolean ; } unsafe extern "C" { pub fn g_io_stream_has_pending (stream : * mut GIOStream) -> gboolean ; } unsafe extern "C" { pub fn g_io_stream_set_pending (stream : * mut GIOStream , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_io_stream_clear_pending (stream : * mut GIOStream) ; } pub type GFileIOStreamClass = _GFileIOStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileIOStreamPrivate { _unused : [u8 ; 0] , } pub type GFileIOStreamPrivate = _GFileIOStreamPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileIOStream { pub parent_instance : GIOStream , pub priv_ : * mut GFileIOStreamPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFileIOStream"] [:: std :: mem :: size_of :: < _GFileIOStream > () - 40usize] ; ["Alignment of _GFileIOStream"] [:: std :: mem :: align_of :: < _GFileIOStream > () - 8usize] ; ["Offset of field: _GFileIOStream::parent_instance"] [:: std :: mem :: offset_of ! (_GFileIOStream , parent_instance) - 0usize] ; ["Offset of field: _GFileIOStream::priv_"] [:: std :: mem :: offset_of ! (_GFileIOStream , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileIOStreamClass { pub parent_class : GIOStreamClass , pub tell : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileIOStream) -> goffset > , pub can_seek : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileIOStream) -> gboolean > , pub seek : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileIOStream , offset : goffset , type_ : GSeekType , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub can_truncate : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileIOStream) -> gboolean > , pub truncate_fn : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileIOStream , size : goffset , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub query_info : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileIOStream , attributes : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileInfo > , pub query_info_async : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileIOStream , attributes : * const :: std :: os :: raw :: c_char , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub query_info_finish : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileIOStream , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileInfo > , pub get_etag : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileIOStream) -> * mut :: std :: os :: raw :: c_char > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFileIOStreamClass"] [:: std :: mem :: size_of :: < _GFileIOStreamClass > () - 368usize] ; ["Alignment of _GFileIOStreamClass"] [:: std :: mem :: align_of :: < _GFileIOStreamClass > () - 8usize] ; ["Offset of field: _GFileIOStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , parent_class) - 0usize] ; ["Offset of field: _GFileIOStreamClass::tell"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , tell) - 256usize] ; ["Offset of field: _GFileIOStreamClass::can_seek"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , can_seek) - 264usize] ; ["Offset of field: _GFileIOStreamClass::seek"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , seek) - 272usize] ; ["Offset of field: _GFileIOStreamClass::can_truncate"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , can_truncate) - 280usize] ; ["Offset of field: _GFileIOStreamClass::truncate_fn"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , truncate_fn) - 288usize] ; ["Offset of field: _GFileIOStreamClass::query_info"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , query_info) - 296usize] ; ["Offset of field: _GFileIOStreamClass::query_info_async"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , query_info_async) - 304usize] ; ["Offset of field: _GFileIOStreamClass::query_info_finish"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , query_info_finish) - 312usize] ; ["Offset of field: _GFileIOStreamClass::get_etag"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , get_etag) - 320usize] ; ["Offset of field: _GFileIOStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , _g_reserved1) - 328usize] ; ["Offset of field: _GFileIOStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , _g_reserved2) - 336usize] ; ["Offset of field: _GFileIOStreamClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , _g_reserved3) - 344usize] ; ["Offset of field: _GFileIOStreamClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , _g_reserved4) - 352usize] ; ["Offset of field: _GFileIOStreamClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GFileIOStreamClass , _g_reserved5) - 360usize] ; } ; unsafe extern "C" { pub fn g_file_io_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_io_stream_query_info (stream : * mut GFileIOStream , attributes : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileInfo ; } unsafe extern "C" { pub fn g_file_io_stream_query_info_async (stream : * mut GFileIOStream , attributes : * const :: std :: os :: raw :: c_char , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_io_stream_query_info_finish (stream : * mut GFileIOStream , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileInfo ; } unsafe extern "C" { pub fn g_file_io_stream_get_etag (stream : * mut GFileIOStream) -> * mut :: std :: os :: raw :: c_char ; } pub type GFileMonitorClass = _GFileMonitorClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileMonitorPrivate { _unused : [u8 ; 0] , } pub type GFileMonitorPrivate = _GFileMonitorPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileMonitor { pub parent_instance : GObject , pub priv_ : * mut GFileMonitorPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFileMonitor"] [:: std :: mem :: size_of :: < _GFileMonitor > () - 32usize] ; ["Alignment of _GFileMonitor"] [:: std :: mem :: align_of :: < _GFileMonitor > () - 8usize] ; ["Offset of field: _GFileMonitor::parent_instance"] [:: std :: mem :: offset_of ! (_GFileMonitor , parent_instance) - 0usize] ; ["Offset of field: _GFileMonitor::priv_"] [:: std :: mem :: offset_of ! (_GFileMonitor , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileMonitorClass { pub parent_class : GObjectClass , pub changed : :: std :: option :: Option < unsafe extern "C" fn (monitor : * mut GFileMonitor , file : * mut GFile , other_file : * mut GFile , event_type : GFileMonitorEvent) > , pub cancel : :: std :: option :: Option < unsafe extern "C" fn (monitor : * mut GFileMonitor) -> gboolean > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFileMonitorClass"] [:: std :: mem :: size_of :: < _GFileMonitorClass > () - 192usize] ; ["Alignment of _GFileMonitorClass"] [:: std :: mem :: align_of :: < _GFileMonitorClass > () - 8usize] ; ["Offset of field: _GFileMonitorClass::parent_class"] [:: std :: mem :: offset_of ! (_GFileMonitorClass , parent_class) - 0usize] ; ["Offset of field: _GFileMonitorClass::changed"] [:: std :: mem :: offset_of ! (_GFileMonitorClass , changed) - 136usize] ; ["Offset of field: _GFileMonitorClass::cancel"] [:: std :: mem :: offset_of ! (_GFileMonitorClass , cancel) - 144usize] ; ["Offset of field: _GFileMonitorClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GFileMonitorClass , _g_reserved1) - 152usize] ; ["Offset of field: _GFileMonitorClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GFileMonitorClass , _g_reserved2) - 160usize] ; ["Offset of field: _GFileMonitorClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GFileMonitorClass , _g_reserved3) - 168usize] ; ["Offset of field: _GFileMonitorClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GFileMonitorClass , _g_reserved4) - 176usize] ; ["Offset of field: _GFileMonitorClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GFileMonitorClass , _g_reserved5) - 184usize] ; } ; unsafe extern "C" { pub fn g_file_monitor_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_monitor_cancel (monitor : * mut GFileMonitor) -> gboolean ; } unsafe extern "C" { pub fn g_file_monitor_is_cancelled (monitor : * mut GFileMonitor) -> gboolean ; } unsafe extern "C" { pub fn g_file_monitor_set_rate_limit (monitor : * mut GFileMonitor , limit_msecs : gint) ; } unsafe extern "C" { pub fn g_file_monitor_emit_event (monitor : * mut GFileMonitor , child : * mut GFile , other_file : * mut GFile , event_type : GFileMonitorEvent) ; } pub type GFilenameCompleterClass = _GFilenameCompleterClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFilenameCompleterClass { pub parent_class : GObjectClass , pub got_completion_data : :: std :: option :: Option < unsafe extern "C" fn (filename_completer : * mut GFilenameCompleter) > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFilenameCompleterClass"] [:: std :: mem :: size_of :: < _GFilenameCompleterClass > () - 168usize] ; ["Alignment of _GFilenameCompleterClass"] [:: std :: mem :: align_of :: < _GFilenameCompleterClass > () - 8usize] ; ["Offset of field: _GFilenameCompleterClass::parent_class"] [:: std :: mem :: offset_of ! (_GFilenameCompleterClass , parent_class) - 0usize] ; ["Offset of field: _GFilenameCompleterClass::got_completion_data"] [:: std :: mem :: offset_of ! (_GFilenameCompleterClass , got_completion_data) - 136usize] ; ["Offset of field: _GFilenameCompleterClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GFilenameCompleterClass , _g_reserved1) - 144usize] ; ["Offset of field: _GFilenameCompleterClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GFilenameCompleterClass , _g_reserved2) - 152usize] ; ["Offset of field: _GFilenameCompleterClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GFilenameCompleterClass , _g_reserved3) - 160usize] ; } ; unsafe extern "C" { pub fn g_filename_completer_get_type () -> GType ; } unsafe extern "C" { pub fn g_filename_completer_new () -> * mut GFilenameCompleter ; } unsafe extern "C" { pub fn g_filename_completer_get_completion_suffix (completer : * mut GFilenameCompleter , initial_text : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_filename_completer_get_completions (completer : * mut GFilenameCompleter , initial_text : * const :: std :: os :: raw :: c_char) -> * mut * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_filename_completer_set_dirs_only (completer : * mut GFilenameCompleter , dirs_only : gboolean) ; } pub type GFileOutputStreamClass = _GFileOutputStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileOutputStreamPrivate { _unused : [u8 ; 0] , } pub type GFileOutputStreamPrivate = _GFileOutputStreamPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileOutputStream { pub parent_instance : GOutputStream , pub priv_ : * mut GFileOutputStreamPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFileOutputStream"] [:: std :: mem :: size_of :: < _GFileOutputStream > () - 40usize] ; ["Alignment of _GFileOutputStream"] [:: std :: mem :: align_of :: < _GFileOutputStream > () - 8usize] ; ["Offset of field: _GFileOutputStream::parent_instance"] [:: std :: mem :: offset_of ! (_GFileOutputStream , parent_instance) - 0usize] ; ["Offset of field: _GFileOutputStream::priv_"] [:: std :: mem :: offset_of ! (_GFileOutputStream , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GFileOutputStreamClass { pub parent_class : GOutputStreamClass , pub tell : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileOutputStream) -> goffset > , pub can_seek : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileOutputStream) -> gboolean > , pub seek : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileOutputStream , offset : goffset , type_ : GSeekType , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub can_truncate : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileOutputStream) -> gboolean > , pub truncate_fn : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileOutputStream , size : goffset , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub query_info : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileOutputStream , attributes : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileInfo > , pub query_info_async : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileOutputStream , attributes : * const :: std :: os :: raw :: c_char , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub query_info_finish : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileOutputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileInfo > , pub get_etag : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GFileOutputStream) -> * mut :: std :: os :: raw :: c_char > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GFileOutputStreamClass"] [:: std :: mem :: size_of :: < _GFileOutputStreamClass > () - 408usize] ; ["Alignment of _GFileOutputStreamClass"] [:: std :: mem :: align_of :: < _GFileOutputStreamClass > () - 8usize] ; ["Offset of field: _GFileOutputStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , parent_class) - 0usize] ; ["Offset of field: _GFileOutputStreamClass::tell"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , tell) - 296usize] ; ["Offset of field: _GFileOutputStreamClass::can_seek"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , can_seek) - 304usize] ; ["Offset of field: _GFileOutputStreamClass::seek"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , seek) - 312usize] ; ["Offset of field: _GFileOutputStreamClass::can_truncate"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , can_truncate) - 320usize] ; ["Offset of field: _GFileOutputStreamClass::truncate_fn"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , truncate_fn) - 328usize] ; ["Offset of field: _GFileOutputStreamClass::query_info"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , query_info) - 336usize] ; ["Offset of field: _GFileOutputStreamClass::query_info_async"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , query_info_async) - 344usize] ; ["Offset of field: _GFileOutputStreamClass::query_info_finish"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , query_info_finish) - 352usize] ; ["Offset of field: _GFileOutputStreamClass::get_etag"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , get_etag) - 360usize] ; ["Offset of field: _GFileOutputStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , _g_reserved1) - 368usize] ; ["Offset of field: _GFileOutputStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , _g_reserved2) - 376usize] ; ["Offset of field: _GFileOutputStreamClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , _g_reserved3) - 384usize] ; ["Offset of field: _GFileOutputStreamClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , _g_reserved4) - 392usize] ; ["Offset of field: _GFileOutputStreamClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GFileOutputStreamClass , _g_reserved5) - 400usize] ; } ; unsafe extern "C" { pub fn g_file_output_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_output_stream_query_info (stream : * mut GFileOutputStream , attributes : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileInfo ; } unsafe extern "C" { pub fn g_file_output_stream_query_info_async (stream : * mut GFileOutputStream , attributes : * const :: std :: os :: raw :: c_char , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_file_output_stream_query_info_finish (stream : * mut GFileOutputStream , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GFileInfo ; } unsafe extern "C" { pub fn g_file_output_stream_get_etag (stream : * mut GFileOutputStream) -> * mut :: std :: os :: raw :: c_char ; } pub type GInetAddressClass = _GInetAddressClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInetAddressPrivate { _unused : [u8 ; 0] , } pub type GInetAddressPrivate = _GInetAddressPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInetAddress { pub parent_instance : GObject , pub priv_ : * mut GInetAddressPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GInetAddress"] [:: std :: mem :: size_of :: < _GInetAddress > () - 32usize] ; ["Alignment of _GInetAddress"] [:: std :: mem :: align_of :: < _GInetAddress > () - 8usize] ; ["Offset of field: _GInetAddress::parent_instance"] [:: std :: mem :: offset_of ! (_GInetAddress , parent_instance) - 0usize] ; ["Offset of field: _GInetAddress::priv_"] [:: std :: mem :: offset_of ! (_GInetAddress , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInetAddressClass { pub parent_class : GObjectClass , pub to_string : :: std :: option :: Option < unsafe extern "C" fn (address : * mut GInetAddress) -> * mut gchar > , pub to_bytes : :: std :: option :: Option < unsafe extern "C" fn (address : * mut GInetAddress) -> * const guint8 > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GInetAddressClass"] [:: std :: mem :: size_of :: < _GInetAddressClass > () - 152usize] ; ["Alignment of _GInetAddressClass"] [:: std :: mem :: align_of :: < _GInetAddressClass > () - 8usize] ; ["Offset of field: _GInetAddressClass::parent_class"] [:: std :: mem :: offset_of ! (_GInetAddressClass , parent_class) - 0usize] ; ["Offset of field: _GInetAddressClass::to_string"] [:: std :: mem :: offset_of ! (_GInetAddressClass , to_string) - 136usize] ; ["Offset of field: _GInetAddressClass::to_bytes"] [:: std :: mem :: offset_of ! (_GInetAddressClass , to_bytes) - 144usize] ; } ; unsafe extern "C" { pub fn g_inet_address_get_type () -> GType ; } unsafe extern "C" { pub fn g_inet_address_new_from_string (string : * const gchar) -> * mut GInetAddress ; } unsafe extern "C" { pub fn g_inet_address_new_from_bytes (bytes : * const guint8 , family : GSocketFamily) -> * mut GInetAddress ; } unsafe extern "C" { pub fn g_inet_address_new_loopback (family : GSocketFamily) -> * mut GInetAddress ; } unsafe extern "C" { pub fn g_inet_address_new_any (family : GSocketFamily) -> * mut GInetAddress ; } unsafe extern "C" { pub fn g_inet_address_equal (address : * mut GInetAddress , other_address : * mut GInetAddress) -> gboolean ; } unsafe extern "C" { pub fn g_inet_address_to_string (address : * mut GInetAddress) -> * mut gchar ; } unsafe extern "C" { pub fn g_inet_address_to_bytes (address : * mut GInetAddress) -> * const guint8 ; } unsafe extern "C" { pub fn g_inet_address_get_native_size (address : * mut GInetAddress) -> gsize ; } unsafe extern "C" { pub fn g_inet_address_get_family (address : * mut GInetAddress) -> GSocketFamily ; } unsafe extern "C" { pub fn g_inet_address_get_is_any (address : * mut GInetAddress) -> gboolean ; } unsafe extern "C" { pub fn g_inet_address_get_is_loopback (address : * mut GInetAddress) -> gboolean ; } unsafe extern "C" { pub fn g_inet_address_get_is_link_local (address : * mut GInetAddress) -> gboolean ; } unsafe extern "C" { pub fn g_inet_address_get_is_site_local (address : * mut GInetAddress) -> gboolean ; } unsafe extern "C" { pub fn g_inet_address_get_is_multicast (address : * mut GInetAddress) -> gboolean ; } unsafe extern "C" { pub fn g_inet_address_get_is_mc_global (address : * mut GInetAddress) -> gboolean ; } unsafe extern "C" { pub fn g_inet_address_get_is_mc_link_local (address : * mut GInetAddress) -> gboolean ; } unsafe extern "C" { pub fn g_inet_address_get_is_mc_node_local (address : * mut GInetAddress) -> gboolean ; } unsafe extern "C" { pub fn g_inet_address_get_is_mc_org_local (address : * mut GInetAddress) -> gboolean ; } unsafe extern "C" { pub fn g_inet_address_get_is_mc_site_local (address : * mut GInetAddress) -> gboolean ; } pub type GInetAddressMaskClass = _GInetAddressMaskClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInetAddressMaskPrivate { _unused : [u8 ; 0] , } pub type GInetAddressMaskPrivate = _GInetAddressMaskPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInetAddressMask { pub parent_instance : GObject , pub priv_ : * mut GInetAddressMaskPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GInetAddressMask"] [:: std :: mem :: size_of :: < _GInetAddressMask > () - 32usize] ; ["Alignment of _GInetAddressMask"] [:: std :: mem :: align_of :: < _GInetAddressMask > () - 8usize] ; ["Offset of field: _GInetAddressMask::parent_instance"] [:: std :: mem :: offset_of ! (_GInetAddressMask , parent_instance) - 0usize] ; ["Offset of field: _GInetAddressMask::priv_"] [:: std :: mem :: offset_of ! (_GInetAddressMask , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInetAddressMaskClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GInetAddressMaskClass"] [:: std :: mem :: size_of :: < _GInetAddressMaskClass > () - 136usize] ; ["Alignment of _GInetAddressMaskClass"] [:: std :: mem :: align_of :: < _GInetAddressMaskClass > () - 8usize] ; ["Offset of field: _GInetAddressMaskClass::parent_class"] [:: std :: mem :: offset_of ! (_GInetAddressMaskClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn g_inet_address_mask_get_type () -> GType ; } unsafe extern "C" { pub fn g_inet_address_mask_new (addr : * mut GInetAddress , length : guint , error : * mut * mut GError) -> * mut GInetAddressMask ; } unsafe extern "C" { pub fn g_inet_address_mask_new_from_string (mask_string : * const gchar , error : * mut * mut GError) -> * mut GInetAddressMask ; } unsafe extern "C" { pub fn g_inet_address_mask_to_string (mask : * mut GInetAddressMask) -> * mut gchar ; } unsafe extern "C" { pub fn g_inet_address_mask_get_family (mask : * mut GInetAddressMask) -> GSocketFamily ; } unsafe extern "C" { pub fn g_inet_address_mask_get_address (mask : * mut GInetAddressMask) -> * mut GInetAddress ; } unsafe extern "C" { pub fn g_inet_address_mask_get_length (mask : * mut GInetAddressMask) -> guint ; } unsafe extern "C" { pub fn g_inet_address_mask_matches (mask : * mut GInetAddressMask , address : * mut GInetAddress) -> gboolean ; } unsafe extern "C" { pub fn g_inet_address_mask_equal (mask : * mut GInetAddressMask , mask2 : * mut GInetAddressMask) -> gboolean ; } pub type GSocketAddressClass = _GSocketAddressClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketAddress { pub parent_instance : GObject , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketAddress"] [:: std :: mem :: size_of :: < _GSocketAddress > () - 24usize] ; ["Alignment of _GSocketAddress"] [:: std :: mem :: align_of :: < _GSocketAddress > () - 8usize] ; ["Offset of field: _GSocketAddress::parent_instance"] [:: std :: mem :: offset_of ! (_GSocketAddress , parent_instance) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketAddressClass { pub parent_class : GObjectClass , pub get_family : :: std :: option :: Option < unsafe extern "C" fn (address : * mut GSocketAddress) -> GSocketFamily > , pub get_native_size : :: std :: option :: Option < unsafe extern "C" fn (address : * mut GSocketAddress) -> gssize > , pub to_native : :: std :: option :: Option < unsafe extern "C" fn (address : * mut GSocketAddress , dest : gpointer , destlen : gsize , error : * mut * mut GError) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketAddressClass"] [:: std :: mem :: size_of :: < _GSocketAddressClass > () - 160usize] ; ["Alignment of _GSocketAddressClass"] [:: std :: mem :: align_of :: < _GSocketAddressClass > () - 8usize] ; ["Offset of field: _GSocketAddressClass::parent_class"] [:: std :: mem :: offset_of ! (_GSocketAddressClass , parent_class) - 0usize] ; ["Offset of field: _GSocketAddressClass::get_family"] [:: std :: mem :: offset_of ! (_GSocketAddressClass , get_family) - 136usize] ; ["Offset of field: _GSocketAddressClass::get_native_size"] [:: std :: mem :: offset_of ! (_GSocketAddressClass , get_native_size) - 144usize] ; ["Offset of field: _GSocketAddressClass::to_native"] [:: std :: mem :: offset_of ! (_GSocketAddressClass , to_native) - 152usize] ; } ; unsafe extern "C" { pub fn g_socket_address_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_address_get_family (address : * mut GSocketAddress) -> GSocketFamily ; } unsafe extern "C" { pub fn g_socket_address_new_from_native (native : gpointer , len : gsize) -> * mut GSocketAddress ; } unsafe extern "C" { pub fn g_socket_address_to_native (address : * mut GSocketAddress , dest : gpointer , destlen : gsize , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_address_get_native_size (address : * mut GSocketAddress) -> gssize ; } pub type GInetSocketAddressClass = _GInetSocketAddressClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInetSocketAddressPrivate { _unused : [u8 ; 0] , } pub type GInetSocketAddressPrivate = _GInetSocketAddressPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInetSocketAddress { pub parent_instance : GSocketAddress , pub priv_ : * mut GInetSocketAddressPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GInetSocketAddress"] [:: std :: mem :: size_of :: < _GInetSocketAddress > () - 32usize] ; ["Alignment of _GInetSocketAddress"] [:: std :: mem :: align_of :: < _GInetSocketAddress > () - 8usize] ; ["Offset of field: _GInetSocketAddress::parent_instance"] [:: std :: mem :: offset_of ! (_GInetSocketAddress , parent_instance) - 0usize] ; ["Offset of field: _GInetSocketAddress::priv_"] [:: std :: mem :: offset_of ! (_GInetSocketAddress , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GInetSocketAddressClass { pub parent_class : GSocketAddressClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GInetSocketAddressClass"] [:: std :: mem :: size_of :: < _GInetSocketAddressClass > () - 160usize] ; ["Alignment of _GInetSocketAddressClass"] [:: std :: mem :: align_of :: < _GInetSocketAddressClass > () - 8usize] ; ["Offset of field: _GInetSocketAddressClass::parent_class"] [:: std :: mem :: offset_of ! (_GInetSocketAddressClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn g_inet_socket_address_get_type () -> GType ; } unsafe extern "C" { pub fn g_inet_socket_address_new (address : * mut GInetAddress , port : guint16) -> * mut GSocketAddress ; } unsafe extern "C" { pub fn g_inet_socket_address_new_from_string (address : * const :: std :: os :: raw :: c_char , port : guint) -> * mut GSocketAddress ; } unsafe extern "C" { pub fn g_inet_socket_address_get_address (address : * mut GInetSocketAddress) -> * mut GInetAddress ; } unsafe extern "C" { pub fn g_inet_socket_address_get_port (address : * mut GInetSocketAddress) -> guint16 ; } unsafe extern "C" { pub fn g_inet_socket_address_get_flowinfo (address : * mut GInetSocketAddress) -> guint32 ; } unsafe extern "C" { pub fn g_inet_socket_address_get_scope_id (address : * mut GInetSocketAddress) -> guint32 ; } unsafe extern "C" { pub fn g_app_info_create_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_converter_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_converter_result_get_type () -> GType ; } unsafe extern "C" { pub fn g_data_stream_byte_order_get_type () -> GType ; } unsafe extern "C" { pub fn g_data_stream_newline_type_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_attribute_type_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_attribute_info_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_attribute_status_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_query_info_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_create_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_measure_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_mount_mount_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_mount_unmount_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_drive_start_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_drive_start_stop_type_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_copy_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_monitor_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_type_get_type () -> GType ; } unsafe extern "C" { pub fn g_filesystem_preview_type_get_type () -> GType ; } unsafe extern "C" { pub fn g_file_monitor_event_get_type () -> GType ; } unsafe extern "C" { pub fn g_io_error_enum_get_type () -> GType ; } unsafe extern "C" { pub fn g_ask_password_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_password_save_get_type () -> GType ; } unsafe extern "C" { pub fn g_mount_operation_result_get_type () -> GType ; } unsafe extern "C" { pub fn g_output_stream_splice_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_io_stream_splice_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_emblem_origin_get_type () -> GType ; } unsafe extern "C" { pub fn g_resolver_error_get_type () -> GType ; } unsafe extern "C" { pub fn g_resolver_record_type_get_type () -> GType ; } unsafe extern "C" { pub fn g_resource_error_get_type () -> GType ; } unsafe extern "C" { pub fn g_resource_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_resource_lookup_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_family_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_type_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_msg_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_protocol_get_type () -> GType ; } unsafe extern "C" { pub fn g_zlib_compressor_format_get_type () -> GType ; } unsafe extern "C" { pub fn g_unix_socket_address_type_get_type () -> GType ; } unsafe extern "C" { pub fn g_bus_type_get_type () -> GType ; } unsafe extern "C" { pub fn g_bus_name_owner_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_bus_name_watcher_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_proxy_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_error_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_connection_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_capability_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_call_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_message_type_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_message_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_message_header_field_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_property_info_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_subtree_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_server_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_signal_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_send_message_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_credentials_type_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_message_byte_order_get_type () -> GType ; } unsafe extern "C" { pub fn g_application_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_error_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_certificate_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_authentication_mode_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_channel_binding_type_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_channel_binding_error_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_rehandshake_mode_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_password_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_interaction_result_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_interface_skeleton_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_dbus_object_manager_client_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_database_verify_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_database_lookup_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_certificate_request_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_protocol_version_get_type () -> GType ; } unsafe extern "C" { pub fn g_io_module_scope_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_client_event_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_listener_event_get_type () -> GType ; } unsafe extern "C" { pub fn g_test_dbus_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_subprocess_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_notification_priority_get_type () -> GType ; } unsafe extern "C" { pub fn g_network_connectivity_get_type () -> GType ; } unsafe extern "C" { pub fn g_pollable_return_get_type () -> GType ; } unsafe extern "C" { pub fn g_memory_monitor_warning_level_get_type () -> GType ; } unsafe extern "C" { pub fn g_resolver_name_lookup_flags_get_type () -> GType ; } unsafe extern "C" { pub fn g_settings_bind_flags_get_type () -> GType ; } pub const GModuleFlags_G_MODULE_BIND_LAZY : GModuleFlags = 1 ; pub const GModuleFlags_G_MODULE_BIND_LOCAL : GModuleFlags = 2 ; pub const GModuleFlags_G_MODULE_BIND_MASK : GModuleFlags = 3 ; pub type GModuleFlags = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GModule { _unused : [u8 ; 0] , } pub type GModule = _GModule ; pub type GModuleCheckInit = :: std :: option :: Option < unsafe extern "C" fn (module : * mut GModule) -> * const gchar > ; pub type GModuleUnload = :: std :: option :: Option < unsafe extern "C" fn (module : * mut GModule) > ; unsafe extern "C" { pub fn g_module_error_quark () -> GQuark ; } pub const GModuleError_G_MODULE_ERROR_FAILED : GModuleError = 0 ; pub const GModuleError_G_MODULE_ERROR_CHECK_FAILED : GModuleError = 1 ; pub type GModuleError = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_module_supported () -> gboolean ; } unsafe extern "C" { pub fn g_module_open (file_name : * const gchar , flags : GModuleFlags) -> * mut GModule ; } unsafe extern "C" { pub fn g_module_open_full (file_name : * const gchar , flags : GModuleFlags , error : * mut * mut GError) -> * mut GModule ; } unsafe extern "C" { pub fn g_module_close (module : * mut GModule) -> gboolean ; } unsafe extern "C" { pub fn g_module_make_resident (module : * mut GModule) ; } unsafe extern "C" { pub fn g_module_error () -> * const gchar ; } unsafe extern "C" { pub fn g_module_symbol (module : * mut GModule , symbol_name : * const gchar , symbol : * mut gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_module_name (module : * mut GModule) -> * const gchar ; } unsafe extern "C" { pub fn g_module_build_path (directory : * const gchar , module_name : * const gchar) -> * mut gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIOModuleScope { _unused : [u8 ; 0] , } pub type GIOModuleScope = _GIOModuleScope ; unsafe extern "C" { pub fn g_io_module_scope_new (flags : GIOModuleScopeFlags) -> * mut GIOModuleScope ; } unsafe extern "C" { pub fn g_io_module_scope_free (scope : * mut GIOModuleScope) ; } unsafe extern "C" { pub fn g_io_module_scope_block (scope : * mut GIOModuleScope , basename : * const gchar) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GIOModuleClass { _unused : [u8 ; 0] , } pub type GIOModuleClass = _GIOModuleClass ; unsafe extern "C" { pub fn g_io_module_get_type () -> GType ; } unsafe extern "C" { pub fn g_io_module_new (filename : * const gchar) -> * mut GIOModule ; } unsafe extern "C" { pub fn g_io_modules_scan_all_in_directory (dirname : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_io_modules_load_all_in_directory (dirname : * const gchar) -> * mut GList ; } unsafe extern "C" { pub fn g_io_modules_scan_all_in_directory_with_scope (dirname : * const gchar , scope : * mut GIOModuleScope) ; } unsafe extern "C" { pub fn g_io_modules_load_all_in_directory_with_scope (dirname : * const gchar , scope : * mut GIOModuleScope) -> * mut GList ; } unsafe extern "C" { pub fn g_io_extension_point_register (name : * const :: std :: os :: raw :: c_char) -> * mut GIOExtensionPoint ; } unsafe extern "C" { pub fn g_io_extension_point_lookup (name : * const :: std :: os :: raw :: c_char) -> * mut GIOExtensionPoint ; } unsafe extern "C" { pub fn g_io_extension_point_set_required_type (extension_point : * mut GIOExtensionPoint , type_ : GType) ; } unsafe extern "C" { pub fn g_io_extension_point_get_required_type (extension_point : * mut GIOExtensionPoint) -> GType ; } unsafe extern "C" { pub fn g_io_extension_point_get_extensions (extension_point : * mut GIOExtensionPoint) -> * mut GList ; } unsafe extern "C" { pub fn g_io_extension_point_get_extension_by_name (extension_point : * mut GIOExtensionPoint , name : * const :: std :: os :: raw :: c_char) -> * mut GIOExtension ; } unsafe extern "C" { pub fn g_io_extension_point_implement (extension_point_name : * const :: std :: os :: raw :: c_char , type_ : GType , extension_name : * const :: std :: os :: raw :: c_char , priority : gint) -> * mut GIOExtension ; } unsafe extern "C" { pub fn g_io_extension_get_type (extension : * mut GIOExtension) -> GType ; } unsafe extern "C" { pub fn g_io_extension_get_name (extension : * mut GIOExtension) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_io_extension_get_priority (extension : * mut GIOExtension) -> gint ; } unsafe extern "C" { pub fn g_io_extension_ref_class (extension : * mut GIOExtension) -> * mut GTypeClass ; } unsafe extern "C" { pub fn g_io_module_load (module : * mut GIOModule) ; } unsafe extern "C" { pub fn g_io_module_unload (module : * mut GIOModule) ; } unsafe extern "C" { pub fn g_io_module_query () -> * mut * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_io_scheduler_push_job (job_func : GIOSchedulerJobFunc , user_data : gpointer , notify : GDestroyNotify , io_priority : gint , cancellable : * mut GCancellable) ; } unsafe extern "C" { pub fn g_io_scheduler_cancel_all_jobs () ; } unsafe extern "C" { pub fn g_io_scheduler_job_send_to_mainloop (job : * mut GIOSchedulerJob , func : GSourceFunc , user_data : gpointer , notify : GDestroyNotify) -> gboolean ; } unsafe extern "C" { pub fn g_io_scheduler_job_send_to_mainloop_async (job : * mut GIOSchedulerJob , func : GSourceFunc , user_data : gpointer , notify : GDestroyNotify) ; } unsafe extern "C" { pub fn g_list_model_get_type () -> GType ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GListModel { _unused : [u8 ; 0] , } pub type GListModel = _GListModel ; pub type GListModelInterface = _GListModelInterface ; pub type GListModel_autoptr = * mut GListModel ; pub type GListModel_listautoptr = * mut GList ; pub type GListModel_slistautoptr = * mut GSList ; pub type GListModel_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GListModelInterface { pub g_iface : GTypeInterface , pub get_item_type : :: std :: option :: Option < unsafe extern "C" fn (list : * mut GListModel) -> GType > , pub get_n_items : :: std :: option :: Option < unsafe extern "C" fn (list : * mut GListModel) -> guint > , pub get_item : :: std :: option :: Option < unsafe extern "C" fn (list : * mut GListModel , position : guint) -> gpointer > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GListModelInterface"] [:: std :: mem :: size_of :: < _GListModelInterface > () - 40usize] ; ["Alignment of _GListModelInterface"] [:: std :: mem :: align_of :: < _GListModelInterface > () - 8usize] ; ["Offset of field: _GListModelInterface::g_iface"] [:: std :: mem :: offset_of ! (_GListModelInterface , g_iface) - 0usize] ; ["Offset of field: _GListModelInterface::get_item_type"] [:: std :: mem :: offset_of ! (_GListModelInterface , get_item_type) - 16usize] ; ["Offset of field: _GListModelInterface::get_n_items"] [:: std :: mem :: offset_of ! (_GListModelInterface , get_n_items) - 24usize] ; ["Offset of field: _GListModelInterface::get_item"] [:: std :: mem :: offset_of ! (_GListModelInterface , get_item) - 32usize] ; } ; unsafe extern "C" { pub fn g_list_model_get_item_type (list : * mut GListModel) -> GType ; } unsafe extern "C" { pub fn g_list_model_get_n_items (list : * mut GListModel) -> guint ; } unsafe extern "C" { pub fn g_list_model_get_item (list : * mut GListModel , position : guint) -> gpointer ; } unsafe extern "C" { pub fn g_list_model_get_object (list : * mut GListModel , position : guint) -> * mut GObject ; } unsafe extern "C" { pub fn g_list_model_items_changed (list : * mut GListModel , position : guint , removed : guint , added : guint) ; } unsafe extern "C" { pub fn g_list_store_get_type () -> GType ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GListStore { _unused : [u8 ; 0] , } pub type GListStore = _GListStore ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GListStoreClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of GListStoreClass"] [:: std :: mem :: size_of :: < GListStoreClass > () - 136usize] ; ["Alignment of GListStoreClass"] [:: std :: mem :: align_of :: < GListStoreClass > () - 8usize] ; ["Offset of field: GListStoreClass::parent_class"] [:: std :: mem :: offset_of ! (GListStoreClass , parent_class) - 0usize] ; } ; pub type GListStore_autoptr = * mut GListStore ; pub type GListStore_listautoptr = * mut GList ; pub type GListStore_slistautoptr = * mut GSList ; pub type GListStore_queueautoptr = * mut GQueue ; pub type GListStoreClass_autoptr = * mut GListStoreClass ; pub type GListStoreClass_listautoptr = * mut GList ; pub type GListStoreClass_slistautoptr = * mut GSList ; pub type GListStoreClass_queueautoptr = * mut GQueue ; unsafe extern "C" { pub fn g_list_store_new (item_type : GType) -> * mut GListStore ; } unsafe extern "C" { pub fn g_list_store_insert (store : * mut GListStore , position : guint , item : gpointer) ; } unsafe extern "C" { pub fn g_list_store_insert_sorted (store : * mut GListStore , item : gpointer , compare_func : GCompareDataFunc , user_data : gpointer) -> guint ; } unsafe extern "C" { pub fn g_list_store_sort (store : * mut GListStore , compare_func : GCompareDataFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn g_list_store_append (store : * mut GListStore , item : gpointer) ; } unsafe extern "C" { pub fn g_list_store_remove (store : * mut GListStore , position : guint) ; } unsafe extern "C" { pub fn g_list_store_remove_all (store : * mut GListStore) ; } unsafe extern "C" { pub fn g_list_store_splice (store : * mut GListStore , position : guint , n_removals : guint , additions : * mut gpointer , n_additions : guint) ; } unsafe extern "C" { pub fn g_list_store_find (store : * mut GListStore , item : gpointer , position : * mut guint) -> gboolean ; } unsafe extern "C" { pub fn g_list_store_find_with_equal_func (store : * mut GListStore , item : gpointer , equal_func : GEqualFunc , position : * mut guint) -> gboolean ; } unsafe extern "C" { pub fn g_list_store_find_with_equal_func_full (store : * mut GListStore , item : gpointer , equal_func : GEqualFuncFull , user_data : gpointer , position : * mut guint) -> gboolean ; } pub type GLoadableIconIface = _GLoadableIconIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GLoadableIconIface { pub g_iface : GTypeInterface , pub load : :: std :: option :: Option < unsafe extern "C" fn (icon : * mut GLoadableIcon , size : :: std :: os :: raw :: c_int , type_ : * mut * mut :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GInputStream > , pub load_async : :: std :: option :: Option < unsafe extern "C" fn (icon : * mut GLoadableIcon , size : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub load_finish : :: std :: option :: Option < unsafe extern "C" fn (icon : * mut GLoadableIcon , res : * mut GAsyncResult , type_ : * mut * mut :: std :: os :: raw :: c_char , error : * mut * mut GError) -> * mut GInputStream > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GLoadableIconIface"] [:: std :: mem :: size_of :: < _GLoadableIconIface > () - 40usize] ; ["Alignment of _GLoadableIconIface"] [:: std :: mem :: align_of :: < _GLoadableIconIface > () - 8usize] ; ["Offset of field: _GLoadableIconIface::g_iface"] [:: std :: mem :: offset_of ! (_GLoadableIconIface , g_iface) - 0usize] ; ["Offset of field: _GLoadableIconIface::load"] [:: std :: mem :: offset_of ! (_GLoadableIconIface , load) - 16usize] ; ["Offset of field: _GLoadableIconIface::load_async"] [:: std :: mem :: offset_of ! (_GLoadableIconIface , load_async) - 24usize] ; ["Offset of field: _GLoadableIconIface::load_finish"] [:: std :: mem :: offset_of ! (_GLoadableIconIface , load_finish) - 32usize] ; } ; unsafe extern "C" { pub fn g_loadable_icon_get_type () -> GType ; } unsafe extern "C" { pub fn g_loadable_icon_load (icon : * mut GLoadableIcon , size : :: std :: os :: raw :: c_int , type_ : * mut * mut :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GInputStream ; } unsafe extern "C" { pub fn g_loadable_icon_load_async (icon : * mut GLoadableIcon , size : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_loadable_icon_load_finish (icon : * mut GLoadableIcon , res : * mut GAsyncResult , type_ : * mut * mut :: std :: os :: raw :: c_char , error : * mut * mut GError) -> * mut GInputStream ; } pub type GMemoryInputStreamClass = _GMemoryInputStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMemoryInputStreamPrivate { _unused : [u8 ; 0] , } pub type GMemoryInputStreamPrivate = _GMemoryInputStreamPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMemoryInputStream { pub parent_instance : GInputStream , pub priv_ : * mut GMemoryInputStreamPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMemoryInputStream"] [:: std :: mem :: size_of :: < _GMemoryInputStream > () - 40usize] ; ["Alignment of _GMemoryInputStream"] [:: std :: mem :: align_of :: < _GMemoryInputStream > () - 8usize] ; ["Offset of field: _GMemoryInputStream::parent_instance"] [:: std :: mem :: offset_of ! (_GMemoryInputStream , parent_instance) - 0usize] ; ["Offset of field: _GMemoryInputStream::priv_"] [:: std :: mem :: offset_of ! (_GMemoryInputStream , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMemoryInputStreamClass { pub parent_class : GInputStreamClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMemoryInputStreamClass"] [:: std :: mem :: size_of :: < _GMemoryInputStreamClass > () - 288usize] ; ["Alignment of _GMemoryInputStreamClass"] [:: std :: mem :: align_of :: < _GMemoryInputStreamClass > () - 8usize] ; ["Offset of field: _GMemoryInputStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GMemoryInputStreamClass , parent_class) - 0usize] ; ["Offset of field: _GMemoryInputStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GMemoryInputStreamClass , _g_reserved1) - 248usize] ; ["Offset of field: _GMemoryInputStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GMemoryInputStreamClass , _g_reserved2) - 256usize] ; ["Offset of field: _GMemoryInputStreamClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GMemoryInputStreamClass , _g_reserved3) - 264usize] ; ["Offset of field: _GMemoryInputStreamClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GMemoryInputStreamClass , _g_reserved4) - 272usize] ; ["Offset of field: _GMemoryInputStreamClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GMemoryInputStreamClass , _g_reserved5) - 280usize] ; } ; unsafe extern "C" { pub fn g_memory_input_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_memory_input_stream_new () -> * mut GInputStream ; } unsafe extern "C" { pub fn g_memory_input_stream_new_from_data (data : * const :: std :: os :: raw :: c_void , len : gssize , destroy : GDestroyNotify) -> * mut GInputStream ; } unsafe extern "C" { pub fn g_memory_input_stream_new_from_bytes (bytes : * mut GBytes) -> * mut GInputStream ; } unsafe extern "C" { pub fn g_memory_input_stream_add_data (stream : * mut GMemoryInputStream , data : * const :: std :: os :: raw :: c_void , len : gssize , destroy : GDestroyNotify) ; } unsafe extern "C" { pub fn g_memory_input_stream_add_bytes (stream : * mut GMemoryInputStream , bytes : * mut GBytes) ; } unsafe extern "C" { pub fn g_memory_monitor_get_type () -> GType ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMemoryMonitor { _unused : [u8 ; 0] , } pub type GMemoryMonitor = _GMemoryMonitor ; pub type GMemoryMonitorInterface = _GMemoryMonitorInterface ; pub type GMemoryMonitor_autoptr = * mut GMemoryMonitor ; pub type GMemoryMonitor_listautoptr = * mut GList ; pub type GMemoryMonitor_slistautoptr = * mut GSList ; pub type GMemoryMonitor_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMemoryMonitorInterface { pub g_iface : GTypeInterface , pub low_memory_warning : :: std :: option :: Option < unsafe extern "C" fn (monitor : * mut GMemoryMonitor , level : GMemoryMonitorWarningLevel) > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMemoryMonitorInterface"] [:: std :: mem :: size_of :: < _GMemoryMonitorInterface > () - 24usize] ; ["Alignment of _GMemoryMonitorInterface"] [:: std :: mem :: align_of :: < _GMemoryMonitorInterface > () - 8usize] ; ["Offset of field: _GMemoryMonitorInterface::g_iface"] [:: std :: mem :: offset_of ! (_GMemoryMonitorInterface , g_iface) - 0usize] ; ["Offset of field: _GMemoryMonitorInterface::low_memory_warning"] [:: std :: mem :: offset_of ! (_GMemoryMonitorInterface , low_memory_warning) - 16usize] ; } ; unsafe extern "C" { pub fn g_memory_monitor_dup_default () -> * mut GMemoryMonitor ; } pub type GMemoryOutputStreamClass = _GMemoryOutputStreamClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMemoryOutputStreamPrivate { _unused : [u8 ; 0] , } pub type GMemoryOutputStreamPrivate = _GMemoryOutputStreamPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMemoryOutputStream { pub parent_instance : GOutputStream , pub priv_ : * mut GMemoryOutputStreamPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMemoryOutputStream"] [:: std :: mem :: size_of :: < _GMemoryOutputStream > () - 40usize] ; ["Alignment of _GMemoryOutputStream"] [:: std :: mem :: align_of :: < _GMemoryOutputStream > () - 8usize] ; ["Offset of field: _GMemoryOutputStream::parent_instance"] [:: std :: mem :: offset_of ! (_GMemoryOutputStream , parent_instance) - 0usize] ; ["Offset of field: _GMemoryOutputStream::priv_"] [:: std :: mem :: offset_of ! (_GMemoryOutputStream , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMemoryOutputStreamClass { pub parent_class : GOutputStreamClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMemoryOutputStreamClass"] [:: std :: mem :: size_of :: < _GMemoryOutputStreamClass > () - 336usize] ; ["Alignment of _GMemoryOutputStreamClass"] [:: std :: mem :: align_of :: < _GMemoryOutputStreamClass > () - 8usize] ; ["Offset of field: _GMemoryOutputStreamClass::parent_class"] [:: std :: mem :: offset_of ! (_GMemoryOutputStreamClass , parent_class) - 0usize] ; ["Offset of field: _GMemoryOutputStreamClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GMemoryOutputStreamClass , _g_reserved1) - 296usize] ; ["Offset of field: _GMemoryOutputStreamClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GMemoryOutputStreamClass , _g_reserved2) - 304usize] ; ["Offset of field: _GMemoryOutputStreamClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GMemoryOutputStreamClass , _g_reserved3) - 312usize] ; ["Offset of field: _GMemoryOutputStreamClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GMemoryOutputStreamClass , _g_reserved4) - 320usize] ; ["Offset of field: _GMemoryOutputStreamClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GMemoryOutputStreamClass , _g_reserved5) - 328usize] ; } ; pub type GReallocFunc = :: std :: option :: Option < unsafe extern "C" fn (data : gpointer , size : gsize) -> gpointer > ; unsafe extern "C" { pub fn g_memory_output_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_memory_output_stream_new (data : gpointer , size : gsize , realloc_function : GReallocFunc , destroy_function : GDestroyNotify) -> * mut GOutputStream ; } unsafe extern "C" { pub fn g_memory_output_stream_new_resizable () -> * mut GOutputStream ; } unsafe extern "C" { pub fn g_memory_output_stream_get_data (ostream : * mut GMemoryOutputStream) -> gpointer ; } unsafe extern "C" { pub fn g_memory_output_stream_get_size (ostream : * mut GMemoryOutputStream) -> gsize ; } unsafe extern "C" { pub fn g_memory_output_stream_get_data_size (ostream : * mut GMemoryOutputStream) -> gsize ; } unsafe extern "C" { pub fn g_memory_output_stream_steal_data (ostream : * mut GMemoryOutputStream) -> gpointer ; } unsafe extern "C" { pub fn g_memory_output_stream_steal_as_bytes (ostream : * mut GMemoryOutputStream) -> * mut GBytes ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMenuModelPrivate { _unused : [u8 ; 0] , } pub type GMenuModelPrivate = _GMenuModelPrivate ; pub type GMenuModelClass = _GMenuModelClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMenuAttributeIterPrivate { _unused : [u8 ; 0] , } pub type GMenuAttributeIterPrivate = _GMenuAttributeIterPrivate ; pub type GMenuAttributeIterClass = _GMenuAttributeIterClass ; pub type GMenuAttributeIter = _GMenuAttributeIter ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMenuLinkIterPrivate { _unused : [u8 ; 0] , } pub type GMenuLinkIterPrivate = _GMenuLinkIterPrivate ; pub type GMenuLinkIterClass = _GMenuLinkIterClass ; pub type GMenuLinkIter = _GMenuLinkIter ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMenuModel { pub parent_instance : GObject , pub priv_ : * mut GMenuModelPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMenuModel"] [:: std :: mem :: size_of :: < _GMenuModel > () - 32usize] ; ["Alignment of _GMenuModel"] [:: std :: mem :: align_of :: < _GMenuModel > () - 8usize] ; ["Offset of field: _GMenuModel::parent_instance"] [:: std :: mem :: offset_of ! (_GMenuModel , parent_instance) - 0usize] ; ["Offset of field: _GMenuModel::priv_"] [:: std :: mem :: offset_of ! (_GMenuModel , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMenuModelClass { pub parent_class : GObjectClass , pub is_mutable : :: std :: option :: Option < unsafe extern "C" fn (model : * mut GMenuModel) -> gboolean > , pub get_n_items : :: std :: option :: Option < unsafe extern "C" fn (model : * mut GMenuModel) -> gint > , pub get_item_attributes : :: std :: option :: Option < unsafe extern "C" fn (model : * mut GMenuModel , item_index : gint , attributes : * mut * mut GHashTable) > , pub iterate_item_attributes : :: std :: option :: Option < unsafe extern "C" fn (model : * mut GMenuModel , item_index : gint) -> * mut GMenuAttributeIter > , pub get_item_attribute_value : :: std :: option :: Option < unsafe extern "C" fn (model : * mut GMenuModel , item_index : gint , attribute : * const gchar , expected_type : * const GVariantType) -> * mut GVariant > , pub get_item_links : :: std :: option :: Option < unsafe extern "C" fn (model : * mut GMenuModel , item_index : gint , links : * mut * mut GHashTable) > , pub iterate_item_links : :: std :: option :: Option < unsafe extern "C" fn (model : * mut GMenuModel , item_index : gint) -> * mut GMenuLinkIter > , pub get_item_link : :: std :: option :: Option < unsafe extern "C" fn (model : * mut GMenuModel , item_index : gint , link : * const gchar) -> * mut GMenuModel > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMenuModelClass"] [:: std :: mem :: size_of :: < _GMenuModelClass > () - 200usize] ; ["Alignment of _GMenuModelClass"] [:: std :: mem :: align_of :: < _GMenuModelClass > () - 8usize] ; ["Offset of field: _GMenuModelClass::parent_class"] [:: std :: mem :: offset_of ! (_GMenuModelClass , parent_class) - 0usize] ; ["Offset of field: _GMenuModelClass::is_mutable"] [:: std :: mem :: offset_of ! (_GMenuModelClass , is_mutable) - 136usize] ; ["Offset of field: _GMenuModelClass::get_n_items"] [:: std :: mem :: offset_of ! (_GMenuModelClass , get_n_items) - 144usize] ; ["Offset of field: _GMenuModelClass::get_item_attributes"] [:: std :: mem :: offset_of ! (_GMenuModelClass , get_item_attributes) - 152usize] ; ["Offset of field: _GMenuModelClass::iterate_item_attributes"] [:: std :: mem :: offset_of ! (_GMenuModelClass , iterate_item_attributes) - 160usize] ; ["Offset of field: _GMenuModelClass::get_item_attribute_value"] [:: std :: mem :: offset_of ! (_GMenuModelClass , get_item_attribute_value) - 168usize] ; ["Offset of field: _GMenuModelClass::get_item_links"] [:: std :: mem :: offset_of ! (_GMenuModelClass , get_item_links) - 176usize] ; ["Offset of field: _GMenuModelClass::iterate_item_links"] [:: std :: mem :: offset_of ! (_GMenuModelClass , iterate_item_links) - 184usize] ; ["Offset of field: _GMenuModelClass::get_item_link"] [:: std :: mem :: offset_of ! (_GMenuModelClass , get_item_link) - 192usize] ; } ; unsafe extern "C" { pub fn g_menu_model_get_type () -> GType ; } unsafe extern "C" { pub fn g_menu_model_is_mutable (model : * mut GMenuModel) -> gboolean ; } unsafe extern "C" { pub fn g_menu_model_get_n_items (model : * mut GMenuModel) -> gint ; } unsafe extern "C" { pub fn g_menu_model_iterate_item_attributes (model : * mut GMenuModel , item_index : gint) -> * mut GMenuAttributeIter ; } unsafe extern "C" { pub fn g_menu_model_get_item_attribute_value (model : * mut GMenuModel , item_index : gint , attribute : * const gchar , expected_type : * const GVariantType) -> * mut GVariant ; } unsafe extern "C" { pub fn g_menu_model_get_item_attribute (model : * mut GMenuModel , item_index : gint , attribute : * const gchar , format_string : * const gchar , ...) -> gboolean ; } unsafe extern "C" { pub fn g_menu_model_iterate_item_links (model : * mut GMenuModel , item_index : gint) -> * mut GMenuLinkIter ; } unsafe extern "C" { pub fn g_menu_model_get_item_link (model : * mut GMenuModel , item_index : gint , link : * const gchar) -> * mut GMenuModel ; } unsafe extern "C" { pub fn g_menu_model_items_changed (model : * mut GMenuModel , position : gint , removed : gint , added : gint) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMenuAttributeIter { pub parent_instance : GObject , pub priv_ : * mut GMenuAttributeIterPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMenuAttributeIter"] [:: std :: mem :: size_of :: < _GMenuAttributeIter > () - 32usize] ; ["Alignment of _GMenuAttributeIter"] [:: std :: mem :: align_of :: < _GMenuAttributeIter > () - 8usize] ; ["Offset of field: _GMenuAttributeIter::parent_instance"] [:: std :: mem :: offset_of ! (_GMenuAttributeIter , parent_instance) - 0usize] ; ["Offset of field: _GMenuAttributeIter::priv_"] [:: std :: mem :: offset_of ! (_GMenuAttributeIter , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMenuAttributeIterClass { pub parent_class : GObjectClass , pub get_next : :: std :: option :: Option < unsafe extern "C" fn (iter : * mut GMenuAttributeIter , out_name : * mut * const gchar , value : * mut * mut GVariant) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMenuAttributeIterClass"] [:: std :: mem :: size_of :: < _GMenuAttributeIterClass > () - 144usize] ; ["Alignment of _GMenuAttributeIterClass"] [:: std :: mem :: align_of :: < _GMenuAttributeIterClass > () - 8usize] ; ["Offset of field: _GMenuAttributeIterClass::parent_class"] [:: std :: mem :: offset_of ! (_GMenuAttributeIterClass , parent_class) - 0usize] ; ["Offset of field: _GMenuAttributeIterClass::get_next"] [:: std :: mem :: offset_of ! (_GMenuAttributeIterClass , get_next) - 136usize] ; } ; unsafe extern "C" { pub fn g_menu_attribute_iter_get_type () -> GType ; } unsafe extern "C" { pub fn g_menu_attribute_iter_get_next (iter : * mut GMenuAttributeIter , out_name : * mut * const gchar , value : * mut * mut GVariant) -> gboolean ; } unsafe extern "C" { pub fn g_menu_attribute_iter_next (iter : * mut GMenuAttributeIter) -> gboolean ; } unsafe extern "C" { pub fn g_menu_attribute_iter_get_name (iter : * mut GMenuAttributeIter) -> * const gchar ; } unsafe extern "C" { pub fn g_menu_attribute_iter_get_value (iter : * mut GMenuAttributeIter) -> * mut GVariant ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMenuLinkIter { pub parent_instance : GObject , pub priv_ : * mut GMenuLinkIterPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMenuLinkIter"] [:: std :: mem :: size_of :: < _GMenuLinkIter > () - 32usize] ; ["Alignment of _GMenuLinkIter"] [:: std :: mem :: align_of :: < _GMenuLinkIter > () - 8usize] ; ["Offset of field: _GMenuLinkIter::parent_instance"] [:: std :: mem :: offset_of ! (_GMenuLinkIter , parent_instance) - 0usize] ; ["Offset of field: _GMenuLinkIter::priv_"] [:: std :: mem :: offset_of ! (_GMenuLinkIter , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMenuLinkIterClass { pub parent_class : GObjectClass , pub get_next : :: std :: option :: Option < unsafe extern "C" fn (iter : * mut GMenuLinkIter , out_link : * mut * const gchar , value : * mut * mut GMenuModel) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMenuLinkIterClass"] [:: std :: mem :: size_of :: < _GMenuLinkIterClass > () - 144usize] ; ["Alignment of _GMenuLinkIterClass"] [:: std :: mem :: align_of :: < _GMenuLinkIterClass > () - 8usize] ; ["Offset of field: _GMenuLinkIterClass::parent_class"] [:: std :: mem :: offset_of ! (_GMenuLinkIterClass , parent_class) - 0usize] ; ["Offset of field: _GMenuLinkIterClass::get_next"] [:: std :: mem :: offset_of ! (_GMenuLinkIterClass , get_next) - 136usize] ; } ; unsafe extern "C" { pub fn g_menu_link_iter_get_type () -> GType ; } unsafe extern "C" { pub fn g_menu_link_iter_get_next (iter : * mut GMenuLinkIter , out_link : * mut * const gchar , value : * mut * mut GMenuModel) -> gboolean ; } unsafe extern "C" { pub fn g_menu_link_iter_next (iter : * mut GMenuLinkIter) -> gboolean ; } unsafe extern "C" { pub fn g_menu_link_iter_get_name (iter : * mut GMenuLinkIter) -> * const gchar ; } unsafe extern "C" { pub fn g_menu_link_iter_get_value (iter : * mut GMenuLinkIter) -> * mut GMenuModel ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMenuItem { _unused : [u8 ; 0] , } pub type GMenuItem = _GMenuItem ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMenu { _unused : [u8 ; 0] , } pub type GMenu = _GMenu ; unsafe extern "C" { pub fn g_menu_get_type () -> GType ; } unsafe extern "C" { pub fn g_menu_new () -> * mut GMenu ; } unsafe extern "C" { pub fn g_menu_freeze (menu : * mut GMenu) ; } unsafe extern "C" { pub fn g_menu_insert_item (menu : * mut GMenu , position : gint , item : * mut GMenuItem) ; } unsafe extern "C" { pub fn g_menu_prepend_item (menu : * mut GMenu , item : * mut GMenuItem) ; } unsafe extern "C" { pub fn g_menu_append_item (menu : * mut GMenu , item : * mut GMenuItem) ; } unsafe extern "C" { pub fn g_menu_remove (menu : * mut GMenu , position : gint) ; } unsafe extern "C" { pub fn g_menu_remove_all (menu : * mut GMenu) ; } unsafe extern "C" { pub fn g_menu_insert (menu : * mut GMenu , position : gint , label : * const gchar , detailed_action : * const gchar) ; } unsafe extern "C" { pub fn g_menu_prepend (menu : * mut GMenu , label : * const gchar , detailed_action : * const gchar) ; } unsafe extern "C" { pub fn g_menu_append (menu : * mut GMenu , label : * const gchar , detailed_action : * const gchar) ; } unsafe extern "C" { pub fn g_menu_insert_section (menu : * mut GMenu , position : gint , label : * const gchar , section : * mut GMenuModel) ; } unsafe extern "C" { pub fn g_menu_prepend_section (menu : * mut GMenu , label : * const gchar , section : * mut GMenuModel) ; } unsafe extern "C" { pub fn g_menu_append_section (menu : * mut GMenu , label : * const gchar , section : * mut GMenuModel) ; } unsafe extern "C" { pub fn g_menu_insert_submenu (menu : * mut GMenu , position : gint , label : * const gchar , submenu : * mut GMenuModel) ; } unsafe extern "C" { pub fn g_menu_prepend_submenu (menu : * mut GMenu , label : * const gchar , submenu : * mut GMenuModel) ; } unsafe extern "C" { pub fn g_menu_append_submenu (menu : * mut GMenu , label : * const gchar , submenu : * mut GMenuModel) ; } unsafe extern "C" { pub fn g_menu_item_get_type () -> GType ; } unsafe extern "C" { pub fn g_menu_item_new (label : * const gchar , detailed_action : * const gchar) -> * mut GMenuItem ; } unsafe extern "C" { pub fn g_menu_item_new_from_model (model : * mut GMenuModel , item_index : gint) -> * mut GMenuItem ; } unsafe extern "C" { pub fn g_menu_item_new_submenu (label : * const gchar , submenu : * mut GMenuModel) -> * mut GMenuItem ; } unsafe extern "C" { pub fn g_menu_item_new_section (label : * const gchar , section : * mut GMenuModel) -> * mut GMenuItem ; } unsafe extern "C" { pub fn g_menu_item_get_attribute_value (menu_item : * mut GMenuItem , attribute : * const gchar , expected_type : * const GVariantType) -> * mut GVariant ; } unsafe extern "C" { pub fn g_menu_item_get_attribute (menu_item : * mut GMenuItem , attribute : * const gchar , format_string : * const gchar , ...) -> gboolean ; } unsafe extern "C" { pub fn g_menu_item_get_link (menu_item : * mut GMenuItem , link : * const gchar) -> * mut GMenuModel ; } unsafe extern "C" { pub fn g_menu_item_set_attribute_value (menu_item : * mut GMenuItem , attribute : * const gchar , value : * mut GVariant) ; } unsafe extern "C" { pub fn g_menu_item_set_attribute (menu_item : * mut GMenuItem , attribute : * const gchar , format_string : * const gchar , ...) ; } unsafe extern "C" { pub fn g_menu_item_set_link (menu_item : * mut GMenuItem , link : * const gchar , model : * mut GMenuModel) ; } unsafe extern "C" { pub fn g_menu_item_set_label (menu_item : * mut GMenuItem , label : * const gchar) ; } unsafe extern "C" { pub fn g_menu_item_set_submenu (menu_item : * mut GMenuItem , submenu : * mut GMenuModel) ; } unsafe extern "C" { pub fn g_menu_item_set_section (menu_item : * mut GMenuItem , section : * mut GMenuModel) ; } unsafe extern "C" { pub fn g_menu_item_set_action_and_target_value (menu_item : * mut GMenuItem , action : * const gchar , target_value : * mut GVariant) ; } unsafe extern "C" { pub fn g_menu_item_set_action_and_target (menu_item : * mut GMenuItem , action : * const gchar , format_string : * const gchar , ...) ; } unsafe extern "C" { pub fn g_menu_item_set_detailed_action (menu_item : * mut GMenuItem , detailed_action : * const gchar) ; } unsafe extern "C" { pub fn g_menu_item_set_icon (menu_item : * mut GMenuItem , icon : * mut GIcon) ; } unsafe extern "C" { pub fn g_dbus_connection_export_menu_model (connection : * mut GDBusConnection , object_path : * const gchar , menu : * mut GMenuModel , error : * mut * mut GError) -> guint ; } unsafe extern "C" { pub fn g_dbus_connection_unexport_menu_model (connection : * mut GDBusConnection , export_id : guint) ; } pub type GMountIface = _GMountIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMountIface { pub g_iface : GTypeInterface , pub changed : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount) > , pub unmounted : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount) > , pub get_root : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount) -> * mut GFile > , pub get_name : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount) -> * mut :: std :: os :: raw :: c_char > , pub get_icon : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount) -> * mut GIcon > , pub get_uuid : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount) -> * mut :: std :: os :: raw :: c_char > , pub get_volume : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount) -> * mut GVolume > , pub get_drive : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount) -> * mut GDrive > , pub can_unmount : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount) -> gboolean > , pub can_eject : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount) -> gboolean > , pub unmount : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount , flags : GMountUnmountFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub unmount_finish : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub eject : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount , flags : GMountUnmountFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub eject_finish : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub remount : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount , flags : GMountMountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub remount_finish : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub guess_content_type : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount , force_rescan : gboolean , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub guess_content_type_finish : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut * mut gchar > , pub guess_content_type_sync : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount , force_rescan : gboolean , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut * mut gchar > , pub pre_unmount : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount) > , pub unmount_with_operation : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub unmount_with_operation_finish : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub eject_with_operation : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub eject_with_operation_finish : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub get_default_location : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount) -> * mut GFile > , pub get_sort_key : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount) -> * const gchar > , pub get_symbolic_icon : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount) -> * mut GIcon > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMountIface"] [:: std :: mem :: size_of :: < _GMountIface > () - 232usize] ; ["Alignment of _GMountIface"] [:: std :: mem :: align_of :: < _GMountIface > () - 8usize] ; ["Offset of field: _GMountIface::g_iface"] [:: std :: mem :: offset_of ! (_GMountIface , g_iface) - 0usize] ; ["Offset of field: _GMountIface::changed"] [:: std :: mem :: offset_of ! (_GMountIface , changed) - 16usize] ; ["Offset of field: _GMountIface::unmounted"] [:: std :: mem :: offset_of ! (_GMountIface , unmounted) - 24usize] ; ["Offset of field: _GMountIface::get_root"] [:: std :: mem :: offset_of ! (_GMountIface , get_root) - 32usize] ; ["Offset of field: _GMountIface::get_name"] [:: std :: mem :: offset_of ! (_GMountIface , get_name) - 40usize] ; ["Offset of field: _GMountIface::get_icon"] [:: std :: mem :: offset_of ! (_GMountIface , get_icon) - 48usize] ; ["Offset of field: _GMountIface::get_uuid"] [:: std :: mem :: offset_of ! (_GMountIface , get_uuid) - 56usize] ; ["Offset of field: _GMountIface::get_volume"] [:: std :: mem :: offset_of ! (_GMountIface , get_volume) - 64usize] ; ["Offset of field: _GMountIface::get_drive"] [:: std :: mem :: offset_of ! (_GMountIface , get_drive) - 72usize] ; ["Offset of field: _GMountIface::can_unmount"] [:: std :: mem :: offset_of ! (_GMountIface , can_unmount) - 80usize] ; ["Offset of field: _GMountIface::can_eject"] [:: std :: mem :: offset_of ! (_GMountIface , can_eject) - 88usize] ; ["Offset of field: _GMountIface::unmount"] [:: std :: mem :: offset_of ! (_GMountIface , unmount) - 96usize] ; ["Offset of field: _GMountIface::unmount_finish"] [:: std :: mem :: offset_of ! (_GMountIface , unmount_finish) - 104usize] ; ["Offset of field: _GMountIface::eject"] [:: std :: mem :: offset_of ! (_GMountIface , eject) - 112usize] ; ["Offset of field: _GMountIface::eject_finish"] [:: std :: mem :: offset_of ! (_GMountIface , eject_finish) - 120usize] ; ["Offset of field: _GMountIface::remount"] [:: std :: mem :: offset_of ! (_GMountIface , remount) - 128usize] ; ["Offset of field: _GMountIface::remount_finish"] [:: std :: mem :: offset_of ! (_GMountIface , remount_finish) - 136usize] ; ["Offset of field: _GMountIface::guess_content_type"] [:: std :: mem :: offset_of ! (_GMountIface , guess_content_type) - 144usize] ; ["Offset of field: _GMountIface::guess_content_type_finish"] [:: std :: mem :: offset_of ! (_GMountIface , guess_content_type_finish) - 152usize] ; ["Offset of field: _GMountIface::guess_content_type_sync"] [:: std :: mem :: offset_of ! (_GMountIface , guess_content_type_sync) - 160usize] ; ["Offset of field: _GMountIface::pre_unmount"] [:: std :: mem :: offset_of ! (_GMountIface , pre_unmount) - 168usize] ; ["Offset of field: _GMountIface::unmount_with_operation"] [:: std :: mem :: offset_of ! (_GMountIface , unmount_with_operation) - 176usize] ; ["Offset of field: _GMountIface::unmount_with_operation_finish"] [:: std :: mem :: offset_of ! (_GMountIface , unmount_with_operation_finish) - 184usize] ; ["Offset of field: _GMountIface::eject_with_operation"] [:: std :: mem :: offset_of ! (_GMountIface , eject_with_operation) - 192usize] ; ["Offset of field: _GMountIface::eject_with_operation_finish"] [:: std :: mem :: offset_of ! (_GMountIface , eject_with_operation_finish) - 200usize] ; ["Offset of field: _GMountIface::get_default_location"] [:: std :: mem :: offset_of ! (_GMountIface , get_default_location) - 208usize] ; ["Offset of field: _GMountIface::get_sort_key"] [:: std :: mem :: offset_of ! (_GMountIface , get_sort_key) - 216usize] ; ["Offset of field: _GMountIface::get_symbolic_icon"] [:: std :: mem :: offset_of ! (_GMountIface , get_symbolic_icon) - 224usize] ; } ; unsafe extern "C" { pub fn g_mount_get_type () -> GType ; } unsafe extern "C" { pub fn g_mount_get_root (mount : * mut GMount) -> * mut GFile ; } unsafe extern "C" { pub fn g_mount_get_default_location (mount : * mut GMount) -> * mut GFile ; } unsafe extern "C" { pub fn g_mount_get_name (mount : * mut GMount) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_mount_get_icon (mount : * mut GMount) -> * mut GIcon ; } unsafe extern "C" { pub fn g_mount_get_symbolic_icon (mount : * mut GMount) -> * mut GIcon ; } unsafe extern "C" { pub fn g_mount_get_uuid (mount : * mut GMount) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_mount_get_volume (mount : * mut GMount) -> * mut GVolume ; } unsafe extern "C" { pub fn g_mount_get_drive (mount : * mut GMount) -> * mut GDrive ; } unsafe extern "C" { pub fn g_mount_can_unmount (mount : * mut GMount) -> gboolean ; } unsafe extern "C" { pub fn g_mount_can_eject (mount : * mut GMount) -> gboolean ; } unsafe extern "C" { pub fn g_mount_unmount (mount : * mut GMount , flags : GMountUnmountFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_mount_unmount_finish (mount : * mut GMount , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_mount_eject (mount : * mut GMount , flags : GMountUnmountFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_mount_eject_finish (mount : * mut GMount , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_mount_remount (mount : * mut GMount , flags : GMountMountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_mount_remount_finish (mount : * mut GMount , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_mount_guess_content_type (mount : * mut GMount , force_rescan : gboolean , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_mount_guess_content_type_finish (mount : * mut GMount , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_mount_guess_content_type_sync (mount : * mut GMount , force_rescan : gboolean , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_mount_is_shadowed (mount : * mut GMount) -> gboolean ; } unsafe extern "C" { pub fn g_mount_shadow (mount : * mut GMount) ; } unsafe extern "C" { pub fn g_mount_unshadow (mount : * mut GMount) ; } unsafe extern "C" { pub fn g_mount_unmount_with_operation (mount : * mut GMount , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_mount_unmount_with_operation_finish (mount : * mut GMount , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_mount_eject_with_operation (mount : * mut GMount , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_mount_eject_with_operation_finish (mount : * mut GMount , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_mount_get_sort_key (mount : * mut GMount) -> * const gchar ; } pub type GMountOperationClass = _GMountOperationClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMountOperationPrivate { _unused : [u8 ; 0] , } pub type GMountOperationPrivate = _GMountOperationPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMountOperation { pub parent_instance : GObject , pub priv_ : * mut GMountOperationPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMountOperation"] [:: std :: mem :: size_of :: < _GMountOperation > () - 32usize] ; ["Alignment of _GMountOperation"] [:: std :: mem :: align_of :: < _GMountOperation > () - 8usize] ; ["Offset of field: _GMountOperation::parent_instance"] [:: std :: mem :: offset_of ! (_GMountOperation , parent_instance) - 0usize] ; ["Offset of field: _GMountOperation::priv_"] [:: std :: mem :: offset_of ! (_GMountOperation , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GMountOperationClass { pub parent_class : GObjectClass , pub ask_password : :: std :: option :: Option < unsafe extern "C" fn (op : * mut GMountOperation , message : * const :: std :: os :: raw :: c_char , default_user : * const :: std :: os :: raw :: c_char , default_domain : * const :: std :: os :: raw :: c_char , flags : GAskPasswordFlags) > , pub ask_question : :: std :: option :: Option < unsafe extern "C" fn (op : * mut GMountOperation , message : * const :: std :: os :: raw :: c_char , choices : * mut * const :: std :: os :: raw :: c_char) > , pub reply : :: std :: option :: Option < unsafe extern "C" fn (op : * mut GMountOperation , result : GMountOperationResult) > , pub aborted : :: std :: option :: Option < unsafe extern "C" fn (op : * mut GMountOperation) > , pub show_processes : :: std :: option :: Option < unsafe extern "C" fn (op : * mut GMountOperation , message : * const gchar , processes : * mut GArray , choices : * mut * const gchar) > , pub show_unmount_progress : :: std :: option :: Option < unsafe extern "C" fn (op : * mut GMountOperation , message : * const gchar , time_left : gint64 , bytes_left : gint64) > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved6 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved7 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved8 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved9 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GMountOperationClass"] [:: std :: mem :: size_of :: < _GMountOperationClass > () - 256usize] ; ["Alignment of _GMountOperationClass"] [:: std :: mem :: align_of :: < _GMountOperationClass > () - 8usize] ; ["Offset of field: _GMountOperationClass::parent_class"] [:: std :: mem :: offset_of ! (_GMountOperationClass , parent_class) - 0usize] ; ["Offset of field: _GMountOperationClass::ask_password"] [:: std :: mem :: offset_of ! (_GMountOperationClass , ask_password) - 136usize] ; ["Offset of field: _GMountOperationClass::ask_question"] [:: std :: mem :: offset_of ! (_GMountOperationClass , ask_question) - 144usize] ; ["Offset of field: _GMountOperationClass::reply"] [:: std :: mem :: offset_of ! (_GMountOperationClass , reply) - 152usize] ; ["Offset of field: _GMountOperationClass::aborted"] [:: std :: mem :: offset_of ! (_GMountOperationClass , aborted) - 160usize] ; ["Offset of field: _GMountOperationClass::show_processes"] [:: std :: mem :: offset_of ! (_GMountOperationClass , show_processes) - 168usize] ; ["Offset of field: _GMountOperationClass::show_unmount_progress"] [:: std :: mem :: offset_of ! (_GMountOperationClass , show_unmount_progress) - 176usize] ; ["Offset of field: _GMountOperationClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GMountOperationClass , _g_reserved1) - 184usize] ; ["Offset of field: _GMountOperationClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GMountOperationClass , _g_reserved2) - 192usize] ; ["Offset of field: _GMountOperationClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GMountOperationClass , _g_reserved3) - 200usize] ; ["Offset of field: _GMountOperationClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GMountOperationClass , _g_reserved4) - 208usize] ; ["Offset of field: _GMountOperationClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GMountOperationClass , _g_reserved5) - 216usize] ; ["Offset of field: _GMountOperationClass::_g_reserved6"] [:: std :: mem :: offset_of ! (_GMountOperationClass , _g_reserved6) - 224usize] ; ["Offset of field: _GMountOperationClass::_g_reserved7"] [:: std :: mem :: offset_of ! (_GMountOperationClass , _g_reserved7) - 232usize] ; ["Offset of field: _GMountOperationClass::_g_reserved8"] [:: std :: mem :: offset_of ! (_GMountOperationClass , _g_reserved8) - 240usize] ; ["Offset of field: _GMountOperationClass::_g_reserved9"] [:: std :: mem :: offset_of ! (_GMountOperationClass , _g_reserved9) - 248usize] ; } ; unsafe extern "C" { pub fn g_mount_operation_get_type () -> GType ; } unsafe extern "C" { pub fn g_mount_operation_new () -> * mut GMountOperation ; } unsafe extern "C" { pub fn g_mount_operation_get_username (op : * mut GMountOperation) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_mount_operation_set_username (op : * mut GMountOperation , username : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_mount_operation_get_password (op : * mut GMountOperation) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_mount_operation_set_password (op : * mut GMountOperation , password : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_mount_operation_get_anonymous (op : * mut GMountOperation) -> gboolean ; } unsafe extern "C" { pub fn g_mount_operation_set_anonymous (op : * mut GMountOperation , anonymous : gboolean) ; } unsafe extern "C" { pub fn g_mount_operation_get_domain (op : * mut GMountOperation) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_mount_operation_set_domain (op : * mut GMountOperation , domain : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_mount_operation_get_password_save (op : * mut GMountOperation) -> GPasswordSave ; } unsafe extern "C" { pub fn g_mount_operation_set_password_save (op : * mut GMountOperation , save : GPasswordSave) ; } unsafe extern "C" { pub fn g_mount_operation_get_choice (op : * mut GMountOperation) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn g_mount_operation_set_choice (op : * mut GMountOperation , choice : :: std :: os :: raw :: c_int) ; } unsafe extern "C" { pub fn g_mount_operation_reply (op : * mut GMountOperation , result : GMountOperationResult) ; } unsafe extern "C" { pub fn g_mount_operation_get_is_tcrypt_hidden_volume (op : * mut GMountOperation) -> gboolean ; } unsafe extern "C" { pub fn g_mount_operation_set_is_tcrypt_hidden_volume (op : * mut GMountOperation , hidden_volume : gboolean) ; } unsafe extern "C" { pub fn g_mount_operation_get_is_tcrypt_system_volume (op : * mut GMountOperation) -> gboolean ; } unsafe extern "C" { pub fn g_mount_operation_set_is_tcrypt_system_volume (op : * mut GMountOperation , system_volume : gboolean) ; } unsafe extern "C" { pub fn g_mount_operation_get_pim (op : * mut GMountOperation) -> guint ; } unsafe extern "C" { pub fn g_mount_operation_set_pim (op : * mut GMountOperation , pim : guint) ; } pub type GNativeSocketAddressClass = _GNativeSocketAddressClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNativeSocketAddressPrivate { _unused : [u8 ; 0] , } pub type GNativeSocketAddressPrivate = _GNativeSocketAddressPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNativeSocketAddress { pub parent_instance : GSocketAddress , pub priv_ : * mut GNativeSocketAddressPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GNativeSocketAddress"] [:: std :: mem :: size_of :: < _GNativeSocketAddress > () - 32usize] ; ["Alignment of _GNativeSocketAddress"] [:: std :: mem :: align_of :: < _GNativeSocketAddress > () - 8usize] ; ["Offset of field: _GNativeSocketAddress::parent_instance"] [:: std :: mem :: offset_of ! (_GNativeSocketAddress , parent_instance) - 0usize] ; ["Offset of field: _GNativeSocketAddress::priv_"] [:: std :: mem :: offset_of ! (_GNativeSocketAddress , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNativeSocketAddressClass { pub parent_class : GSocketAddressClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GNativeSocketAddressClass"] [:: std :: mem :: size_of :: < _GNativeSocketAddressClass > () - 160usize] ; ["Alignment of _GNativeSocketAddressClass"] [:: std :: mem :: align_of :: < _GNativeSocketAddressClass > () - 8usize] ; ["Offset of field: _GNativeSocketAddressClass::parent_class"] [:: std :: mem :: offset_of ! (_GNativeSocketAddressClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn g_native_socket_address_get_type () -> GType ; } unsafe extern "C" { pub fn g_native_socket_address_new (native : gpointer , len : gsize) -> * mut GSocketAddress ; } pub type GVolumeMonitorClass = _GVolumeMonitorClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GVolumeMonitor { pub parent_instance : GObject , pub priv_ : gpointer , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GVolumeMonitor"] [:: std :: mem :: size_of :: < _GVolumeMonitor > () - 32usize] ; ["Alignment of _GVolumeMonitor"] [:: std :: mem :: align_of :: < _GVolumeMonitor > () - 8usize] ; ["Offset of field: _GVolumeMonitor::parent_instance"] [:: std :: mem :: offset_of ! (_GVolumeMonitor , parent_instance) - 0usize] ; ["Offset of field: _GVolumeMonitor::priv_"] [:: std :: mem :: offset_of ! (_GVolumeMonitor , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GVolumeMonitorClass { pub parent_class : GObjectClass , pub volume_added : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor , volume : * mut GVolume) > , pub volume_removed : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor , volume : * mut GVolume) > , pub volume_changed : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor , volume : * mut GVolume) > , pub mount_added : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor , mount : * mut GMount) > , pub mount_removed : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor , mount : * mut GMount) > , pub mount_pre_unmount : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor , mount : * mut GMount) > , pub mount_changed : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor , mount : * mut GMount) > , pub drive_connected : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor , drive : * mut GDrive) > , pub drive_disconnected : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor , drive : * mut GDrive) > , pub drive_changed : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor , drive : * mut GDrive) > , pub is_supported : :: std :: option :: Option < unsafe extern "C" fn () -> gboolean > , pub get_connected_drives : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor) -> * mut GList > , pub get_volumes : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor) -> * mut GList > , pub get_mounts : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor) -> * mut GList > , pub get_volume_for_uuid : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor , uuid : * const :: std :: os :: raw :: c_char) -> * mut GVolume > , pub get_mount_for_uuid : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor , uuid : * const :: std :: os :: raw :: c_char) -> * mut GMount > , pub adopt_orphan_mount : :: std :: option :: Option < unsafe extern "C" fn (mount : * mut GMount , volume_monitor : * mut GVolumeMonitor) -> * mut GVolume > , pub drive_eject_button : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor , drive : * mut GDrive) > , pub drive_stop_button : :: std :: option :: Option < unsafe extern "C" fn (volume_monitor : * mut GVolumeMonitor , drive : * mut GDrive) > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved6 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GVolumeMonitorClass"] [:: std :: mem :: size_of :: < _GVolumeMonitorClass > () - 336usize] ; ["Alignment of _GVolumeMonitorClass"] [:: std :: mem :: align_of :: < _GVolumeMonitorClass > () - 8usize] ; ["Offset of field: _GVolumeMonitorClass::parent_class"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , parent_class) - 0usize] ; ["Offset of field: _GVolumeMonitorClass::volume_added"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , volume_added) - 136usize] ; ["Offset of field: _GVolumeMonitorClass::volume_removed"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , volume_removed) - 144usize] ; ["Offset of field: _GVolumeMonitorClass::volume_changed"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , volume_changed) - 152usize] ; ["Offset of field: _GVolumeMonitorClass::mount_added"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , mount_added) - 160usize] ; ["Offset of field: _GVolumeMonitorClass::mount_removed"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , mount_removed) - 168usize] ; ["Offset of field: _GVolumeMonitorClass::mount_pre_unmount"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , mount_pre_unmount) - 176usize] ; ["Offset of field: _GVolumeMonitorClass::mount_changed"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , mount_changed) - 184usize] ; ["Offset of field: _GVolumeMonitorClass::drive_connected"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , drive_connected) - 192usize] ; ["Offset of field: _GVolumeMonitorClass::drive_disconnected"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , drive_disconnected) - 200usize] ; ["Offset of field: _GVolumeMonitorClass::drive_changed"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , drive_changed) - 208usize] ; ["Offset of field: _GVolumeMonitorClass::is_supported"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , is_supported) - 216usize] ; ["Offset of field: _GVolumeMonitorClass::get_connected_drives"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , get_connected_drives) - 224usize] ; ["Offset of field: _GVolumeMonitorClass::get_volumes"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , get_volumes) - 232usize] ; ["Offset of field: _GVolumeMonitorClass::get_mounts"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , get_mounts) - 240usize] ; ["Offset of field: _GVolumeMonitorClass::get_volume_for_uuid"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , get_volume_for_uuid) - 248usize] ; ["Offset of field: _GVolumeMonitorClass::get_mount_for_uuid"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , get_mount_for_uuid) - 256usize] ; ["Offset of field: _GVolumeMonitorClass::adopt_orphan_mount"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , adopt_orphan_mount) - 264usize] ; ["Offset of field: _GVolumeMonitorClass::drive_eject_button"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , drive_eject_button) - 272usize] ; ["Offset of field: _GVolumeMonitorClass::drive_stop_button"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , drive_stop_button) - 280usize] ; ["Offset of field: _GVolumeMonitorClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , _g_reserved1) - 288usize] ; ["Offset of field: _GVolumeMonitorClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , _g_reserved2) - 296usize] ; ["Offset of field: _GVolumeMonitorClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , _g_reserved3) - 304usize] ; ["Offset of field: _GVolumeMonitorClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , _g_reserved4) - 312usize] ; ["Offset of field: _GVolumeMonitorClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , _g_reserved5) - 320usize] ; ["Offset of field: _GVolumeMonitorClass::_g_reserved6"] [:: std :: mem :: offset_of ! (_GVolumeMonitorClass , _g_reserved6) - 328usize] ; } ; unsafe extern "C" { pub fn g_volume_monitor_get_type () -> GType ; } unsafe extern "C" { pub fn g_volume_monitor_get () -> * mut GVolumeMonitor ; } unsafe extern "C" { pub fn g_volume_monitor_get_connected_drives (volume_monitor : * mut GVolumeMonitor) -> * mut GList ; } unsafe extern "C" { pub fn g_volume_monitor_get_volumes (volume_monitor : * mut GVolumeMonitor) -> * mut GList ; } unsafe extern "C" { pub fn g_volume_monitor_get_mounts (volume_monitor : * mut GVolumeMonitor) -> * mut GList ; } unsafe extern "C" { pub fn g_volume_monitor_get_volume_for_uuid (volume_monitor : * mut GVolumeMonitor , uuid : * const :: std :: os :: raw :: c_char) -> * mut GVolume ; } unsafe extern "C" { pub fn g_volume_monitor_get_mount_for_uuid (volume_monitor : * mut GVolumeMonitor , uuid : * const :: std :: os :: raw :: c_char) -> * mut GMount ; } unsafe extern "C" { pub fn g_volume_monitor_adopt_orphan_mount (mount : * mut GMount) -> * mut GVolume ; } pub type GNativeVolumeMonitor = _GNativeVolumeMonitor ; pub type GNativeVolumeMonitorClass = _GNativeVolumeMonitorClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNativeVolumeMonitor { pub parent_instance : GVolumeMonitor , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GNativeVolumeMonitor"] [:: std :: mem :: size_of :: < _GNativeVolumeMonitor > () - 32usize] ; ["Alignment of _GNativeVolumeMonitor"] [:: std :: mem :: align_of :: < _GNativeVolumeMonitor > () - 8usize] ; ["Offset of field: _GNativeVolumeMonitor::parent_instance"] [:: std :: mem :: offset_of ! (_GNativeVolumeMonitor , parent_instance) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNativeVolumeMonitorClass { pub parent_class : GVolumeMonitorClass , pub get_mount_for_mount_path : :: std :: option :: Option < unsafe extern "C" fn (mount_path : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable) -> * mut GMount > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GNativeVolumeMonitorClass"] [:: std :: mem :: size_of :: < _GNativeVolumeMonitorClass > () - 344usize] ; ["Alignment of _GNativeVolumeMonitorClass"] [:: std :: mem :: align_of :: < _GNativeVolumeMonitorClass > () - 8usize] ; ["Offset of field: _GNativeVolumeMonitorClass::parent_class"] [:: std :: mem :: offset_of ! (_GNativeVolumeMonitorClass , parent_class) - 0usize] ; ["Offset of field: _GNativeVolumeMonitorClass::get_mount_for_mount_path"] [:: std :: mem :: offset_of ! (_GNativeVolumeMonitorClass , get_mount_for_mount_path) - 336usize] ; } ; unsafe extern "C" { pub fn g_native_volume_monitor_get_type () -> GType ; } pub type GNetworkAddressClass = _GNetworkAddressClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNetworkAddressPrivate { _unused : [u8 ; 0] , } pub type GNetworkAddressPrivate = _GNetworkAddressPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNetworkAddress { pub parent_instance : GObject , pub priv_ : * mut GNetworkAddressPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GNetworkAddress"] [:: std :: mem :: size_of :: < _GNetworkAddress > () - 32usize] ; ["Alignment of _GNetworkAddress"] [:: std :: mem :: align_of :: < _GNetworkAddress > () - 8usize] ; ["Offset of field: _GNetworkAddress::parent_instance"] [:: std :: mem :: offset_of ! (_GNetworkAddress , parent_instance) - 0usize] ; ["Offset of field: _GNetworkAddress::priv_"] [:: std :: mem :: offset_of ! (_GNetworkAddress , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNetworkAddressClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GNetworkAddressClass"] [:: std :: mem :: size_of :: < _GNetworkAddressClass > () - 136usize] ; ["Alignment of _GNetworkAddressClass"] [:: std :: mem :: align_of :: < _GNetworkAddressClass > () - 8usize] ; ["Offset of field: _GNetworkAddressClass::parent_class"] [:: std :: mem :: offset_of ! (_GNetworkAddressClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn g_network_address_get_type () -> GType ; } unsafe extern "C" { pub fn g_network_address_new (hostname : * const gchar , port : guint16) -> * mut GSocketConnectable ; } unsafe extern "C" { pub fn g_network_address_new_loopback (port : guint16) -> * mut GSocketConnectable ; } unsafe extern "C" { pub fn g_network_address_parse (host_and_port : * const gchar , default_port : guint16 , error : * mut * mut GError) -> * mut GSocketConnectable ; } unsafe extern "C" { pub fn g_network_address_parse_uri (uri : * const gchar , default_port : guint16 , error : * mut * mut GError) -> * mut GSocketConnectable ; } unsafe extern "C" { pub fn g_network_address_get_hostname (addr : * mut GNetworkAddress) -> * const gchar ; } unsafe extern "C" { pub fn g_network_address_get_port (addr : * mut GNetworkAddress) -> guint16 ; } unsafe extern "C" { pub fn g_network_address_get_scheme (addr : * mut GNetworkAddress) -> * const gchar ; } pub type GNetworkMonitorInterface = _GNetworkMonitorInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNetworkMonitorInterface { pub g_iface : GTypeInterface , pub network_changed : :: std :: option :: Option < unsafe extern "C" fn (monitor : * mut GNetworkMonitor , network_available : gboolean) > , pub can_reach : :: std :: option :: Option < unsafe extern "C" fn (monitor : * mut GNetworkMonitor , connectable : * mut GSocketConnectable , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub can_reach_async : :: std :: option :: Option < unsafe extern "C" fn (monitor : * mut GNetworkMonitor , connectable : * mut GSocketConnectable , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub can_reach_finish : :: std :: option :: Option < unsafe extern "C" fn (monitor : * mut GNetworkMonitor , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GNetworkMonitorInterface"] [:: std :: mem :: size_of :: < _GNetworkMonitorInterface > () - 48usize] ; ["Alignment of _GNetworkMonitorInterface"] [:: std :: mem :: align_of :: < _GNetworkMonitorInterface > () - 8usize] ; ["Offset of field: _GNetworkMonitorInterface::g_iface"] [:: std :: mem :: offset_of ! (_GNetworkMonitorInterface , g_iface) - 0usize] ; ["Offset of field: _GNetworkMonitorInterface::network_changed"] [:: std :: mem :: offset_of ! (_GNetworkMonitorInterface , network_changed) - 16usize] ; ["Offset of field: _GNetworkMonitorInterface::can_reach"] [:: std :: mem :: offset_of ! (_GNetworkMonitorInterface , can_reach) - 24usize] ; ["Offset of field: _GNetworkMonitorInterface::can_reach_async"] [:: std :: mem :: offset_of ! (_GNetworkMonitorInterface , can_reach_async) - 32usize] ; ["Offset of field: _GNetworkMonitorInterface::can_reach_finish"] [:: std :: mem :: offset_of ! (_GNetworkMonitorInterface , can_reach_finish) - 40usize] ; } ; unsafe extern "C" { pub fn g_network_monitor_get_type () -> GType ; } unsafe extern "C" { pub fn g_network_monitor_get_default () -> * mut GNetworkMonitor ; } unsafe extern "C" { pub fn g_network_monitor_get_network_available (monitor : * mut GNetworkMonitor) -> gboolean ; } unsafe extern "C" { pub fn g_network_monitor_get_network_metered (monitor : * mut GNetworkMonitor) -> gboolean ; } unsafe extern "C" { pub fn g_network_monitor_get_connectivity (monitor : * mut GNetworkMonitor) -> GNetworkConnectivity ; } unsafe extern "C" { pub fn g_network_monitor_can_reach (monitor : * mut GNetworkMonitor , connectable : * mut GSocketConnectable , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_network_monitor_can_reach_async (monitor : * mut GNetworkMonitor , connectable : * mut GSocketConnectable , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_network_monitor_can_reach_finish (monitor : * mut GNetworkMonitor , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } pub type GNetworkServiceClass = _GNetworkServiceClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNetworkServicePrivate { _unused : [u8 ; 0] , } pub type GNetworkServicePrivate = _GNetworkServicePrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNetworkService { pub parent_instance : GObject , pub priv_ : * mut GNetworkServicePrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GNetworkService"] [:: std :: mem :: size_of :: < _GNetworkService > () - 32usize] ; ["Alignment of _GNetworkService"] [:: std :: mem :: align_of :: < _GNetworkService > () - 8usize] ; ["Offset of field: _GNetworkService::parent_instance"] [:: std :: mem :: offset_of ! (_GNetworkService , parent_instance) - 0usize] ; ["Offset of field: _GNetworkService::priv_"] [:: std :: mem :: offset_of ! (_GNetworkService , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GNetworkServiceClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GNetworkServiceClass"] [:: std :: mem :: size_of :: < _GNetworkServiceClass > () - 136usize] ; ["Alignment of _GNetworkServiceClass"] [:: std :: mem :: align_of :: < _GNetworkServiceClass > () - 8usize] ; ["Offset of field: _GNetworkServiceClass::parent_class"] [:: std :: mem :: offset_of ! (_GNetworkServiceClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn g_network_service_get_type () -> GType ; } unsafe extern "C" { pub fn g_network_service_new (service : * const gchar , protocol : * const gchar , domain : * const gchar) -> * mut GSocketConnectable ; } unsafe extern "C" { pub fn g_network_service_get_service (srv : * mut GNetworkService) -> * const gchar ; } unsafe extern "C" { pub fn g_network_service_get_protocol (srv : * mut GNetworkService) -> * const gchar ; } unsafe extern "C" { pub fn g_network_service_get_domain (srv : * mut GNetworkService) -> * const gchar ; } unsafe extern "C" { pub fn g_network_service_get_scheme (srv : * mut GNetworkService) -> * const gchar ; } unsafe extern "C" { pub fn g_network_service_set_scheme (srv : * mut GNetworkService , scheme : * const gchar) ; } unsafe extern "C" { pub fn g_notification_get_type () -> GType ; } unsafe extern "C" { pub fn g_notification_new (title : * const gchar) -> * mut GNotification ; } unsafe extern "C" { pub fn g_notification_set_title (notification : * mut GNotification , title : * const gchar) ; } unsafe extern "C" { pub fn g_notification_set_body (notification : * mut GNotification , body : * const gchar) ; } unsafe extern "C" { pub fn g_notification_set_icon (notification : * mut GNotification , icon : * mut GIcon) ; } unsafe extern "C" { pub fn g_notification_set_urgent (notification : * mut GNotification , urgent : gboolean) ; } unsafe extern "C" { pub fn g_notification_set_priority (notification : * mut GNotification , priority : GNotificationPriority) ; } unsafe extern "C" { pub fn g_notification_set_category (notification : * mut GNotification , category : * const gchar) ; } unsafe extern "C" { pub fn g_notification_add_button (notification : * mut GNotification , label : * const gchar , detailed_action : * const gchar) ; } unsafe extern "C" { pub fn g_notification_add_button_with_target (notification : * mut GNotification , label : * const gchar , action : * const gchar , target_format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_notification_add_button_with_target_value (notification : * mut GNotification , label : * const gchar , action : * const gchar , target : * mut GVariant) ; } unsafe extern "C" { pub fn g_notification_set_default_action (notification : * mut GNotification , detailed_action : * const gchar) ; } unsafe extern "C" { pub fn g_notification_set_default_action_and_target (notification : * mut GNotification , action : * const gchar , target_format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_notification_set_default_action_and_target_value (notification : * mut GNotification , action : * const gchar , target : * mut GVariant) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPermissionPrivate { _unused : [u8 ; 0] , } pub type GPermissionPrivate = _GPermissionPrivate ; pub type GPermissionClass = _GPermissionClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPermission { pub parent_instance : GObject , pub priv_ : * mut GPermissionPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GPermission"] [:: std :: mem :: size_of :: < _GPermission > () - 32usize] ; ["Alignment of _GPermission"] [:: std :: mem :: align_of :: < _GPermission > () - 8usize] ; ["Offset of field: _GPermission::parent_instance"] [:: std :: mem :: offset_of ! (_GPermission , parent_instance) - 0usize] ; ["Offset of field: _GPermission::priv_"] [:: std :: mem :: offset_of ! (_GPermission , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPermissionClass { pub parent_class : GObjectClass , pub acquire : :: std :: option :: Option < unsafe extern "C" fn (permission : * mut GPermission , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub acquire_async : :: std :: option :: Option < unsafe extern "C" fn (permission : * mut GPermission , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub acquire_finish : :: std :: option :: Option < unsafe extern "C" fn (permission : * mut GPermission , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub release : :: std :: option :: Option < unsafe extern "C" fn (permission : * mut GPermission , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub release_async : :: std :: option :: Option < unsafe extern "C" fn (permission : * mut GPermission , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub release_finish : :: std :: option :: Option < unsafe extern "C" fn (permission : * mut GPermission , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub reserved : [gpointer ; 16usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GPermissionClass"] [:: std :: mem :: size_of :: < _GPermissionClass > () - 312usize] ; ["Alignment of _GPermissionClass"] [:: std :: mem :: align_of :: < _GPermissionClass > () - 8usize] ; ["Offset of field: _GPermissionClass::parent_class"] [:: std :: mem :: offset_of ! (_GPermissionClass , parent_class) - 0usize] ; ["Offset of field: _GPermissionClass::acquire"] [:: std :: mem :: offset_of ! (_GPermissionClass , acquire) - 136usize] ; ["Offset of field: _GPermissionClass::acquire_async"] [:: std :: mem :: offset_of ! (_GPermissionClass , acquire_async) - 144usize] ; ["Offset of field: _GPermissionClass::acquire_finish"] [:: std :: mem :: offset_of ! (_GPermissionClass , acquire_finish) - 152usize] ; ["Offset of field: _GPermissionClass::release"] [:: std :: mem :: offset_of ! (_GPermissionClass , release) - 160usize] ; ["Offset of field: _GPermissionClass::release_async"] [:: std :: mem :: offset_of ! (_GPermissionClass , release_async) - 168usize] ; ["Offset of field: _GPermissionClass::release_finish"] [:: std :: mem :: offset_of ! (_GPermissionClass , release_finish) - 176usize] ; ["Offset of field: _GPermissionClass::reserved"] [:: std :: mem :: offset_of ! (_GPermissionClass , reserved) - 184usize] ; } ; unsafe extern "C" { pub fn g_permission_get_type () -> GType ; } unsafe extern "C" { pub fn g_permission_acquire (permission : * mut GPermission , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_permission_acquire_async (permission : * mut GPermission , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_permission_acquire_finish (permission : * mut GPermission , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_permission_release (permission : * mut GPermission , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_permission_release_async (permission : * mut GPermission , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_permission_release_finish (permission : * mut GPermission , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_permission_get_allowed (permission : * mut GPermission) -> gboolean ; } unsafe extern "C" { pub fn g_permission_get_can_acquire (permission : * mut GPermission) -> gboolean ; } unsafe extern "C" { pub fn g_permission_get_can_release (permission : * mut GPermission) -> gboolean ; } unsafe extern "C" { pub fn g_permission_impl_update (permission : * mut GPermission , allowed : gboolean , can_acquire : gboolean , can_release : gboolean) ; } pub type GPollableInputStreamInterface = _GPollableInputStreamInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPollableInputStreamInterface { pub g_iface : GTypeInterface , pub can_poll : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GPollableInputStream) -> gboolean > , pub is_readable : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GPollableInputStream) -> gboolean > , pub create_source : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GPollableInputStream , cancellable : * mut GCancellable) -> * mut GSource > , pub read_nonblocking : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GPollableInputStream , buffer : * mut :: std :: os :: raw :: c_void , count : gsize , error : * mut * mut GError) -> gssize > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GPollableInputStreamInterface"] [:: std :: mem :: size_of :: < _GPollableInputStreamInterface > () - 48usize] ; ["Alignment of _GPollableInputStreamInterface"] [:: std :: mem :: align_of :: < _GPollableInputStreamInterface > () - 8usize] ; ["Offset of field: _GPollableInputStreamInterface::g_iface"] [:: std :: mem :: offset_of ! (_GPollableInputStreamInterface , g_iface) - 0usize] ; ["Offset of field: _GPollableInputStreamInterface::can_poll"] [:: std :: mem :: offset_of ! (_GPollableInputStreamInterface , can_poll) - 16usize] ; ["Offset of field: _GPollableInputStreamInterface::is_readable"] [:: std :: mem :: offset_of ! (_GPollableInputStreamInterface , is_readable) - 24usize] ; ["Offset of field: _GPollableInputStreamInterface::create_source"] [:: std :: mem :: offset_of ! (_GPollableInputStreamInterface , create_source) - 32usize] ; ["Offset of field: _GPollableInputStreamInterface::read_nonblocking"] [:: std :: mem :: offset_of ! (_GPollableInputStreamInterface , read_nonblocking) - 40usize] ; } ; unsafe extern "C" { pub fn g_pollable_input_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_pollable_input_stream_can_poll (stream : * mut GPollableInputStream) -> gboolean ; } unsafe extern "C" { pub fn g_pollable_input_stream_is_readable (stream : * mut GPollableInputStream) -> gboolean ; } unsafe extern "C" { pub fn g_pollable_input_stream_create_source (stream : * mut GPollableInputStream , cancellable : * mut GCancellable) -> * mut GSource ; } unsafe extern "C" { pub fn g_pollable_input_stream_read_nonblocking (stream : * mut GPollableInputStream , buffer : * mut :: std :: os :: raw :: c_void , count : gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } pub type GPollableOutputStreamInterface = _GPollableOutputStreamInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPollableOutputStreamInterface { pub g_iface : GTypeInterface , pub can_poll : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GPollableOutputStream) -> gboolean > , pub is_writable : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GPollableOutputStream) -> gboolean > , pub create_source : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GPollableOutputStream , cancellable : * mut GCancellable) -> * mut GSource > , pub write_nonblocking : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GPollableOutputStream , buffer : * const :: std :: os :: raw :: c_void , count : gsize , error : * mut * mut GError) -> gssize > , pub writev_nonblocking : :: std :: option :: Option < unsafe extern "C" fn (stream : * mut GPollableOutputStream , vectors : * const GOutputVector , n_vectors : gsize , bytes_written : * mut gsize , error : * mut * mut GError) -> GPollableReturn > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GPollableOutputStreamInterface"] [:: std :: mem :: size_of :: < _GPollableOutputStreamInterface > () - 56usize] ; ["Alignment of _GPollableOutputStreamInterface"] [:: std :: mem :: align_of :: < _GPollableOutputStreamInterface > () - 8usize] ; ["Offset of field: _GPollableOutputStreamInterface::g_iface"] [:: std :: mem :: offset_of ! (_GPollableOutputStreamInterface , g_iface) - 0usize] ; ["Offset of field: _GPollableOutputStreamInterface::can_poll"] [:: std :: mem :: offset_of ! (_GPollableOutputStreamInterface , can_poll) - 16usize] ; ["Offset of field: _GPollableOutputStreamInterface::is_writable"] [:: std :: mem :: offset_of ! (_GPollableOutputStreamInterface , is_writable) - 24usize] ; ["Offset of field: _GPollableOutputStreamInterface::create_source"] [:: std :: mem :: offset_of ! (_GPollableOutputStreamInterface , create_source) - 32usize] ; ["Offset of field: _GPollableOutputStreamInterface::write_nonblocking"] [:: std :: mem :: offset_of ! (_GPollableOutputStreamInterface , write_nonblocking) - 40usize] ; ["Offset of field: _GPollableOutputStreamInterface::writev_nonblocking"] [:: std :: mem :: offset_of ! (_GPollableOutputStreamInterface , writev_nonblocking) - 48usize] ; } ; unsafe extern "C" { pub fn g_pollable_output_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_pollable_output_stream_can_poll (stream : * mut GPollableOutputStream) -> gboolean ; } unsafe extern "C" { pub fn g_pollable_output_stream_is_writable (stream : * mut GPollableOutputStream) -> gboolean ; } unsafe extern "C" { pub fn g_pollable_output_stream_create_source (stream : * mut GPollableOutputStream , cancellable : * mut GCancellable) -> * mut GSource ; } unsafe extern "C" { pub fn g_pollable_output_stream_write_nonblocking (stream : * mut GPollableOutputStream , buffer : * const :: std :: os :: raw :: c_void , count : gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_pollable_output_stream_writev_nonblocking (stream : * mut GPollableOutputStream , vectors : * const GOutputVector , n_vectors : gsize , bytes_written : * mut gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> GPollableReturn ; } unsafe extern "C" { pub fn g_pollable_source_new (pollable_stream : * mut GObject) -> * mut GSource ; } unsafe extern "C" { pub fn g_pollable_source_new_full (pollable_stream : gpointer , child_source : * mut GSource , cancellable : * mut GCancellable) -> * mut GSource ; } unsafe extern "C" { pub fn g_pollable_stream_read (stream : * mut GInputStream , buffer : * mut :: std :: os :: raw :: c_void , count : gsize , blocking : gboolean , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_pollable_stream_write (stream : * mut GOutputStream , buffer : * const :: std :: os :: raw :: c_void , count : gsize , blocking : gboolean , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_pollable_stream_write_all (stream : * mut GOutputStream , buffer : * const :: std :: os :: raw :: c_void , count : gsize , blocking : gboolean , bytes_written : * mut gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_power_profile_monitor_get_type () -> GType ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPowerProfileMonitor { _unused : [u8 ; 0] , } pub type GPowerProfileMonitor = _GPowerProfileMonitor ; pub type GPowerProfileMonitorInterface = _GPowerProfileMonitorInterface ; pub type GPowerProfileMonitor_autoptr = * mut GPowerProfileMonitor ; pub type GPowerProfileMonitor_listautoptr = * mut GList ; pub type GPowerProfileMonitor_slistautoptr = * mut GSList ; pub type GPowerProfileMonitor_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GPowerProfileMonitorInterface { pub g_iface : GTypeInterface , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GPowerProfileMonitorInterface"] [:: std :: mem :: size_of :: < _GPowerProfileMonitorInterface > () - 16usize] ; ["Alignment of _GPowerProfileMonitorInterface"] [:: std :: mem :: align_of :: < _GPowerProfileMonitorInterface > () - 8usize] ; ["Offset of field: _GPowerProfileMonitorInterface::g_iface"] [:: std :: mem :: offset_of ! (_GPowerProfileMonitorInterface , g_iface) - 0usize] ; } ; unsafe extern "C" { pub fn g_power_profile_monitor_dup_default () -> * mut GPowerProfileMonitor ; } unsafe extern "C" { pub fn g_power_profile_monitor_get_power_saver_enabled (monitor : * mut GPowerProfileMonitor) -> gboolean ; } unsafe extern "C" { pub fn g_property_action_get_type () -> GType ; } unsafe extern "C" { pub fn g_property_action_new (name : * const gchar , object : gpointer , property_name : * const gchar) -> * mut GPropertyAction ; } pub type GProxyInterface = _GProxyInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GProxyInterface { pub g_iface : GTypeInterface , pub connect : :: std :: option :: Option < unsafe extern "C" fn (proxy : * mut GProxy , connection : * mut GIOStream , proxy_address : * mut GProxyAddress , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GIOStream > , pub connect_async : :: std :: option :: Option < unsafe extern "C" fn (proxy : * mut GProxy , connection : * mut GIOStream , proxy_address : * mut GProxyAddress , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub connect_finish : :: std :: option :: Option < unsafe extern "C" fn (proxy : * mut GProxy , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GIOStream > , pub supports_hostname : :: std :: option :: Option < unsafe extern "C" fn (proxy : * mut GProxy) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GProxyInterface"] [:: std :: mem :: size_of :: < _GProxyInterface > () - 48usize] ; ["Alignment of _GProxyInterface"] [:: std :: mem :: align_of :: < _GProxyInterface > () - 8usize] ; ["Offset of field: _GProxyInterface::g_iface"] [:: std :: mem :: offset_of ! (_GProxyInterface , g_iface) - 0usize] ; ["Offset of field: _GProxyInterface::connect"] [:: std :: mem :: offset_of ! (_GProxyInterface , connect) - 16usize] ; ["Offset of field: _GProxyInterface::connect_async"] [:: std :: mem :: offset_of ! (_GProxyInterface , connect_async) - 24usize] ; ["Offset of field: _GProxyInterface::connect_finish"] [:: std :: mem :: offset_of ! (_GProxyInterface , connect_finish) - 32usize] ; ["Offset of field: _GProxyInterface::supports_hostname"] [:: std :: mem :: offset_of ! (_GProxyInterface , supports_hostname) - 40usize] ; } ; unsafe extern "C" { pub fn g_proxy_get_type () -> GType ; } unsafe extern "C" { pub fn g_proxy_get_default_for_protocol (protocol : * const gchar) -> * mut GProxy ; } unsafe extern "C" { pub fn g_proxy_connect (proxy : * mut GProxy , connection : * mut GIOStream , proxy_address : * mut GProxyAddress , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GIOStream ; } unsafe extern "C" { pub fn g_proxy_connect_async (proxy : * mut GProxy , connection : * mut GIOStream , proxy_address : * mut GProxyAddress , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_proxy_connect_finish (proxy : * mut GProxy , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GIOStream ; } unsafe extern "C" { pub fn g_proxy_supports_hostname (proxy : * mut GProxy) -> gboolean ; } pub type GProxyAddressClass = _GProxyAddressClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GProxyAddressPrivate { _unused : [u8 ; 0] , } pub type GProxyAddressPrivate = _GProxyAddressPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GProxyAddress { pub parent_instance : GInetSocketAddress , pub priv_ : * mut GProxyAddressPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GProxyAddress"] [:: std :: mem :: size_of :: < _GProxyAddress > () - 40usize] ; ["Alignment of _GProxyAddress"] [:: std :: mem :: align_of :: < _GProxyAddress > () - 8usize] ; ["Offset of field: _GProxyAddress::parent_instance"] [:: std :: mem :: offset_of ! (_GProxyAddress , parent_instance) - 0usize] ; ["Offset of field: _GProxyAddress::priv_"] [:: std :: mem :: offset_of ! (_GProxyAddress , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GProxyAddressClass { pub parent_class : GInetSocketAddressClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GProxyAddressClass"] [:: std :: mem :: size_of :: < _GProxyAddressClass > () - 160usize] ; ["Alignment of _GProxyAddressClass"] [:: std :: mem :: align_of :: < _GProxyAddressClass > () - 8usize] ; ["Offset of field: _GProxyAddressClass::parent_class"] [:: std :: mem :: offset_of ! (_GProxyAddressClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn g_proxy_address_get_type () -> GType ; } unsafe extern "C" { pub fn g_proxy_address_new (inetaddr : * mut GInetAddress , port : guint16 , protocol : * const gchar , dest_hostname : * const gchar , dest_port : guint16 , username : * const gchar , password : * const gchar) -> * mut GSocketAddress ; } unsafe extern "C" { pub fn g_proxy_address_get_protocol (proxy : * mut GProxyAddress) -> * const gchar ; } unsafe extern "C" { pub fn g_proxy_address_get_destination_protocol (proxy : * mut GProxyAddress) -> * const gchar ; } unsafe extern "C" { pub fn g_proxy_address_get_destination_hostname (proxy : * mut GProxyAddress) -> * const gchar ; } unsafe extern "C" { pub fn g_proxy_address_get_destination_port (proxy : * mut GProxyAddress) -> guint16 ; } unsafe extern "C" { pub fn g_proxy_address_get_username (proxy : * mut GProxyAddress) -> * const gchar ; } unsafe extern "C" { pub fn g_proxy_address_get_password (proxy : * mut GProxyAddress) -> * const gchar ; } unsafe extern "C" { pub fn g_proxy_address_get_uri (proxy : * mut GProxyAddress) -> * const gchar ; } pub type GSocketAddressEnumeratorClass = _GSocketAddressEnumeratorClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketAddressEnumerator { pub parent_instance : GObject , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketAddressEnumerator"] [:: std :: mem :: size_of :: < _GSocketAddressEnumerator > () - 24usize] ; ["Alignment of _GSocketAddressEnumerator"] [:: std :: mem :: align_of :: < _GSocketAddressEnumerator > () - 8usize] ; ["Offset of field: _GSocketAddressEnumerator::parent_instance"] [:: std :: mem :: offset_of ! (_GSocketAddressEnumerator , parent_instance) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketAddressEnumeratorClass { pub parent_class : GObjectClass , pub next : :: std :: option :: Option < unsafe extern "C" fn (enumerator : * mut GSocketAddressEnumerator , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GSocketAddress > , pub next_async : :: std :: option :: Option < unsafe extern "C" fn (enumerator : * mut GSocketAddressEnumerator , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub next_finish : :: std :: option :: Option < unsafe extern "C" fn (enumerator : * mut GSocketAddressEnumerator , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GSocketAddress > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketAddressEnumeratorClass"] [:: std :: mem :: size_of :: < _GSocketAddressEnumeratorClass > () - 160usize] ; ["Alignment of _GSocketAddressEnumeratorClass"] [:: std :: mem :: align_of :: < _GSocketAddressEnumeratorClass > () - 8usize] ; ["Offset of field: _GSocketAddressEnumeratorClass::parent_class"] [:: std :: mem :: offset_of ! (_GSocketAddressEnumeratorClass , parent_class) - 0usize] ; ["Offset of field: _GSocketAddressEnumeratorClass::next"] [:: std :: mem :: offset_of ! (_GSocketAddressEnumeratorClass , next) - 136usize] ; ["Offset of field: _GSocketAddressEnumeratorClass::next_async"] [:: std :: mem :: offset_of ! (_GSocketAddressEnumeratorClass , next_async) - 144usize] ; ["Offset of field: _GSocketAddressEnumeratorClass::next_finish"] [:: std :: mem :: offset_of ! (_GSocketAddressEnumeratorClass , next_finish) - 152usize] ; } ; unsafe extern "C" { pub fn g_socket_address_enumerator_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_address_enumerator_next (enumerator : * mut GSocketAddressEnumerator , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GSocketAddress ; } unsafe extern "C" { pub fn g_socket_address_enumerator_next_async (enumerator : * mut GSocketAddressEnumerator , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_socket_address_enumerator_next_finish (enumerator : * mut GSocketAddressEnumerator , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GSocketAddress ; } pub type GProxyAddressEnumeratorClass = _GProxyAddressEnumeratorClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GProxyAddressEnumeratorPrivate { _unused : [u8 ; 0] , } pub type GProxyAddressEnumeratorPrivate = _GProxyAddressEnumeratorPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GProxyAddressEnumerator { pub parent_instance : GSocketAddressEnumerator , pub priv_ : * mut GProxyAddressEnumeratorPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GProxyAddressEnumerator"] [:: std :: mem :: size_of :: < _GProxyAddressEnumerator > () - 32usize] ; ["Alignment of _GProxyAddressEnumerator"] [:: std :: mem :: align_of :: < _GProxyAddressEnumerator > () - 8usize] ; ["Offset of field: _GProxyAddressEnumerator::parent_instance"] [:: std :: mem :: offset_of ! (_GProxyAddressEnumerator , parent_instance) - 0usize] ; ["Offset of field: _GProxyAddressEnumerator::priv_"] [:: std :: mem :: offset_of ! (_GProxyAddressEnumerator , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GProxyAddressEnumeratorClass { pub parent_class : GSocketAddressEnumeratorClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved6 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved7 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GProxyAddressEnumeratorClass"] [:: std :: mem :: size_of :: < _GProxyAddressEnumeratorClass > () - 216usize] ; ["Alignment of _GProxyAddressEnumeratorClass"] [:: std :: mem :: align_of :: < _GProxyAddressEnumeratorClass > () - 8usize] ; ["Offset of field: _GProxyAddressEnumeratorClass::parent_class"] [:: std :: mem :: offset_of ! (_GProxyAddressEnumeratorClass , parent_class) - 0usize] ; ["Offset of field: _GProxyAddressEnumeratorClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GProxyAddressEnumeratorClass , _g_reserved1) - 160usize] ; ["Offset of field: _GProxyAddressEnumeratorClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GProxyAddressEnumeratorClass , _g_reserved2) - 168usize] ; ["Offset of field: _GProxyAddressEnumeratorClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GProxyAddressEnumeratorClass , _g_reserved3) - 176usize] ; ["Offset of field: _GProxyAddressEnumeratorClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GProxyAddressEnumeratorClass , _g_reserved4) - 184usize] ; ["Offset of field: _GProxyAddressEnumeratorClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GProxyAddressEnumeratorClass , _g_reserved5) - 192usize] ; ["Offset of field: _GProxyAddressEnumeratorClass::_g_reserved6"] [:: std :: mem :: offset_of ! (_GProxyAddressEnumeratorClass , _g_reserved6) - 200usize] ; ["Offset of field: _GProxyAddressEnumeratorClass::_g_reserved7"] [:: std :: mem :: offset_of ! (_GProxyAddressEnumeratorClass , _g_reserved7) - 208usize] ; } ; unsafe extern "C" { pub fn g_proxy_address_enumerator_get_type () -> GType ; } pub type GProxyResolverInterface = _GProxyResolverInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GProxyResolverInterface { pub g_iface : GTypeInterface , pub is_supported : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GProxyResolver) -> gboolean > , pub lookup : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GProxyResolver , uri : * const gchar , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut * mut gchar > , pub lookup_async : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GProxyResolver , uri : * const gchar , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub lookup_finish : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GProxyResolver , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut * mut gchar > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GProxyResolverInterface"] [:: std :: mem :: size_of :: < _GProxyResolverInterface > () - 48usize] ; ["Alignment of _GProxyResolverInterface"] [:: std :: mem :: align_of :: < _GProxyResolverInterface > () - 8usize] ; ["Offset of field: _GProxyResolverInterface::g_iface"] [:: std :: mem :: offset_of ! (_GProxyResolverInterface , g_iface) - 0usize] ; ["Offset of field: _GProxyResolverInterface::is_supported"] [:: std :: mem :: offset_of ! (_GProxyResolverInterface , is_supported) - 16usize] ; ["Offset of field: _GProxyResolverInterface::lookup"] [:: std :: mem :: offset_of ! (_GProxyResolverInterface , lookup) - 24usize] ; ["Offset of field: _GProxyResolverInterface::lookup_async"] [:: std :: mem :: offset_of ! (_GProxyResolverInterface , lookup_async) - 32usize] ; ["Offset of field: _GProxyResolverInterface::lookup_finish"] [:: std :: mem :: offset_of ! (_GProxyResolverInterface , lookup_finish) - 40usize] ; } ; unsafe extern "C" { pub fn g_proxy_resolver_get_type () -> GType ; } unsafe extern "C" { pub fn g_proxy_resolver_get_default () -> * mut GProxyResolver ; } unsafe extern "C" { pub fn g_proxy_resolver_is_supported (resolver : * mut GProxyResolver) -> gboolean ; } unsafe extern "C" { pub fn g_proxy_resolver_lookup (resolver : * mut GProxyResolver , uri : * const gchar , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_proxy_resolver_lookup_async (resolver : * mut GProxyResolver , uri : * const gchar , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_proxy_resolver_lookup_finish (resolver : * mut GProxyResolver , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut * mut gchar ; } pub type GRemoteActionGroupInterface = _GRemoteActionGroupInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GRemoteActionGroupInterface { pub g_iface : GTypeInterface , pub activate_action_full : :: std :: option :: Option < unsafe extern "C" fn (remote : * mut GRemoteActionGroup , action_name : * const gchar , parameter : * mut GVariant , platform_data : * mut GVariant) > , pub change_action_state_full : :: std :: option :: Option < unsafe extern "C" fn (remote : * mut GRemoteActionGroup , action_name : * const gchar , value : * mut GVariant , platform_data : * mut GVariant) > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GRemoteActionGroupInterface"] [:: std :: mem :: size_of :: < _GRemoteActionGroupInterface > () - 32usize] ; ["Alignment of _GRemoteActionGroupInterface"] [:: std :: mem :: align_of :: < _GRemoteActionGroupInterface > () - 8usize] ; ["Offset of field: _GRemoteActionGroupInterface::g_iface"] [:: std :: mem :: offset_of ! (_GRemoteActionGroupInterface , g_iface) - 0usize] ; ["Offset of field: _GRemoteActionGroupInterface::activate_action_full"] [:: std :: mem :: offset_of ! (_GRemoteActionGroupInterface , activate_action_full) - 16usize] ; ["Offset of field: _GRemoteActionGroupInterface::change_action_state_full"] [:: std :: mem :: offset_of ! (_GRemoteActionGroupInterface , change_action_state_full) - 24usize] ; } ; unsafe extern "C" { pub fn g_remote_action_group_get_type () -> GType ; } unsafe extern "C" { pub fn g_remote_action_group_activate_action_full (remote : * mut GRemoteActionGroup , action_name : * const gchar , parameter : * mut GVariant , platform_data : * mut GVariant) ; } unsafe extern "C" { pub fn g_remote_action_group_change_action_state_full (remote : * mut GRemoteActionGroup , action_name : * const gchar , value : * mut GVariant , platform_data : * mut GVariant) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GResolverPrivate { _unused : [u8 ; 0] , } pub type GResolverPrivate = _GResolverPrivate ; pub type GResolverClass = _GResolverClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GResolver { pub parent_instance : GObject , pub priv_ : * mut GResolverPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GResolver"] [:: std :: mem :: size_of :: < _GResolver > () - 32usize] ; ["Alignment of _GResolver"] [:: std :: mem :: align_of :: < _GResolver > () - 8usize] ; ["Offset of field: _GResolver::parent_instance"] [:: std :: mem :: offset_of ! (_GResolver , parent_instance) - 0usize] ; ["Offset of field: _GResolver::priv_"] [:: std :: mem :: offset_of ! (_GResolver , priv_) - 24usize] ; } ; pub const GResolverNameLookupFlags_G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT : GResolverNameLookupFlags = 0 ; pub const GResolverNameLookupFlags_G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY : GResolverNameLookupFlags = 1 ; pub const GResolverNameLookupFlags_G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY : GResolverNameLookupFlags = 2 ; pub type GResolverNameLookupFlags = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GResolverClass { pub parent_class : GObjectClass , pub reload : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver) > , pub lookup_by_name : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , hostname : * const gchar , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GList > , pub lookup_by_name_async : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , hostname : * const gchar , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub lookup_by_name_finish : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GList > , pub lookup_by_address : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , address : * mut GInetAddress , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut gchar > , pub lookup_by_address_async : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , address : * mut GInetAddress , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub lookup_by_address_finish : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut gchar > , pub lookup_service : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , rrname : * const gchar , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GList > , pub lookup_service_async : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , rrname : * const gchar , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub lookup_service_finish : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GList > , pub lookup_records : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , rrname : * const gchar , record_type : GResolverRecordType , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GList > , pub lookup_records_async : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , rrname : * const gchar , record_type : GResolverRecordType , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub lookup_records_finish : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GList > , pub lookup_by_name_with_flags_async : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , hostname : * const gchar , flags : GResolverNameLookupFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub lookup_by_name_with_flags_finish : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GList > , pub lookup_by_name_with_flags : :: std :: option :: Option < unsafe extern "C" fn (resolver : * mut GResolver , hostname : * const gchar , flags : GResolverNameLookupFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GList > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GResolverClass"] [:: std :: mem :: size_of :: < _GResolverClass > () - 264usize] ; ["Alignment of _GResolverClass"] [:: std :: mem :: align_of :: < _GResolverClass > () - 8usize] ; ["Offset of field: _GResolverClass::parent_class"] [:: std :: mem :: offset_of ! (_GResolverClass , parent_class) - 0usize] ; ["Offset of field: _GResolverClass::reload"] [:: std :: mem :: offset_of ! (_GResolverClass , reload) - 136usize] ; ["Offset of field: _GResolverClass::lookup_by_name"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_by_name) - 144usize] ; ["Offset of field: _GResolverClass::lookup_by_name_async"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_by_name_async) - 152usize] ; ["Offset of field: _GResolverClass::lookup_by_name_finish"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_by_name_finish) - 160usize] ; ["Offset of field: _GResolverClass::lookup_by_address"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_by_address) - 168usize] ; ["Offset of field: _GResolverClass::lookup_by_address_async"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_by_address_async) - 176usize] ; ["Offset of field: _GResolverClass::lookup_by_address_finish"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_by_address_finish) - 184usize] ; ["Offset of field: _GResolverClass::lookup_service"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_service) - 192usize] ; ["Offset of field: _GResolverClass::lookup_service_async"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_service_async) - 200usize] ; ["Offset of field: _GResolverClass::lookup_service_finish"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_service_finish) - 208usize] ; ["Offset of field: _GResolverClass::lookup_records"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_records) - 216usize] ; ["Offset of field: _GResolverClass::lookup_records_async"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_records_async) - 224usize] ; ["Offset of field: _GResolverClass::lookup_records_finish"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_records_finish) - 232usize] ; ["Offset of field: _GResolverClass::lookup_by_name_with_flags_async"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_by_name_with_flags_async) - 240usize] ; ["Offset of field: _GResolverClass::lookup_by_name_with_flags_finish"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_by_name_with_flags_finish) - 248usize] ; ["Offset of field: _GResolverClass::lookup_by_name_with_flags"] [:: std :: mem :: offset_of ! (_GResolverClass , lookup_by_name_with_flags) - 256usize] ; } ; unsafe extern "C" { pub fn g_resolver_get_type () -> GType ; } unsafe extern "C" { pub fn g_resolver_get_default () -> * mut GResolver ; } unsafe extern "C" { pub fn g_resolver_set_default (resolver : * mut GResolver) ; } unsafe extern "C" { pub fn g_resolver_lookup_by_name (resolver : * mut GResolver , hostname : * const gchar , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GList ; } unsafe extern "C" { pub fn g_resolver_lookup_by_name_async (resolver : * mut GResolver , hostname : * const gchar , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_resolver_lookup_by_name_finish (resolver : * mut GResolver , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GList ; } unsafe extern "C" { pub fn g_resolver_lookup_by_name_with_flags_async (resolver : * mut GResolver , hostname : * const gchar , flags : GResolverNameLookupFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_resolver_lookup_by_name_with_flags_finish (resolver : * mut GResolver , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GList ; } unsafe extern "C" { pub fn g_resolver_lookup_by_name_with_flags (resolver : * mut GResolver , hostname : * const gchar , flags : GResolverNameLookupFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GList ; } unsafe extern "C" { pub fn g_resolver_free_addresses (addresses : * mut GList) ; } unsafe extern "C" { pub fn g_resolver_lookup_by_address (resolver : * mut GResolver , address : * mut GInetAddress , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_resolver_lookup_by_address_async (resolver : * mut GResolver , address : * mut GInetAddress , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_resolver_lookup_by_address_finish (resolver : * mut GResolver , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn g_resolver_lookup_service (resolver : * mut GResolver , service : * const gchar , protocol : * const gchar , domain : * const gchar , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GList ; } unsafe extern "C" { pub fn g_resolver_lookup_service_async (resolver : * mut GResolver , service : * const gchar , protocol : * const gchar , domain : * const gchar , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_resolver_lookup_service_finish (resolver : * mut GResolver , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GList ; } unsafe extern "C" { pub fn g_resolver_lookup_records (resolver : * mut GResolver , rrname : * const gchar , record_type : GResolverRecordType , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GList ; } unsafe extern "C" { pub fn g_resolver_lookup_records_async (resolver : * mut GResolver , rrname : * const gchar , record_type : GResolverRecordType , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_resolver_lookup_records_finish (resolver : * mut GResolver , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GList ; } unsafe extern "C" { pub fn g_resolver_free_targets (targets : * mut GList) ; } unsafe extern "C" { pub fn g_resolver_get_timeout (resolver : * mut GResolver) -> :: std :: os :: raw :: c_uint ; } unsafe extern "C" { pub fn g_resolver_set_timeout (resolver : * mut GResolver , timeout_ms : :: std :: os :: raw :: c_uint) ; } unsafe extern "C" { pub fn g_resolver_error_quark () -> GQuark ; } unsafe extern "C" { pub fn g_resource_error_quark () -> GQuark ; } pub type GStaticResource = _GStaticResource ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GStaticResource { pub data : * const guint8 , pub data_len : gsize , pub resource : * mut GResource , pub next : * mut GStaticResource , pub padding : gpointer , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GStaticResource"] [:: std :: mem :: size_of :: < _GStaticResource > () - 40usize] ; ["Alignment of _GStaticResource"] [:: std :: mem :: align_of :: < _GStaticResource > () - 8usize] ; ["Offset of field: _GStaticResource::data"] [:: std :: mem :: offset_of ! (_GStaticResource , data) - 0usize] ; ["Offset of field: _GStaticResource::data_len"] [:: std :: mem :: offset_of ! (_GStaticResource , data_len) - 8usize] ; ["Offset of field: _GStaticResource::resource"] [:: std :: mem :: offset_of ! (_GStaticResource , resource) - 16usize] ; ["Offset of field: _GStaticResource::next"] [:: std :: mem :: offset_of ! (_GStaticResource , next) - 24usize] ; ["Offset of field: _GStaticResource::padding"] [:: std :: mem :: offset_of ! (_GStaticResource , padding) - 32usize] ; } ; unsafe extern "C" { pub fn g_resource_get_type () -> GType ; } unsafe extern "C" { pub fn g_resource_new_from_data (data : * mut GBytes , error : * mut * mut GError) -> * mut GResource ; } unsafe extern "C" { pub fn g_resource_ref (resource : * mut GResource) -> * mut GResource ; } unsafe extern "C" { pub fn g_resource_unref (resource : * mut GResource) ; } unsafe extern "C" { pub fn g_resource_load (filename : * const gchar , error : * mut * mut GError) -> * mut GResource ; } unsafe extern "C" { pub fn g_resource_open_stream (resource : * mut GResource , path : * const :: std :: os :: raw :: c_char , lookup_flags : GResourceLookupFlags , error : * mut * mut GError) -> * mut GInputStream ; } unsafe extern "C" { pub fn g_resource_lookup_data (resource : * mut GResource , path : * const :: std :: os :: raw :: c_char , lookup_flags : GResourceLookupFlags , error : * mut * mut GError) -> * mut GBytes ; } unsafe extern "C" { pub fn g_resource_enumerate_children (resource : * mut GResource , path : * const :: std :: os :: raw :: c_char , lookup_flags : GResourceLookupFlags , error : * mut * mut GError) -> * mut * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_resource_get_info (resource : * mut GResource , path : * const :: std :: os :: raw :: c_char , lookup_flags : GResourceLookupFlags , size : * mut gsize , flags : * mut guint32 , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_resources_register (resource : * mut GResource) ; } unsafe extern "C" { pub fn g_resources_unregister (resource : * mut GResource) ; } unsafe extern "C" { pub fn g_resources_open_stream (path : * const :: std :: os :: raw :: c_char , lookup_flags : GResourceLookupFlags , error : * mut * mut GError) -> * mut GInputStream ; } unsafe extern "C" { pub fn g_resources_lookup_data (path : * const :: std :: os :: raw :: c_char , lookup_flags : GResourceLookupFlags , error : * mut * mut GError) -> * mut GBytes ; } unsafe extern "C" { pub fn g_resources_enumerate_children (path : * const :: std :: os :: raw :: c_char , lookup_flags : GResourceLookupFlags , error : * mut * mut GError) -> * mut * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_resources_get_info (path : * const :: std :: os :: raw :: c_char , lookup_flags : GResourceLookupFlags , size : * mut gsize , flags : * mut guint32 , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_resource_has_children (resource : * mut GResource , path : * const :: std :: os :: raw :: c_char) -> gboolean ; } unsafe extern "C" { pub fn g_resources_has_children (path : * const :: std :: os :: raw :: c_char) -> gboolean ; } unsafe extern "C" { pub fn g_static_resource_init (static_resource : * mut GStaticResource) ; } unsafe extern "C" { pub fn g_static_resource_fini (static_resource : * mut GStaticResource) ; } unsafe extern "C" { pub fn g_static_resource_get_resource (static_resource : * mut GStaticResource) -> * mut GResource ; } pub type GSeekableIface = _GSeekableIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSeekableIface { pub g_iface : GTypeInterface , pub tell : :: std :: option :: Option < unsafe extern "C" fn (seekable : * mut GSeekable) -> goffset > , pub can_seek : :: std :: option :: Option < unsafe extern "C" fn (seekable : * mut GSeekable) -> gboolean > , pub seek : :: std :: option :: Option < unsafe extern "C" fn (seekable : * mut GSeekable , offset : goffset , type_ : GSeekType , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub can_truncate : :: std :: option :: Option < unsafe extern "C" fn (seekable : * mut GSeekable) -> gboolean > , pub truncate_fn : :: std :: option :: Option < unsafe extern "C" fn (seekable : * mut GSeekable , offset : goffset , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSeekableIface"] [:: std :: mem :: size_of :: < _GSeekableIface > () - 56usize] ; ["Alignment of _GSeekableIface"] [:: std :: mem :: align_of :: < _GSeekableIface > () - 8usize] ; ["Offset of field: _GSeekableIface::g_iface"] [:: std :: mem :: offset_of ! (_GSeekableIface , g_iface) - 0usize] ; ["Offset of field: _GSeekableIface::tell"] [:: std :: mem :: offset_of ! (_GSeekableIface , tell) - 16usize] ; ["Offset of field: _GSeekableIface::can_seek"] [:: std :: mem :: offset_of ! (_GSeekableIface , can_seek) - 24usize] ; ["Offset of field: _GSeekableIface::seek"] [:: std :: mem :: offset_of ! (_GSeekableIface , seek) - 32usize] ; ["Offset of field: _GSeekableIface::can_truncate"] [:: std :: mem :: offset_of ! (_GSeekableIface , can_truncate) - 40usize] ; ["Offset of field: _GSeekableIface::truncate_fn"] [:: std :: mem :: offset_of ! (_GSeekableIface , truncate_fn) - 48usize] ; } ; unsafe extern "C" { pub fn g_seekable_get_type () -> GType ; } unsafe extern "C" { pub fn g_seekable_tell (seekable : * mut GSeekable) -> goffset ; } unsafe extern "C" { pub fn g_seekable_can_seek (seekable : * mut GSeekable) -> gboolean ; } unsafe extern "C" { pub fn g_seekable_seek (seekable : * mut GSeekable , offset : goffset , type_ : GSeekType , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_seekable_can_truncate (seekable : * mut GSeekable) -> gboolean ; } unsafe extern "C" { pub fn g_seekable_truncate (seekable : * mut GSeekable , offset : goffset , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSettingsSchemaSource { _unused : [u8 ; 0] , } pub type GSettingsSchemaSource = _GSettingsSchemaSource ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSettingsSchema { _unused : [u8 ; 0] , } pub type GSettingsSchema = _GSettingsSchema ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSettingsSchemaKey { _unused : [u8 ; 0] , } pub type GSettingsSchemaKey = _GSettingsSchemaKey ; unsafe extern "C" { pub fn g_settings_schema_source_get_type () -> GType ; } unsafe extern "C" { pub fn g_settings_schema_source_get_default () -> * mut GSettingsSchemaSource ; } unsafe extern "C" { pub fn g_settings_schema_source_ref (source : * mut GSettingsSchemaSource) -> * mut GSettingsSchemaSource ; } unsafe extern "C" { pub fn g_settings_schema_source_unref (source : * mut GSettingsSchemaSource) ; } unsafe extern "C" { pub fn g_settings_schema_source_new_from_directory (directory : * const gchar , parent : * mut GSettingsSchemaSource , trusted : gboolean , error : * mut * mut GError) -> * mut GSettingsSchemaSource ; } unsafe extern "C" { pub fn g_settings_schema_source_lookup (source : * mut GSettingsSchemaSource , schema_id : * const gchar , recursive : gboolean) -> * mut GSettingsSchema ; } unsafe extern "C" { pub fn g_settings_schema_source_list_schemas (source : * mut GSettingsSchemaSource , recursive : gboolean , non_relocatable : * mut * mut * mut gchar , relocatable : * mut * mut * mut gchar) ; } unsafe extern "C" { pub fn g_settings_schema_get_type () -> GType ; } unsafe extern "C" { pub fn g_settings_schema_ref (schema : * mut GSettingsSchema) -> * mut GSettingsSchema ; } unsafe extern "C" { pub fn g_settings_schema_unref (schema : * mut GSettingsSchema) ; } unsafe extern "C" { pub fn g_settings_schema_get_id (schema : * mut GSettingsSchema) -> * const gchar ; } unsafe extern "C" { pub fn g_settings_schema_get_path (schema : * mut GSettingsSchema) -> * const gchar ; } unsafe extern "C" { pub fn g_settings_schema_get_key (schema : * mut GSettingsSchema , name : * const gchar) -> * mut GSettingsSchemaKey ; } unsafe extern "C" { pub fn g_settings_schema_has_key (schema : * mut GSettingsSchema , name : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_settings_schema_list_keys (schema : * mut GSettingsSchema) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_settings_schema_list_children (schema : * mut GSettingsSchema) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_settings_schema_key_get_type () -> GType ; } unsafe extern "C" { pub fn g_settings_schema_key_ref (key : * mut GSettingsSchemaKey) -> * mut GSettingsSchemaKey ; } unsafe extern "C" { pub fn g_settings_schema_key_unref (key : * mut GSettingsSchemaKey) ; } unsafe extern "C" { pub fn g_settings_schema_key_get_value_type (key : * mut GSettingsSchemaKey) -> * const GVariantType ; } unsafe extern "C" { pub fn g_settings_schema_key_get_default_value (key : * mut GSettingsSchemaKey) -> * mut GVariant ; } unsafe extern "C" { pub fn g_settings_schema_key_get_range (key : * mut GSettingsSchemaKey) -> * mut GVariant ; } unsafe extern "C" { pub fn g_settings_schema_key_range_check (key : * mut GSettingsSchemaKey , value : * mut GVariant) -> gboolean ; } unsafe extern "C" { pub fn g_settings_schema_key_get_name (key : * mut GSettingsSchemaKey) -> * const gchar ; } unsafe extern "C" { pub fn g_settings_schema_key_get_summary (key : * mut GSettingsSchemaKey) -> * const gchar ; } unsafe extern "C" { pub fn g_settings_schema_key_get_description (key : * mut GSettingsSchemaKey) -> * const gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSettingsPrivate { _unused : [u8 ; 0] , } pub type GSettingsPrivate = _GSettingsPrivate ; pub type GSettingsClass = _GSettingsClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSettingsClass { pub parent_class : GObjectClass , pub writable_changed : :: std :: option :: Option < unsafe extern "C" fn (settings : * mut GSettings , key : * const gchar) > , pub changed : :: std :: option :: Option < unsafe extern "C" fn (settings : * mut GSettings , key : * const gchar) > , pub writable_change_event : :: std :: option :: Option < unsafe extern "C" fn (settings : * mut GSettings , key : GQuark) -> gboolean > , pub change_event : :: std :: option :: Option < unsafe extern "C" fn (settings : * mut GSettings , keys : * const GQuark , n_keys : gint) -> gboolean > , pub padding : [gpointer ; 20usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSettingsClass"] [:: std :: mem :: size_of :: < _GSettingsClass > () - 328usize] ; ["Alignment of _GSettingsClass"] [:: std :: mem :: align_of :: < _GSettingsClass > () - 8usize] ; ["Offset of field: _GSettingsClass::parent_class"] [:: std :: mem :: offset_of ! (_GSettingsClass , parent_class) - 0usize] ; ["Offset of field: _GSettingsClass::writable_changed"] [:: std :: mem :: offset_of ! (_GSettingsClass , writable_changed) - 136usize] ; ["Offset of field: _GSettingsClass::changed"] [:: std :: mem :: offset_of ! (_GSettingsClass , changed) - 144usize] ; ["Offset of field: _GSettingsClass::writable_change_event"] [:: std :: mem :: offset_of ! (_GSettingsClass , writable_change_event) - 152usize] ; ["Offset of field: _GSettingsClass::change_event"] [:: std :: mem :: offset_of ! (_GSettingsClass , change_event) - 160usize] ; ["Offset of field: _GSettingsClass::padding"] [:: std :: mem :: offset_of ! (_GSettingsClass , padding) - 168usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSettings { pub parent_instance : GObject , pub priv_ : * mut GSettingsPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSettings"] [:: std :: mem :: size_of :: < _GSettings > () - 32usize] ; ["Alignment of _GSettings"] [:: std :: mem :: align_of :: < _GSettings > () - 8usize] ; ["Offset of field: _GSettings::parent_instance"] [:: std :: mem :: offset_of ! (_GSettings , parent_instance) - 0usize] ; ["Offset of field: _GSettings::priv_"] [:: std :: mem :: offset_of ! (_GSettings , priv_) - 24usize] ; } ; unsafe extern "C" { pub fn g_settings_get_type () -> GType ; } unsafe extern "C" { pub fn g_settings_list_schemas () -> * const * const gchar ; } unsafe extern "C" { pub fn g_settings_list_relocatable_schemas () -> * const * const gchar ; } unsafe extern "C" { pub fn g_settings_new (schema_id : * const gchar) -> * mut GSettings ; } unsafe extern "C" { pub fn g_settings_new_with_path (schema_id : * const gchar , path : * const gchar) -> * mut GSettings ; } unsafe extern "C" { pub fn g_settings_new_with_backend (schema_id : * const gchar , backend : * mut GSettingsBackend) -> * mut GSettings ; } unsafe extern "C" { pub fn g_settings_new_with_backend_and_path (schema_id : * const gchar , backend : * mut GSettingsBackend , path : * const gchar) -> * mut GSettings ; } unsafe extern "C" { pub fn g_settings_new_full (schema : * mut GSettingsSchema , backend : * mut GSettingsBackend , path : * const gchar) -> * mut GSettings ; } unsafe extern "C" { pub fn g_settings_list_children (settings : * mut GSettings) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_settings_list_keys (settings : * mut GSettings) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_settings_get_range (settings : * mut GSettings , key : * const gchar) -> * mut GVariant ; } unsafe extern "C" { pub fn g_settings_range_check (settings : * mut GSettings , key : * const gchar , value : * mut GVariant) -> gboolean ; } unsafe extern "C" { pub fn g_settings_set_value (settings : * mut GSettings , key : * const gchar , value : * mut GVariant) -> gboolean ; } unsafe extern "C" { pub fn g_settings_get_value (settings : * mut GSettings , key : * const gchar) -> * mut GVariant ; } unsafe extern "C" { pub fn g_settings_get_user_value (settings : * mut GSettings , key : * const gchar) -> * mut GVariant ; } unsafe extern "C" { pub fn g_settings_get_default_value (settings : * mut GSettings , key : * const gchar) -> * mut GVariant ; } unsafe extern "C" { pub fn g_settings_set (settings : * mut GSettings , key : * const gchar , format : * const gchar , ...) -> gboolean ; } unsafe extern "C" { pub fn g_settings_get (settings : * mut GSettings , key : * const gchar , format : * const gchar , ...) ; } unsafe extern "C" { pub fn g_settings_reset (settings : * mut GSettings , key : * const gchar) ; } unsafe extern "C" { pub fn g_settings_get_int (settings : * mut GSettings , key : * const gchar) -> gint ; } unsafe extern "C" { pub fn g_settings_set_int (settings : * mut GSettings , key : * const gchar , value : gint) -> gboolean ; } unsafe extern "C" { pub fn g_settings_get_int64 (settings : * mut GSettings , key : * const gchar) -> gint64 ; } unsafe extern "C" { pub fn g_settings_set_int64 (settings : * mut GSettings , key : * const gchar , value : gint64) -> gboolean ; } unsafe extern "C" { pub fn g_settings_get_uint (settings : * mut GSettings , key : * const gchar) -> guint ; } unsafe extern "C" { pub fn g_settings_set_uint (settings : * mut GSettings , key : * const gchar , value : guint) -> gboolean ; } unsafe extern "C" { pub fn g_settings_get_uint64 (settings : * mut GSettings , key : * const gchar) -> guint64 ; } unsafe extern "C" { pub fn g_settings_set_uint64 (settings : * mut GSettings , key : * const gchar , value : guint64) -> gboolean ; } unsafe extern "C" { pub fn g_settings_get_string (settings : * mut GSettings , key : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn g_settings_set_string (settings : * mut GSettings , key : * const gchar , value : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_settings_get_boolean (settings : * mut GSettings , key : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_settings_set_boolean (settings : * mut GSettings , key : * const gchar , value : gboolean) -> gboolean ; } unsafe extern "C" { pub fn g_settings_get_double (settings : * mut GSettings , key : * const gchar) -> gdouble ; } unsafe extern "C" { pub fn g_settings_set_double (settings : * mut GSettings , key : * const gchar , value : gdouble) -> gboolean ; } unsafe extern "C" { pub fn g_settings_get_strv (settings : * mut GSettings , key : * const gchar) -> * mut * mut gchar ; } unsafe extern "C" { pub fn g_settings_set_strv (settings : * mut GSettings , key : * const gchar , value : * const * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_settings_get_enum (settings : * mut GSettings , key : * const gchar) -> gint ; } unsafe extern "C" { pub fn g_settings_set_enum (settings : * mut GSettings , key : * const gchar , value : gint) -> gboolean ; } unsafe extern "C" { pub fn g_settings_get_flags (settings : * mut GSettings , key : * const gchar) -> guint ; } unsafe extern "C" { pub fn g_settings_set_flags (settings : * mut GSettings , key : * const gchar , value : guint) -> gboolean ; } unsafe extern "C" { pub fn g_settings_get_child (settings : * mut GSettings , name : * const gchar) -> * mut GSettings ; } unsafe extern "C" { pub fn g_settings_is_writable (settings : * mut GSettings , name : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn g_settings_delay (settings : * mut GSettings) ; } unsafe extern "C" { pub fn g_settings_apply (settings : * mut GSettings) ; } unsafe extern "C" { pub fn g_settings_revert (settings : * mut GSettings) ; } unsafe extern "C" { pub fn g_settings_get_has_unapplied (settings : * mut GSettings) -> gboolean ; } unsafe extern "C" { pub fn g_settings_sync () ; } pub type GSettingsBindSetMapping = :: std :: option :: Option < unsafe extern "C" fn (value : * const GValue , expected_type : * const GVariantType , user_data : gpointer) -> * mut GVariant > ; pub type GSettingsBindGetMapping = :: std :: option :: Option < unsafe extern "C" fn (value : * mut GValue , variant : * mut GVariant , user_data : gpointer) -> gboolean > ; pub type GSettingsGetMapping = :: std :: option :: Option < unsafe extern "C" fn (value : * mut GVariant , result : * mut gpointer , user_data : gpointer) -> gboolean > ; pub const GSettingsBindFlags_G_SETTINGS_BIND_DEFAULT : GSettingsBindFlags = 0 ; pub const GSettingsBindFlags_G_SETTINGS_BIND_GET : GSettingsBindFlags = 1 ; pub const GSettingsBindFlags_G_SETTINGS_BIND_SET : GSettingsBindFlags = 2 ; pub const GSettingsBindFlags_G_SETTINGS_BIND_NO_SENSITIVITY : GSettingsBindFlags = 4 ; pub const GSettingsBindFlags_G_SETTINGS_BIND_GET_NO_CHANGES : GSettingsBindFlags = 8 ; pub const GSettingsBindFlags_G_SETTINGS_BIND_INVERT_BOOLEAN : GSettingsBindFlags = 16 ; pub type GSettingsBindFlags = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn g_settings_bind (settings : * mut GSettings , key : * const gchar , object : gpointer , property : * const gchar , flags : GSettingsBindFlags) ; } unsafe extern "C" { pub fn g_settings_bind_with_mapping (settings : * mut GSettings , key : * const gchar , object : gpointer , property : * const gchar , flags : GSettingsBindFlags , get_mapping : GSettingsBindGetMapping , set_mapping : GSettingsBindSetMapping , user_data : gpointer , destroy : GDestroyNotify) ; } unsafe extern "C" { pub fn g_settings_bind_with_mapping_closures (settings : * mut GSettings , key : * const :: std :: os :: raw :: c_char , object : * mut GObject , property : * const :: std :: os :: raw :: c_char , flags : GSettingsBindFlags , get_mapping : * mut GClosure , set_mapping : * mut GClosure) ; } unsafe extern "C" { pub fn g_settings_bind_writable (settings : * mut GSettings , key : * const gchar , object : gpointer , property : * const gchar , inverted : gboolean) ; } unsafe extern "C" { pub fn g_settings_unbind (object : gpointer , property : * const gchar) ; } unsafe extern "C" { pub fn g_settings_create_action (settings : * mut GSettings , key : * const gchar) -> * mut GAction ; } unsafe extern "C" { pub fn g_settings_get_mapped (settings : * mut GSettings , key : * const gchar , mapping : GSettingsGetMapping , user_data : gpointer) -> gpointer ; } unsafe extern "C" { pub fn g_simple_action_get_type () -> GType ; } unsafe extern "C" { pub fn g_simple_action_new (name : * const gchar , parameter_type : * const GVariantType) -> * mut GSimpleAction ; } unsafe extern "C" { pub fn g_simple_action_new_stateful (name : * const gchar , parameter_type : * const GVariantType , state : * mut GVariant) -> * mut GSimpleAction ; } unsafe extern "C" { pub fn g_simple_action_set_enabled (simple : * mut GSimpleAction , enabled : gboolean) ; } unsafe extern "C" { pub fn g_simple_action_set_state (simple : * mut GSimpleAction , value : * mut GVariant) ; } unsafe extern "C" { pub fn g_simple_action_set_state_hint (simple : * mut GSimpleAction , state_hint : * mut GVariant) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSimpleActionGroupPrivate { _unused : [u8 ; 0] , } pub type GSimpleActionGroupPrivate = _GSimpleActionGroupPrivate ; pub type GSimpleActionGroupClass = _GSimpleActionGroupClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSimpleActionGroup { pub parent_instance : GObject , pub priv_ : * mut GSimpleActionGroupPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSimpleActionGroup"] [:: std :: mem :: size_of :: < _GSimpleActionGroup > () - 32usize] ; ["Alignment of _GSimpleActionGroup"] [:: std :: mem :: align_of :: < _GSimpleActionGroup > () - 8usize] ; ["Offset of field: _GSimpleActionGroup::parent_instance"] [:: std :: mem :: offset_of ! (_GSimpleActionGroup , parent_instance) - 0usize] ; ["Offset of field: _GSimpleActionGroup::priv_"] [:: std :: mem :: offset_of ! (_GSimpleActionGroup , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSimpleActionGroupClass { pub parent_class : GObjectClass , pub padding : [gpointer ; 12usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSimpleActionGroupClass"] [:: std :: mem :: size_of :: < _GSimpleActionGroupClass > () - 232usize] ; ["Alignment of _GSimpleActionGroupClass"] [:: std :: mem :: align_of :: < _GSimpleActionGroupClass > () - 8usize] ; ["Offset of field: _GSimpleActionGroupClass::parent_class"] [:: std :: mem :: offset_of ! (_GSimpleActionGroupClass , parent_class) - 0usize] ; ["Offset of field: _GSimpleActionGroupClass::padding"] [:: std :: mem :: offset_of ! (_GSimpleActionGroupClass , padding) - 136usize] ; } ; unsafe extern "C" { pub fn g_simple_action_group_get_type () -> GType ; } unsafe extern "C" { pub fn g_simple_action_group_new () -> * mut GSimpleActionGroup ; } unsafe extern "C" { pub fn g_simple_action_group_lookup (simple : * mut GSimpleActionGroup , action_name : * const gchar) -> * mut GAction ; } unsafe extern "C" { pub fn g_simple_action_group_insert (simple : * mut GSimpleActionGroup , action : * mut GAction) ; } unsafe extern "C" { pub fn g_simple_action_group_remove (simple : * mut GSimpleActionGroup , action_name : * const gchar) ; } unsafe extern "C" { pub fn g_simple_action_group_add_entries (simple : * mut GSimpleActionGroup , entries : * const GActionEntry , n_entries : gint , user_data : gpointer) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSimpleAsyncResultClass { _unused : [u8 ; 0] , } pub type GSimpleAsyncResultClass = _GSimpleAsyncResultClass ; unsafe extern "C" { pub fn g_simple_async_result_get_type () -> GType ; } unsafe extern "C" { pub fn g_simple_async_result_new (source_object : * mut GObject , callback : GAsyncReadyCallback , user_data : gpointer , source_tag : gpointer) -> * mut GSimpleAsyncResult ; } unsafe extern "C" { pub fn g_simple_async_result_new_error (source_object : * mut GObject , callback : GAsyncReadyCallback , user_data : gpointer , domain : GQuark , code : gint , format : * const :: std :: os :: raw :: c_char , ...) -> * mut GSimpleAsyncResult ; } unsafe extern "C" { pub fn g_simple_async_result_new_from_error (source_object : * mut GObject , callback : GAsyncReadyCallback , user_data : gpointer , error : * const GError) -> * mut GSimpleAsyncResult ; } unsafe extern "C" { pub fn g_simple_async_result_new_take_error (source_object : * mut GObject , callback : GAsyncReadyCallback , user_data : gpointer , error : * mut GError) -> * mut GSimpleAsyncResult ; } unsafe extern "C" { pub fn g_simple_async_result_set_op_res_gpointer (simple : * mut GSimpleAsyncResult , op_res : gpointer , destroy_op_res : GDestroyNotify) ; } unsafe extern "C" { pub fn g_simple_async_result_get_op_res_gpointer (simple : * mut GSimpleAsyncResult) -> gpointer ; } unsafe extern "C" { pub fn g_simple_async_result_set_op_res_gssize (simple : * mut GSimpleAsyncResult , op_res : gssize) ; } unsafe extern "C" { pub fn g_simple_async_result_get_op_res_gssize (simple : * mut GSimpleAsyncResult) -> gssize ; } unsafe extern "C" { pub fn g_simple_async_result_set_op_res_gboolean (simple : * mut GSimpleAsyncResult , op_res : gboolean) ; } unsafe extern "C" { pub fn g_simple_async_result_get_op_res_gboolean (simple : * mut GSimpleAsyncResult) -> gboolean ; } unsafe extern "C" { pub fn g_simple_async_result_set_check_cancellable (simple : * mut GSimpleAsyncResult , check_cancellable : * mut GCancellable) ; } unsafe extern "C" { pub fn g_simple_async_result_get_source_tag (simple : * mut GSimpleAsyncResult) -> gpointer ; } unsafe extern "C" { pub fn g_simple_async_result_set_handle_cancellation (simple : * mut GSimpleAsyncResult , handle_cancellation : gboolean) ; } unsafe extern "C" { pub fn g_simple_async_result_complete (simple : * mut GSimpleAsyncResult) ; } unsafe extern "C" { pub fn g_simple_async_result_complete_in_idle (simple : * mut GSimpleAsyncResult) ; } unsafe extern "C" { pub fn g_simple_async_result_run_in_thread (simple : * mut GSimpleAsyncResult , func : GSimpleAsyncThreadFunc , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable) ; } unsafe extern "C" { pub fn g_simple_async_result_set_from_error (simple : * mut GSimpleAsyncResult , error : * const GError) ; } unsafe extern "C" { pub fn g_simple_async_result_take_error (simple : * mut GSimpleAsyncResult , error : * mut GError) ; } unsafe extern "C" { pub fn g_simple_async_result_propagate_error (simple : * mut GSimpleAsyncResult , dest : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_simple_async_result_set_error (simple : * mut GSimpleAsyncResult , domain : GQuark , code : gint , format : * const :: std :: os :: raw :: c_char , ...) ; } unsafe extern "C" { pub fn g_simple_async_result_set_error_va (simple : * mut GSimpleAsyncResult , domain : GQuark , code : gint , format : * const :: std :: os :: raw :: c_char , args : * mut __va_list_tag) ; } unsafe extern "C" { pub fn g_simple_async_result_is_valid (result : * mut GAsyncResult , source : * mut GObject , source_tag : gpointer) -> gboolean ; } unsafe extern "C" { pub fn g_simple_async_report_error_in_idle (object : * mut GObject , callback : GAsyncReadyCallback , user_data : gpointer , domain : GQuark , code : gint , format : * const :: std :: os :: raw :: c_char , ...) ; } unsafe extern "C" { pub fn g_simple_async_report_gerror_in_idle (object : * mut GObject , callback : GAsyncReadyCallback , user_data : gpointer , error : * const GError) ; } unsafe extern "C" { pub fn g_simple_async_report_take_gerror_in_idle (object : * mut GObject , callback : GAsyncReadyCallback , user_data : gpointer , error : * mut GError) ; } unsafe extern "C" { pub fn g_simple_io_stream_get_type () -> GType ; } unsafe extern "C" { pub fn g_simple_io_stream_new (input_stream : * mut GInputStream , output_stream : * mut GOutputStream) -> * mut GIOStream ; } unsafe extern "C" { pub fn g_simple_permission_get_type () -> GType ; } unsafe extern "C" { pub fn g_simple_permission_new (allowed : gboolean) -> * mut GPermission ; } pub type GSimpleProxyResolver = _GSimpleProxyResolver ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSimpleProxyResolverPrivate { _unused : [u8 ; 0] , } pub type GSimpleProxyResolverPrivate = _GSimpleProxyResolverPrivate ; pub type GSimpleProxyResolverClass = _GSimpleProxyResolverClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSimpleProxyResolver { pub parent_instance : GObject , pub priv_ : * mut GSimpleProxyResolverPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSimpleProxyResolver"] [:: std :: mem :: size_of :: < _GSimpleProxyResolver > () - 32usize] ; ["Alignment of _GSimpleProxyResolver"] [:: std :: mem :: align_of :: < _GSimpleProxyResolver > () - 8usize] ; ["Offset of field: _GSimpleProxyResolver::parent_instance"] [:: std :: mem :: offset_of ! (_GSimpleProxyResolver , parent_instance) - 0usize] ; ["Offset of field: _GSimpleProxyResolver::priv_"] [:: std :: mem :: offset_of ! (_GSimpleProxyResolver , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSimpleProxyResolverClass { pub parent_class : GObjectClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSimpleProxyResolverClass"] [:: std :: mem :: size_of :: < _GSimpleProxyResolverClass > () - 176usize] ; ["Alignment of _GSimpleProxyResolverClass"] [:: std :: mem :: align_of :: < _GSimpleProxyResolverClass > () - 8usize] ; ["Offset of field: _GSimpleProxyResolverClass::parent_class"] [:: std :: mem :: offset_of ! (_GSimpleProxyResolverClass , parent_class) - 0usize] ; ["Offset of field: _GSimpleProxyResolverClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GSimpleProxyResolverClass , _g_reserved1) - 136usize] ; ["Offset of field: _GSimpleProxyResolverClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GSimpleProxyResolverClass , _g_reserved2) - 144usize] ; ["Offset of field: _GSimpleProxyResolverClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GSimpleProxyResolverClass , _g_reserved3) - 152usize] ; ["Offset of field: _GSimpleProxyResolverClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GSimpleProxyResolverClass , _g_reserved4) - 160usize] ; ["Offset of field: _GSimpleProxyResolverClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GSimpleProxyResolverClass , _g_reserved5) - 168usize] ; } ; unsafe extern "C" { pub fn g_simple_proxy_resolver_get_type () -> GType ; } unsafe extern "C" { pub fn g_simple_proxy_resolver_new (default_proxy : * const gchar , ignore_hosts : * mut * mut gchar) -> * mut GProxyResolver ; } unsafe extern "C" { pub fn g_simple_proxy_resolver_set_default_proxy (resolver : * mut GSimpleProxyResolver , default_proxy : * const gchar) ; } unsafe extern "C" { pub fn g_simple_proxy_resolver_set_ignore_hosts (resolver : * mut GSimpleProxyResolver , ignore_hosts : * mut * mut gchar) ; } unsafe extern "C" { pub fn g_simple_proxy_resolver_set_uri_proxy (resolver : * mut GSimpleProxyResolver , uri_scheme : * const gchar , proxy : * const gchar) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketPrivate { _unused : [u8 ; 0] , } pub type GSocketPrivate = _GSocketPrivate ; pub type GSocketClass = _GSocketClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketClass { pub parent_class : GObjectClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved6 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved7 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved8 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved9 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved10 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketClass"] [:: std :: mem :: size_of :: < _GSocketClass > () - 216usize] ; ["Alignment of _GSocketClass"] [:: std :: mem :: align_of :: < _GSocketClass > () - 8usize] ; ["Offset of field: _GSocketClass::parent_class"] [:: std :: mem :: offset_of ! (_GSocketClass , parent_class) - 0usize] ; ["Offset of field: _GSocketClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GSocketClass , _g_reserved1) - 136usize] ; ["Offset of field: _GSocketClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GSocketClass , _g_reserved2) - 144usize] ; ["Offset of field: _GSocketClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GSocketClass , _g_reserved3) - 152usize] ; ["Offset of field: _GSocketClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GSocketClass , _g_reserved4) - 160usize] ; ["Offset of field: _GSocketClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GSocketClass , _g_reserved5) - 168usize] ; ["Offset of field: _GSocketClass::_g_reserved6"] [:: std :: mem :: offset_of ! (_GSocketClass , _g_reserved6) - 176usize] ; ["Offset of field: _GSocketClass::_g_reserved7"] [:: std :: mem :: offset_of ! (_GSocketClass , _g_reserved7) - 184usize] ; ["Offset of field: _GSocketClass::_g_reserved8"] [:: std :: mem :: offset_of ! (_GSocketClass , _g_reserved8) - 192usize] ; ["Offset of field: _GSocketClass::_g_reserved9"] [:: std :: mem :: offset_of ! (_GSocketClass , _g_reserved9) - 200usize] ; ["Offset of field: _GSocketClass::_g_reserved10"] [:: std :: mem :: offset_of ! (_GSocketClass , _g_reserved10) - 208usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocket { pub parent_instance : GObject , pub priv_ : * mut GSocketPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocket"] [:: std :: mem :: size_of :: < _GSocket > () - 32usize] ; ["Alignment of _GSocket"] [:: std :: mem :: align_of :: < _GSocket > () - 8usize] ; ["Offset of field: _GSocket::parent_instance"] [:: std :: mem :: offset_of ! (_GSocket , parent_instance) - 0usize] ; ["Offset of field: _GSocket::priv_"] [:: std :: mem :: offset_of ! (_GSocket , priv_) - 24usize] ; } ; unsafe extern "C" { pub fn g_socket_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_new (family : GSocketFamily , type_ : GSocketType , protocol : GSocketProtocol , error : * mut * mut GError) -> * mut GSocket ; } unsafe extern "C" { pub fn g_socket_new_from_fd (fd : gint , error : * mut * mut GError) -> * mut GSocket ; } unsafe extern "C" { pub fn g_socket_get_fd (socket : * mut GSocket) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn g_socket_get_family (socket : * mut GSocket) -> GSocketFamily ; } unsafe extern "C" { pub fn g_socket_get_socket_type (socket : * mut GSocket) -> GSocketType ; } unsafe extern "C" { pub fn g_socket_get_protocol (socket : * mut GSocket) -> GSocketProtocol ; } unsafe extern "C" { pub fn g_socket_get_local_address (socket : * mut GSocket , error : * mut * mut GError) -> * mut GSocketAddress ; } unsafe extern "C" { pub fn g_socket_get_remote_address (socket : * mut GSocket , error : * mut * mut GError) -> * mut GSocketAddress ; } unsafe extern "C" { pub fn g_socket_set_blocking (socket : * mut GSocket , blocking : gboolean) ; } unsafe extern "C" { pub fn g_socket_get_blocking (socket : * mut GSocket) -> gboolean ; } unsafe extern "C" { pub fn g_socket_set_keepalive (socket : * mut GSocket , keepalive : gboolean) ; } unsafe extern "C" { pub fn g_socket_get_keepalive (socket : * mut GSocket) -> gboolean ; } unsafe extern "C" { pub fn g_socket_get_listen_backlog (socket : * mut GSocket) -> gint ; } unsafe extern "C" { pub fn g_socket_set_listen_backlog (socket : * mut GSocket , backlog : gint) ; } unsafe extern "C" { pub fn g_socket_get_timeout (socket : * mut GSocket) -> guint ; } unsafe extern "C" { pub fn g_socket_set_timeout (socket : * mut GSocket , timeout : guint) ; } unsafe extern "C" { pub fn g_socket_get_ttl (socket : * mut GSocket) -> guint ; } unsafe extern "C" { pub fn g_socket_set_ttl (socket : * mut GSocket , ttl : guint) ; } unsafe extern "C" { pub fn g_socket_get_broadcast (socket : * mut GSocket) -> gboolean ; } unsafe extern "C" { pub fn g_socket_set_broadcast (socket : * mut GSocket , broadcast : gboolean) ; } unsafe extern "C" { pub fn g_socket_get_multicast_loopback (socket : * mut GSocket) -> gboolean ; } unsafe extern "C" { pub fn g_socket_set_multicast_loopback (socket : * mut GSocket , loopback : gboolean) ; } unsafe extern "C" { pub fn g_socket_get_multicast_ttl (socket : * mut GSocket) -> guint ; } unsafe extern "C" { pub fn g_socket_set_multicast_ttl (socket : * mut GSocket , ttl : guint) ; } unsafe extern "C" { pub fn g_socket_is_connected (socket : * mut GSocket) -> gboolean ; } unsafe extern "C" { pub fn g_socket_bind (socket : * mut GSocket , address : * mut GSocketAddress , allow_reuse : gboolean , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_join_multicast_group (socket : * mut GSocket , group : * mut GInetAddress , source_specific : gboolean , iface : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_leave_multicast_group (socket : * mut GSocket , group : * mut GInetAddress , source_specific : gboolean , iface : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_join_multicast_group_ssm (socket : * mut GSocket , group : * mut GInetAddress , source_specific : * mut GInetAddress , iface : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_leave_multicast_group_ssm (socket : * mut GSocket , group : * mut GInetAddress , source_specific : * mut GInetAddress , iface : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_connect (socket : * mut GSocket , address : * mut GSocketAddress , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_check_connect_result (socket : * mut GSocket , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_get_available_bytes (socket : * mut GSocket) -> gssize ; } unsafe extern "C" { pub fn g_socket_condition_check (socket : * mut GSocket , condition : GIOCondition) -> GIOCondition ; } unsafe extern "C" { pub fn g_socket_condition_wait (socket : * mut GSocket , condition : GIOCondition , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_condition_timed_wait (socket : * mut GSocket , condition : GIOCondition , timeout_us : gint64 , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_accept (socket : * mut GSocket , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GSocket ; } unsafe extern "C" { pub fn g_socket_listen (socket : * mut GSocket , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_receive (socket : * mut GSocket , buffer : * mut gchar , size : gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_socket_receive_bytes (socket : * mut GSocket , size : gsize , timeout_us : gint64 , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GBytes ; } unsafe extern "C" { pub fn g_socket_receive_from (socket : * mut GSocket , address : * mut * mut GSocketAddress , buffer : * mut gchar , size : gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_socket_receive_bytes_from (socket : * mut GSocket , address : * mut * mut GSocketAddress , size : gsize , timeout_us : gint64 , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GBytes ; } unsafe extern "C" { pub fn g_socket_send (socket : * mut GSocket , buffer : * const gchar , size : gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_socket_send_to (socket : * mut GSocket , address : * mut GSocketAddress , buffer : * const gchar , size : gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_socket_receive_message (socket : * mut GSocket , address : * mut * mut GSocketAddress , vectors : * mut GInputVector , num_vectors : gint , messages : * mut * mut * mut GSocketControlMessage , num_messages : * mut gint , flags : * mut gint , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_socket_send_message (socket : * mut GSocket , address : * mut GSocketAddress , vectors : * mut GOutputVector , num_vectors : gint , messages : * mut * mut GSocketControlMessage , num_messages : gint , flags : gint , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_socket_receive_messages (socket : * mut GSocket , messages : * mut GInputMessage , num_messages : guint , flags : gint , cancellable : * mut GCancellable , error : * mut * mut GError) -> gint ; } unsafe extern "C" { pub fn g_socket_send_messages (socket : * mut GSocket , messages : * mut GOutputMessage , num_messages : guint , flags : gint , cancellable : * mut GCancellable , error : * mut * mut GError) -> gint ; } unsafe extern "C" { pub fn g_socket_close (socket : * mut GSocket , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_shutdown (socket : * mut GSocket , shutdown_read : gboolean , shutdown_write : gboolean , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_is_closed (socket : * mut GSocket) -> gboolean ; } unsafe extern "C" { pub fn g_socket_create_source (socket : * mut GSocket , condition : GIOCondition , cancellable : * mut GCancellable) -> * mut GSource ; } unsafe extern "C" { pub fn g_socket_speaks_ipv4 (socket : * mut GSocket) -> gboolean ; } unsafe extern "C" { pub fn g_socket_get_credentials (socket : * mut GSocket , error : * mut * mut GError) -> * mut GCredentials ; } unsafe extern "C" { pub fn g_socket_receive_with_blocking (socket : * mut GSocket , buffer : * mut gchar , size : gsize , blocking : gboolean , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_socket_send_with_blocking (socket : * mut GSocket , buffer : * const gchar , size : gsize , blocking : gboolean , cancellable : * mut GCancellable , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_socket_send_message_with_timeout (socket : * mut GSocket , address : * mut GSocketAddress , vectors : * const GOutputVector , num_vectors : gint , messages : * mut * mut GSocketControlMessage , num_messages : gint , flags : gint , timeout_us : gint64 , bytes_written : * mut gsize , cancellable : * mut GCancellable , error : * mut * mut GError) -> GPollableReturn ; } unsafe extern "C" { pub fn g_socket_get_option (socket : * mut GSocket , level : gint , optname : gint , value : * mut gint , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_set_option (socket : * mut GSocket , level : gint , optname : gint , value : gint , error : * mut * mut GError) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketClientPrivate { _unused : [u8 ; 0] , } pub type GSocketClientPrivate = _GSocketClientPrivate ; pub type GSocketClientClass = _GSocketClientClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketClientClass { pub parent_class : GObjectClass , pub event : :: std :: option :: Option < unsafe extern "C" fn (client : * mut GSocketClient , event : GSocketClientEvent , connectable : * mut GSocketConnectable , connection : * mut GIOStream) > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketClientClass"] [:: std :: mem :: size_of :: < _GSocketClientClass > () - 176usize] ; ["Alignment of _GSocketClientClass"] [:: std :: mem :: align_of :: < _GSocketClientClass > () - 8usize] ; ["Offset of field: _GSocketClientClass::parent_class"] [:: std :: mem :: offset_of ! (_GSocketClientClass , parent_class) - 0usize] ; ["Offset of field: _GSocketClientClass::event"] [:: std :: mem :: offset_of ! (_GSocketClientClass , event) - 136usize] ; ["Offset of field: _GSocketClientClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GSocketClientClass , _g_reserved1) - 144usize] ; ["Offset of field: _GSocketClientClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GSocketClientClass , _g_reserved2) - 152usize] ; ["Offset of field: _GSocketClientClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GSocketClientClass , _g_reserved3) - 160usize] ; ["Offset of field: _GSocketClientClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GSocketClientClass , _g_reserved4) - 168usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketClient { pub parent_instance : GObject , pub priv_ : * mut GSocketClientPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketClient"] [:: std :: mem :: size_of :: < _GSocketClient > () - 32usize] ; ["Alignment of _GSocketClient"] [:: std :: mem :: align_of :: < _GSocketClient > () - 8usize] ; ["Offset of field: _GSocketClient::parent_instance"] [:: std :: mem :: offset_of ! (_GSocketClient , parent_instance) - 0usize] ; ["Offset of field: _GSocketClient::priv_"] [:: std :: mem :: offset_of ! (_GSocketClient , priv_) - 24usize] ; } ; unsafe extern "C" { pub fn g_socket_client_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_client_new () -> * mut GSocketClient ; } unsafe extern "C" { pub fn g_socket_client_get_family (client : * mut GSocketClient) -> GSocketFamily ; } unsafe extern "C" { pub fn g_socket_client_set_family (client : * mut GSocketClient , family : GSocketFamily) ; } unsafe extern "C" { pub fn g_socket_client_get_socket_type (client : * mut GSocketClient) -> GSocketType ; } unsafe extern "C" { pub fn g_socket_client_set_socket_type (client : * mut GSocketClient , type_ : GSocketType) ; } unsafe extern "C" { pub fn g_socket_client_get_protocol (client : * mut GSocketClient) -> GSocketProtocol ; } unsafe extern "C" { pub fn g_socket_client_set_protocol (client : * mut GSocketClient , protocol : GSocketProtocol) ; } unsafe extern "C" { pub fn g_socket_client_get_local_address (client : * mut GSocketClient) -> * mut GSocketAddress ; } unsafe extern "C" { pub fn g_socket_client_set_local_address (client : * mut GSocketClient , address : * mut GSocketAddress) ; } unsafe extern "C" { pub fn g_socket_client_get_timeout (client : * mut GSocketClient) -> guint ; } unsafe extern "C" { pub fn g_socket_client_set_timeout (client : * mut GSocketClient , timeout : guint) ; } unsafe extern "C" { pub fn g_socket_client_get_enable_proxy (client : * mut GSocketClient) -> gboolean ; } unsafe extern "C" { pub fn g_socket_client_set_enable_proxy (client : * mut GSocketClient , enable : gboolean) ; } unsafe extern "C" { pub fn g_socket_client_get_tls (client : * mut GSocketClient) -> gboolean ; } unsafe extern "C" { pub fn g_socket_client_set_tls (client : * mut GSocketClient , tls : gboolean) ; } unsafe extern "C" { pub fn g_socket_client_get_tls_validation_flags (client : * mut GSocketClient) -> GTlsCertificateFlags ; } unsafe extern "C" { pub fn g_socket_client_set_tls_validation_flags (client : * mut GSocketClient , flags : GTlsCertificateFlags) ; } unsafe extern "C" { pub fn g_socket_client_get_proxy_resolver (client : * mut GSocketClient) -> * mut GProxyResolver ; } unsafe extern "C" { pub fn g_socket_client_set_proxy_resolver (client : * mut GSocketClient , proxy_resolver : * mut GProxyResolver) ; } unsafe extern "C" { pub fn g_socket_client_connect (client : * mut GSocketClient , connectable : * mut GSocketConnectable , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GSocketConnection ; } unsafe extern "C" { pub fn g_socket_client_connect_to_host (client : * mut GSocketClient , host_and_port : * const gchar , default_port : guint16 , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GSocketConnection ; } unsafe extern "C" { pub fn g_socket_client_connect_to_service (client : * mut GSocketClient , domain : * const gchar , service : * const gchar , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GSocketConnection ; } unsafe extern "C" { pub fn g_socket_client_connect_to_uri (client : * mut GSocketClient , uri : * const gchar , default_port : guint16 , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GSocketConnection ; } unsafe extern "C" { pub fn g_socket_client_connect_async (client : * mut GSocketClient , connectable : * mut GSocketConnectable , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_socket_client_connect_finish (client : * mut GSocketClient , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GSocketConnection ; } unsafe extern "C" { pub fn g_socket_client_connect_to_host_async (client : * mut GSocketClient , host_and_port : * const gchar , default_port : guint16 , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_socket_client_connect_to_host_finish (client : * mut GSocketClient , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GSocketConnection ; } unsafe extern "C" { pub fn g_socket_client_connect_to_service_async (client : * mut GSocketClient , domain : * const gchar , service : * const gchar , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_socket_client_connect_to_service_finish (client : * mut GSocketClient , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GSocketConnection ; } unsafe extern "C" { pub fn g_socket_client_connect_to_uri_async (client : * mut GSocketClient , uri : * const gchar , default_port : guint16 , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_socket_client_connect_to_uri_finish (client : * mut GSocketClient , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GSocketConnection ; } unsafe extern "C" { pub fn g_socket_client_add_application_proxy (client : * mut GSocketClient , protocol : * const gchar) ; } pub type GSocketConnectableIface = _GSocketConnectableIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketConnectableIface { pub g_iface : GTypeInterface , pub enumerate : :: std :: option :: Option < unsafe extern "C" fn (connectable : * mut GSocketConnectable) -> * mut GSocketAddressEnumerator > , pub proxy_enumerate : :: std :: option :: Option < unsafe extern "C" fn (connectable : * mut GSocketConnectable) -> * mut GSocketAddressEnumerator > , pub to_string : :: std :: option :: Option < unsafe extern "C" fn (connectable : * mut GSocketConnectable) -> * mut gchar > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketConnectableIface"] [:: std :: mem :: size_of :: < _GSocketConnectableIface > () - 40usize] ; ["Alignment of _GSocketConnectableIface"] [:: std :: mem :: align_of :: < _GSocketConnectableIface > () - 8usize] ; ["Offset of field: _GSocketConnectableIface::g_iface"] [:: std :: mem :: offset_of ! (_GSocketConnectableIface , g_iface) - 0usize] ; ["Offset of field: _GSocketConnectableIface::enumerate"] [:: std :: mem :: offset_of ! (_GSocketConnectableIface , enumerate) - 16usize] ; ["Offset of field: _GSocketConnectableIface::proxy_enumerate"] [:: std :: mem :: offset_of ! (_GSocketConnectableIface , proxy_enumerate) - 24usize] ; ["Offset of field: _GSocketConnectableIface::to_string"] [:: std :: mem :: offset_of ! (_GSocketConnectableIface , to_string) - 32usize] ; } ; unsafe extern "C" { pub fn g_socket_connectable_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_connectable_enumerate (connectable : * mut GSocketConnectable) -> * mut GSocketAddressEnumerator ; } unsafe extern "C" { pub fn g_socket_connectable_proxy_enumerate (connectable : * mut GSocketConnectable) -> * mut GSocketAddressEnumerator ; } unsafe extern "C" { pub fn g_socket_connectable_to_string (connectable : * mut GSocketConnectable) -> * mut gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketConnectionPrivate { _unused : [u8 ; 0] , } pub type GSocketConnectionPrivate = _GSocketConnectionPrivate ; pub type GSocketConnectionClass = _GSocketConnectionClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketConnectionClass { pub parent_class : GIOStreamClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved6 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketConnectionClass"] [:: std :: mem :: size_of :: < _GSocketConnectionClass > () - 304usize] ; ["Alignment of _GSocketConnectionClass"] [:: std :: mem :: align_of :: < _GSocketConnectionClass > () - 8usize] ; ["Offset of field: _GSocketConnectionClass::parent_class"] [:: std :: mem :: offset_of ! (_GSocketConnectionClass , parent_class) - 0usize] ; ["Offset of field: _GSocketConnectionClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GSocketConnectionClass , _g_reserved1) - 256usize] ; ["Offset of field: _GSocketConnectionClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GSocketConnectionClass , _g_reserved2) - 264usize] ; ["Offset of field: _GSocketConnectionClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GSocketConnectionClass , _g_reserved3) - 272usize] ; ["Offset of field: _GSocketConnectionClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GSocketConnectionClass , _g_reserved4) - 280usize] ; ["Offset of field: _GSocketConnectionClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GSocketConnectionClass , _g_reserved5) - 288usize] ; ["Offset of field: _GSocketConnectionClass::_g_reserved6"] [:: std :: mem :: offset_of ! (_GSocketConnectionClass , _g_reserved6) - 296usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketConnection { pub parent_instance : GIOStream , pub priv_ : * mut GSocketConnectionPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketConnection"] [:: std :: mem :: size_of :: < _GSocketConnection > () - 40usize] ; ["Alignment of _GSocketConnection"] [:: std :: mem :: align_of :: < _GSocketConnection > () - 8usize] ; ["Offset of field: _GSocketConnection::parent_instance"] [:: std :: mem :: offset_of ! (_GSocketConnection , parent_instance) - 0usize] ; ["Offset of field: _GSocketConnection::priv_"] [:: std :: mem :: offset_of ! (_GSocketConnection , priv_) - 32usize] ; } ; unsafe extern "C" { pub fn g_socket_connection_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_connection_is_connected (connection : * mut GSocketConnection) -> gboolean ; } unsafe extern "C" { pub fn g_socket_connection_connect (connection : * mut GSocketConnection , address : * mut GSocketAddress , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_connection_connect_async (connection : * mut GSocketConnection , address : * mut GSocketAddress , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_socket_connection_connect_finish (connection : * mut GSocketConnection , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_connection_get_socket (connection : * mut GSocketConnection) -> * mut GSocket ; } unsafe extern "C" { pub fn g_socket_connection_get_local_address (connection : * mut GSocketConnection , error : * mut * mut GError) -> * mut GSocketAddress ; } unsafe extern "C" { pub fn g_socket_connection_get_remote_address (connection : * mut GSocketConnection , error : * mut * mut GError) -> * mut GSocketAddress ; } unsafe extern "C" { pub fn g_socket_connection_factory_register_type (g_type : GType , family : GSocketFamily , type_ : GSocketType , protocol : gint) ; } unsafe extern "C" { pub fn g_socket_connection_factory_lookup_type (family : GSocketFamily , type_ : GSocketType , protocol_id : gint) -> GType ; } unsafe extern "C" { pub fn g_socket_connection_factory_create_connection (socket : * mut GSocket) -> * mut GSocketConnection ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketControlMessagePrivate { _unused : [u8 ; 0] , } pub type GSocketControlMessagePrivate = _GSocketControlMessagePrivate ; pub type GSocketControlMessageClass = _GSocketControlMessageClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketControlMessageClass { pub parent_class : GObjectClass , pub get_size : :: std :: option :: Option < unsafe extern "C" fn (message : * mut GSocketControlMessage) -> gsize > , pub get_level : :: std :: option :: Option < unsafe extern "C" fn (message : * mut GSocketControlMessage) -> :: std :: os :: raw :: c_int > , pub get_type : :: std :: option :: Option < unsafe extern "C" fn (message : * mut GSocketControlMessage) -> :: std :: os :: raw :: c_int > , pub serialize : :: std :: option :: Option < unsafe extern "C" fn (message : * mut GSocketControlMessage , data : gpointer) > , pub deserialize : :: std :: option :: Option < unsafe extern "C" fn (level : :: std :: os :: raw :: c_int , type_ : :: std :: os :: raw :: c_int , size : gsize , data : gpointer) -> * mut GSocketControlMessage > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketControlMessageClass"] [:: std :: mem :: size_of :: < _GSocketControlMessageClass > () - 216usize] ; ["Alignment of _GSocketControlMessageClass"] [:: std :: mem :: align_of :: < _GSocketControlMessageClass > () - 8usize] ; ["Offset of field: _GSocketControlMessageClass::parent_class"] [:: std :: mem :: offset_of ! (_GSocketControlMessageClass , parent_class) - 0usize] ; ["Offset of field: _GSocketControlMessageClass::get_size"] [:: std :: mem :: offset_of ! (_GSocketControlMessageClass , get_size) - 136usize] ; ["Offset of field: _GSocketControlMessageClass::get_level"] [:: std :: mem :: offset_of ! (_GSocketControlMessageClass , get_level) - 144usize] ; ["Offset of field: _GSocketControlMessageClass::get_type"] [:: std :: mem :: offset_of ! (_GSocketControlMessageClass , get_type) - 152usize] ; ["Offset of field: _GSocketControlMessageClass::serialize"] [:: std :: mem :: offset_of ! (_GSocketControlMessageClass , serialize) - 160usize] ; ["Offset of field: _GSocketControlMessageClass::deserialize"] [:: std :: mem :: offset_of ! (_GSocketControlMessageClass , deserialize) - 168usize] ; ["Offset of field: _GSocketControlMessageClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GSocketControlMessageClass , _g_reserved1) - 176usize] ; ["Offset of field: _GSocketControlMessageClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GSocketControlMessageClass , _g_reserved2) - 184usize] ; ["Offset of field: _GSocketControlMessageClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GSocketControlMessageClass , _g_reserved3) - 192usize] ; ["Offset of field: _GSocketControlMessageClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GSocketControlMessageClass , _g_reserved4) - 200usize] ; ["Offset of field: _GSocketControlMessageClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GSocketControlMessageClass , _g_reserved5) - 208usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketControlMessage { pub parent_instance : GObject , pub priv_ : * mut GSocketControlMessagePrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketControlMessage"] [:: std :: mem :: size_of :: < _GSocketControlMessage > () - 32usize] ; ["Alignment of _GSocketControlMessage"] [:: std :: mem :: align_of :: < _GSocketControlMessage > () - 8usize] ; ["Offset of field: _GSocketControlMessage::parent_instance"] [:: std :: mem :: offset_of ! (_GSocketControlMessage , parent_instance) - 0usize] ; ["Offset of field: _GSocketControlMessage::priv_"] [:: std :: mem :: offset_of ! (_GSocketControlMessage , priv_) - 24usize] ; } ; unsafe extern "C" { pub fn g_socket_control_message_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_control_message_get_size (message : * mut GSocketControlMessage) -> gsize ; } unsafe extern "C" { pub fn g_socket_control_message_get_level (message : * mut GSocketControlMessage) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn g_socket_control_message_get_msg_type (message : * mut GSocketControlMessage) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn g_socket_control_message_serialize (message : * mut GSocketControlMessage , data : gpointer) ; } unsafe extern "C" { pub fn g_socket_control_message_deserialize (level : :: std :: os :: raw :: c_int , type_ : :: std :: os :: raw :: c_int , size : gsize , data : gpointer) -> * mut GSocketControlMessage ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketListenerPrivate { _unused : [u8 ; 0] , } pub type GSocketListenerPrivate = _GSocketListenerPrivate ; pub type GSocketListenerClass = _GSocketListenerClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketListenerClass { pub parent_class : GObjectClass , pub changed : :: std :: option :: Option < unsafe extern "C" fn (listener : * mut GSocketListener) > , pub event : :: std :: option :: Option < unsafe extern "C" fn (listener : * mut GSocketListener , event : GSocketListenerEvent , socket : * mut GSocket) > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved6 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketListenerClass"] [:: std :: mem :: size_of :: < _GSocketListenerClass > () - 192usize] ; ["Alignment of _GSocketListenerClass"] [:: std :: mem :: align_of :: < _GSocketListenerClass > () - 8usize] ; ["Offset of field: _GSocketListenerClass::parent_class"] [:: std :: mem :: offset_of ! (_GSocketListenerClass , parent_class) - 0usize] ; ["Offset of field: _GSocketListenerClass::changed"] [:: std :: mem :: offset_of ! (_GSocketListenerClass , changed) - 136usize] ; ["Offset of field: _GSocketListenerClass::event"] [:: std :: mem :: offset_of ! (_GSocketListenerClass , event) - 144usize] ; ["Offset of field: _GSocketListenerClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GSocketListenerClass , _g_reserved2) - 152usize] ; ["Offset of field: _GSocketListenerClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GSocketListenerClass , _g_reserved3) - 160usize] ; ["Offset of field: _GSocketListenerClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GSocketListenerClass , _g_reserved4) - 168usize] ; ["Offset of field: _GSocketListenerClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GSocketListenerClass , _g_reserved5) - 176usize] ; ["Offset of field: _GSocketListenerClass::_g_reserved6"] [:: std :: mem :: offset_of ! (_GSocketListenerClass , _g_reserved6) - 184usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketListener { pub parent_instance : GObject , pub priv_ : * mut GSocketListenerPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketListener"] [:: std :: mem :: size_of :: < _GSocketListener > () - 32usize] ; ["Alignment of _GSocketListener"] [:: std :: mem :: align_of :: < _GSocketListener > () - 8usize] ; ["Offset of field: _GSocketListener::parent_instance"] [:: std :: mem :: offset_of ! (_GSocketListener , parent_instance) - 0usize] ; ["Offset of field: _GSocketListener::priv_"] [:: std :: mem :: offset_of ! (_GSocketListener , priv_) - 24usize] ; } ; unsafe extern "C" { pub fn g_socket_listener_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_listener_new () -> * mut GSocketListener ; } unsafe extern "C" { pub fn g_socket_listener_set_backlog (listener : * mut GSocketListener , listen_backlog : :: std :: os :: raw :: c_int) ; } unsafe extern "C" { pub fn g_socket_listener_add_socket (listener : * mut GSocketListener , socket : * mut GSocket , source_object : * mut GObject , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_listener_add_address (listener : * mut GSocketListener , address : * mut GSocketAddress , type_ : GSocketType , protocol : GSocketProtocol , source_object : * mut GObject , effective_address : * mut * mut GSocketAddress , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_listener_add_inet_port (listener : * mut GSocketListener , port : guint16 , source_object : * mut GObject , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_socket_listener_add_any_inet_port (listener : * mut GSocketListener , source_object : * mut GObject , error : * mut * mut GError) -> guint16 ; } unsafe extern "C" { pub fn g_socket_listener_accept_socket (listener : * mut GSocketListener , source_object : * mut * mut GObject , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GSocket ; } unsafe extern "C" { pub fn g_socket_listener_accept_socket_async (listener : * mut GSocketListener , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_socket_listener_accept_socket_finish (listener : * mut GSocketListener , result : * mut GAsyncResult , source_object : * mut * mut GObject , error : * mut * mut GError) -> * mut GSocket ; } unsafe extern "C" { pub fn g_socket_listener_accept (listener : * mut GSocketListener , source_object : * mut * mut GObject , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GSocketConnection ; } unsafe extern "C" { pub fn g_socket_listener_accept_async (listener : * mut GSocketListener , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_socket_listener_accept_finish (listener : * mut GSocketListener , result : * mut GAsyncResult , source_object : * mut * mut GObject , error : * mut * mut GError) -> * mut GSocketConnection ; } unsafe extern "C" { pub fn g_socket_listener_close (listener : * mut GSocketListener) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketServicePrivate { _unused : [u8 ; 0] , } pub type GSocketServicePrivate = _GSocketServicePrivate ; pub type GSocketServiceClass = _GSocketServiceClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketServiceClass { pub parent_class : GSocketListenerClass , pub incoming : :: std :: option :: Option < unsafe extern "C" fn (service : * mut GSocketService , connection : * mut GSocketConnection , source_object : * mut GObject) -> gboolean > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved6 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketServiceClass"] [:: std :: mem :: size_of :: < _GSocketServiceClass > () - 248usize] ; ["Alignment of _GSocketServiceClass"] [:: std :: mem :: align_of :: < _GSocketServiceClass > () - 8usize] ; ["Offset of field: _GSocketServiceClass::parent_class"] [:: std :: mem :: offset_of ! (_GSocketServiceClass , parent_class) - 0usize] ; ["Offset of field: _GSocketServiceClass::incoming"] [:: std :: mem :: offset_of ! (_GSocketServiceClass , incoming) - 192usize] ; ["Offset of field: _GSocketServiceClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GSocketServiceClass , _g_reserved1) - 200usize] ; ["Offset of field: _GSocketServiceClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GSocketServiceClass , _g_reserved2) - 208usize] ; ["Offset of field: _GSocketServiceClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GSocketServiceClass , _g_reserved3) - 216usize] ; ["Offset of field: _GSocketServiceClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GSocketServiceClass , _g_reserved4) - 224usize] ; ["Offset of field: _GSocketServiceClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GSocketServiceClass , _g_reserved5) - 232usize] ; ["Offset of field: _GSocketServiceClass::_g_reserved6"] [:: std :: mem :: offset_of ! (_GSocketServiceClass , _g_reserved6) - 240usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GSocketService { pub parent_instance : GSocketListener , pub priv_ : * mut GSocketServicePrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GSocketService"] [:: std :: mem :: size_of :: < _GSocketService > () - 40usize] ; ["Alignment of _GSocketService"] [:: std :: mem :: align_of :: < _GSocketService > () - 8usize] ; ["Offset of field: _GSocketService::parent_instance"] [:: std :: mem :: offset_of ! (_GSocketService , parent_instance) - 0usize] ; ["Offset of field: _GSocketService::priv_"] [:: std :: mem :: offset_of ! (_GSocketService , priv_) - 32usize] ; } ; unsafe extern "C" { pub fn g_socket_service_get_type () -> GType ; } unsafe extern "C" { pub fn g_socket_service_new () -> * mut GSocketService ; } unsafe extern "C" { pub fn g_socket_service_start (service : * mut GSocketService) ; } unsafe extern "C" { pub fn g_socket_service_stop (service : * mut GSocketService) ; } unsafe extern "C" { pub fn g_socket_service_is_active (service : * mut GSocketService) -> gboolean ; } unsafe extern "C" { pub fn g_srv_target_get_type () -> GType ; } unsafe extern "C" { pub fn g_srv_target_new (hostname : * const gchar , port : guint16 , priority : guint16 , weight : guint16) -> * mut GSrvTarget ; } unsafe extern "C" { pub fn g_srv_target_copy (target : * mut GSrvTarget) -> * mut GSrvTarget ; } unsafe extern "C" { pub fn g_srv_target_free (target : * mut GSrvTarget) ; } unsafe extern "C" { pub fn g_srv_target_get_hostname (target : * mut GSrvTarget) -> * const gchar ; } unsafe extern "C" { pub fn g_srv_target_get_port (target : * mut GSrvTarget) -> guint16 ; } unsafe extern "C" { pub fn g_srv_target_get_priority (target : * mut GSrvTarget) -> guint16 ; } unsafe extern "C" { pub fn g_srv_target_get_weight (target : * mut GSrvTarget) -> guint16 ; } unsafe extern "C" { pub fn g_srv_target_list_sort (targets : * mut GList) -> * mut GList ; } unsafe extern "C" { pub fn g_subprocess_get_type () -> GType ; } unsafe extern "C" { pub fn g_subprocess_new (flags : GSubprocessFlags , error : * mut * mut GError , argv0 : * const gchar , ...) -> * mut GSubprocess ; } unsafe extern "C" { pub fn g_subprocess_newv (argv : * const * const gchar , flags : GSubprocessFlags , error : * mut * mut GError) -> * mut GSubprocess ; } unsafe extern "C" { pub fn g_subprocess_get_stdin_pipe (subprocess : * mut GSubprocess) -> * mut GOutputStream ; } unsafe extern "C" { pub fn g_subprocess_get_stdout_pipe (subprocess : * mut GSubprocess) -> * mut GInputStream ; } unsafe extern "C" { pub fn g_subprocess_get_stderr_pipe (subprocess : * mut GSubprocess) -> * mut GInputStream ; } unsafe extern "C" { pub fn g_subprocess_get_identifier (subprocess : * mut GSubprocess) -> * const gchar ; } unsafe extern "C" { pub fn g_subprocess_send_signal (subprocess : * mut GSubprocess , signal_num : gint) ; } unsafe extern "C" { pub fn g_subprocess_force_exit (subprocess : * mut GSubprocess) ; } unsafe extern "C" { pub fn g_subprocess_wait (subprocess : * mut GSubprocess , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_subprocess_wait_async (subprocess : * mut GSubprocess , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_subprocess_wait_finish (subprocess : * mut GSubprocess , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_subprocess_wait_check (subprocess : * mut GSubprocess , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_subprocess_wait_check_async (subprocess : * mut GSubprocess , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_subprocess_wait_check_finish (subprocess : * mut GSubprocess , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_subprocess_get_status (subprocess : * mut GSubprocess) -> gint ; } unsafe extern "C" { pub fn g_subprocess_get_successful (subprocess : * mut GSubprocess) -> gboolean ; } unsafe extern "C" { pub fn g_subprocess_get_if_exited (subprocess : * mut GSubprocess) -> gboolean ; } unsafe extern "C" { pub fn g_subprocess_get_exit_status (subprocess : * mut GSubprocess) -> gint ; } unsafe extern "C" { pub fn g_subprocess_get_if_signaled (subprocess : * mut GSubprocess) -> gboolean ; } unsafe extern "C" { pub fn g_subprocess_get_term_sig (subprocess : * mut GSubprocess) -> gint ; } unsafe extern "C" { pub fn g_subprocess_communicate (subprocess : * mut GSubprocess , stdin_buf : * mut GBytes , cancellable : * mut GCancellable , stdout_buf : * mut * mut GBytes , stderr_buf : * mut * mut GBytes , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_subprocess_communicate_async (subprocess : * mut GSubprocess , stdin_buf : * mut GBytes , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_subprocess_communicate_finish (subprocess : * mut GSubprocess , result : * mut GAsyncResult , stdout_buf : * mut * mut GBytes , stderr_buf : * mut * mut GBytes , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_subprocess_communicate_utf8 (subprocess : * mut GSubprocess , stdin_buf : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , stdout_buf : * mut * mut :: std :: os :: raw :: c_char , stderr_buf : * mut * mut :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_subprocess_communicate_utf8_async (subprocess : * mut GSubprocess , stdin_buf : * const :: std :: os :: raw :: c_char , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_subprocess_communicate_utf8_finish (subprocess : * mut GSubprocess , result : * mut GAsyncResult , stdout_buf : * mut * mut :: std :: os :: raw :: c_char , stderr_buf : * mut * mut :: std :: os :: raw :: c_char , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_subprocess_launcher_get_type () -> GType ; } unsafe extern "C" { pub fn g_subprocess_launcher_new (flags : GSubprocessFlags) -> * mut GSubprocessLauncher ; } unsafe extern "C" { pub fn g_subprocess_launcher_spawn (self_ : * mut GSubprocessLauncher , error : * mut * mut GError , argv0 : * const gchar , ...) -> * mut GSubprocess ; } unsafe extern "C" { pub fn g_subprocess_launcher_spawnv (self_ : * mut GSubprocessLauncher , argv : * const * const gchar , error : * mut * mut GError) -> * mut GSubprocess ; } unsafe extern "C" { pub fn g_subprocess_launcher_set_environ (self_ : * mut GSubprocessLauncher , env : * mut * mut gchar) ; } unsafe extern "C" { pub fn g_subprocess_launcher_setenv (self_ : * mut GSubprocessLauncher , variable : * const gchar , value : * const gchar , overwrite : gboolean) ; } unsafe extern "C" { pub fn g_subprocess_launcher_unsetenv (self_ : * mut GSubprocessLauncher , variable : * const gchar) ; } unsafe extern "C" { pub fn g_subprocess_launcher_getenv (self_ : * mut GSubprocessLauncher , variable : * const gchar) -> * const gchar ; } unsafe extern "C" { pub fn g_subprocess_launcher_set_cwd (self_ : * mut GSubprocessLauncher , cwd : * const gchar) ; } unsafe extern "C" { pub fn g_subprocess_launcher_set_flags (self_ : * mut GSubprocessLauncher , flags : GSubprocessFlags) ; } unsafe extern "C" { pub fn g_subprocess_launcher_set_stdin_file_path (self_ : * mut GSubprocessLauncher , path : * const gchar) ; } unsafe extern "C" { pub fn g_subprocess_launcher_take_stdin_fd (self_ : * mut GSubprocessLauncher , fd : gint) ; } unsafe extern "C" { pub fn g_subprocess_launcher_set_stdout_file_path (self_ : * mut GSubprocessLauncher , path : * const gchar) ; } unsafe extern "C" { pub fn g_subprocess_launcher_take_stdout_fd (self_ : * mut GSubprocessLauncher , fd : gint) ; } unsafe extern "C" { pub fn g_subprocess_launcher_set_stderr_file_path (self_ : * mut GSubprocessLauncher , path : * const gchar) ; } unsafe extern "C" { pub fn g_subprocess_launcher_take_stderr_fd (self_ : * mut GSubprocessLauncher , fd : gint) ; } unsafe extern "C" { pub fn g_subprocess_launcher_take_fd (self_ : * mut GSubprocessLauncher , source_fd : gint , target_fd : gint) ; } unsafe extern "C" { pub fn g_subprocess_launcher_close (self_ : * mut GSubprocessLauncher) ; } unsafe extern "C" { pub fn g_subprocess_launcher_set_child_setup (self_ : * mut GSubprocessLauncher , child_setup : GSpawnChildSetupFunc , user_data : gpointer , destroy_notify : GDestroyNotify) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTaskClass { _unused : [u8 ; 0] , } pub type GTaskClass = _GTaskClass ; unsafe extern "C" { pub fn g_task_get_type () -> GType ; } unsafe extern "C" { pub fn g_task_new (source_object : gpointer , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , callback_data : gpointer) -> * mut GTask ; } unsafe extern "C" { pub fn g_task_report_error (source_object : gpointer , callback : GAsyncReadyCallback , callback_data : gpointer , source_tag : gpointer , error : * mut GError) ; } unsafe extern "C" { pub fn g_task_report_new_error (source_object : gpointer , callback : GAsyncReadyCallback , callback_data : gpointer , source_tag : gpointer , domain : GQuark , code : gint , format : * const :: std :: os :: raw :: c_char , ...) ; } unsafe extern "C" { pub fn g_task_set_task_data (task : * mut GTask , task_data : gpointer , task_data_destroy : GDestroyNotify) ; } unsafe extern "C" { pub fn g_task_set_priority (task : * mut GTask , priority : gint) ; } unsafe extern "C" { pub fn g_task_set_check_cancellable (task : * mut GTask , check_cancellable : gboolean) ; } unsafe extern "C" { pub fn g_task_set_source_tag (task : * mut GTask , source_tag : gpointer) ; } unsafe extern "C" { pub fn g_task_set_name (task : * mut GTask , name : * const gchar) ; } unsafe extern "C" { pub fn g_task_set_static_name (task : * mut GTask , name : * const gchar) ; } unsafe extern "C" { pub fn g_task_get_source_object (task : * mut GTask) -> gpointer ; } unsafe extern "C" { pub fn g_task_get_task_data (task : * mut GTask) -> gpointer ; } unsafe extern "C" { pub fn g_task_get_priority (task : * mut GTask) -> gint ; } unsafe extern "C" { pub fn g_task_get_context (task : * mut GTask) -> * mut GMainContext ; } unsafe extern "C" { pub fn g_task_get_cancellable (task : * mut GTask) -> * mut GCancellable ; } unsafe extern "C" { pub fn g_task_get_check_cancellable (task : * mut GTask) -> gboolean ; } unsafe extern "C" { pub fn g_task_get_source_tag (task : * mut GTask) -> gpointer ; } unsafe extern "C" { pub fn g_task_get_name (task : * mut GTask) -> * const gchar ; } unsafe extern "C" { pub fn g_task_is_valid (result : gpointer , source_object : gpointer) -> gboolean ; } pub type GTaskThreadFunc = :: std :: option :: Option < unsafe extern "C" fn (task : * mut GTask , source_object : gpointer , task_data : gpointer , cancellable : * mut GCancellable) > ; unsafe extern "C" { pub fn g_task_run_in_thread (task : * mut GTask , task_func : GTaskThreadFunc) ; } unsafe extern "C" { pub fn g_task_run_in_thread_sync (task : * mut GTask , task_func : GTaskThreadFunc) ; } unsafe extern "C" { pub fn g_task_set_return_on_cancel (task : * mut GTask , return_on_cancel : gboolean) -> gboolean ; } unsafe extern "C" { pub fn g_task_get_return_on_cancel (task : * mut GTask) -> gboolean ; } unsafe extern "C" { pub fn g_task_attach_source (task : * mut GTask , source : * mut GSource , callback : GSourceFunc) ; } unsafe extern "C" { pub fn g_task_return_pointer (task : * mut GTask , result : gpointer , result_destroy : GDestroyNotify) ; } unsafe extern "C" { pub fn g_task_return_boolean (task : * mut GTask , result : gboolean) ; } unsafe extern "C" { pub fn g_task_return_int (task : * mut GTask , result : gssize) ; } unsafe extern "C" { pub fn g_task_return_error (task : * mut GTask , error : * mut GError) ; } unsafe extern "C" { pub fn g_task_return_prefixed_error (task : * mut GTask , error : * mut GError , format : * const :: std :: os :: raw :: c_char , ...) ; } unsafe extern "C" { pub fn g_task_return_new_error (task : * mut GTask , domain : GQuark , code : gint , format : * const :: std :: os :: raw :: c_char , ...) ; } unsafe extern "C" { pub fn g_task_return_new_error_literal (task : * mut GTask , domain : GQuark , code : gint , message : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_task_return_value (task : * mut GTask , result : * mut GValue) ; } unsafe extern "C" { pub fn g_task_return_error_if_cancelled (task : * mut GTask) -> gboolean ; } unsafe extern "C" { pub fn g_task_propagate_pointer (task : * mut GTask , error : * mut * mut GError) -> gpointer ; } unsafe extern "C" { pub fn g_task_propagate_boolean (task : * mut GTask , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_task_propagate_int (task : * mut GTask , error : * mut * mut GError) -> gssize ; } unsafe extern "C" { pub fn g_task_propagate_value (task : * mut GTask , value : * mut GValue , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_task_had_error (task : * mut GTask) -> gboolean ; } unsafe extern "C" { pub fn g_task_get_completed (task : * mut GTask) -> gboolean ; } unsafe extern "C" { pub fn g_task_print_alive_tasks () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTcpConnectionPrivate { _unused : [u8 ; 0] , } pub type GTcpConnectionPrivate = _GTcpConnectionPrivate ; pub type GTcpConnectionClass = _GTcpConnectionClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTcpConnectionClass { pub parent_class : GSocketConnectionClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTcpConnectionClass"] [:: std :: mem :: size_of :: < _GTcpConnectionClass > () - 304usize] ; ["Alignment of _GTcpConnectionClass"] [:: std :: mem :: align_of :: < _GTcpConnectionClass > () - 8usize] ; ["Offset of field: _GTcpConnectionClass::parent_class"] [:: std :: mem :: offset_of ! (_GTcpConnectionClass , parent_class) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTcpConnection { pub parent_instance : GSocketConnection , pub priv_ : * mut GTcpConnectionPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTcpConnection"] [:: std :: mem :: size_of :: < _GTcpConnection > () - 48usize] ; ["Alignment of _GTcpConnection"] [:: std :: mem :: align_of :: < _GTcpConnection > () - 8usize] ; ["Offset of field: _GTcpConnection::parent_instance"] [:: std :: mem :: offset_of ! (_GTcpConnection , parent_instance) - 0usize] ; ["Offset of field: _GTcpConnection::priv_"] [:: std :: mem :: offset_of ! (_GTcpConnection , priv_) - 40usize] ; } ; unsafe extern "C" { pub fn g_tcp_connection_get_type () -> GType ; } unsafe extern "C" { pub fn g_tcp_connection_set_graceful_disconnect (connection : * mut GTcpConnection , graceful_disconnect : gboolean) ; } unsafe extern "C" { pub fn g_tcp_connection_get_graceful_disconnect (connection : * mut GTcpConnection) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTcpWrapperConnectionPrivate { _unused : [u8 ; 0] , } pub type GTcpWrapperConnectionPrivate = _GTcpWrapperConnectionPrivate ; pub type GTcpWrapperConnectionClass = _GTcpWrapperConnectionClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTcpWrapperConnectionClass { pub parent_class : GTcpConnectionClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTcpWrapperConnectionClass"] [:: std :: mem :: size_of :: < _GTcpWrapperConnectionClass > () - 304usize] ; ["Alignment of _GTcpWrapperConnectionClass"] [:: std :: mem :: align_of :: < _GTcpWrapperConnectionClass > () - 8usize] ; ["Offset of field: _GTcpWrapperConnectionClass::parent_class"] [:: std :: mem :: offset_of ! (_GTcpWrapperConnectionClass , parent_class) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTcpWrapperConnection { pub parent_instance : GTcpConnection , pub priv_ : * mut GTcpWrapperConnectionPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTcpWrapperConnection"] [:: std :: mem :: size_of :: < _GTcpWrapperConnection > () - 56usize] ; ["Alignment of _GTcpWrapperConnection"] [:: std :: mem :: align_of :: < _GTcpWrapperConnection > () - 8usize] ; ["Offset of field: _GTcpWrapperConnection::parent_instance"] [:: std :: mem :: offset_of ! (_GTcpWrapperConnection , parent_instance) - 0usize] ; ["Offset of field: _GTcpWrapperConnection::priv_"] [:: std :: mem :: offset_of ! (_GTcpWrapperConnection , priv_) - 48usize] ; } ; unsafe extern "C" { pub fn g_tcp_wrapper_connection_get_type () -> GType ; } unsafe extern "C" { pub fn g_tcp_wrapper_connection_new (base_io_stream : * mut GIOStream , socket : * mut GSocket) -> * mut GSocketConnection ; } unsafe extern "C" { pub fn g_tcp_wrapper_connection_get_base_io_stream (conn : * mut GTcpWrapperConnection) -> * mut GIOStream ; } unsafe extern "C" { pub fn g_test_dbus_get_type () -> GType ; } unsafe extern "C" { pub fn g_test_dbus_new (flags : GTestDBusFlags) -> * mut GTestDBus ; } unsafe extern "C" { pub fn g_test_dbus_get_flags (self_ : * mut GTestDBus) -> GTestDBusFlags ; } unsafe extern "C" { pub fn g_test_dbus_get_bus_address (self_ : * mut GTestDBus) -> * const gchar ; } unsafe extern "C" { pub fn g_test_dbus_add_service_dir (self_ : * mut GTestDBus , path : * const gchar) ; } unsafe extern "C" { pub fn g_test_dbus_up (self_ : * mut GTestDBus) ; } unsafe extern "C" { pub fn g_test_dbus_stop (self_ : * mut GTestDBus) ; } unsafe extern "C" { pub fn g_test_dbus_down (self_ : * mut GTestDBus) ; } unsafe extern "C" { pub fn g_test_dbus_unset () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GThemedIconClass { _unused : [u8 ; 0] , } pub type GThemedIconClass = _GThemedIconClass ; unsafe extern "C" { pub fn g_themed_icon_get_type () -> GType ; } unsafe extern "C" { pub fn g_themed_icon_new (iconname : * const :: std :: os :: raw :: c_char) -> * mut GIcon ; } unsafe extern "C" { pub fn g_themed_icon_new_with_default_fallbacks (iconname : * const :: std :: os :: raw :: c_char) -> * mut GIcon ; } unsafe extern "C" { pub fn g_themed_icon_new_from_names (iconnames : * mut * mut :: std :: os :: raw :: c_char , len : :: std :: os :: raw :: c_int) -> * mut GIcon ; } unsafe extern "C" { pub fn g_themed_icon_prepend_name (icon : * mut GThemedIcon , iconname : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_themed_icon_append_name (icon : * mut GThemedIcon , iconname : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn g_themed_icon_get_names (icon : * mut GThemedIcon) -> * const * const gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GThreadedSocketServicePrivate { _unused : [u8 ; 0] , } pub type GThreadedSocketServicePrivate = _GThreadedSocketServicePrivate ; pub type GThreadedSocketServiceClass = _GThreadedSocketServiceClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GThreadedSocketServiceClass { pub parent_class : GSocketServiceClass , pub run : :: std :: option :: Option < unsafe extern "C" fn (service : * mut GThreadedSocketService , connection : * mut GSocketConnection , source_object : * mut GObject) -> gboolean > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GThreadedSocketServiceClass"] [:: std :: mem :: size_of :: < _GThreadedSocketServiceClass > () - 296usize] ; ["Alignment of _GThreadedSocketServiceClass"] [:: std :: mem :: align_of :: < _GThreadedSocketServiceClass > () - 8usize] ; ["Offset of field: _GThreadedSocketServiceClass::parent_class"] [:: std :: mem :: offset_of ! (_GThreadedSocketServiceClass , parent_class) - 0usize] ; ["Offset of field: _GThreadedSocketServiceClass::run"] [:: std :: mem :: offset_of ! (_GThreadedSocketServiceClass , run) - 248usize] ; ["Offset of field: _GThreadedSocketServiceClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GThreadedSocketServiceClass , _g_reserved1) - 256usize] ; ["Offset of field: _GThreadedSocketServiceClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GThreadedSocketServiceClass , _g_reserved2) - 264usize] ; ["Offset of field: _GThreadedSocketServiceClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GThreadedSocketServiceClass , _g_reserved3) - 272usize] ; ["Offset of field: _GThreadedSocketServiceClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GThreadedSocketServiceClass , _g_reserved4) - 280usize] ; ["Offset of field: _GThreadedSocketServiceClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GThreadedSocketServiceClass , _g_reserved5) - 288usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GThreadedSocketService { pub parent_instance : GSocketService , pub priv_ : * mut GThreadedSocketServicePrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GThreadedSocketService"] [:: std :: mem :: size_of :: < _GThreadedSocketService > () - 48usize] ; ["Alignment of _GThreadedSocketService"] [:: std :: mem :: align_of :: < _GThreadedSocketService > () - 8usize] ; ["Offset of field: _GThreadedSocketService::parent_instance"] [:: std :: mem :: offset_of ! (_GThreadedSocketService , parent_instance) - 0usize] ; ["Offset of field: _GThreadedSocketService::priv_"] [:: std :: mem :: offset_of ! (_GThreadedSocketService , priv_) - 40usize] ; } ; unsafe extern "C" { pub fn g_threaded_socket_service_get_type () -> GType ; } unsafe extern "C" { pub fn g_threaded_socket_service_new (max_threads : :: std :: os :: raw :: c_int) -> * mut GSocketService ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsBackend { _unused : [u8 ; 0] , } pub type GTlsBackend = _GTlsBackend ; pub type GTlsBackendInterface = _GTlsBackendInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsBackendInterface { pub g_iface : GTypeInterface , pub supports_tls : :: std :: option :: Option < unsafe extern "C" fn (backend : * mut GTlsBackend) -> gboolean > , pub get_certificate_type : :: std :: option :: Option < unsafe extern "C" fn () -> GType > , pub get_client_connection_type : :: std :: option :: Option < unsafe extern "C" fn () -> GType > , pub get_server_connection_type : :: std :: option :: Option < unsafe extern "C" fn () -> GType > , pub get_file_database_type : :: std :: option :: Option < unsafe extern "C" fn () -> GType > , pub get_default_database : :: std :: option :: Option < unsafe extern "C" fn (backend : * mut GTlsBackend) -> * mut GTlsDatabase > , pub supports_dtls : :: std :: option :: Option < unsafe extern "C" fn (backend : * mut GTlsBackend) -> gboolean > , pub get_dtls_client_connection_type : :: std :: option :: Option < unsafe extern "C" fn () -> GType > , pub get_dtls_server_connection_type : :: std :: option :: Option < unsafe extern "C" fn () -> GType > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTlsBackendInterface"] [:: std :: mem :: size_of :: < _GTlsBackendInterface > () - 88usize] ; ["Alignment of _GTlsBackendInterface"] [:: std :: mem :: align_of :: < _GTlsBackendInterface > () - 8usize] ; ["Offset of field: _GTlsBackendInterface::g_iface"] [:: std :: mem :: offset_of ! (_GTlsBackendInterface , g_iface) - 0usize] ; ["Offset of field: _GTlsBackendInterface::supports_tls"] [:: std :: mem :: offset_of ! (_GTlsBackendInterface , supports_tls) - 16usize] ; ["Offset of field: _GTlsBackendInterface::get_certificate_type"] [:: std :: mem :: offset_of ! (_GTlsBackendInterface , get_certificate_type) - 24usize] ; ["Offset of field: _GTlsBackendInterface::get_client_connection_type"] [:: std :: mem :: offset_of ! (_GTlsBackendInterface , get_client_connection_type) - 32usize] ; ["Offset of field: _GTlsBackendInterface::get_server_connection_type"] [:: std :: mem :: offset_of ! (_GTlsBackendInterface , get_server_connection_type) - 40usize] ; ["Offset of field: _GTlsBackendInterface::get_file_database_type"] [:: std :: mem :: offset_of ! (_GTlsBackendInterface , get_file_database_type) - 48usize] ; ["Offset of field: _GTlsBackendInterface::get_default_database"] [:: std :: mem :: offset_of ! (_GTlsBackendInterface , get_default_database) - 56usize] ; ["Offset of field: _GTlsBackendInterface::supports_dtls"] [:: std :: mem :: offset_of ! (_GTlsBackendInterface , supports_dtls) - 64usize] ; ["Offset of field: _GTlsBackendInterface::get_dtls_client_connection_type"] [:: std :: mem :: offset_of ! (_GTlsBackendInterface , get_dtls_client_connection_type) - 72usize] ; ["Offset of field: _GTlsBackendInterface::get_dtls_server_connection_type"] [:: std :: mem :: offset_of ! (_GTlsBackendInterface , get_dtls_server_connection_type) - 80usize] ; } ; unsafe extern "C" { pub fn g_tls_backend_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_backend_get_default () -> * mut GTlsBackend ; } unsafe extern "C" { pub fn g_tls_backend_get_default_database (backend : * mut GTlsBackend) -> * mut GTlsDatabase ; } unsafe extern "C" { pub fn g_tls_backend_set_default_database (backend : * mut GTlsBackend , database : * mut GTlsDatabase) ; } unsafe extern "C" { pub fn g_tls_backend_supports_tls (backend : * mut GTlsBackend) -> gboolean ; } unsafe extern "C" { pub fn g_tls_backend_supports_dtls (backend : * mut GTlsBackend) -> gboolean ; } unsafe extern "C" { pub fn g_tls_backend_get_certificate_type (backend : * mut GTlsBackend) -> GType ; } unsafe extern "C" { pub fn g_tls_backend_get_client_connection_type (backend : * mut GTlsBackend) -> GType ; } unsafe extern "C" { pub fn g_tls_backend_get_server_connection_type (backend : * mut GTlsBackend) -> GType ; } unsafe extern "C" { pub fn g_tls_backend_get_file_database_type (backend : * mut GTlsBackend) -> GType ; } unsafe extern "C" { pub fn g_tls_backend_get_dtls_client_connection_type (backend : * mut GTlsBackend) -> GType ; } unsafe extern "C" { pub fn g_tls_backend_get_dtls_server_connection_type (backend : * mut GTlsBackend) -> GType ; } pub type GTlsCertificateClass = _GTlsCertificateClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsCertificatePrivate { _unused : [u8 ; 0] , } pub type GTlsCertificatePrivate = _GTlsCertificatePrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsCertificate { pub parent_instance : GObject , pub priv_ : * mut GTlsCertificatePrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTlsCertificate"] [:: std :: mem :: size_of :: < _GTlsCertificate > () - 32usize] ; ["Alignment of _GTlsCertificate"] [:: std :: mem :: align_of :: < _GTlsCertificate > () - 8usize] ; ["Offset of field: _GTlsCertificate::parent_instance"] [:: std :: mem :: offset_of ! (_GTlsCertificate , parent_instance) - 0usize] ; ["Offset of field: _GTlsCertificate::priv_"] [:: std :: mem :: offset_of ! (_GTlsCertificate , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsCertificateClass { pub parent_class : GObjectClass , pub verify : :: std :: option :: Option < unsafe extern "C" fn (cert : * mut GTlsCertificate , identity : * mut GSocketConnectable , trusted_ca : * mut GTlsCertificate) -> GTlsCertificateFlags > , pub padding : [gpointer ; 8usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTlsCertificateClass"] [:: std :: mem :: size_of :: < _GTlsCertificateClass > () - 208usize] ; ["Alignment of _GTlsCertificateClass"] [:: std :: mem :: align_of :: < _GTlsCertificateClass > () - 8usize] ; ["Offset of field: _GTlsCertificateClass::parent_class"] [:: std :: mem :: offset_of ! (_GTlsCertificateClass , parent_class) - 0usize] ; ["Offset of field: _GTlsCertificateClass::verify"] [:: std :: mem :: offset_of ! (_GTlsCertificateClass , verify) - 136usize] ; ["Offset of field: _GTlsCertificateClass::padding"] [:: std :: mem :: offset_of ! (_GTlsCertificateClass , padding) - 144usize] ; } ; unsafe extern "C" { pub fn g_tls_certificate_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_certificate_new_from_pem (data : * const gchar , length : gssize , error : * mut * mut GError) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_tls_certificate_new_from_pkcs12 (data : * const guint8 , length : gsize , password : * const gchar , error : * mut * mut GError) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_tls_certificate_new_from_file_with_password (file : * const gchar , password : * const gchar , error : * mut * mut GError) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_tls_certificate_new_from_file (file : * const gchar , error : * mut * mut GError) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_tls_certificate_new_from_files (cert_file : * const gchar , key_file : * const gchar , error : * mut * mut GError) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_tls_certificate_new_from_pkcs11_uris (pkcs11_uri : * const gchar , private_key_pkcs11_uri : * const gchar , error : * mut * mut GError) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_tls_certificate_list_new_from_file (file : * const gchar , error : * mut * mut GError) -> * mut GList ; } unsafe extern "C" { pub fn g_tls_certificate_get_issuer (cert : * mut GTlsCertificate) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_tls_certificate_verify (cert : * mut GTlsCertificate , identity : * mut GSocketConnectable , trusted_ca : * mut GTlsCertificate) -> GTlsCertificateFlags ; } unsafe extern "C" { pub fn g_tls_certificate_is_same (cert_one : * mut GTlsCertificate , cert_two : * mut GTlsCertificate) -> gboolean ; } unsafe extern "C" { pub fn g_tls_certificate_get_not_valid_before (cert : * mut GTlsCertificate) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_tls_certificate_get_not_valid_after (cert : * mut GTlsCertificate) -> * mut GDateTime ; } unsafe extern "C" { pub fn g_tls_certificate_get_subject_name (cert : * mut GTlsCertificate) -> * mut gchar ; } unsafe extern "C" { pub fn g_tls_certificate_get_issuer_name (cert : * mut GTlsCertificate) -> * mut gchar ; } unsafe extern "C" { pub fn g_tls_certificate_get_dns_names (cert : * mut GTlsCertificate) -> * mut GPtrArray ; } unsafe extern "C" { pub fn g_tls_certificate_get_ip_addresses (cert : * mut GTlsCertificate) -> * mut GPtrArray ; } pub type GTlsConnectionClass = _GTlsConnectionClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsConnectionPrivate { _unused : [u8 ; 0] , } pub type GTlsConnectionPrivate = _GTlsConnectionPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsConnection { pub parent_instance : GIOStream , pub priv_ : * mut GTlsConnectionPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTlsConnection"] [:: std :: mem :: size_of :: < _GTlsConnection > () - 40usize] ; ["Alignment of _GTlsConnection"] [:: std :: mem :: align_of :: < _GTlsConnection > () - 8usize] ; ["Offset of field: _GTlsConnection::parent_instance"] [:: std :: mem :: offset_of ! (_GTlsConnection , parent_instance) - 0usize] ; ["Offset of field: _GTlsConnection::priv_"] [:: std :: mem :: offset_of ! (_GTlsConnection , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsConnectionClass { pub parent_class : GIOStreamClass , pub accept_certificate : :: std :: option :: Option < unsafe extern "C" fn (connection : * mut GTlsConnection , peer_cert : * mut GTlsCertificate , errors : GTlsCertificateFlags) -> gboolean > , pub handshake : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GTlsConnection , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub handshake_async : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GTlsConnection , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub handshake_finish : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GTlsConnection , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub get_binding_data : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GTlsConnection , type_ : GTlsChannelBindingType , data : * mut GByteArray , error : * mut * mut GError) -> gboolean > , pub get_negotiated_protocol : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GTlsConnection) -> * const gchar > , pub padding : [gpointer ; 6usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTlsConnectionClass"] [:: std :: mem :: size_of :: < _GTlsConnectionClass > () - 352usize] ; ["Alignment of _GTlsConnectionClass"] [:: std :: mem :: align_of :: < _GTlsConnectionClass > () - 8usize] ; ["Offset of field: _GTlsConnectionClass::parent_class"] [:: std :: mem :: offset_of ! (_GTlsConnectionClass , parent_class) - 0usize] ; ["Offset of field: _GTlsConnectionClass::accept_certificate"] [:: std :: mem :: offset_of ! (_GTlsConnectionClass , accept_certificate) - 256usize] ; ["Offset of field: _GTlsConnectionClass::handshake"] [:: std :: mem :: offset_of ! (_GTlsConnectionClass , handshake) - 264usize] ; ["Offset of field: _GTlsConnectionClass::handshake_async"] [:: std :: mem :: offset_of ! (_GTlsConnectionClass , handshake_async) - 272usize] ; ["Offset of field: _GTlsConnectionClass::handshake_finish"] [:: std :: mem :: offset_of ! (_GTlsConnectionClass , handshake_finish) - 280usize] ; ["Offset of field: _GTlsConnectionClass::get_binding_data"] [:: std :: mem :: offset_of ! (_GTlsConnectionClass , get_binding_data) - 288usize] ; ["Offset of field: _GTlsConnectionClass::get_negotiated_protocol"] [:: std :: mem :: offset_of ! (_GTlsConnectionClass , get_negotiated_protocol) - 296usize] ; ["Offset of field: _GTlsConnectionClass::padding"] [:: std :: mem :: offset_of ! (_GTlsConnectionClass , padding) - 304usize] ; } ; unsafe extern "C" { pub fn g_tls_connection_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_connection_set_use_system_certdb (conn : * mut GTlsConnection , use_system_certdb : gboolean) ; } unsafe extern "C" { pub fn g_tls_connection_get_use_system_certdb (conn : * mut GTlsConnection) -> gboolean ; } unsafe extern "C" { pub fn g_tls_connection_set_database (conn : * mut GTlsConnection , database : * mut GTlsDatabase) ; } unsafe extern "C" { pub fn g_tls_connection_get_database (conn : * mut GTlsConnection) -> * mut GTlsDatabase ; } unsafe extern "C" { pub fn g_tls_connection_set_certificate (conn : * mut GTlsConnection , certificate : * mut GTlsCertificate) ; } unsafe extern "C" { pub fn g_tls_connection_get_certificate (conn : * mut GTlsConnection) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_tls_connection_set_interaction (conn : * mut GTlsConnection , interaction : * mut GTlsInteraction) ; } unsafe extern "C" { pub fn g_tls_connection_get_interaction (conn : * mut GTlsConnection) -> * mut GTlsInteraction ; } unsafe extern "C" { pub fn g_tls_connection_get_peer_certificate (conn : * mut GTlsConnection) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_tls_connection_get_peer_certificate_errors (conn : * mut GTlsConnection) -> GTlsCertificateFlags ; } unsafe extern "C" { pub fn g_tls_connection_set_require_close_notify (conn : * mut GTlsConnection , require_close_notify : gboolean) ; } unsafe extern "C" { pub fn g_tls_connection_get_require_close_notify (conn : * mut GTlsConnection) -> gboolean ; } unsafe extern "C" { pub fn g_tls_connection_set_rehandshake_mode (conn : * mut GTlsConnection , mode : GTlsRehandshakeMode) ; } unsafe extern "C" { pub fn g_tls_connection_get_rehandshake_mode (conn : * mut GTlsConnection) -> GTlsRehandshakeMode ; } unsafe extern "C" { pub fn g_tls_connection_set_advertised_protocols (conn : * mut GTlsConnection , protocols : * const * const gchar) ; } unsafe extern "C" { pub fn g_tls_connection_get_negotiated_protocol (conn : * mut GTlsConnection) -> * const gchar ; } unsafe extern "C" { pub fn g_tls_connection_get_channel_binding_data (conn : * mut GTlsConnection , type_ : GTlsChannelBindingType , data : * mut GByteArray , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_tls_connection_handshake (conn : * mut GTlsConnection , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_tls_connection_handshake_async (conn : * mut GTlsConnection , io_priority : :: std :: os :: raw :: c_int , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_tls_connection_handshake_finish (conn : * mut GTlsConnection , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_tls_connection_get_protocol_version (conn : * mut GTlsConnection) -> GTlsProtocolVersion ; } unsafe extern "C" { pub fn g_tls_connection_get_ciphersuite_name (conn : * mut GTlsConnection) -> * mut gchar ; } unsafe extern "C" { pub fn g_tls_error_quark () -> GQuark ; } unsafe extern "C" { pub fn g_tls_channel_binding_error_quark () -> GQuark ; } unsafe extern "C" { pub fn g_tls_connection_emit_accept_certificate (conn : * mut GTlsConnection , peer_cert : * mut GTlsCertificate , errors : GTlsCertificateFlags) -> gboolean ; } pub type GTlsClientConnectionInterface = _GTlsClientConnectionInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsClientConnectionInterface { pub g_iface : GTypeInterface , pub copy_session_state : :: std :: option :: Option < unsafe extern "C" fn (conn : * mut GTlsClientConnection , source : * mut GTlsClientConnection) > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTlsClientConnectionInterface"] [:: std :: mem :: size_of :: < _GTlsClientConnectionInterface > () - 24usize] ; ["Alignment of _GTlsClientConnectionInterface"] [:: std :: mem :: align_of :: < _GTlsClientConnectionInterface > () - 8usize] ; ["Offset of field: _GTlsClientConnectionInterface::g_iface"] [:: std :: mem :: offset_of ! (_GTlsClientConnectionInterface , g_iface) - 0usize] ; ["Offset of field: _GTlsClientConnectionInterface::copy_session_state"] [:: std :: mem :: offset_of ! (_GTlsClientConnectionInterface , copy_session_state) - 16usize] ; } ; unsafe extern "C" { pub fn g_tls_client_connection_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_client_connection_new (base_io_stream : * mut GIOStream , server_identity : * mut GSocketConnectable , error : * mut * mut GError) -> * mut GIOStream ; } unsafe extern "C" { pub fn g_tls_client_connection_get_validation_flags (conn : * mut GTlsClientConnection) -> GTlsCertificateFlags ; } unsafe extern "C" { pub fn g_tls_client_connection_set_validation_flags (conn : * mut GTlsClientConnection , flags : GTlsCertificateFlags) ; } unsafe extern "C" { pub fn g_tls_client_connection_get_server_identity (conn : * mut GTlsClientConnection) -> * mut GSocketConnectable ; } unsafe extern "C" { pub fn g_tls_client_connection_set_server_identity (conn : * mut GTlsClientConnection , identity : * mut GSocketConnectable) ; } unsafe extern "C" { pub fn g_tls_client_connection_get_use_ssl3 (conn : * mut GTlsClientConnection) -> gboolean ; } unsafe extern "C" { pub fn g_tls_client_connection_set_use_ssl3 (conn : * mut GTlsClientConnection , use_ssl3 : gboolean) ; } unsafe extern "C" { pub fn g_tls_client_connection_get_accepted_cas (conn : * mut GTlsClientConnection) -> * mut GList ; } unsafe extern "C" { pub fn g_tls_client_connection_copy_session_state (conn : * mut GTlsClientConnection , source : * mut GTlsClientConnection) ; } pub type GTlsDatabaseClass = _GTlsDatabaseClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsDatabasePrivate { _unused : [u8 ; 0] , } pub type GTlsDatabasePrivate = _GTlsDatabasePrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsDatabase { pub parent_instance : GObject , pub priv_ : * mut GTlsDatabasePrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTlsDatabase"] [:: std :: mem :: size_of :: < _GTlsDatabase > () - 32usize] ; ["Alignment of _GTlsDatabase"] [:: std :: mem :: align_of :: < _GTlsDatabase > () - 8usize] ; ["Offset of field: _GTlsDatabase::parent_instance"] [:: std :: mem :: offset_of ! (_GTlsDatabase , parent_instance) - 0usize] ; ["Offset of field: _GTlsDatabase::priv_"] [:: std :: mem :: offset_of ! (_GTlsDatabase , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsDatabaseClass { pub parent_class : GObjectClass , pub verify_chain : :: std :: option :: Option < unsafe extern "C" fn (self_ : * mut GTlsDatabase , chain : * mut GTlsCertificate , purpose : * const gchar , identity : * mut GSocketConnectable , interaction : * mut GTlsInteraction , flags : GTlsDatabaseVerifyFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> GTlsCertificateFlags > , pub verify_chain_async : :: std :: option :: Option < unsafe extern "C" fn (self_ : * mut GTlsDatabase , chain : * mut GTlsCertificate , purpose : * const gchar , identity : * mut GSocketConnectable , interaction : * mut GTlsInteraction , flags : GTlsDatabaseVerifyFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub verify_chain_finish : :: std :: option :: Option < unsafe extern "C" fn (self_ : * mut GTlsDatabase , result : * mut GAsyncResult , error : * mut * mut GError) -> GTlsCertificateFlags > , pub create_certificate_handle : :: std :: option :: Option < unsafe extern "C" fn (self_ : * mut GTlsDatabase , certificate : * mut GTlsCertificate) -> * mut gchar > , pub lookup_certificate_for_handle : :: std :: option :: Option < unsafe extern "C" fn (self_ : * mut GTlsDatabase , handle : * const gchar , interaction : * mut GTlsInteraction , flags : GTlsDatabaseLookupFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GTlsCertificate > , pub lookup_certificate_for_handle_async : :: std :: option :: Option < unsafe extern "C" fn (self_ : * mut GTlsDatabase , handle : * const gchar , interaction : * mut GTlsInteraction , flags : GTlsDatabaseLookupFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub lookup_certificate_for_handle_finish : :: std :: option :: Option < unsafe extern "C" fn (self_ : * mut GTlsDatabase , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GTlsCertificate > , pub lookup_certificate_issuer : :: std :: option :: Option < unsafe extern "C" fn (self_ : * mut GTlsDatabase , certificate : * mut GTlsCertificate , interaction : * mut GTlsInteraction , flags : GTlsDatabaseLookupFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GTlsCertificate > , pub lookup_certificate_issuer_async : :: std :: option :: Option < unsafe extern "C" fn (self_ : * mut GTlsDatabase , certificate : * mut GTlsCertificate , interaction : * mut GTlsInteraction , flags : GTlsDatabaseLookupFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub lookup_certificate_issuer_finish : :: std :: option :: Option < unsafe extern "C" fn (self_ : * mut GTlsDatabase , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GTlsCertificate > , pub lookup_certificates_issued_by : :: std :: option :: Option < unsafe extern "C" fn (self_ : * mut GTlsDatabase , issuer_raw_dn : * mut GByteArray , interaction : * mut GTlsInteraction , flags : GTlsDatabaseLookupFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GList > , pub lookup_certificates_issued_by_async : :: std :: option :: Option < unsafe extern "C" fn (self_ : * mut GTlsDatabase , issuer_raw_dn : * mut GByteArray , interaction : * mut GTlsInteraction , flags : GTlsDatabaseLookupFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub lookup_certificates_issued_by_finish : :: std :: option :: Option < unsafe extern "C" fn (self_ : * mut GTlsDatabase , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GList > , pub padding : [gpointer ; 16usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTlsDatabaseClass"] [:: std :: mem :: size_of :: < _GTlsDatabaseClass > () - 368usize] ; ["Alignment of _GTlsDatabaseClass"] [:: std :: mem :: align_of :: < _GTlsDatabaseClass > () - 8usize] ; ["Offset of field: _GTlsDatabaseClass::parent_class"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , parent_class) - 0usize] ; ["Offset of field: _GTlsDatabaseClass::verify_chain"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , verify_chain) - 136usize] ; ["Offset of field: _GTlsDatabaseClass::verify_chain_async"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , verify_chain_async) - 144usize] ; ["Offset of field: _GTlsDatabaseClass::verify_chain_finish"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , verify_chain_finish) - 152usize] ; ["Offset of field: _GTlsDatabaseClass::create_certificate_handle"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , create_certificate_handle) - 160usize] ; ["Offset of field: _GTlsDatabaseClass::lookup_certificate_for_handle"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , lookup_certificate_for_handle) - 168usize] ; ["Offset of field: _GTlsDatabaseClass::lookup_certificate_for_handle_async"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , lookup_certificate_for_handle_async) - 176usize] ; ["Offset of field: _GTlsDatabaseClass::lookup_certificate_for_handle_finish"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , lookup_certificate_for_handle_finish) - 184usize] ; ["Offset of field: _GTlsDatabaseClass::lookup_certificate_issuer"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , lookup_certificate_issuer) - 192usize] ; ["Offset of field: _GTlsDatabaseClass::lookup_certificate_issuer_async"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , lookup_certificate_issuer_async) - 200usize] ; ["Offset of field: _GTlsDatabaseClass::lookup_certificate_issuer_finish"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , lookup_certificate_issuer_finish) - 208usize] ; ["Offset of field: _GTlsDatabaseClass::lookup_certificates_issued_by"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , lookup_certificates_issued_by) - 216usize] ; ["Offset of field: _GTlsDatabaseClass::lookup_certificates_issued_by_async"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , lookup_certificates_issued_by_async) - 224usize] ; ["Offset of field: _GTlsDatabaseClass::lookup_certificates_issued_by_finish"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , lookup_certificates_issued_by_finish) - 232usize] ; ["Offset of field: _GTlsDatabaseClass::padding"] [:: std :: mem :: offset_of ! (_GTlsDatabaseClass , padding) - 240usize] ; } ; unsafe extern "C" { pub fn g_tls_database_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_database_verify_chain (self_ : * mut GTlsDatabase , chain : * mut GTlsCertificate , purpose : * const gchar , identity : * mut GSocketConnectable , interaction : * mut GTlsInteraction , flags : GTlsDatabaseVerifyFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> GTlsCertificateFlags ; } unsafe extern "C" { pub fn g_tls_database_verify_chain_async (self_ : * mut GTlsDatabase , chain : * mut GTlsCertificate , purpose : * const gchar , identity : * mut GSocketConnectable , interaction : * mut GTlsInteraction , flags : GTlsDatabaseVerifyFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_tls_database_verify_chain_finish (self_ : * mut GTlsDatabase , result : * mut GAsyncResult , error : * mut * mut GError) -> GTlsCertificateFlags ; } unsafe extern "C" { pub fn g_tls_database_create_certificate_handle (self_ : * mut GTlsDatabase , certificate : * mut GTlsCertificate) -> * mut gchar ; } unsafe extern "C" { pub fn g_tls_database_lookup_certificate_for_handle (self_ : * mut GTlsDatabase , handle : * const gchar , interaction : * mut GTlsInteraction , flags : GTlsDatabaseLookupFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_tls_database_lookup_certificate_for_handle_async (self_ : * mut GTlsDatabase , handle : * const gchar , interaction : * mut GTlsInteraction , flags : GTlsDatabaseLookupFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_tls_database_lookup_certificate_for_handle_finish (self_ : * mut GTlsDatabase , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_tls_database_lookup_certificate_issuer (self_ : * mut GTlsDatabase , certificate : * mut GTlsCertificate , interaction : * mut GTlsInteraction , flags : GTlsDatabaseLookupFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_tls_database_lookup_certificate_issuer_async (self_ : * mut GTlsDatabase , certificate : * mut GTlsCertificate , interaction : * mut GTlsInteraction , flags : GTlsDatabaseLookupFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_tls_database_lookup_certificate_issuer_finish (self_ : * mut GTlsDatabase , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GTlsCertificate ; } unsafe extern "C" { pub fn g_tls_database_lookup_certificates_issued_by (self_ : * mut GTlsDatabase , issuer_raw_dn : * mut GByteArray , interaction : * mut GTlsInteraction , flags : GTlsDatabaseLookupFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GList ; } unsafe extern "C" { pub fn g_tls_database_lookup_certificates_issued_by_async (self_ : * mut GTlsDatabase , issuer_raw_dn : * mut GByteArray , interaction : * mut GTlsInteraction , flags : GTlsDatabaseLookupFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_tls_database_lookup_certificates_issued_by_finish (self_ : * mut GTlsDatabase , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GList ; } pub type GTlsFileDatabaseInterface = _GTlsFileDatabaseInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsFileDatabaseInterface { pub g_iface : GTypeInterface , pub padding : [gpointer ; 8usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTlsFileDatabaseInterface"] [:: std :: mem :: size_of :: < _GTlsFileDatabaseInterface > () - 80usize] ; ["Alignment of _GTlsFileDatabaseInterface"] [:: std :: mem :: align_of :: < _GTlsFileDatabaseInterface > () - 8usize] ; ["Offset of field: _GTlsFileDatabaseInterface::g_iface"] [:: std :: mem :: offset_of ! (_GTlsFileDatabaseInterface , g_iface) - 0usize] ; ["Offset of field: _GTlsFileDatabaseInterface::padding"] [:: std :: mem :: offset_of ! (_GTlsFileDatabaseInterface , padding) - 16usize] ; } ; unsafe extern "C" { pub fn g_tls_file_database_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_file_database_new (anchors : * const gchar , error : * mut * mut GError) -> * mut GTlsDatabase ; } pub type GTlsInteractionClass = _GTlsInteractionClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsInteractionPrivate { _unused : [u8 ; 0] , } pub type GTlsInteractionPrivate = _GTlsInteractionPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsInteraction { pub parent_instance : GObject , pub priv_ : * mut GTlsInteractionPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTlsInteraction"] [:: std :: mem :: size_of :: < _GTlsInteraction > () - 32usize] ; ["Alignment of _GTlsInteraction"] [:: std :: mem :: align_of :: < _GTlsInteraction > () - 8usize] ; ["Offset of field: _GTlsInteraction::parent_instance"] [:: std :: mem :: offset_of ! (_GTlsInteraction , parent_instance) - 0usize] ; ["Offset of field: _GTlsInteraction::priv_"] [:: std :: mem :: offset_of ! (_GTlsInteraction , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsInteractionClass { pub parent_class : GObjectClass , pub ask_password : :: std :: option :: Option < unsafe extern "C" fn (interaction : * mut GTlsInteraction , password : * mut GTlsPassword , cancellable : * mut GCancellable , error : * mut * mut GError) -> GTlsInteractionResult > , pub ask_password_async : :: std :: option :: Option < unsafe extern "C" fn (interaction : * mut GTlsInteraction , password : * mut GTlsPassword , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub ask_password_finish : :: std :: option :: Option < unsafe extern "C" fn (interaction : * mut GTlsInteraction , result : * mut GAsyncResult , error : * mut * mut GError) -> GTlsInteractionResult > , pub request_certificate : :: std :: option :: Option < unsafe extern "C" fn (interaction : * mut GTlsInteraction , connection : * mut GTlsConnection , flags : GTlsCertificateRequestFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> GTlsInteractionResult > , pub request_certificate_async : :: std :: option :: Option < unsafe extern "C" fn (interaction : * mut GTlsInteraction , connection : * mut GTlsConnection , flags : GTlsCertificateRequestFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub request_certificate_finish : :: std :: option :: Option < unsafe extern "C" fn (interaction : * mut GTlsInteraction , result : * mut GAsyncResult , error : * mut * mut GError) -> GTlsInteractionResult > , pub padding : [gpointer ; 21usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTlsInteractionClass"] [:: std :: mem :: size_of :: < _GTlsInteractionClass > () - 352usize] ; ["Alignment of _GTlsInteractionClass"] [:: std :: mem :: align_of :: < _GTlsInteractionClass > () - 8usize] ; ["Offset of field: _GTlsInteractionClass::parent_class"] [:: std :: mem :: offset_of ! (_GTlsInteractionClass , parent_class) - 0usize] ; ["Offset of field: _GTlsInteractionClass::ask_password"] [:: std :: mem :: offset_of ! (_GTlsInteractionClass , ask_password) - 136usize] ; ["Offset of field: _GTlsInteractionClass::ask_password_async"] [:: std :: mem :: offset_of ! (_GTlsInteractionClass , ask_password_async) - 144usize] ; ["Offset of field: _GTlsInteractionClass::ask_password_finish"] [:: std :: mem :: offset_of ! (_GTlsInteractionClass , ask_password_finish) - 152usize] ; ["Offset of field: _GTlsInteractionClass::request_certificate"] [:: std :: mem :: offset_of ! (_GTlsInteractionClass , request_certificate) - 160usize] ; ["Offset of field: _GTlsInteractionClass::request_certificate_async"] [:: std :: mem :: offset_of ! (_GTlsInteractionClass , request_certificate_async) - 168usize] ; ["Offset of field: _GTlsInteractionClass::request_certificate_finish"] [:: std :: mem :: offset_of ! (_GTlsInteractionClass , request_certificate_finish) - 176usize] ; ["Offset of field: _GTlsInteractionClass::padding"] [:: std :: mem :: offset_of ! (_GTlsInteractionClass , padding) - 184usize] ; } ; unsafe extern "C" { pub fn g_tls_interaction_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_interaction_invoke_ask_password (interaction : * mut GTlsInteraction , password : * mut GTlsPassword , cancellable : * mut GCancellable , error : * mut * mut GError) -> GTlsInteractionResult ; } unsafe extern "C" { pub fn g_tls_interaction_ask_password (interaction : * mut GTlsInteraction , password : * mut GTlsPassword , cancellable : * mut GCancellable , error : * mut * mut GError) -> GTlsInteractionResult ; } unsafe extern "C" { pub fn g_tls_interaction_ask_password_async (interaction : * mut GTlsInteraction , password : * mut GTlsPassword , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_tls_interaction_ask_password_finish (interaction : * mut GTlsInteraction , result : * mut GAsyncResult , error : * mut * mut GError) -> GTlsInteractionResult ; } unsafe extern "C" { pub fn g_tls_interaction_invoke_request_certificate (interaction : * mut GTlsInteraction , connection : * mut GTlsConnection , flags : GTlsCertificateRequestFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> GTlsInteractionResult ; } unsafe extern "C" { pub fn g_tls_interaction_request_certificate (interaction : * mut GTlsInteraction , connection : * mut GTlsConnection , flags : GTlsCertificateRequestFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> GTlsInteractionResult ; } unsafe extern "C" { pub fn g_tls_interaction_request_certificate_async (interaction : * mut GTlsInteraction , connection : * mut GTlsConnection , flags : GTlsCertificateRequestFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_tls_interaction_request_certificate_finish (interaction : * mut GTlsInteraction , result : * mut GAsyncResult , error : * mut * mut GError) -> GTlsInteractionResult ; } pub type GTlsPasswordClass = _GTlsPasswordClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsPasswordPrivate { _unused : [u8 ; 0] , } pub type GTlsPasswordPrivate = _GTlsPasswordPrivate ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsPassword { pub parent_instance : GObject , pub priv_ : * mut GTlsPasswordPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTlsPassword"] [:: std :: mem :: size_of :: < _GTlsPassword > () - 32usize] ; ["Alignment of _GTlsPassword"] [:: std :: mem :: align_of :: < _GTlsPassword > () - 8usize] ; ["Offset of field: _GTlsPassword::parent_instance"] [:: std :: mem :: offset_of ! (_GTlsPassword , parent_instance) - 0usize] ; ["Offset of field: _GTlsPassword::priv_"] [:: std :: mem :: offset_of ! (_GTlsPassword , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsPasswordClass { pub parent_class : GObjectClass , pub get_value : :: std :: option :: Option < unsafe extern "C" fn (password : * mut GTlsPassword , length : * mut gsize) -> * const guchar > , pub set_value : :: std :: option :: Option < unsafe extern "C" fn (password : * mut GTlsPassword , value : * mut guchar , length : gssize , destroy : GDestroyNotify) > , pub get_default_warning : :: std :: option :: Option < unsafe extern "C" fn (password : * mut GTlsPassword) -> * const gchar > , pub padding : [gpointer ; 4usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTlsPasswordClass"] [:: std :: mem :: size_of :: < _GTlsPasswordClass > () - 192usize] ; ["Alignment of _GTlsPasswordClass"] [:: std :: mem :: align_of :: < _GTlsPasswordClass > () - 8usize] ; ["Offset of field: _GTlsPasswordClass::parent_class"] [:: std :: mem :: offset_of ! (_GTlsPasswordClass , parent_class) - 0usize] ; ["Offset of field: _GTlsPasswordClass::get_value"] [:: std :: mem :: offset_of ! (_GTlsPasswordClass , get_value) - 136usize] ; ["Offset of field: _GTlsPasswordClass::set_value"] [:: std :: mem :: offset_of ! (_GTlsPasswordClass , set_value) - 144usize] ; ["Offset of field: _GTlsPasswordClass::get_default_warning"] [:: std :: mem :: offset_of ! (_GTlsPasswordClass , get_default_warning) - 152usize] ; ["Offset of field: _GTlsPasswordClass::padding"] [:: std :: mem :: offset_of ! (_GTlsPasswordClass , padding) - 160usize] ; } ; unsafe extern "C" { pub fn g_tls_password_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_password_new (flags : GTlsPasswordFlags , description : * const gchar) -> * mut GTlsPassword ; } unsafe extern "C" { pub fn g_tls_password_get_value (password : * mut GTlsPassword , length : * mut gsize) -> * const guchar ; } unsafe extern "C" { pub fn g_tls_password_set_value (password : * mut GTlsPassword , value : * const guchar , length : gssize) ; } unsafe extern "C" { pub fn g_tls_password_set_value_full (password : * mut GTlsPassword , value : * mut guchar , length : gssize , destroy : GDestroyNotify) ; } unsafe extern "C" { pub fn g_tls_password_get_flags (password : * mut GTlsPassword) -> GTlsPasswordFlags ; } unsafe extern "C" { pub fn g_tls_password_set_flags (password : * mut GTlsPassword , flags : GTlsPasswordFlags) ; } unsafe extern "C" { pub fn g_tls_password_get_description (password : * mut GTlsPassword) -> * const gchar ; } unsafe extern "C" { pub fn g_tls_password_set_description (password : * mut GTlsPassword , description : * const gchar) ; } unsafe extern "C" { pub fn g_tls_password_get_warning (password : * mut GTlsPassword) -> * const gchar ; } unsafe extern "C" { pub fn g_tls_password_set_warning (password : * mut GTlsPassword , warning : * const gchar) ; } pub type GTlsServerConnectionInterface = _GTlsServerConnectionInterface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GTlsServerConnectionInterface { pub g_iface : GTypeInterface , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GTlsServerConnectionInterface"] [:: std :: mem :: size_of :: < _GTlsServerConnectionInterface > () - 16usize] ; ["Alignment of _GTlsServerConnectionInterface"] [:: std :: mem :: align_of :: < _GTlsServerConnectionInterface > () - 8usize] ; ["Offset of field: _GTlsServerConnectionInterface::g_iface"] [:: std :: mem :: offset_of ! (_GTlsServerConnectionInterface , g_iface) - 0usize] ; } ; unsafe extern "C" { pub fn g_tls_server_connection_get_type () -> GType ; } unsafe extern "C" { pub fn g_tls_server_connection_new (base_io_stream : * mut GIOStream , certificate : * mut GTlsCertificate , error : * mut * mut GError) -> * mut GIOStream ; } pub type GUnixConnection = _GUnixConnection ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GUnixConnectionPrivate { _unused : [u8 ; 0] , } pub type GUnixConnectionPrivate = _GUnixConnectionPrivate ; pub type GUnixConnectionClass = _GUnixConnectionClass ; pub type GUnixConnection_autoptr = * mut GUnixConnection ; pub type GUnixConnection_listautoptr = * mut GList ; pub type GUnixConnection_slistautoptr = * mut GSList ; pub type GUnixConnection_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GUnixConnectionClass { pub parent_class : GSocketConnectionClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GUnixConnectionClass"] [:: std :: mem :: size_of :: < _GUnixConnectionClass > () - 304usize] ; ["Alignment of _GUnixConnectionClass"] [:: std :: mem :: align_of :: < _GUnixConnectionClass > () - 8usize] ; ["Offset of field: _GUnixConnectionClass::parent_class"] [:: std :: mem :: offset_of ! (_GUnixConnectionClass , parent_class) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GUnixConnection { pub parent_instance : GSocketConnection , pub priv_ : * mut GUnixConnectionPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GUnixConnection"] [:: std :: mem :: size_of :: < _GUnixConnection > () - 48usize] ; ["Alignment of _GUnixConnection"] [:: std :: mem :: align_of :: < _GUnixConnection > () - 8usize] ; ["Offset of field: _GUnixConnection::parent_instance"] [:: std :: mem :: offset_of ! (_GUnixConnection , parent_instance) - 0usize] ; ["Offset of field: _GUnixConnection::priv_"] [:: std :: mem :: offset_of ! (_GUnixConnection , priv_) - 40usize] ; } ; unsafe extern "C" { pub fn g_unix_connection_get_type () -> GType ; } unsafe extern "C" { pub fn g_unix_connection_send_fd (connection : * mut GUnixConnection , fd : gint , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_unix_connection_receive_fd (connection : * mut GUnixConnection , cancellable : * mut GCancellable , error : * mut * mut GError) -> gint ; } unsafe extern "C" { pub fn g_unix_connection_send_credentials (connection : * mut GUnixConnection , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_unix_connection_send_credentials_async (connection : * mut GUnixConnection , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_unix_connection_send_credentials_finish (connection : * mut GUnixConnection , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_unix_connection_receive_credentials (connection : * mut GUnixConnection , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GCredentials ; } unsafe extern "C" { pub fn g_unix_connection_receive_credentials_async (connection : * mut GUnixConnection , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_unix_connection_receive_credentials_finish (connection : * mut GUnixConnection , result : * mut GAsyncResult , error : * mut * mut GError) -> * mut GCredentials ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GUnixCredentialsMessagePrivate { _unused : [u8 ; 0] , } pub type GUnixCredentialsMessagePrivate = _GUnixCredentialsMessagePrivate ; pub type GUnixCredentialsMessageClass = _GUnixCredentialsMessageClass ; pub type GUnixCredentialsMessage_autoptr = * mut GUnixCredentialsMessage ; pub type GUnixCredentialsMessage_listautoptr = * mut GList ; pub type GUnixCredentialsMessage_slistautoptr = * mut GSList ; pub type GUnixCredentialsMessage_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GUnixCredentialsMessageClass { pub parent_class : GSocketControlMessageClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GUnixCredentialsMessageClass"] [:: std :: mem :: size_of :: < _GUnixCredentialsMessageClass > () - 232usize] ; ["Alignment of _GUnixCredentialsMessageClass"] [:: std :: mem :: align_of :: < _GUnixCredentialsMessageClass > () - 8usize] ; ["Offset of field: _GUnixCredentialsMessageClass::parent_class"] [:: std :: mem :: offset_of ! (_GUnixCredentialsMessageClass , parent_class) - 0usize] ; ["Offset of field: _GUnixCredentialsMessageClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GUnixCredentialsMessageClass , _g_reserved1) - 216usize] ; ["Offset of field: _GUnixCredentialsMessageClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GUnixCredentialsMessageClass , _g_reserved2) - 224usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GUnixCredentialsMessage { pub parent_instance : GSocketControlMessage , pub priv_ : * mut GUnixCredentialsMessagePrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GUnixCredentialsMessage"] [:: std :: mem :: size_of :: < _GUnixCredentialsMessage > () - 40usize] ; ["Alignment of _GUnixCredentialsMessage"] [:: std :: mem :: align_of :: < _GUnixCredentialsMessage > () - 8usize] ; ["Offset of field: _GUnixCredentialsMessage::parent_instance"] [:: std :: mem :: offset_of ! (_GUnixCredentialsMessage , parent_instance) - 0usize] ; ["Offset of field: _GUnixCredentialsMessage::priv_"] [:: std :: mem :: offset_of ! (_GUnixCredentialsMessage , priv_) - 32usize] ; } ; unsafe extern "C" { pub fn g_unix_credentials_message_get_type () -> GType ; } unsafe extern "C" { pub fn g_unix_credentials_message_new () -> * mut GSocketControlMessage ; } unsafe extern "C" { pub fn g_unix_credentials_message_new_with_credentials (credentials : * mut GCredentials) -> * mut GSocketControlMessage ; } unsafe extern "C" { pub fn g_unix_credentials_message_get_credentials (message : * mut GUnixCredentialsMessage) -> * mut GCredentials ; } unsafe extern "C" { pub fn g_unix_credentials_message_is_supported () -> gboolean ; } pub type GUnixFDList_autoptr = * mut GUnixFDList ; pub type GUnixFDList_listautoptr = * mut GList ; pub type GUnixFDList_slistautoptr = * mut GSList ; pub type GUnixFDList_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GUnixFDListPrivate { _unused : [u8 ; 0] , } pub type GUnixFDListPrivate = _GUnixFDListPrivate ; pub type GUnixFDListClass = _GUnixFDListClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GUnixFDListClass { pub parent_class : GObjectClass , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GUnixFDListClass"] [:: std :: mem :: size_of :: < _GUnixFDListClass > () - 176usize] ; ["Alignment of _GUnixFDListClass"] [:: std :: mem :: align_of :: < _GUnixFDListClass > () - 8usize] ; ["Offset of field: _GUnixFDListClass::parent_class"] [:: std :: mem :: offset_of ! (_GUnixFDListClass , parent_class) - 0usize] ; ["Offset of field: _GUnixFDListClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GUnixFDListClass , _g_reserved1) - 136usize] ; ["Offset of field: _GUnixFDListClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GUnixFDListClass , _g_reserved2) - 144usize] ; ["Offset of field: _GUnixFDListClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GUnixFDListClass , _g_reserved3) - 152usize] ; ["Offset of field: _GUnixFDListClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GUnixFDListClass , _g_reserved4) - 160usize] ; ["Offset of field: _GUnixFDListClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GUnixFDListClass , _g_reserved5) - 168usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GUnixFDList { pub parent_instance : GObject , pub priv_ : * mut GUnixFDListPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GUnixFDList"] [:: std :: mem :: size_of :: < _GUnixFDList > () - 32usize] ; ["Alignment of _GUnixFDList"] [:: std :: mem :: align_of :: < _GUnixFDList > () - 8usize] ; ["Offset of field: _GUnixFDList::parent_instance"] [:: std :: mem :: offset_of ! (_GUnixFDList , parent_instance) - 0usize] ; ["Offset of field: _GUnixFDList::priv_"] [:: std :: mem :: offset_of ! (_GUnixFDList , priv_) - 24usize] ; } ; unsafe extern "C" { pub fn g_unix_fd_list_get_type () -> GType ; } unsafe extern "C" { pub fn g_unix_fd_list_new () -> * mut GUnixFDList ; } unsafe extern "C" { pub fn g_unix_fd_list_new_from_array (fds : * const gint , n_fds : gint) -> * mut GUnixFDList ; } unsafe extern "C" { pub fn g_unix_fd_list_append (list : * mut GUnixFDList , fd : gint , error : * mut * mut GError) -> gint ; } unsafe extern "C" { pub fn g_unix_fd_list_get_length (list : * mut GUnixFDList) -> gint ; } unsafe extern "C" { pub fn g_unix_fd_list_get (list : * mut GUnixFDList , index_ : gint , error : * mut * mut GError) -> gint ; } unsafe extern "C" { pub fn g_unix_fd_list_peek_fds (list : * mut GUnixFDList , length : * mut gint) -> * const gint ; } unsafe extern "C" { pub fn g_unix_fd_list_steal_fds (list : * mut GUnixFDList , length : * mut gint) -> * mut gint ; } pub type GUnixSocketAddress = _GUnixSocketAddress ; pub type GUnixSocketAddressClass = _GUnixSocketAddressClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GUnixSocketAddressPrivate { _unused : [u8 ; 0] , } pub type GUnixSocketAddressPrivate = _GUnixSocketAddressPrivate ; pub type GUnixSocketAddress_autoptr = * mut GUnixSocketAddress ; pub type GUnixSocketAddress_listautoptr = * mut GList ; pub type GUnixSocketAddress_slistautoptr = * mut GSList ; pub type GUnixSocketAddress_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GUnixSocketAddress { pub parent_instance : GSocketAddress , pub priv_ : * mut GUnixSocketAddressPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GUnixSocketAddress"] [:: std :: mem :: size_of :: < _GUnixSocketAddress > () - 32usize] ; ["Alignment of _GUnixSocketAddress"] [:: std :: mem :: align_of :: < _GUnixSocketAddress > () - 8usize] ; ["Offset of field: _GUnixSocketAddress::parent_instance"] [:: std :: mem :: offset_of ! (_GUnixSocketAddress , parent_instance) - 0usize] ; ["Offset of field: _GUnixSocketAddress::priv_"] [:: std :: mem :: offset_of ! (_GUnixSocketAddress , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GUnixSocketAddressClass { pub parent_class : GSocketAddressClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GUnixSocketAddressClass"] [:: std :: mem :: size_of :: < _GUnixSocketAddressClass > () - 160usize] ; ["Alignment of _GUnixSocketAddressClass"] [:: std :: mem :: align_of :: < _GUnixSocketAddressClass > () - 8usize] ; ["Offset of field: _GUnixSocketAddressClass::parent_class"] [:: std :: mem :: offset_of ! (_GUnixSocketAddressClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn g_unix_socket_address_get_type () -> GType ; } unsafe extern "C" { pub fn g_unix_socket_address_new (path : * const gchar) -> * mut GSocketAddress ; } unsafe extern "C" { pub fn g_unix_socket_address_new_abstract (path : * const gchar , path_len : gint) -> * mut GSocketAddress ; } unsafe extern "C" { pub fn g_unix_socket_address_new_with_type (path : * const gchar , path_len : gint , type_ : GUnixSocketAddressType) -> * mut GSocketAddress ; } unsafe extern "C" { pub fn g_unix_socket_address_get_path (address : * mut GUnixSocketAddress) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_unix_socket_address_get_path_len (address : * mut GUnixSocketAddress) -> gsize ; } unsafe extern "C" { pub fn g_unix_socket_address_get_address_type (address : * mut GUnixSocketAddress) -> GUnixSocketAddressType ; } unsafe extern "C" { pub fn g_unix_socket_address_get_is_abstract (address : * mut GUnixSocketAddress) -> gboolean ; } unsafe extern "C" { pub fn g_unix_socket_address_abstract_names_supported () -> gboolean ; } pub type GVfsFileLookupFunc = :: std :: option :: Option < unsafe extern "C" fn (vfs : * mut GVfs , identifier : * const :: std :: os :: raw :: c_char , user_data : gpointer) -> * mut GFile > ; pub type GVfsClass = _GVfsClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GVfs { pub parent_instance : GObject , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GVfs"] [:: std :: mem :: size_of :: < _GVfs > () - 24usize] ; ["Alignment of _GVfs"] [:: std :: mem :: align_of :: < _GVfs > () - 8usize] ; ["Offset of field: _GVfs::parent_instance"] [:: std :: mem :: offset_of ! (_GVfs , parent_instance) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GVfsClass { pub parent_class : GObjectClass , pub is_active : :: std :: option :: Option < unsafe extern "C" fn (vfs : * mut GVfs) -> gboolean > , pub get_file_for_path : :: std :: option :: Option < unsafe extern "C" fn (vfs : * mut GVfs , path : * const :: std :: os :: raw :: c_char) -> * mut GFile > , pub get_file_for_uri : :: std :: option :: Option < unsafe extern "C" fn (vfs : * mut GVfs , uri : * const :: std :: os :: raw :: c_char) -> * mut GFile > , pub get_supported_uri_schemes : :: std :: option :: Option < unsafe extern "C" fn (vfs : * mut GVfs) -> * const * const gchar > , pub parse_name : :: std :: option :: Option < unsafe extern "C" fn (vfs : * mut GVfs , parse_name : * const :: std :: os :: raw :: c_char) -> * mut GFile > , pub local_file_add_info : :: std :: option :: Option < unsafe extern "C" fn (vfs : * mut GVfs , filename : * const :: std :: os :: raw :: c_char , device : guint64 , attribute_matcher : * mut GFileAttributeMatcher , info : * mut GFileInfo , cancellable : * mut GCancellable , extra_data : * mut gpointer , free_extra_data : * mut GDestroyNotify) > , pub add_writable_namespaces : :: std :: option :: Option < unsafe extern "C" fn (vfs : * mut GVfs , list : * mut GFileAttributeInfoList) > , pub local_file_set_attributes : :: std :: option :: Option < unsafe extern "C" fn (vfs : * mut GVfs , filename : * const :: std :: os :: raw :: c_char , info : * mut GFileInfo , flags : GFileQueryInfoFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean > , pub local_file_removed : :: std :: option :: Option < unsafe extern "C" fn (vfs : * mut GVfs , filename : * const :: std :: os :: raw :: c_char) > , pub local_file_moved : :: std :: option :: Option < unsafe extern "C" fn (vfs : * mut GVfs , source : * const :: std :: os :: raw :: c_char , dest : * const :: std :: os :: raw :: c_char) > , pub deserialize_icon : :: std :: option :: Option < unsafe extern "C" fn (vfs : * mut GVfs , value : * mut GVariant) -> * mut GIcon > , pub _g_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _g_reserved6 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GVfsClass"] [:: std :: mem :: size_of :: < _GVfsClass > () - 272usize] ; ["Alignment of _GVfsClass"] [:: std :: mem :: align_of :: < _GVfsClass > () - 8usize] ; ["Offset of field: _GVfsClass::parent_class"] [:: std :: mem :: offset_of ! (_GVfsClass , parent_class) - 0usize] ; ["Offset of field: _GVfsClass::is_active"] [:: std :: mem :: offset_of ! (_GVfsClass , is_active) - 136usize] ; ["Offset of field: _GVfsClass::get_file_for_path"] [:: std :: mem :: offset_of ! (_GVfsClass , get_file_for_path) - 144usize] ; ["Offset of field: _GVfsClass::get_file_for_uri"] [:: std :: mem :: offset_of ! (_GVfsClass , get_file_for_uri) - 152usize] ; ["Offset of field: _GVfsClass::get_supported_uri_schemes"] [:: std :: mem :: offset_of ! (_GVfsClass , get_supported_uri_schemes) - 160usize] ; ["Offset of field: _GVfsClass::parse_name"] [:: std :: mem :: offset_of ! (_GVfsClass , parse_name) - 168usize] ; ["Offset of field: _GVfsClass::local_file_add_info"] [:: std :: mem :: offset_of ! (_GVfsClass , local_file_add_info) - 176usize] ; ["Offset of field: _GVfsClass::add_writable_namespaces"] [:: std :: mem :: offset_of ! (_GVfsClass , add_writable_namespaces) - 184usize] ; ["Offset of field: _GVfsClass::local_file_set_attributes"] [:: std :: mem :: offset_of ! (_GVfsClass , local_file_set_attributes) - 192usize] ; ["Offset of field: _GVfsClass::local_file_removed"] [:: std :: mem :: offset_of ! (_GVfsClass , local_file_removed) - 200usize] ; ["Offset of field: _GVfsClass::local_file_moved"] [:: std :: mem :: offset_of ! (_GVfsClass , local_file_moved) - 208usize] ; ["Offset of field: _GVfsClass::deserialize_icon"] [:: std :: mem :: offset_of ! (_GVfsClass , deserialize_icon) - 216usize] ; ["Offset of field: _GVfsClass::_g_reserved1"] [:: std :: mem :: offset_of ! (_GVfsClass , _g_reserved1) - 224usize] ; ["Offset of field: _GVfsClass::_g_reserved2"] [:: std :: mem :: offset_of ! (_GVfsClass , _g_reserved2) - 232usize] ; ["Offset of field: _GVfsClass::_g_reserved3"] [:: std :: mem :: offset_of ! (_GVfsClass , _g_reserved3) - 240usize] ; ["Offset of field: _GVfsClass::_g_reserved4"] [:: std :: mem :: offset_of ! (_GVfsClass , _g_reserved4) - 248usize] ; ["Offset of field: _GVfsClass::_g_reserved5"] [:: std :: mem :: offset_of ! (_GVfsClass , _g_reserved5) - 256usize] ; ["Offset of field: _GVfsClass::_g_reserved6"] [:: std :: mem :: offset_of ! (_GVfsClass , _g_reserved6) - 264usize] ; } ; unsafe extern "C" { pub fn g_vfs_get_type () -> GType ; } unsafe extern "C" { pub fn g_vfs_is_active (vfs : * mut GVfs) -> gboolean ; } unsafe extern "C" { pub fn g_vfs_get_file_for_path (vfs : * mut GVfs , path : * const :: std :: os :: raw :: c_char) -> * mut GFile ; } unsafe extern "C" { pub fn g_vfs_get_file_for_uri (vfs : * mut GVfs , uri : * const :: std :: os :: raw :: c_char) -> * mut GFile ; } unsafe extern "C" { pub fn g_vfs_get_supported_uri_schemes (vfs : * mut GVfs) -> * const * const gchar ; } unsafe extern "C" { pub fn g_vfs_parse_name (vfs : * mut GVfs , parse_name : * const :: std :: os :: raw :: c_char) -> * mut GFile ; } unsafe extern "C" { pub fn g_vfs_get_default () -> * mut GVfs ; } unsafe extern "C" { pub fn g_vfs_get_local () -> * mut GVfs ; } unsafe extern "C" { pub fn g_vfs_register_uri_scheme (vfs : * mut GVfs , scheme : * const :: std :: os :: raw :: c_char , uri_func : GVfsFileLookupFunc , uri_data : gpointer , uri_destroy : GDestroyNotify , parse_name_func : GVfsFileLookupFunc , parse_name_data : gpointer , parse_name_destroy : GDestroyNotify) -> gboolean ; } unsafe extern "C" { pub fn g_vfs_unregister_uri_scheme (vfs : * mut GVfs , scheme : * const :: std :: os :: raw :: c_char) -> gboolean ; } pub type GVolumeIface = _GVolumeIface ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GVolumeIface { pub g_iface : GTypeInterface , pub changed : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume) > , pub removed : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume) > , pub get_name : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume) -> * mut :: std :: os :: raw :: c_char > , pub get_icon : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume) -> * mut GIcon > , pub get_uuid : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume) -> * mut :: std :: os :: raw :: c_char > , pub get_drive : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume) -> * mut GDrive > , pub get_mount : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume) -> * mut GMount > , pub can_mount : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume) -> gboolean > , pub can_eject : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume) -> gboolean > , pub mount_fn : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume , flags : GMountMountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub mount_finish : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub eject : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume , flags : GMountUnmountFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub eject_finish : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub get_identifier : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume , kind : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char > , pub enumerate_identifiers : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume) -> * mut * mut :: std :: os :: raw :: c_char > , pub should_automount : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume) -> gboolean > , pub get_activation_root : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume) -> * mut GFile > , pub eject_with_operation : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) > , pub eject_with_operation_finish : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean > , pub get_sort_key : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume) -> * const gchar > , pub get_symbolic_icon : :: std :: option :: Option < unsafe extern "C" fn (volume : * mut GVolume) -> * mut GIcon > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GVolumeIface"] [:: std :: mem :: size_of :: < _GVolumeIface > () - 184usize] ; ["Alignment of _GVolumeIface"] [:: std :: mem :: align_of :: < _GVolumeIface > () - 8usize] ; ["Offset of field: _GVolumeIface::g_iface"] [:: std :: mem :: offset_of ! (_GVolumeIface , g_iface) - 0usize] ; ["Offset of field: _GVolumeIface::changed"] [:: std :: mem :: offset_of ! (_GVolumeIface , changed) - 16usize] ; ["Offset of field: _GVolumeIface::removed"] [:: std :: mem :: offset_of ! (_GVolumeIface , removed) - 24usize] ; ["Offset of field: _GVolumeIface::get_name"] [:: std :: mem :: offset_of ! (_GVolumeIface , get_name) - 32usize] ; ["Offset of field: _GVolumeIface::get_icon"] [:: std :: mem :: offset_of ! (_GVolumeIface , get_icon) - 40usize] ; ["Offset of field: _GVolumeIface::get_uuid"] [:: std :: mem :: offset_of ! (_GVolumeIface , get_uuid) - 48usize] ; ["Offset of field: _GVolumeIface::get_drive"] [:: std :: mem :: offset_of ! (_GVolumeIface , get_drive) - 56usize] ; ["Offset of field: _GVolumeIface::get_mount"] [:: std :: mem :: offset_of ! (_GVolumeIface , get_mount) - 64usize] ; ["Offset of field: _GVolumeIface::can_mount"] [:: std :: mem :: offset_of ! (_GVolumeIface , can_mount) - 72usize] ; ["Offset of field: _GVolumeIface::can_eject"] [:: std :: mem :: offset_of ! (_GVolumeIface , can_eject) - 80usize] ; ["Offset of field: _GVolumeIface::mount_fn"] [:: std :: mem :: offset_of ! (_GVolumeIface , mount_fn) - 88usize] ; ["Offset of field: _GVolumeIface::mount_finish"] [:: std :: mem :: offset_of ! (_GVolumeIface , mount_finish) - 96usize] ; ["Offset of field: _GVolumeIface::eject"] [:: std :: mem :: offset_of ! (_GVolumeIface , eject) - 104usize] ; ["Offset of field: _GVolumeIface::eject_finish"] [:: std :: mem :: offset_of ! (_GVolumeIface , eject_finish) - 112usize] ; ["Offset of field: _GVolumeIface::get_identifier"] [:: std :: mem :: offset_of ! (_GVolumeIface , get_identifier) - 120usize] ; ["Offset of field: _GVolumeIface::enumerate_identifiers"] [:: std :: mem :: offset_of ! (_GVolumeIface , enumerate_identifiers) - 128usize] ; ["Offset of field: _GVolumeIface::should_automount"] [:: std :: mem :: offset_of ! (_GVolumeIface , should_automount) - 136usize] ; ["Offset of field: _GVolumeIface::get_activation_root"] [:: std :: mem :: offset_of ! (_GVolumeIface , get_activation_root) - 144usize] ; ["Offset of field: _GVolumeIface::eject_with_operation"] [:: std :: mem :: offset_of ! (_GVolumeIface , eject_with_operation) - 152usize] ; ["Offset of field: _GVolumeIface::eject_with_operation_finish"] [:: std :: mem :: offset_of ! (_GVolumeIface , eject_with_operation_finish) - 160usize] ; ["Offset of field: _GVolumeIface::get_sort_key"] [:: std :: mem :: offset_of ! (_GVolumeIface , get_sort_key) - 168usize] ; ["Offset of field: _GVolumeIface::get_symbolic_icon"] [:: std :: mem :: offset_of ! (_GVolumeIface , get_symbolic_icon) - 176usize] ; } ; unsafe extern "C" { pub fn g_volume_get_type () -> GType ; } unsafe extern "C" { pub fn g_volume_get_name (volume : * mut GVolume) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_volume_get_icon (volume : * mut GVolume) -> * mut GIcon ; } unsafe extern "C" { pub fn g_volume_get_symbolic_icon (volume : * mut GVolume) -> * mut GIcon ; } unsafe extern "C" { pub fn g_volume_get_uuid (volume : * mut GVolume) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_volume_get_drive (volume : * mut GVolume) -> * mut GDrive ; } unsafe extern "C" { pub fn g_volume_get_mount (volume : * mut GVolume) -> * mut GMount ; } unsafe extern "C" { pub fn g_volume_can_mount (volume : * mut GVolume) -> gboolean ; } unsafe extern "C" { pub fn g_volume_can_eject (volume : * mut GVolume) -> gboolean ; } unsafe extern "C" { pub fn g_volume_should_automount (volume : * mut GVolume) -> gboolean ; } unsafe extern "C" { pub fn g_volume_mount (volume : * mut GVolume , flags : GMountMountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_volume_mount_finish (volume : * mut GVolume , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_volume_eject (volume : * mut GVolume , flags : GMountUnmountFlags , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_volume_eject_finish (volume : * mut GVolume , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_volume_get_identifier (volume : * mut GVolume , kind : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_volume_enumerate_identifiers (volume : * mut GVolume) -> * mut * mut :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn g_volume_get_activation_root (volume : * mut GVolume) -> * mut GFile ; } unsafe extern "C" { pub fn g_volume_eject_with_operation (volume : * mut GVolume , flags : GMountUnmountFlags , mount_operation : * mut GMountOperation , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn g_volume_eject_with_operation_finish (volume : * mut GVolume , result : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn g_volume_get_sort_key (volume : * mut GVolume) -> * const gchar ; } pub type GZlibCompressorClass = _GZlibCompressorClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GZlibCompressorClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GZlibCompressorClass"] [:: std :: mem :: size_of :: < _GZlibCompressorClass > () - 136usize] ; ["Alignment of _GZlibCompressorClass"] [:: std :: mem :: align_of :: < _GZlibCompressorClass > () - 8usize] ; ["Offset of field: _GZlibCompressorClass::parent_class"] [:: std :: mem :: offset_of ! (_GZlibCompressorClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn g_zlib_compressor_get_type () -> GType ; } unsafe extern "C" { pub fn g_zlib_compressor_new (format : GZlibCompressorFormat , level : :: std :: os :: raw :: c_int) -> * mut GZlibCompressor ; } unsafe extern "C" { pub fn g_zlib_compressor_get_file_info (compressor : * mut GZlibCompressor) -> * mut GFileInfo ; } unsafe extern "C" { pub fn g_zlib_compressor_set_file_info (compressor : * mut GZlibCompressor , file_info : * mut GFileInfo) ; } pub type GZlibDecompressorClass = _GZlibDecompressorClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _GZlibDecompressorClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _GZlibDecompressorClass"] [:: std :: mem :: size_of :: < _GZlibDecompressorClass > () - 136usize] ; ["Alignment of _GZlibDecompressorClass"] [:: std :: mem :: align_of :: < _GZlibDecompressorClass > () - 8usize] ; ["Offset of field: _GZlibDecompressorClass::parent_class"] [:: std :: mem :: offset_of ! (_GZlibDecompressorClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn g_zlib_decompressor_get_type () -> GType ; } unsafe extern "C" { pub fn g_zlib_decompressor_new (format : GZlibCompressorFormat) -> * mut GZlibDecompressor ; } unsafe extern "C" { pub fn g_zlib_decompressor_get_file_info (decompressor : * mut GZlibDecompressor) -> * mut GFileInfo ; } pub type GAction_autoptr = * mut GAction ; pub type GAction_listautoptr = * mut GList ; pub type GAction_slistautoptr = * mut GSList ; pub type GAction_queueautoptr = * mut GQueue ; pub type GActionMap_autoptr = * mut GActionMap ; pub type GActionMap_listautoptr = * mut GList ; pub type GActionMap_slistautoptr = * mut GSList ; pub type GActionMap_queueautoptr = * mut GQueue ; pub type GAppInfo_autoptr = * mut GAppInfo ; pub type GAppInfo_listautoptr = * mut GList ; pub type GAppInfo_slistautoptr = * mut GSList ; pub type GAppInfo_queueautoptr = * mut GQueue ; pub type GAppLaunchContext_autoptr = * mut GAppLaunchContext ; pub type GAppLaunchContext_listautoptr = * mut GList ; pub type GAppLaunchContext_slistautoptr = * mut GSList ; pub type GAppLaunchContext_queueautoptr = * mut GQueue ; pub type GAppInfoMonitor_autoptr = * mut GAppInfoMonitor ; pub type GAppInfoMonitor_listautoptr = * mut GList ; pub type GAppInfoMonitor_slistautoptr = * mut GSList ; pub type GAppInfoMonitor_queueautoptr = * mut GQueue ; pub type GApplicationCommandLine_autoptr = * mut GApplicationCommandLine ; pub type GApplicationCommandLine_listautoptr = * mut GList ; pub type GApplicationCommandLine_slistautoptr = * mut GSList ; pub type GApplicationCommandLine_queueautoptr = * mut GQueue ; pub type GApplication_autoptr = * mut GApplication ; pub type GApplication_listautoptr = * mut GList ; pub type GApplication_slistautoptr = * mut GSList ; pub type GApplication_queueautoptr = * mut GQueue ; pub type GAsyncInitable_autoptr = * mut GAsyncInitable ; pub type GAsyncInitable_listautoptr = * mut GList ; pub type GAsyncInitable_slistautoptr = * mut GSList ; pub type GAsyncInitable_queueautoptr = * mut GQueue ; pub type GAsyncResult_autoptr = * mut GAsyncResult ; pub type GAsyncResult_listautoptr = * mut GList ; pub type GAsyncResult_slistautoptr = * mut GSList ; pub type GAsyncResult_queueautoptr = * mut GQueue ; pub type GBufferedInputStream_autoptr = * mut GBufferedInputStream ; pub type GBufferedInputStream_listautoptr = * mut GList ; pub type GBufferedInputStream_slistautoptr = * mut GSList ; pub type GBufferedInputStream_queueautoptr = * mut GQueue ; pub type GBufferedOutputStream_autoptr = * mut GBufferedOutputStream ; pub type GBufferedOutputStream_listautoptr = * mut GList ; pub type GBufferedOutputStream_slistautoptr = * mut GSList ; pub type GBufferedOutputStream_queueautoptr = * mut GQueue ; pub type GBytesIcon_autoptr = * mut GBytesIcon ; pub type GBytesIcon_listautoptr = * mut GList ; pub type GBytesIcon_slistautoptr = * mut GSList ; pub type GBytesIcon_queueautoptr = * mut GQueue ; pub type GCancellable_autoptr = * mut GCancellable ; pub type GCancellable_listautoptr = * mut GList ; pub type GCancellable_slistautoptr = * mut GSList ; pub type GCancellable_queueautoptr = * mut GQueue ; pub type GCharsetConverter_autoptr = * mut GCharsetConverter ; pub type GCharsetConverter_listautoptr = * mut GList ; pub type GCharsetConverter_slistautoptr = * mut GSList ; pub type GCharsetConverter_queueautoptr = * mut GQueue ; pub type GConverter_autoptr = * mut GConverter ; pub type GConverter_listautoptr = * mut GList ; pub type GConverter_slistautoptr = * mut GSList ; pub type GConverter_queueautoptr = * mut GQueue ; pub type GConverterInputStream_autoptr = * mut GConverterInputStream ; pub type GConverterInputStream_listautoptr = * mut GList ; pub type GConverterInputStream_slistautoptr = * mut GSList ; pub type GConverterInputStream_queueautoptr = * mut GQueue ; pub type GConverterOutputStream_autoptr = * mut GConverterOutputStream ; pub type GConverterOutputStream_listautoptr = * mut GList ; pub type GConverterOutputStream_slistautoptr = * mut GSList ; pub type GConverterOutputStream_queueautoptr = * mut GQueue ; pub type GCredentials_autoptr = * mut GCredentials ; pub type GCredentials_listautoptr = * mut GList ; pub type GCredentials_slistautoptr = * mut GSList ; pub type GCredentials_queueautoptr = * mut GQueue ; pub type GDatagramBased_autoptr = * mut GDatagramBased ; pub type GDatagramBased_listautoptr = * mut GList ; pub type GDatagramBased_slistautoptr = * mut GSList ; pub type GDatagramBased_queueautoptr = * mut GQueue ; pub type GDataInputStream_autoptr = * mut GDataInputStream ; pub type GDataInputStream_listautoptr = * mut GList ; pub type GDataInputStream_slistautoptr = * mut GSList ; pub type GDataInputStream_queueautoptr = * mut GQueue ; pub type GDataOutputStream_autoptr = * mut GDataOutputStream ; pub type GDataOutputStream_listautoptr = * mut GList ; pub type GDataOutputStream_slistautoptr = * mut GSList ; pub type GDataOutputStream_queueautoptr = * mut GQueue ; pub type GDBusActionGroup_autoptr = * mut GDBusActionGroup ; pub type GDBusActionGroup_listautoptr = * mut GList ; pub type GDBusActionGroup_slistautoptr = * mut GSList ; pub type GDBusActionGroup_queueautoptr = * mut GQueue ; pub type GDBusAuthObserver_autoptr = * mut GDBusAuthObserver ; pub type GDBusAuthObserver_listautoptr = * mut GList ; pub type GDBusAuthObserver_slistautoptr = * mut GSList ; pub type GDBusAuthObserver_queueautoptr = * mut GQueue ; pub type GDBusConnection_autoptr = * mut GDBusConnection ; pub type GDBusConnection_listautoptr = * mut GList ; pub type GDBusConnection_slistautoptr = * mut GSList ; pub type GDBusConnection_queueautoptr = * mut GQueue ; pub type GDBusInterface_autoptr = * mut GDBusInterface ; pub type GDBusInterface_listautoptr = * mut GList ; pub type GDBusInterface_slistautoptr = * mut GSList ; pub type GDBusInterface_queueautoptr = * mut GQueue ; pub type GDBusInterfaceSkeleton_autoptr = * mut GDBusInterfaceSkeleton ; pub type GDBusInterfaceSkeleton_listautoptr = * mut GList ; pub type GDBusInterfaceSkeleton_slistautoptr = * mut GSList ; pub type GDBusInterfaceSkeleton_queueautoptr = * mut GQueue ; pub type GDBusMenuModel_autoptr = * mut GDBusMenuModel ; pub type GDBusMenuModel_listautoptr = * mut GList ; pub type GDBusMenuModel_slistautoptr = * mut GSList ; pub type GDBusMenuModel_queueautoptr = * mut GQueue ; pub type GDBusMessage_autoptr = * mut GDBusMessage ; pub type GDBusMessage_listautoptr = * mut GList ; pub type GDBusMessage_slistautoptr = * mut GSList ; pub type GDBusMessage_queueautoptr = * mut GQueue ; pub type GDBusMethodInvocation_autoptr = * mut GDBusMethodInvocation ; pub type GDBusMethodInvocation_listautoptr = * mut GList ; pub type GDBusMethodInvocation_slistautoptr = * mut GSList ; pub type GDBusMethodInvocation_queueautoptr = * mut GQueue ; pub type GDBusNodeInfo_autoptr = * mut GDBusNodeInfo ; pub type GDBusNodeInfo_listautoptr = * mut GList ; pub type GDBusNodeInfo_slistautoptr = * mut GSList ; pub type GDBusNodeInfo_queueautoptr = * mut GQueue ; pub type GDBusObject_autoptr = * mut GDBusObject ; pub type GDBusObject_listautoptr = * mut GList ; pub type GDBusObject_slistautoptr = * mut GSList ; pub type GDBusObject_queueautoptr = * mut GQueue ; pub type GDBusObjectManagerClient_autoptr = * mut GDBusObjectManagerClient ; pub type GDBusObjectManagerClient_listautoptr = * mut GList ; pub type GDBusObjectManagerClient_slistautoptr = * mut GSList ; pub type GDBusObjectManagerClient_queueautoptr = * mut GQueue ; pub type GDBusObjectManager_autoptr = * mut GDBusObjectManager ; pub type GDBusObjectManager_listautoptr = * mut GList ; pub type GDBusObjectManager_slistautoptr = * mut GSList ; pub type GDBusObjectManager_queueautoptr = * mut GQueue ; pub type GDBusObjectManagerServer_autoptr = * mut GDBusObjectManagerServer ; pub type GDBusObjectManagerServer_listautoptr = * mut GList ; pub type GDBusObjectManagerServer_slistautoptr = * mut GSList ; pub type GDBusObjectManagerServer_queueautoptr = * mut GQueue ; pub type GDBusObjectProxy_autoptr = * mut GDBusObjectProxy ; pub type GDBusObjectProxy_listautoptr = * mut GList ; pub type GDBusObjectProxy_slistautoptr = * mut GSList ; pub type GDBusObjectProxy_queueautoptr = * mut GQueue ; pub type GDBusObjectSkeleton_autoptr = * mut GDBusObjectSkeleton ; pub type GDBusObjectSkeleton_listautoptr = * mut GList ; pub type GDBusObjectSkeleton_slistautoptr = * mut GSList ; pub type GDBusObjectSkeleton_queueautoptr = * mut GQueue ; pub type GDBusProxy_autoptr = * mut GDBusProxy ; pub type GDBusProxy_listautoptr = * mut GList ; pub type GDBusProxy_slistautoptr = * mut GSList ; pub type GDBusProxy_queueautoptr = * mut GQueue ; pub type GDBusServer_autoptr = * mut GDBusServer ; pub type GDBusServer_listautoptr = * mut GList ; pub type GDBusServer_slistautoptr = * mut GSList ; pub type GDBusServer_queueautoptr = * mut GQueue ; pub type GDrive_autoptr = * mut GDrive ; pub type GDrive_listautoptr = * mut GList ; pub type GDrive_slistautoptr = * mut GSList ; pub type GDrive_queueautoptr = * mut GQueue ; pub type GEmblemedIcon_autoptr = * mut GEmblemedIcon ; pub type GEmblemedIcon_listautoptr = * mut GList ; pub type GEmblemedIcon_slistautoptr = * mut GSList ; pub type GEmblemedIcon_queueautoptr = * mut GQueue ; pub type GEmblem_autoptr = * mut GEmblem ; pub type GEmblem_listautoptr = * mut GList ; pub type GEmblem_slistautoptr = * mut GSList ; pub type GEmblem_queueautoptr = * mut GQueue ; pub type GFileEnumerator_autoptr = * mut GFileEnumerator ; pub type GFileEnumerator_listautoptr = * mut GList ; pub type GFileEnumerator_slistautoptr = * mut GSList ; pub type GFileEnumerator_queueautoptr = * mut GQueue ; pub type GFile_autoptr = * mut GFile ; pub type GFile_listautoptr = * mut GList ; pub type GFile_slistautoptr = * mut GSList ; pub type GFile_queueautoptr = * mut GQueue ; pub type GFileAttributeInfoList_autoptr = * mut GFileAttributeInfoList ; pub type GFileAttributeInfoList_listautoptr = * mut GList ; pub type GFileAttributeInfoList_slistautoptr = * mut GSList ; pub type GFileAttributeInfoList_queueautoptr = * mut GQueue ; pub type GFileIcon_autoptr = * mut GFileIcon ; pub type GFileIcon_listautoptr = * mut GList ; pub type GFileIcon_slistautoptr = * mut GSList ; pub type GFileIcon_queueautoptr = * mut GQueue ; pub type GFileInfo_autoptr = * mut GFileInfo ; pub type GFileInfo_listautoptr = * mut GList ; pub type GFileInfo_slistautoptr = * mut GSList ; pub type GFileInfo_queueautoptr = * mut GQueue ; pub type GFileInputStream_autoptr = * mut GFileInputStream ; pub type GFileInputStream_listautoptr = * mut GList ; pub type GFileInputStream_slistautoptr = * mut GSList ; pub type GFileInputStream_queueautoptr = * mut GQueue ; pub type GFileIOStream_autoptr = * mut GFileIOStream ; pub type GFileIOStream_listautoptr = * mut GList ; pub type GFileIOStream_slistautoptr = * mut GSList ; pub type GFileIOStream_queueautoptr = * mut GQueue ; pub type GFileMonitor_autoptr = * mut GFileMonitor ; pub type GFileMonitor_listautoptr = * mut GList ; pub type GFileMonitor_slistautoptr = * mut GSList ; pub type GFileMonitor_queueautoptr = * mut GQueue ; pub type GFilenameCompleter_autoptr = * mut GFilenameCompleter ; pub type GFilenameCompleter_listautoptr = * mut GList ; pub type GFilenameCompleter_slistautoptr = * mut GSList ; pub type GFilenameCompleter_queueautoptr = * mut GQueue ; pub type GFileOutputStream_autoptr = * mut GFileOutputStream ; pub type GFileOutputStream_listautoptr = * mut GList ; pub type GFileOutputStream_slistautoptr = * mut GSList ; pub type GFileOutputStream_queueautoptr = * mut GQueue ; pub type GFilterInputStream_autoptr = * mut GFilterInputStream ; pub type GFilterInputStream_listautoptr = * mut GList ; pub type GFilterInputStream_slistautoptr = * mut GSList ; pub type GFilterInputStream_queueautoptr = * mut GQueue ; pub type GFilterOutputStream_autoptr = * mut GFilterOutputStream ; pub type GFilterOutputStream_listautoptr = * mut GList ; pub type GFilterOutputStream_slistautoptr = * mut GSList ; pub type GFilterOutputStream_queueautoptr = * mut GQueue ; pub type GIcon_autoptr = * mut GIcon ; pub type GIcon_listautoptr = * mut GList ; pub type GIcon_slistautoptr = * mut GSList ; pub type GIcon_queueautoptr = * mut GQueue ; pub type GInetAddress_autoptr = * mut GInetAddress ; pub type GInetAddress_listautoptr = * mut GList ; pub type GInetAddress_slistautoptr = * mut GSList ; pub type GInetAddress_queueautoptr = * mut GQueue ; pub type GInetAddressMask_autoptr = * mut GInetAddressMask ; pub type GInetAddressMask_listautoptr = * mut GList ; pub type GInetAddressMask_slistautoptr = * mut GSList ; pub type GInetAddressMask_queueautoptr = * mut GQueue ; pub type GInetSocketAddress_autoptr = * mut GInetSocketAddress ; pub type GInetSocketAddress_listautoptr = * mut GList ; pub type GInetSocketAddress_slistautoptr = * mut GSList ; pub type GInetSocketAddress_queueautoptr = * mut GQueue ; pub type GInitable_autoptr = * mut GInitable ; pub type GInitable_listautoptr = * mut GList ; pub type GInitable_slistautoptr = * mut GSList ; pub type GInitable_queueautoptr = * mut GQueue ; pub type GInputStream_autoptr = * mut GInputStream ; pub type GInputStream_listautoptr = * mut GList ; pub type GInputStream_slistautoptr = * mut GSList ; pub type GInputStream_queueautoptr = * mut GQueue ; pub type GIOModule_autoptr = * mut GIOModule ; pub type GIOModule_listautoptr = * mut GList ; pub type GIOModule_slistautoptr = * mut GSList ; pub type GIOModule_queueautoptr = * mut GQueue ; pub type GIOStream_autoptr = * mut GIOStream ; pub type GIOStream_listautoptr = * mut GList ; pub type GIOStream_slistautoptr = * mut GSList ; pub type GIOStream_queueautoptr = * mut GQueue ; pub type GLoadableIcon_autoptr = * mut GLoadableIcon ; pub type GLoadableIcon_listautoptr = * mut GList ; pub type GLoadableIcon_slistautoptr = * mut GSList ; pub type GLoadableIcon_queueautoptr = * mut GQueue ; pub type GMemoryInputStream_autoptr = * mut GMemoryInputStream ; pub type GMemoryInputStream_listautoptr = * mut GList ; pub type GMemoryInputStream_slistautoptr = * mut GSList ; pub type GMemoryInputStream_queueautoptr = * mut GQueue ; pub type GMemoryOutputStream_autoptr = * mut GMemoryOutputStream ; pub type GMemoryOutputStream_listautoptr = * mut GList ; pub type GMemoryOutputStream_slistautoptr = * mut GSList ; pub type GMemoryOutputStream_queueautoptr = * mut GQueue ; pub type GMenu_autoptr = * mut GMenu ; pub type GMenu_listautoptr = * mut GList ; pub type GMenu_slistautoptr = * mut GSList ; pub type GMenu_queueautoptr = * mut GQueue ; pub type GMenuItem_autoptr = * mut GMenuItem ; pub type GMenuItem_listautoptr = * mut GList ; pub type GMenuItem_slistautoptr = * mut GSList ; pub type GMenuItem_queueautoptr = * mut GQueue ; pub type GMenuModel_autoptr = * mut GMenuModel ; pub type GMenuModel_listautoptr = * mut GList ; pub type GMenuModel_slistautoptr = * mut GSList ; pub type GMenuModel_queueautoptr = * mut GQueue ; pub type GMenuAttributeIter_autoptr = * mut GMenuAttributeIter ; pub type GMenuAttributeIter_listautoptr = * mut GList ; pub type GMenuAttributeIter_slistautoptr = * mut GSList ; pub type GMenuAttributeIter_queueautoptr = * mut GQueue ; pub type GMenuLinkIter_autoptr = * mut GMenuLinkIter ; pub type GMenuLinkIter_listautoptr = * mut GList ; pub type GMenuLinkIter_slistautoptr = * mut GSList ; pub type GMenuLinkIter_queueautoptr = * mut GQueue ; pub type GMount_autoptr = * mut GMount ; pub type GMount_listautoptr = * mut GList ; pub type GMount_slistautoptr = * mut GSList ; pub type GMount_queueautoptr = * mut GQueue ; pub type GMountOperation_autoptr = * mut GMountOperation ; pub type GMountOperation_listautoptr = * mut GList ; pub type GMountOperation_slistautoptr = * mut GSList ; pub type GMountOperation_queueautoptr = * mut GQueue ; pub type GNativeVolumeMonitor_autoptr = * mut GNativeVolumeMonitor ; pub type GNativeVolumeMonitor_listautoptr = * mut GList ; pub type GNativeVolumeMonitor_slistautoptr = * mut GSList ; pub type GNativeVolumeMonitor_queueautoptr = * mut GQueue ; pub type GNetworkAddress_autoptr = * mut GNetworkAddress ; pub type GNetworkAddress_listautoptr = * mut GList ; pub type GNetworkAddress_slistautoptr = * mut GSList ; pub type GNetworkAddress_queueautoptr = * mut GQueue ; pub type GNetworkMonitor_autoptr = * mut GNetworkMonitor ; pub type GNetworkMonitor_listautoptr = * mut GList ; pub type GNetworkMonitor_slistautoptr = * mut GSList ; pub type GNetworkMonitor_queueautoptr = * mut GQueue ; pub type GNetworkService_autoptr = * mut GNetworkService ; pub type GNetworkService_listautoptr = * mut GList ; pub type GNetworkService_slistautoptr = * mut GSList ; pub type GNetworkService_queueautoptr = * mut GQueue ; pub type GNotification_autoptr = * mut GNotification ; pub type GNotification_listautoptr = * mut GList ; pub type GNotification_slistautoptr = * mut GSList ; pub type GNotification_queueautoptr = * mut GQueue ; pub type GOutputStream_autoptr = * mut GOutputStream ; pub type GOutputStream_listautoptr = * mut GList ; pub type GOutputStream_slistautoptr = * mut GSList ; pub type GOutputStream_queueautoptr = * mut GQueue ; pub type GPermission_autoptr = * mut GPermission ; pub type GPermission_listautoptr = * mut GList ; pub type GPermission_slistautoptr = * mut GSList ; pub type GPermission_queueautoptr = * mut GQueue ; pub type GPollableInputStream_autoptr = * mut GPollableInputStream ; pub type GPollableInputStream_listautoptr = * mut GList ; pub type GPollableInputStream_slistautoptr = * mut GSList ; pub type GPollableInputStream_queueautoptr = * mut GQueue ; pub type GPollableOutputStream_autoptr = * mut GPollableOutputStream ; pub type GPollableOutputStream_listautoptr = * mut GList ; pub type GPollableOutputStream_slistautoptr = * mut GSList ; pub type GPollableOutputStream_queueautoptr = * mut GQueue ; pub type GPropertyAction_autoptr = * mut GPropertyAction ; pub type GPropertyAction_listautoptr = * mut GList ; pub type GPropertyAction_slistautoptr = * mut GSList ; pub type GPropertyAction_queueautoptr = * mut GQueue ; pub type GProxyAddressEnumerator_autoptr = * mut GProxyAddressEnumerator ; pub type GProxyAddressEnumerator_listautoptr = * mut GList ; pub type GProxyAddressEnumerator_slistautoptr = * mut GSList ; pub type GProxyAddressEnumerator_queueautoptr = * mut GQueue ; pub type GProxyAddress_autoptr = * mut GProxyAddress ; pub type GProxyAddress_listautoptr = * mut GList ; pub type GProxyAddress_slistautoptr = * mut GSList ; pub type GProxyAddress_queueautoptr = * mut GQueue ; pub type GProxy_autoptr = * mut GProxy ; pub type GProxy_listautoptr = * mut GList ; pub type GProxy_slistautoptr = * mut GSList ; pub type GProxy_queueautoptr = * mut GQueue ; pub type GProxyResolver_autoptr = * mut GProxyResolver ; pub type GProxyResolver_listautoptr = * mut GList ; pub type GProxyResolver_slistautoptr = * mut GSList ; pub type GProxyResolver_queueautoptr = * mut GQueue ; pub type GRemoteActionGroup_autoptr = * mut GRemoteActionGroup ; pub type GRemoteActionGroup_listautoptr = * mut GList ; pub type GRemoteActionGroup_slistautoptr = * mut GSList ; pub type GRemoteActionGroup_queueautoptr = * mut GQueue ; pub type GResolver_autoptr = * mut GResolver ; pub type GResolver_listautoptr = * mut GList ; pub type GResolver_slistautoptr = * mut GSList ; pub type GResolver_queueautoptr = * mut GQueue ; pub type GResource_autoptr = * mut GResource ; pub type GResource_listautoptr = * mut GList ; pub type GResource_slistautoptr = * mut GSList ; pub type GResource_queueautoptr = * mut GQueue ; pub type GSeekable_autoptr = * mut GSeekable ; pub type GSeekable_listautoptr = * mut GList ; pub type GSeekable_slistautoptr = * mut GSList ; pub type GSeekable_queueautoptr = * mut GQueue ; pub type GSettingsBackend_autoptr = * mut GSettingsBackend ; pub type GSettingsBackend_listautoptr = * mut GList ; pub type GSettingsBackend_slistautoptr = * mut GSList ; pub type GSettingsBackend_queueautoptr = * mut GQueue ; pub type GSettingsSchema_autoptr = * mut GSettingsSchema ; pub type GSettingsSchema_listautoptr = * mut GList ; pub type GSettingsSchema_slistautoptr = * mut GSList ; pub type GSettingsSchema_queueautoptr = * mut GQueue ; pub type GSettingsSchemaKey_autoptr = * mut GSettingsSchemaKey ; pub type GSettingsSchemaKey_listautoptr = * mut GList ; pub type GSettingsSchemaKey_slistautoptr = * mut GSList ; pub type GSettingsSchemaKey_queueautoptr = * mut GQueue ; pub type GSettingsSchemaSource_autoptr = * mut GSettingsSchemaSource ; pub type GSettingsSchemaSource_listautoptr = * mut GList ; pub type GSettingsSchemaSource_slistautoptr = * mut GSList ; pub type GSettingsSchemaSource_queueautoptr = * mut GQueue ; pub type GSettings_autoptr = * mut GSettings ; pub type GSettings_listautoptr = * mut GList ; pub type GSettings_slistautoptr = * mut GSList ; pub type GSettings_queueautoptr = * mut GQueue ; pub type GSimpleActionGroup_autoptr = * mut GSimpleActionGroup ; pub type GSimpleActionGroup_listautoptr = * mut GList ; pub type GSimpleActionGroup_slistautoptr = * mut GSList ; pub type GSimpleActionGroup_queueautoptr = * mut GQueue ; pub type GSimpleAction_autoptr = * mut GSimpleAction ; pub type GSimpleAction_listautoptr = * mut GList ; pub type GSimpleAction_slistautoptr = * mut GSList ; pub type GSimpleAction_queueautoptr = * mut GQueue ; pub type GSimpleAsyncResult_autoptr = * mut GSimpleAsyncResult ; pub type GSimpleAsyncResult_listautoptr = * mut GList ; pub type GSimpleAsyncResult_slistautoptr = * mut GSList ; pub type GSimpleAsyncResult_queueautoptr = * mut GQueue ; pub type GSimplePermission_autoptr = * mut GSimplePermission ; pub type GSimplePermission_listautoptr = * mut GList ; pub type GSimplePermission_slistautoptr = * mut GSList ; pub type GSimplePermission_queueautoptr = * mut GQueue ; pub type GSimpleProxyResolver_autoptr = * mut GSimpleProxyResolver ; pub type GSimpleProxyResolver_listautoptr = * mut GList ; pub type GSimpleProxyResolver_slistautoptr = * mut GSList ; pub type GSimpleProxyResolver_queueautoptr = * mut GQueue ; pub type GSocketAddressEnumerator_autoptr = * mut GSocketAddressEnumerator ; pub type GSocketAddressEnumerator_listautoptr = * mut GList ; pub type GSocketAddressEnumerator_slistautoptr = * mut GSList ; pub type GSocketAddressEnumerator_queueautoptr = * mut GQueue ; pub type GSocketAddress_autoptr = * mut GSocketAddress ; pub type GSocketAddress_listautoptr = * mut GList ; pub type GSocketAddress_slistautoptr = * mut GSList ; pub type GSocketAddress_queueautoptr = * mut GQueue ; pub type GSocketClient_autoptr = * mut GSocketClient ; pub type GSocketClient_listautoptr = * mut GList ; pub type GSocketClient_slistautoptr = * mut GSList ; pub type GSocketClient_queueautoptr = * mut GQueue ; pub type GSocketConnectable_autoptr = * mut GSocketConnectable ; pub type GSocketConnectable_listautoptr = * mut GList ; pub type GSocketConnectable_slistautoptr = * mut GSList ; pub type GSocketConnectable_queueautoptr = * mut GQueue ; pub type GSocketConnection_autoptr = * mut GSocketConnection ; pub type GSocketConnection_listautoptr = * mut GList ; pub type GSocketConnection_slistautoptr = * mut GSList ; pub type GSocketConnection_queueautoptr = * mut GQueue ; pub type GSocketControlMessage_autoptr = * mut GSocketControlMessage ; pub type GSocketControlMessage_listautoptr = * mut GList ; pub type GSocketControlMessage_slistautoptr = * mut GSList ; pub type GSocketControlMessage_queueautoptr = * mut GQueue ; pub type GSocket_autoptr = * mut GSocket ; pub type GSocket_listautoptr = * mut GList ; pub type GSocket_slistautoptr = * mut GSList ; pub type GSocket_queueautoptr = * mut GQueue ; pub type GSocketListener_autoptr = * mut GSocketListener ; pub type GSocketListener_listautoptr = * mut GList ; pub type GSocketListener_slistautoptr = * mut GSList ; pub type GSocketListener_queueautoptr = * mut GQueue ; pub type GSocketService_autoptr = * mut GSocketService ; pub type GSocketService_listautoptr = * mut GList ; pub type GSocketService_slistautoptr = * mut GSList ; pub type GSocketService_queueautoptr = * mut GQueue ; pub type GSubprocess_autoptr = * mut GSubprocess ; pub type GSubprocess_listautoptr = * mut GList ; pub type GSubprocess_slistautoptr = * mut GSList ; pub type GSubprocess_queueautoptr = * mut GQueue ; pub type GSubprocessLauncher_autoptr = * mut GSubprocessLauncher ; pub type GSubprocessLauncher_listautoptr = * mut GList ; pub type GSubprocessLauncher_slistautoptr = * mut GSList ; pub type GSubprocessLauncher_queueautoptr = * mut GQueue ; pub type GTask_autoptr = * mut GTask ; pub type GTask_listautoptr = * mut GList ; pub type GTask_slistautoptr = * mut GSList ; pub type GTask_queueautoptr = * mut GQueue ; pub type GTcpConnection_autoptr = * mut GTcpConnection ; pub type GTcpConnection_listautoptr = * mut GList ; pub type GTcpConnection_slistautoptr = * mut GSList ; pub type GTcpConnection_queueautoptr = * mut GQueue ; pub type GTcpWrapperConnection_autoptr = * mut GTcpWrapperConnection ; pub type GTcpWrapperConnection_listautoptr = * mut GList ; pub type GTcpWrapperConnection_slistautoptr = * mut GSList ; pub type GTcpWrapperConnection_queueautoptr = * mut GQueue ; pub type GTestDBus_autoptr = * mut GTestDBus ; pub type GTestDBus_listautoptr = * mut GList ; pub type GTestDBus_slistautoptr = * mut GSList ; pub type GTestDBus_queueautoptr = * mut GQueue ; pub type GThemedIcon_autoptr = * mut GThemedIcon ; pub type GThemedIcon_listautoptr = * mut GList ; pub type GThemedIcon_slistautoptr = * mut GSList ; pub type GThemedIcon_queueautoptr = * mut GQueue ; pub type GThreadedSocketService_autoptr = * mut GThreadedSocketService ; pub type GThreadedSocketService_listautoptr = * mut GList ; pub type GThreadedSocketService_slistautoptr = * mut GSList ; pub type GThreadedSocketService_queueautoptr = * mut GQueue ; pub type GTlsBackend_autoptr = * mut GTlsBackend ; pub type GTlsBackend_listautoptr = * mut GList ; pub type GTlsBackend_slistautoptr = * mut GSList ; pub type GTlsBackend_queueautoptr = * mut GQueue ; pub type GTlsCertificate_autoptr = * mut GTlsCertificate ; pub type GTlsCertificate_listautoptr = * mut GList ; pub type GTlsCertificate_slistautoptr = * mut GSList ; pub type GTlsCertificate_queueautoptr = * mut GQueue ; pub type GTlsClientConnection_autoptr = * mut GTlsClientConnection ; pub type GTlsClientConnection_listautoptr = * mut GList ; pub type GTlsClientConnection_slistautoptr = * mut GSList ; pub type GTlsClientConnection_queueautoptr = * mut GQueue ; pub type GTlsConnection_autoptr = * mut GTlsConnection ; pub type GTlsConnection_listautoptr = * mut GList ; pub type GTlsConnection_slistautoptr = * mut GSList ; pub type GTlsConnection_queueautoptr = * mut GQueue ; pub type GTlsDatabase_autoptr = * mut GTlsDatabase ; pub type GTlsDatabase_listautoptr = * mut GList ; pub type GTlsDatabase_slistautoptr = * mut GSList ; pub type GTlsDatabase_queueautoptr = * mut GQueue ; pub type GTlsFileDatabase_autoptr = * mut GTlsFileDatabase ; pub type GTlsFileDatabase_listautoptr = * mut GList ; pub type GTlsFileDatabase_slistautoptr = * mut GSList ; pub type GTlsFileDatabase_queueautoptr = * mut GQueue ; pub type GTlsInteraction_autoptr = * mut GTlsInteraction ; pub type GTlsInteraction_listautoptr = * mut GList ; pub type GTlsInteraction_slistautoptr = * mut GSList ; pub type GTlsInteraction_queueautoptr = * mut GQueue ; pub type GTlsPassword_autoptr = * mut GTlsPassword ; pub type GTlsPassword_listautoptr = * mut GList ; pub type GTlsPassword_slistautoptr = * mut GSList ; pub type GTlsPassword_queueautoptr = * mut GQueue ; pub type GTlsServerConnection_autoptr = * mut GTlsServerConnection ; pub type GTlsServerConnection_listautoptr = * mut GList ; pub type GTlsServerConnection_slistautoptr = * mut GSList ; pub type GTlsServerConnection_queueautoptr = * mut GQueue ; pub type GVfs_autoptr = * mut GVfs ; pub type GVfs_listautoptr = * mut GList ; pub type GVfs_slistautoptr = * mut GSList ; pub type GVfs_queueautoptr = * mut GQueue ; pub type GVolume_autoptr = * mut GVolume ; pub type GVolume_listautoptr = * mut GList ; pub type GVolume_slistautoptr = * mut GSList ; pub type GVolume_queueautoptr = * mut GQueue ; pub type GVolumeMonitor_autoptr = * mut GVolumeMonitor ; pub type GVolumeMonitor_listautoptr = * mut GList ; pub type GVolumeMonitor_slistautoptr = * mut GSList ; pub type GVolumeMonitor_queueautoptr = * mut GQueue ; pub type GZlibCompressor_autoptr = * mut GZlibCompressor ; pub type GZlibCompressor_listautoptr = * mut GList ; pub type GZlibCompressor_slistautoptr = * mut GSList ; pub type GZlibCompressor_queueautoptr = * mut GQueue ; pub type GZlibDecompressor_autoptr = * mut GZlibDecompressor ; pub type GZlibDecompressor_listautoptr = * mut GList ; pub type GZlibDecompressor_slistautoptr = * mut GSList ; pub type GZlibDecompressor_queueautoptr = * mut GQueue ; pub type PkBitfield = guint64 ; unsafe extern "C" { pub fn pk_bitfield_contain_priority (values : PkBitfield , value : gint , ...) -> gint ; } unsafe extern "C" { pub fn pk_bitfield_from_enums (value : gint , ...) -> PkBitfield ; } unsafe extern "C" { pub fn pk_role_bitfield_from_string (roles : * const gchar) -> PkBitfield ; } unsafe extern "C" { pub fn pk_role_bitfield_to_string (roles : PkBitfield) -> * mut gchar ; } unsafe extern "C" { pub fn pk_group_bitfield_from_string (groups : * const gchar) -> PkBitfield ; } unsafe extern "C" { pub fn pk_group_bitfield_to_string (groups : PkBitfield) -> * mut gchar ; } unsafe extern "C" { pub fn pk_filter_bitfield_from_string (filters : * const gchar) -> PkBitfield ; } unsafe extern "C" { pub fn pk_filter_bitfield_to_string (filters : PkBitfield) -> * mut gchar ; } unsafe extern "C" { pub fn pk_transaction_flag_bitfield_from_string (transaction_flags : * const gchar) -> PkBitfield ; } unsafe extern "C" { pub fn pk_transaction_flag_bitfield_to_string (transaction_flags : PkBitfield) -> * mut gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkEnumMatch { pub value : guint , pub string : * const gchar , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkEnumMatch"] [:: std :: mem :: size_of :: < PkEnumMatch > () - 16usize] ; ["Alignment of PkEnumMatch"] [:: std :: mem :: align_of :: < PkEnumMatch > () - 8usize] ; ["Offset of field: PkEnumMatch::value"] [:: std :: mem :: offset_of ! (PkEnumMatch , value) - 0usize] ; ["Offset of field: PkEnumMatch::string"] [:: std :: mem :: offset_of ! (PkEnumMatch , string) - 8usize] ; } ; pub const PkRoleEnum_PK_ROLE_ENUM_UNKNOWN : PkRoleEnum = 0 ; pub const PkRoleEnum_PK_ROLE_ENUM_CANCEL : PkRoleEnum = 1 ; pub const PkRoleEnum_PK_ROLE_ENUM_DEPENDS_ON : PkRoleEnum = 2 ; pub const PkRoleEnum_PK_ROLE_ENUM_GET_DETAILS : PkRoleEnum = 3 ; pub const PkRoleEnum_PK_ROLE_ENUM_GET_FILES : PkRoleEnum = 4 ; pub const PkRoleEnum_PK_ROLE_ENUM_GET_PACKAGES : PkRoleEnum = 5 ; pub const PkRoleEnum_PK_ROLE_ENUM_GET_REPO_LIST : PkRoleEnum = 6 ; pub const PkRoleEnum_PK_ROLE_ENUM_REQUIRED_BY : PkRoleEnum = 7 ; pub const PkRoleEnum_PK_ROLE_ENUM_GET_UPDATE_DETAIL : PkRoleEnum = 8 ; pub const PkRoleEnum_PK_ROLE_ENUM_GET_UPDATES : PkRoleEnum = 9 ; pub const PkRoleEnum_PK_ROLE_ENUM_INSTALL_FILES : PkRoleEnum = 10 ; pub const PkRoleEnum_PK_ROLE_ENUM_INSTALL_PACKAGES : PkRoleEnum = 11 ; pub const PkRoleEnum_PK_ROLE_ENUM_INSTALL_SIGNATURE : PkRoleEnum = 12 ; pub const PkRoleEnum_PK_ROLE_ENUM_REFRESH_CACHE : PkRoleEnum = 13 ; pub const PkRoleEnum_PK_ROLE_ENUM_REMOVE_PACKAGES : PkRoleEnum = 14 ; pub const PkRoleEnum_PK_ROLE_ENUM_REPO_ENABLE : PkRoleEnum = 15 ; pub const PkRoleEnum_PK_ROLE_ENUM_REPO_SET_DATA : PkRoleEnum = 16 ; pub const PkRoleEnum_PK_ROLE_ENUM_RESOLVE : PkRoleEnum = 17 ; pub const PkRoleEnum_PK_ROLE_ENUM_SEARCH_DETAILS : PkRoleEnum = 18 ; pub const PkRoleEnum_PK_ROLE_ENUM_SEARCH_FILE : PkRoleEnum = 19 ; pub const PkRoleEnum_PK_ROLE_ENUM_SEARCH_GROUP : PkRoleEnum = 20 ; pub const PkRoleEnum_PK_ROLE_ENUM_SEARCH_NAME : PkRoleEnum = 21 ; pub const PkRoleEnum_PK_ROLE_ENUM_UPDATE_PACKAGES : PkRoleEnum = 22 ; pub const PkRoleEnum_PK_ROLE_ENUM_WHAT_PROVIDES : PkRoleEnum = 23 ; pub const PkRoleEnum_PK_ROLE_ENUM_ACCEPT_EULA : PkRoleEnum = 24 ; pub const PkRoleEnum_PK_ROLE_ENUM_DOWNLOAD_PACKAGES : PkRoleEnum = 25 ; pub const PkRoleEnum_PK_ROLE_ENUM_GET_DISTRO_UPGRADES : PkRoleEnum = 26 ; pub const PkRoleEnum_PK_ROLE_ENUM_GET_CATEGORIES : PkRoleEnum = 27 ; pub const PkRoleEnum_PK_ROLE_ENUM_GET_OLD_TRANSACTIONS : PkRoleEnum = 28 ; pub const PkRoleEnum_PK_ROLE_ENUM_REPAIR_SYSTEM : PkRoleEnum = 29 ; pub const PkRoleEnum_PK_ROLE_ENUM_GET_DETAILS_LOCAL : PkRoleEnum = 30 ; pub const PkRoleEnum_PK_ROLE_ENUM_GET_FILES_LOCAL : PkRoleEnum = 31 ; pub const PkRoleEnum_PK_ROLE_ENUM_REPO_REMOVE : PkRoleEnum = 32 ; pub const PkRoleEnum_PK_ROLE_ENUM_UPGRADE_SYSTEM : PkRoleEnum = 33 ; pub const PkRoleEnum_PK_ROLE_ENUM_LAST : PkRoleEnum = 34 ; pub type PkRoleEnum = :: std :: os :: raw :: c_uint ; pub const PkStatusEnum_PK_STATUS_ENUM_UNKNOWN : PkStatusEnum = 0 ; pub const PkStatusEnum_PK_STATUS_ENUM_WAIT : PkStatusEnum = 1 ; pub const PkStatusEnum_PK_STATUS_ENUM_SETUP : PkStatusEnum = 2 ; pub const PkStatusEnum_PK_STATUS_ENUM_RUNNING : PkStatusEnum = 3 ; pub const PkStatusEnum_PK_STATUS_ENUM_QUERY : PkStatusEnum = 4 ; pub const PkStatusEnum_PK_STATUS_ENUM_INFO : PkStatusEnum = 5 ; pub const PkStatusEnum_PK_STATUS_ENUM_REMOVE : PkStatusEnum = 6 ; pub const PkStatusEnum_PK_STATUS_ENUM_REFRESH_CACHE : PkStatusEnum = 7 ; pub const PkStatusEnum_PK_STATUS_ENUM_DOWNLOAD : PkStatusEnum = 8 ; pub const PkStatusEnum_PK_STATUS_ENUM_INSTALL : PkStatusEnum = 9 ; pub const PkStatusEnum_PK_STATUS_ENUM_UPDATE : PkStatusEnum = 10 ; pub const PkStatusEnum_PK_STATUS_ENUM_CLEANUP : PkStatusEnum = 11 ; pub const PkStatusEnum_PK_STATUS_ENUM_OBSOLETE : PkStatusEnum = 12 ; pub const PkStatusEnum_PK_STATUS_ENUM_DEP_RESOLVE : PkStatusEnum = 13 ; pub const PkStatusEnum_PK_STATUS_ENUM_SIG_CHECK : PkStatusEnum = 14 ; pub const PkStatusEnum_PK_STATUS_ENUM_TEST_COMMIT : PkStatusEnum = 15 ; pub const PkStatusEnum_PK_STATUS_ENUM_COMMIT : PkStatusEnum = 16 ; pub const PkStatusEnum_PK_STATUS_ENUM_REQUEST : PkStatusEnum = 17 ; pub const PkStatusEnum_PK_STATUS_ENUM_FINISHED : PkStatusEnum = 18 ; pub const PkStatusEnum_PK_STATUS_ENUM_CANCEL : PkStatusEnum = 19 ; pub const PkStatusEnum_PK_STATUS_ENUM_DOWNLOAD_REPOSITORY : PkStatusEnum = 20 ; pub const PkStatusEnum_PK_STATUS_ENUM_DOWNLOAD_PACKAGELIST : PkStatusEnum = 21 ; pub const PkStatusEnum_PK_STATUS_ENUM_DOWNLOAD_FILELIST : PkStatusEnum = 22 ; pub const PkStatusEnum_PK_STATUS_ENUM_DOWNLOAD_CHANGELOG : PkStatusEnum = 23 ; pub const PkStatusEnum_PK_STATUS_ENUM_DOWNLOAD_GROUP : PkStatusEnum = 24 ; pub const PkStatusEnum_PK_STATUS_ENUM_DOWNLOAD_UPDATEINFO : PkStatusEnum = 25 ; pub const PkStatusEnum_PK_STATUS_ENUM_REPACKAGING : PkStatusEnum = 26 ; pub const PkStatusEnum_PK_STATUS_ENUM_LOADING_CACHE : PkStatusEnum = 27 ; pub const PkStatusEnum_PK_STATUS_ENUM_SCAN_APPLICATIONS : PkStatusEnum = 28 ; pub const PkStatusEnum_PK_STATUS_ENUM_GENERATE_PACKAGE_LIST : PkStatusEnum = 29 ; pub const PkStatusEnum_PK_STATUS_ENUM_WAITING_FOR_LOCK : PkStatusEnum = 30 ; pub const PkStatusEnum_PK_STATUS_ENUM_WAITING_FOR_AUTH : PkStatusEnum = 31 ; pub const PkStatusEnum_PK_STATUS_ENUM_SCAN_PROCESS_LIST : PkStatusEnum = 32 ; pub const PkStatusEnum_PK_STATUS_ENUM_CHECK_EXECUTABLE_FILES : PkStatusEnum = 33 ; pub const PkStatusEnum_PK_STATUS_ENUM_CHECK_LIBRARIES : PkStatusEnum = 34 ; pub const PkStatusEnum_PK_STATUS_ENUM_COPY_FILES : PkStatusEnum = 35 ; pub const PkStatusEnum_PK_STATUS_ENUM_RUN_HOOK : PkStatusEnum = 36 ; pub const PkStatusEnum_PK_STATUS_ENUM_LAST : PkStatusEnum = 37 ; pub type PkStatusEnum = :: std :: os :: raw :: c_uint ; pub const PkExitEnum_PK_EXIT_ENUM_UNKNOWN : PkExitEnum = 0 ; pub const PkExitEnum_PK_EXIT_ENUM_SUCCESS : PkExitEnum = 1 ; pub const PkExitEnum_PK_EXIT_ENUM_FAILED : PkExitEnum = 2 ; pub const PkExitEnum_PK_EXIT_ENUM_CANCELLED : PkExitEnum = 3 ; pub const PkExitEnum_PK_EXIT_ENUM_KEY_REQUIRED : PkExitEnum = 4 ; pub const PkExitEnum_PK_EXIT_ENUM_EULA_REQUIRED : PkExitEnum = 5 ; pub const PkExitEnum_PK_EXIT_ENUM_KILLED : PkExitEnum = 6 ; pub const PkExitEnum_PK_EXIT_ENUM_MEDIA_CHANGE_REQUIRED : PkExitEnum = 7 ; pub const PkExitEnum_PK_EXIT_ENUM_NEED_UNTRUSTED : PkExitEnum = 8 ; pub const PkExitEnum_PK_EXIT_ENUM_CANCELLED_PRIORITY : PkExitEnum = 9 ; pub const PkExitEnum_PK_EXIT_ENUM_SKIP_TRANSACTION : PkExitEnum = 10 ; pub const PkExitEnum_PK_EXIT_ENUM_REPAIR_REQUIRED : PkExitEnum = 11 ; pub const PkExitEnum_PK_EXIT_ENUM_LAST : PkExitEnum = 12 ; pub type PkExitEnum = :: std :: os :: raw :: c_uint ; pub const PkNetworkEnum_PK_NETWORK_ENUM_UNKNOWN : PkNetworkEnum = 0 ; pub const PkNetworkEnum_PK_NETWORK_ENUM_OFFLINE : PkNetworkEnum = 1 ; pub const PkNetworkEnum_PK_NETWORK_ENUM_ONLINE : PkNetworkEnum = 2 ; pub const PkNetworkEnum_PK_NETWORK_ENUM_WIRED : PkNetworkEnum = 3 ; pub const PkNetworkEnum_PK_NETWORK_ENUM_WIFI : PkNetworkEnum = 4 ; pub const PkNetworkEnum_PK_NETWORK_ENUM_MOBILE : PkNetworkEnum = 5 ; pub const PkNetworkEnum_PK_NETWORK_ENUM_LAST : PkNetworkEnum = 6 ; pub type PkNetworkEnum = :: std :: os :: raw :: c_uint ; pub const PkFilterEnum_PK_FILTER_ENUM_UNKNOWN : PkFilterEnum = 0 ; pub const PkFilterEnum_PK_FILTER_ENUM_NONE : PkFilterEnum = 1 ; pub const PkFilterEnum_PK_FILTER_ENUM_INSTALLED : PkFilterEnum = 2 ; pub const PkFilterEnum_PK_FILTER_ENUM_NOT_INSTALLED : PkFilterEnum = 3 ; pub const PkFilterEnum_PK_FILTER_ENUM_DEVELOPMENT : PkFilterEnum = 4 ; pub const PkFilterEnum_PK_FILTER_ENUM_NOT_DEVELOPMENT : PkFilterEnum = 5 ; pub const PkFilterEnum_PK_FILTER_ENUM_GUI : PkFilterEnum = 6 ; pub const PkFilterEnum_PK_FILTER_ENUM_NOT_GUI : PkFilterEnum = 7 ; pub const PkFilterEnum_PK_FILTER_ENUM_FREE : PkFilterEnum = 8 ; pub const PkFilterEnum_PK_FILTER_ENUM_NOT_FREE : PkFilterEnum = 9 ; pub const PkFilterEnum_PK_FILTER_ENUM_VISIBLE : PkFilterEnum = 10 ; pub const PkFilterEnum_PK_FILTER_ENUM_NOT_VISIBLE : PkFilterEnum = 11 ; pub const PkFilterEnum_PK_FILTER_ENUM_SUPPORTED : PkFilterEnum = 12 ; pub const PkFilterEnum_PK_FILTER_ENUM_NOT_SUPPORTED : PkFilterEnum = 13 ; pub const PkFilterEnum_PK_FILTER_ENUM_BASENAME : PkFilterEnum = 14 ; pub const PkFilterEnum_PK_FILTER_ENUM_NOT_BASENAME : PkFilterEnum = 15 ; pub const PkFilterEnum_PK_FILTER_ENUM_NEWEST : PkFilterEnum = 16 ; pub const PkFilterEnum_PK_FILTER_ENUM_NOT_NEWEST : PkFilterEnum = 17 ; pub const PkFilterEnum_PK_FILTER_ENUM_ARCH : PkFilterEnum = 18 ; pub const PkFilterEnum_PK_FILTER_ENUM_NOT_ARCH : PkFilterEnum = 19 ; pub const PkFilterEnum_PK_FILTER_ENUM_SOURCE : PkFilterEnum = 20 ; pub const PkFilterEnum_PK_FILTER_ENUM_NOT_SOURCE : PkFilterEnum = 21 ; pub const PkFilterEnum_PK_FILTER_ENUM_COLLECTIONS : PkFilterEnum = 22 ; pub const PkFilterEnum_PK_FILTER_ENUM_NOT_COLLECTIONS : PkFilterEnum = 23 ; pub const PkFilterEnum_PK_FILTER_ENUM_APPLICATION : PkFilterEnum = 24 ; pub const PkFilterEnum_PK_FILTER_ENUM_NOT_APPLICATION : PkFilterEnum = 25 ; pub const PkFilterEnum_PK_FILTER_ENUM_DOWNLOADED : PkFilterEnum = 26 ; pub const PkFilterEnum_PK_FILTER_ENUM_NOT_DOWNLOADED : PkFilterEnum = 27 ; pub const PkFilterEnum_PK_FILTER_ENUM_LAST : PkFilterEnum = 28 ; pub type PkFilterEnum = :: std :: os :: raw :: c_uint ; pub const PkRestartEnum_PK_RESTART_ENUM_UNKNOWN : PkRestartEnum = 0 ; pub const PkRestartEnum_PK_RESTART_ENUM_NONE : PkRestartEnum = 1 ; pub const PkRestartEnum_PK_RESTART_ENUM_APPLICATION : PkRestartEnum = 2 ; pub const PkRestartEnum_PK_RESTART_ENUM_SESSION : PkRestartEnum = 3 ; pub const PkRestartEnum_PK_RESTART_ENUM_SYSTEM : PkRestartEnum = 4 ; pub const PkRestartEnum_PK_RESTART_ENUM_SECURITY_SESSION : PkRestartEnum = 5 ; pub const PkRestartEnum_PK_RESTART_ENUM_SECURITY_SYSTEM : PkRestartEnum = 6 ; pub const PkRestartEnum_PK_RESTART_ENUM_LAST : PkRestartEnum = 7 ; pub type PkRestartEnum = :: std :: os :: raw :: c_uint ; pub const PkErrorEnum_PK_ERROR_ENUM_UNKNOWN : PkErrorEnum = 0 ; pub const PkErrorEnum_PK_ERROR_ENUM_OOM : PkErrorEnum = 1 ; pub const PkErrorEnum_PK_ERROR_ENUM_NO_NETWORK : PkErrorEnum = 2 ; pub const PkErrorEnum_PK_ERROR_ENUM_NOT_SUPPORTED : PkErrorEnum = 3 ; pub const PkErrorEnum_PK_ERROR_ENUM_INTERNAL_ERROR : PkErrorEnum = 4 ; pub const PkErrorEnum_PK_ERROR_ENUM_GPG_FAILURE : PkErrorEnum = 5 ; pub const PkErrorEnum_PK_ERROR_ENUM_PACKAGE_ID_INVALID : PkErrorEnum = 6 ; pub const PkErrorEnum_PK_ERROR_ENUM_PACKAGE_NOT_INSTALLED : PkErrorEnum = 7 ; pub const PkErrorEnum_PK_ERROR_ENUM_PACKAGE_NOT_FOUND : PkErrorEnum = 8 ; pub const PkErrorEnum_PK_ERROR_ENUM_PACKAGE_ALREADY_INSTALLED : PkErrorEnum = 9 ; pub const PkErrorEnum_PK_ERROR_ENUM_PACKAGE_DOWNLOAD_FAILED : PkErrorEnum = 10 ; pub const PkErrorEnum_PK_ERROR_ENUM_GROUP_NOT_FOUND : PkErrorEnum = 11 ; pub const PkErrorEnum_PK_ERROR_ENUM_GROUP_LIST_INVALID : PkErrorEnum = 12 ; pub const PkErrorEnum_PK_ERROR_ENUM_DEP_RESOLUTION_FAILED : PkErrorEnum = 13 ; pub const PkErrorEnum_PK_ERROR_ENUM_FILTER_INVALID : PkErrorEnum = 14 ; pub const PkErrorEnum_PK_ERROR_ENUM_CREATE_THREAD_FAILED : PkErrorEnum = 15 ; pub const PkErrorEnum_PK_ERROR_ENUM_TRANSACTION_ERROR : PkErrorEnum = 16 ; pub const PkErrorEnum_PK_ERROR_ENUM_TRANSACTION_CANCELLED : PkErrorEnum = 17 ; pub const PkErrorEnum_PK_ERROR_ENUM_NO_CACHE : PkErrorEnum = 18 ; pub const PkErrorEnum_PK_ERROR_ENUM_REPO_NOT_FOUND : PkErrorEnum = 19 ; pub const PkErrorEnum_PK_ERROR_ENUM_CANNOT_REMOVE_SYSTEM_PACKAGE : PkErrorEnum = 20 ; pub const PkErrorEnum_PK_ERROR_ENUM_PROCESS_KILL : PkErrorEnum = 21 ; pub const PkErrorEnum_PK_ERROR_ENUM_FAILED_INITIALIZATION : PkErrorEnum = 22 ; pub const PkErrorEnum_PK_ERROR_ENUM_FAILED_FINALISE : PkErrorEnum = 23 ; pub const PkErrorEnum_PK_ERROR_ENUM_FAILED_CONFIG_PARSING : PkErrorEnum = 24 ; pub const PkErrorEnum_PK_ERROR_ENUM_CANNOT_CANCEL : PkErrorEnum = 25 ; pub const PkErrorEnum_PK_ERROR_ENUM_CANNOT_GET_LOCK : PkErrorEnum = 26 ; pub const PkErrorEnum_PK_ERROR_ENUM_NO_PACKAGES_TO_UPDATE : PkErrorEnum = 27 ; pub const PkErrorEnum_PK_ERROR_ENUM_CANNOT_WRITE_REPO_CONFIG : PkErrorEnum = 28 ; pub const PkErrorEnum_PK_ERROR_ENUM_LOCAL_INSTALL_FAILED : PkErrorEnum = 29 ; pub const PkErrorEnum_PK_ERROR_ENUM_BAD_GPG_SIGNATURE : PkErrorEnum = 30 ; pub const PkErrorEnum_PK_ERROR_ENUM_MISSING_GPG_SIGNATURE : PkErrorEnum = 31 ; pub const PkErrorEnum_PK_ERROR_ENUM_CANNOT_INSTALL_SOURCE_PACKAGE : PkErrorEnum = 32 ; pub const PkErrorEnum_PK_ERROR_ENUM_REPO_CONFIGURATION_ERROR : PkErrorEnum = 33 ; pub const PkErrorEnum_PK_ERROR_ENUM_NO_LICENSE_AGREEMENT : PkErrorEnum = 34 ; pub const PkErrorEnum_PK_ERROR_ENUM_FILE_CONFLICTS : PkErrorEnum = 35 ; pub const PkErrorEnum_PK_ERROR_ENUM_PACKAGE_CONFLICTS : PkErrorEnum = 36 ; pub const PkErrorEnum_PK_ERROR_ENUM_REPO_NOT_AVAILABLE : PkErrorEnum = 37 ; pub const PkErrorEnum_PK_ERROR_ENUM_INVALID_PACKAGE_FILE : PkErrorEnum = 38 ; pub const PkErrorEnum_PK_ERROR_ENUM_PACKAGE_INSTALL_BLOCKED : PkErrorEnum = 39 ; pub const PkErrorEnum_PK_ERROR_ENUM_PACKAGE_CORRUPT : PkErrorEnum = 40 ; pub const PkErrorEnum_PK_ERROR_ENUM_ALL_PACKAGES_ALREADY_INSTALLED : PkErrorEnum = 41 ; pub const PkErrorEnum_PK_ERROR_ENUM_FILE_NOT_FOUND : PkErrorEnum = 42 ; pub const PkErrorEnum_PK_ERROR_ENUM_NO_MORE_MIRRORS_TO_TRY : PkErrorEnum = 43 ; pub const PkErrorEnum_PK_ERROR_ENUM_NO_DISTRO_UPGRADE_DATA : PkErrorEnum = 44 ; pub const PkErrorEnum_PK_ERROR_ENUM_INCOMPATIBLE_ARCHITECTURE : PkErrorEnum = 45 ; pub const PkErrorEnum_PK_ERROR_ENUM_NO_SPACE_ON_DEVICE : PkErrorEnum = 46 ; pub const PkErrorEnum_PK_ERROR_ENUM_MEDIA_CHANGE_REQUIRED : PkErrorEnum = 47 ; pub const PkErrorEnum_PK_ERROR_ENUM_NOT_AUTHORIZED : PkErrorEnum = 48 ; pub const PkErrorEnum_PK_ERROR_ENUM_UPDATE_NOT_FOUND : PkErrorEnum = 49 ; pub const PkErrorEnum_PK_ERROR_ENUM_CANNOT_INSTALL_REPO_UNSIGNED : PkErrorEnum = 50 ; pub const PkErrorEnum_PK_ERROR_ENUM_CANNOT_UPDATE_REPO_UNSIGNED : PkErrorEnum = 51 ; pub const PkErrorEnum_PK_ERROR_ENUM_CANNOT_GET_FILELIST : PkErrorEnum = 52 ; pub const PkErrorEnum_PK_ERROR_ENUM_CANNOT_GET_REQUIRES : PkErrorEnum = 53 ; pub const PkErrorEnum_PK_ERROR_ENUM_CANNOT_DISABLE_REPOSITORY : PkErrorEnum = 54 ; pub const PkErrorEnum_PK_ERROR_ENUM_RESTRICTED_DOWNLOAD : PkErrorEnum = 55 ; pub const PkErrorEnum_PK_ERROR_ENUM_PACKAGE_FAILED_TO_CONFIGURE : PkErrorEnum = 56 ; pub const PkErrorEnum_PK_ERROR_ENUM_PACKAGE_FAILED_TO_BUILD : PkErrorEnum = 57 ; pub const PkErrorEnum_PK_ERROR_ENUM_PACKAGE_FAILED_TO_INSTALL : PkErrorEnum = 58 ; pub const PkErrorEnum_PK_ERROR_ENUM_PACKAGE_FAILED_TO_REMOVE : PkErrorEnum = 59 ; pub const PkErrorEnum_PK_ERROR_ENUM_UPDATE_FAILED_DUE_TO_RUNNING_PROCESS : PkErrorEnum = 60 ; pub const PkErrorEnum_PK_ERROR_ENUM_PACKAGE_DATABASE_CHANGED : PkErrorEnum = 61 ; pub const PkErrorEnum_PK_ERROR_ENUM_PROVIDE_TYPE_NOT_SUPPORTED : PkErrorEnum = 62 ; pub const PkErrorEnum_PK_ERROR_ENUM_INSTALL_ROOT_INVALID : PkErrorEnum = 63 ; pub const PkErrorEnum_PK_ERROR_ENUM_CANNOT_FETCH_SOURCES : PkErrorEnum = 64 ; pub const PkErrorEnum_PK_ERROR_ENUM_CANCELLED_PRIORITY : PkErrorEnum = 65 ; pub const PkErrorEnum_PK_ERROR_ENUM_UNFINISHED_TRANSACTION : PkErrorEnum = 66 ; pub const PkErrorEnum_PK_ERROR_ENUM_LOCK_REQUIRED : PkErrorEnum = 67 ; pub const PkErrorEnum_PK_ERROR_ENUM_REPO_ALREADY_SET : PkErrorEnum = 68 ; pub const PkErrorEnum_PK_ERROR_ENUM_LAST : PkErrorEnum = 69 ; pub type PkErrorEnum = :: std :: os :: raw :: c_uint ; pub const PkGroupEnum_PK_GROUP_ENUM_UNKNOWN : PkGroupEnum = 0 ; pub const PkGroupEnum_PK_GROUP_ENUM_ACCESSIBILITY : PkGroupEnum = 1 ; pub const PkGroupEnum_PK_GROUP_ENUM_ACCESSORIES : PkGroupEnum = 2 ; pub const PkGroupEnum_PK_GROUP_ENUM_ADMIN_TOOLS : PkGroupEnum = 3 ; pub const PkGroupEnum_PK_GROUP_ENUM_COMMUNICATION : PkGroupEnum = 4 ; pub const PkGroupEnum_PK_GROUP_ENUM_DESKTOP_GNOME : PkGroupEnum = 5 ; pub const PkGroupEnum_PK_GROUP_ENUM_DESKTOP_KDE : PkGroupEnum = 6 ; pub const PkGroupEnum_PK_GROUP_ENUM_DESKTOP_OTHER : PkGroupEnum = 7 ; pub const PkGroupEnum_PK_GROUP_ENUM_DESKTOP_XFCE : PkGroupEnum = 8 ; pub const PkGroupEnum_PK_GROUP_ENUM_EDUCATION : PkGroupEnum = 9 ; pub const PkGroupEnum_PK_GROUP_ENUM_FONTS : PkGroupEnum = 10 ; pub const PkGroupEnum_PK_GROUP_ENUM_GAMES : PkGroupEnum = 11 ; pub const PkGroupEnum_PK_GROUP_ENUM_GRAPHICS : PkGroupEnum = 12 ; pub const PkGroupEnum_PK_GROUP_ENUM_INTERNET : PkGroupEnum = 13 ; pub const PkGroupEnum_PK_GROUP_ENUM_LEGACY : PkGroupEnum = 14 ; pub const PkGroupEnum_PK_GROUP_ENUM_LOCALIZATION : PkGroupEnum = 15 ; pub const PkGroupEnum_PK_GROUP_ENUM_MAPS : PkGroupEnum = 16 ; pub const PkGroupEnum_PK_GROUP_ENUM_MULTIMEDIA : PkGroupEnum = 17 ; pub const PkGroupEnum_PK_GROUP_ENUM_NETWORK : PkGroupEnum = 18 ; pub const PkGroupEnum_PK_GROUP_ENUM_OFFICE : PkGroupEnum = 19 ; pub const PkGroupEnum_PK_GROUP_ENUM_OTHER : PkGroupEnum = 20 ; pub const PkGroupEnum_PK_GROUP_ENUM_POWER_MANAGEMENT : PkGroupEnum = 21 ; pub const PkGroupEnum_PK_GROUP_ENUM_PROGRAMMING : PkGroupEnum = 22 ; pub const PkGroupEnum_PK_GROUP_ENUM_PUBLISHING : PkGroupEnum = 23 ; pub const PkGroupEnum_PK_GROUP_ENUM_REPOS : PkGroupEnum = 24 ; pub const PkGroupEnum_PK_GROUP_ENUM_SECURITY : PkGroupEnum = 25 ; pub const PkGroupEnum_PK_GROUP_ENUM_SERVERS : PkGroupEnum = 26 ; pub const PkGroupEnum_PK_GROUP_ENUM_SYSTEM : PkGroupEnum = 27 ; pub const PkGroupEnum_PK_GROUP_ENUM_VIRTUALIZATION : PkGroupEnum = 28 ; pub const PkGroupEnum_PK_GROUP_ENUM_SCIENCE : PkGroupEnum = 29 ; pub const PkGroupEnum_PK_GROUP_ENUM_DOCUMENTATION : PkGroupEnum = 30 ; pub const PkGroupEnum_PK_GROUP_ENUM_ELECTRONICS : PkGroupEnum = 31 ; pub const PkGroupEnum_PK_GROUP_ENUM_COLLECTIONS : PkGroupEnum = 32 ; pub const PkGroupEnum_PK_GROUP_ENUM_VENDOR : PkGroupEnum = 33 ; pub const PkGroupEnum_PK_GROUP_ENUM_NEWEST : PkGroupEnum = 34 ; pub const PkGroupEnum_PK_GROUP_ENUM_DESKTOP_DDE : PkGroupEnum = 35 ; pub const PkGroupEnum_PK_GROUP_ENUM_LAST : PkGroupEnum = 36 ; pub type PkGroupEnum = :: std :: os :: raw :: c_uint ; pub const PkUpdateStateEnum_PK_UPDATE_STATE_ENUM_UNKNOWN : PkUpdateStateEnum = 0 ; pub const PkUpdateStateEnum_PK_UPDATE_STATE_ENUM_STABLE : PkUpdateStateEnum = 1 ; pub const PkUpdateStateEnum_PK_UPDATE_STATE_ENUM_UNSTABLE : PkUpdateStateEnum = 2 ; pub const PkUpdateStateEnum_PK_UPDATE_STATE_ENUM_TESTING : PkUpdateStateEnum = 3 ; pub const PkUpdateStateEnum_PK_UPDATE_STATE_ENUM_LAST : PkUpdateStateEnum = 4 ; pub type PkUpdateStateEnum = :: std :: os :: raw :: c_uint ; pub const PkInfoEnum_PK_INFO_ENUM_UNKNOWN : PkInfoEnum = 0 ; pub const PkInfoEnum_PK_INFO_ENUM_INSTALLED : PkInfoEnum = 1 ; pub const PkInfoEnum_PK_INFO_ENUM_AVAILABLE : PkInfoEnum = 2 ; pub const PkInfoEnum_PK_INFO_ENUM_LOW : PkInfoEnum = 3 ; pub const PkInfoEnum_PK_INFO_ENUM_ENHANCEMENT : PkInfoEnum = 4 ; pub const PkInfoEnum_PK_INFO_ENUM_NORMAL : PkInfoEnum = 5 ; pub const PkInfoEnum_PK_INFO_ENUM_BUGFIX : PkInfoEnum = 6 ; pub const PkInfoEnum_PK_INFO_ENUM_IMPORTANT : PkInfoEnum = 7 ; pub const PkInfoEnum_PK_INFO_ENUM_SECURITY : PkInfoEnum = 8 ; pub const PkInfoEnum_PK_INFO_ENUM_BLOCKED : PkInfoEnum = 9 ; pub const PkInfoEnum_PK_INFO_ENUM_DOWNLOADING : PkInfoEnum = 10 ; pub const PkInfoEnum_PK_INFO_ENUM_UPDATING : PkInfoEnum = 11 ; pub const PkInfoEnum_PK_INFO_ENUM_INSTALLING : PkInfoEnum = 12 ; pub const PkInfoEnum_PK_INFO_ENUM_REMOVING : PkInfoEnum = 13 ; pub const PkInfoEnum_PK_INFO_ENUM_CLEANUP : PkInfoEnum = 14 ; pub const PkInfoEnum_PK_INFO_ENUM_OBSOLETING : PkInfoEnum = 15 ; pub const PkInfoEnum_PK_INFO_ENUM_COLLECTION_INSTALLED : PkInfoEnum = 16 ; pub const PkInfoEnum_PK_INFO_ENUM_COLLECTION_AVAILABLE : PkInfoEnum = 17 ; pub const PkInfoEnum_PK_INFO_ENUM_FINISHED : PkInfoEnum = 18 ; pub const PkInfoEnum_PK_INFO_ENUM_REINSTALLING : PkInfoEnum = 19 ; pub const PkInfoEnum_PK_INFO_ENUM_DOWNGRADING : PkInfoEnum = 20 ; pub const PkInfoEnum_PK_INFO_ENUM_PREPARING : PkInfoEnum = 21 ; pub const PkInfoEnum_PK_INFO_ENUM_DECOMPRESSING : PkInfoEnum = 22 ; pub const PkInfoEnum_PK_INFO_ENUM_UNTRUSTED : PkInfoEnum = 23 ; pub const PkInfoEnum_PK_INFO_ENUM_TRUSTED : PkInfoEnum = 24 ; pub const PkInfoEnum_PK_INFO_ENUM_UNAVAILABLE : PkInfoEnum = 25 ; pub const PkInfoEnum_PK_INFO_ENUM_CRITICAL : PkInfoEnum = 26 ; pub const PkInfoEnum_PK_INFO_ENUM_INSTALL : PkInfoEnum = 27 ; pub const PkInfoEnum_PK_INFO_ENUM_REMOVE : PkInfoEnum = 28 ; pub const PkInfoEnum_PK_INFO_ENUM_OBSOLETE : PkInfoEnum = 29 ; pub const PkInfoEnum_PK_INFO_ENUM_DOWNGRADE : PkInfoEnum = 30 ; pub const PkInfoEnum_PK_INFO_ENUM_LAST : PkInfoEnum = 31 ; pub type PkInfoEnum = :: std :: os :: raw :: c_uint ; pub const PkDistroUpgradeEnum_PK_DISTRO_UPGRADE_ENUM_UNKNOWN : PkDistroUpgradeEnum = 0 ; pub const PkDistroUpgradeEnum_PK_DISTRO_UPGRADE_ENUM_STABLE : PkDistroUpgradeEnum = 1 ; pub const PkDistroUpgradeEnum_PK_DISTRO_UPGRADE_ENUM_UNSTABLE : PkDistroUpgradeEnum = 2 ; pub const PkDistroUpgradeEnum_PK_DISTRO_UPGRADE_ENUM_LAST : PkDistroUpgradeEnum = 3 ; pub type PkDistroUpgradeEnum = :: std :: os :: raw :: c_uint ; pub const PkSigTypeEnum_PK_SIGTYPE_ENUM_UNKNOWN : PkSigTypeEnum = 0 ; pub const PkSigTypeEnum_PK_SIGTYPE_ENUM_GPG : PkSigTypeEnum = 1 ; pub const PkSigTypeEnum_PK_SIGTYPE_ENUM_LAST : PkSigTypeEnum = 2 ; pub type PkSigTypeEnum = :: std :: os :: raw :: c_uint ; pub const PkMediaTypeEnum_PK_MEDIA_TYPE_ENUM_UNKNOWN : PkMediaTypeEnum = 0 ; pub const PkMediaTypeEnum_PK_MEDIA_TYPE_ENUM_CD : PkMediaTypeEnum = 1 ; pub const PkMediaTypeEnum_PK_MEDIA_TYPE_ENUM_DVD : PkMediaTypeEnum = 2 ; pub const PkMediaTypeEnum_PK_MEDIA_TYPE_ENUM_DISC : PkMediaTypeEnum = 3 ; pub const PkMediaTypeEnum_PK_MEDIA_TYPE_ENUM_LAST : PkMediaTypeEnum = 4 ; pub type PkMediaTypeEnum = :: std :: os :: raw :: c_uint ; pub const PkAuthorizeEnum_PK_AUTHORIZE_ENUM_UNKNOWN : PkAuthorizeEnum = 0 ; pub const PkAuthorizeEnum_PK_AUTHORIZE_ENUM_YES : PkAuthorizeEnum = 1 ; pub const PkAuthorizeEnum_PK_AUTHORIZE_ENUM_NO : PkAuthorizeEnum = 2 ; pub const PkAuthorizeEnum_PK_AUTHORIZE_ENUM_INTERACTIVE : PkAuthorizeEnum = 3 ; pub const PkAuthorizeEnum_PK_AUTHORIZE_ENUM_LAST : PkAuthorizeEnum = 4 ; pub type PkAuthorizeEnum = :: std :: os :: raw :: c_uint ; pub const PkUpgradeKindEnum_PK_UPGRADE_KIND_ENUM_UNKNOWN : PkUpgradeKindEnum = 0 ; pub const PkUpgradeKindEnum_PK_UPGRADE_KIND_ENUM_MINIMAL : PkUpgradeKindEnum = 1 ; pub const PkUpgradeKindEnum_PK_UPGRADE_KIND_ENUM_DEFAULT : PkUpgradeKindEnum = 2 ; pub const PkUpgradeKindEnum_PK_UPGRADE_KIND_ENUM_COMPLETE : PkUpgradeKindEnum = 3 ; pub const PkUpgradeKindEnum_PK_UPGRADE_KIND_ENUM_LAST : PkUpgradeKindEnum = 4 ; pub type PkUpgradeKindEnum = :: std :: os :: raw :: c_uint ; pub const PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_NONE : PkTransactionFlagEnum = 0 ; pub const PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_ONLY_TRUSTED : PkTransactionFlagEnum = 1 ; pub const PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_SIMULATE : PkTransactionFlagEnum = 2 ; pub const PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD : PkTransactionFlagEnum = 3 ; pub const PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_ALLOW_REINSTALL : PkTransactionFlagEnum = 4 ; pub const PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_JUST_REINSTALL : PkTransactionFlagEnum = 5 ; pub const PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_ALLOW_DOWNGRADE : PkTransactionFlagEnum = 6 ; pub const PkTransactionFlagEnum_PK_TRANSACTION_FLAG_ENUM_LAST : PkTransactionFlagEnum = 7 ; pub type PkTransactionFlagEnum = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn pk_enum_find_value (table : * const PkEnumMatch , string : * const gchar) -> guint ; } unsafe extern "C" { pub fn pk_enum_find_string (table : * const PkEnumMatch , value : guint) -> * const gchar ; } unsafe extern "C" { pub fn pk_sig_type_enum_from_string (sig_type : * const gchar) -> PkSigTypeEnum ; } unsafe extern "C" { pub fn pk_sig_type_enum_to_string (sig_type : PkSigTypeEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_info_enum_from_string (info : * const gchar) -> PkInfoEnum ; } unsafe extern "C" { pub fn pk_info_enum_to_string (info : PkInfoEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_update_state_enum_from_string (update_state : * const gchar) -> PkUpdateStateEnum ; } unsafe extern "C" { pub fn pk_update_state_enum_to_string (update_state : PkUpdateStateEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_exit_enum_from_string (exit : * const gchar) -> PkExitEnum ; } unsafe extern "C" { pub fn pk_exit_enum_to_string (exit : PkExitEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_network_enum_from_string (network : * const gchar) -> PkNetworkEnum ; } unsafe extern "C" { pub fn pk_network_enum_to_string (network : PkNetworkEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_status_enum_from_string (status : * const gchar) -> PkStatusEnum ; } unsafe extern "C" { pub fn pk_status_enum_to_string (status : PkStatusEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_role_enum_from_string (role : * const gchar) -> PkRoleEnum ; } unsafe extern "C" { pub fn pk_role_enum_to_string (role : PkRoleEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_error_enum_from_string (code : * const gchar) -> PkErrorEnum ; } unsafe extern "C" { pub fn pk_error_enum_to_string (code : PkErrorEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_restart_enum_from_string (restart : * const gchar) -> PkRestartEnum ; } unsafe extern "C" { pub fn pk_restart_enum_to_string (restart : PkRestartEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_group_enum_from_string (group : * const gchar) -> PkGroupEnum ; } unsafe extern "C" { pub fn pk_group_enum_to_string (group : PkGroupEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_filter_enum_from_string (filter : * const gchar) -> PkFilterEnum ; } unsafe extern "C" { pub fn pk_filter_enum_to_string (filter : PkFilterEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_distro_upgrade_enum_from_string (upgrade : * const gchar) -> PkDistroUpgradeEnum ; } unsafe extern "C" { pub fn pk_distro_upgrade_enum_to_string (upgrade : PkDistroUpgradeEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_media_type_enum_from_string (media_type : * const gchar) -> PkMediaTypeEnum ; } unsafe extern "C" { pub fn pk_media_type_enum_to_string (media_type : PkMediaTypeEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_authorize_type_enum_from_string (authorize_type : * const gchar) -> PkAuthorizeEnum ; } unsafe extern "C" { pub fn pk_authorize_type_enum_to_string (authorize_type : PkAuthorizeEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_upgrade_kind_enum_from_string (upgrade_kind : * const gchar) -> PkUpgradeKindEnum ; } unsafe extern "C" { pub fn pk_upgrade_kind_enum_to_string (upgrade_kind : PkUpgradeKindEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_transaction_flag_enum_from_string (transaction_flag : * const gchar) -> PkTransactionFlagEnum ; } unsafe extern "C" { pub fn pk_transaction_flag_enum_to_string (transaction_flag : PkTransactionFlagEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_status_enum_to_localised_text (status : PkStatusEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_info_enum_to_localised_past (info : PkInfoEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_info_enum_to_localised_present (info : PkInfoEnum) -> * const gchar ; } unsafe extern "C" { pub fn pk_role_enum_to_localised_present (role : PkRoleEnum) -> * const gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkDetailsPrivate { _unused : [u8 ; 0] , } pub type PkDetailsPrivate = _PkDetailsPrivate ; pub type PkDetails = _PkDetails ; pub type PkDetailsClass = _PkDetailsClass ; pub type PkDetails_autoptr = * mut PkDetails ; pub type PkDetails_listautoptr = * mut GList ; pub type PkDetails_slistautoptr = * mut GSList ; pub type PkDetails_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkDetails { pub parent : PkSource , pub priv_ : * mut PkDetailsPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkDetails"] [:: std :: mem :: size_of :: < _PkDetails > () - 40usize] ; ["Alignment of _PkDetails"] [:: std :: mem :: align_of :: < _PkDetails > () - 8usize] ; ["Offset of field: _PkDetails::parent"] [:: std :: mem :: offset_of ! (_PkDetails , parent) - 0usize] ; ["Offset of field: _PkDetails::priv_"] [:: std :: mem :: offset_of ! (_PkDetails , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkDetailsClass { pub parent_class : PkSourceClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkDetailsClass"] [:: std :: mem :: size_of :: < _PkDetailsClass > () - 216usize] ; ["Alignment of _PkDetailsClass"] [:: std :: mem :: align_of :: < _PkDetailsClass > () - 8usize] ; ["Offset of field: _PkDetailsClass::parent_class"] [:: std :: mem :: offset_of ! (_PkDetailsClass , parent_class) - 0usize] ; ["Offset of field: _PkDetailsClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkDetailsClass , _pk_reserved1) - 176usize] ; ["Offset of field: _PkDetailsClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkDetailsClass , _pk_reserved2) - 184usize] ; ["Offset of field: _PkDetailsClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkDetailsClass , _pk_reserved3) - 192usize] ; ["Offset of field: _PkDetailsClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkDetailsClass , _pk_reserved4) - 200usize] ; ["Offset of field: _PkDetailsClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkDetailsClass , _pk_reserved5) - 208usize] ; } ; unsafe extern "C" { pub fn pk_details_get_type () -> GType ; } unsafe extern "C" { pub fn pk_details_new () -> * mut PkDetails ; } unsafe extern "C" { pub fn pk_details_get_package_id (details : * mut PkDetails) -> * const gchar ; } unsafe extern "C" { pub fn pk_details_get_license (details : * mut PkDetails) -> * const gchar ; } unsafe extern "C" { pub fn pk_details_get_group (details : * mut PkDetails) -> PkGroupEnum ; } unsafe extern "C" { pub fn pk_details_get_description (details : * mut PkDetails) -> * const gchar ; } unsafe extern "C" { pub fn pk_details_get_url (details : * mut PkDetails) -> * const gchar ; } unsafe extern "C" { pub fn pk_details_get_size (details : * mut PkDetails) -> guint64 ; } unsafe extern "C" { pub fn pk_details_get_summary (details : * mut PkDetails) -> * const gchar ; } unsafe extern "C" { pub fn pk_details_get_download_size (details : * mut PkDetails) -> guint64 ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkDistroUpgradePrivate { _unused : [u8 ; 0] , } pub type PkDistroUpgradePrivate = _PkDistroUpgradePrivate ; pub type PkDistroUpgrade = _PkDistroUpgrade ; pub type PkDistroUpgradeClass = _PkDistroUpgradeClass ; pub type PkDistroUpgrade_autoptr = * mut PkDistroUpgrade ; pub type PkDistroUpgrade_listautoptr = * mut GList ; pub type PkDistroUpgrade_slistautoptr = * mut GSList ; pub type PkDistroUpgrade_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkDistroUpgrade { pub parent : PkSource , pub priv_ : * mut PkDistroUpgradePrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkDistroUpgrade"] [:: std :: mem :: size_of :: < _PkDistroUpgrade > () - 40usize] ; ["Alignment of _PkDistroUpgrade"] [:: std :: mem :: align_of :: < _PkDistroUpgrade > () - 8usize] ; ["Offset of field: _PkDistroUpgrade::parent"] [:: std :: mem :: offset_of ! (_PkDistroUpgrade , parent) - 0usize] ; ["Offset of field: _PkDistroUpgrade::priv_"] [:: std :: mem :: offset_of ! (_PkDistroUpgrade , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkDistroUpgradeClass { pub parent_class : PkSourceClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkDistroUpgradeClass"] [:: std :: mem :: size_of :: < _PkDistroUpgradeClass > () - 216usize] ; ["Alignment of _PkDistroUpgradeClass"] [:: std :: mem :: align_of :: < _PkDistroUpgradeClass > () - 8usize] ; ["Offset of field: _PkDistroUpgradeClass::parent_class"] [:: std :: mem :: offset_of ! (_PkDistroUpgradeClass , parent_class) - 0usize] ; ["Offset of field: _PkDistroUpgradeClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkDistroUpgradeClass , _pk_reserved1) - 176usize] ; ["Offset of field: _PkDistroUpgradeClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkDistroUpgradeClass , _pk_reserved2) - 184usize] ; ["Offset of field: _PkDistroUpgradeClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkDistroUpgradeClass , _pk_reserved3) - 192usize] ; ["Offset of field: _PkDistroUpgradeClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkDistroUpgradeClass , _pk_reserved4) - 200usize] ; ["Offset of field: _PkDistroUpgradeClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkDistroUpgradeClass , _pk_reserved5) - 208usize] ; } ; unsafe extern "C" { pub fn pk_distro_upgrade_get_type () -> GType ; } unsafe extern "C" { pub fn pk_distro_upgrade_new () -> * mut PkDistroUpgrade ; } unsafe extern "C" { pub fn pk_distro_upgrade_get_id (distro_upgrade : * mut PkDistroUpgrade) -> * const gchar ; } unsafe extern "C" { pub fn pk_distro_upgrade_get_summary (distro_upgrade : * mut PkDistroUpgrade) -> * const gchar ; } unsafe extern "C" { pub fn pk_distro_upgrade_get_state (distro_upgrade : * mut PkDistroUpgrade) -> PkDistroUpgradeEnum ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkErrorPrivate { _unused : [u8 ; 0] , } pub type PkErrorPrivate = _PkErrorPrivate ; pub type PkError = _PkError ; pub type PkErrorClass = _PkErrorClass ; pub type PkError_autoptr = * mut PkError ; pub type PkError_listautoptr = * mut GList ; pub type PkError_slistautoptr = * mut GSList ; pub type PkError_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkError { pub parent : PkSource , pub priv_ : * mut PkErrorPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkError"] [:: std :: mem :: size_of :: < _PkError > () - 40usize] ; ["Alignment of _PkError"] [:: std :: mem :: align_of :: < _PkError > () - 8usize] ; ["Offset of field: _PkError::parent"] [:: std :: mem :: offset_of ! (_PkError , parent) - 0usize] ; ["Offset of field: _PkError::priv_"] [:: std :: mem :: offset_of ! (_PkError , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkErrorClass { pub parent_class : PkSourceClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkErrorClass"] [:: std :: mem :: size_of :: < _PkErrorClass > () - 216usize] ; ["Alignment of _PkErrorClass"] [:: std :: mem :: align_of :: < _PkErrorClass > () - 8usize] ; ["Offset of field: _PkErrorClass::parent_class"] [:: std :: mem :: offset_of ! (_PkErrorClass , parent_class) - 0usize] ; ["Offset of field: _PkErrorClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkErrorClass , _pk_reserved1) - 176usize] ; ["Offset of field: _PkErrorClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkErrorClass , _pk_reserved2) - 184usize] ; ["Offset of field: _PkErrorClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkErrorClass , _pk_reserved3) - 192usize] ; ["Offset of field: _PkErrorClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkErrorClass , _pk_reserved4) - 200usize] ; ["Offset of field: _PkErrorClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkErrorClass , _pk_reserved5) - 208usize] ; } ; unsafe extern "C" { pub fn pk_error_get_type () -> GType ; } unsafe extern "C" { pub fn pk_error_new () -> * mut PkError ; } unsafe extern "C" { pub fn pk_error_get_code (error_code : * mut PkError) -> PkErrorEnum ; } unsafe extern "C" { pub fn pk_error_get_details (error_code : * mut PkError) -> * const gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkEulaRequiredPrivate { _unused : [u8 ; 0] , } pub type PkEulaRequiredPrivate = _PkEulaRequiredPrivate ; pub type PkEulaRequired = _PkEulaRequired ; pub type PkEulaRequiredClass = _PkEulaRequiredClass ; pub type PkEulaRequired_autoptr = * mut PkEulaRequired ; pub type PkEulaRequired_listautoptr = * mut GList ; pub type PkEulaRequired_slistautoptr = * mut GSList ; pub type PkEulaRequired_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkEulaRequired { pub parent : PkSource , pub priv_ : * mut PkEulaRequiredPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkEulaRequired"] [:: std :: mem :: size_of :: < _PkEulaRequired > () - 40usize] ; ["Alignment of _PkEulaRequired"] [:: std :: mem :: align_of :: < _PkEulaRequired > () - 8usize] ; ["Offset of field: _PkEulaRequired::parent"] [:: std :: mem :: offset_of ! (_PkEulaRequired , parent) - 0usize] ; ["Offset of field: _PkEulaRequired::priv_"] [:: std :: mem :: offset_of ! (_PkEulaRequired , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkEulaRequiredClass { pub parent_class : PkSourceClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkEulaRequiredClass"] [:: std :: mem :: size_of :: < _PkEulaRequiredClass > () - 216usize] ; ["Alignment of _PkEulaRequiredClass"] [:: std :: mem :: align_of :: < _PkEulaRequiredClass > () - 8usize] ; ["Offset of field: _PkEulaRequiredClass::parent_class"] [:: std :: mem :: offset_of ! (_PkEulaRequiredClass , parent_class) - 0usize] ; ["Offset of field: _PkEulaRequiredClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkEulaRequiredClass , _pk_reserved1) - 176usize] ; ["Offset of field: _PkEulaRequiredClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkEulaRequiredClass , _pk_reserved2) - 184usize] ; ["Offset of field: _PkEulaRequiredClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkEulaRequiredClass , _pk_reserved3) - 192usize] ; ["Offset of field: _PkEulaRequiredClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkEulaRequiredClass , _pk_reserved4) - 200usize] ; ["Offset of field: _PkEulaRequiredClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkEulaRequiredClass , _pk_reserved5) - 208usize] ; } ; unsafe extern "C" { pub fn pk_eula_required_get_type () -> GType ; } unsafe extern "C" { pub fn pk_eula_required_new () -> * mut PkEulaRequired ; } unsafe extern "C" { pub fn pk_eula_required_get_eula_id (eula_required : * mut PkEulaRequired) -> * const gchar ; } unsafe extern "C" { pub fn pk_eula_required_get_package_id (eula_required : * mut PkEulaRequired) -> * const gchar ; } unsafe extern "C" { pub fn pk_eula_required_get_vendor_name (eula_required : * mut PkEulaRequired) -> * const gchar ; } unsafe extern "C" { pub fn pk_eula_required_get_license_agreement (eula_required : * mut PkEulaRequired) -> * const gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkFilesPrivate { _unused : [u8 ; 0] , } pub type PkFilesPrivate = _PkFilesPrivate ; pub type PkFiles = _PkFiles ; pub type PkFilesClass = _PkFilesClass ; pub type PkFiles_autoptr = * mut PkFiles ; pub type PkFiles_listautoptr = * mut GList ; pub type PkFiles_slistautoptr = * mut GSList ; pub type PkFiles_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkFiles { pub parent : PkSource , pub priv_ : * mut PkFilesPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkFiles"] [:: std :: mem :: size_of :: < _PkFiles > () - 40usize] ; ["Alignment of _PkFiles"] [:: std :: mem :: align_of :: < _PkFiles > () - 8usize] ; ["Offset of field: _PkFiles::parent"] [:: std :: mem :: offset_of ! (_PkFiles , parent) - 0usize] ; ["Offset of field: _PkFiles::priv_"] [:: std :: mem :: offset_of ! (_PkFiles , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkFilesClass { pub parent_class : PkSourceClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkFilesClass"] [:: std :: mem :: size_of :: < _PkFilesClass > () - 216usize] ; ["Alignment of _PkFilesClass"] [:: std :: mem :: align_of :: < _PkFilesClass > () - 8usize] ; ["Offset of field: _PkFilesClass::parent_class"] [:: std :: mem :: offset_of ! (_PkFilesClass , parent_class) - 0usize] ; ["Offset of field: _PkFilesClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkFilesClass , _pk_reserved1) - 176usize] ; ["Offset of field: _PkFilesClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkFilesClass , _pk_reserved2) - 184usize] ; ["Offset of field: _PkFilesClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkFilesClass , _pk_reserved3) - 192usize] ; ["Offset of field: _PkFilesClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkFilesClass , _pk_reserved4) - 200usize] ; ["Offset of field: _PkFilesClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkFilesClass , _pk_reserved5) - 208usize] ; } ; unsafe extern "C" { pub fn pk_files_get_type () -> GType ; } unsafe extern "C" { pub fn pk_files_new () -> * mut PkFiles ; } unsafe extern "C" { pub fn pk_files_get_package_id (files : * mut PkFiles) -> * const gchar ; } unsafe extern "C" { pub fn pk_files_get_files (files : * mut PkFiles) -> * mut * mut gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkMediaChangeRequiredPrivate { _unused : [u8 ; 0] , } pub type PkMediaChangeRequiredPrivate = _PkMediaChangeRequiredPrivate ; pub type PkMediaChangeRequired = _PkMediaChangeRequired ; pub type PkMediaChangeRequiredClass = _PkMediaChangeRequiredClass ; pub type PkMediaChangeRequired_autoptr = * mut PkMediaChangeRequired ; pub type PkMediaChangeRequired_listautoptr = * mut GList ; pub type PkMediaChangeRequired_slistautoptr = * mut GSList ; pub type PkMediaChangeRequired_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkMediaChangeRequired { pub parent : PkSource , pub priv_ : * mut PkMediaChangeRequiredPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkMediaChangeRequired"] [:: std :: mem :: size_of :: < _PkMediaChangeRequired > () - 40usize] ; ["Alignment of _PkMediaChangeRequired"] [:: std :: mem :: align_of :: < _PkMediaChangeRequired > () - 8usize] ; ["Offset of field: _PkMediaChangeRequired::parent"] [:: std :: mem :: offset_of ! (_PkMediaChangeRequired , parent) - 0usize] ; ["Offset of field: _PkMediaChangeRequired::priv_"] [:: std :: mem :: offset_of ! (_PkMediaChangeRequired , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkMediaChangeRequiredClass { pub parent_class : PkSourceClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkMediaChangeRequiredClass"] [:: std :: mem :: size_of :: < _PkMediaChangeRequiredClass > () - 216usize] ; ["Alignment of _PkMediaChangeRequiredClass"] [:: std :: mem :: align_of :: < _PkMediaChangeRequiredClass > () - 8usize] ; ["Offset of field: _PkMediaChangeRequiredClass::parent_class"] [:: std :: mem :: offset_of ! (_PkMediaChangeRequiredClass , parent_class) - 0usize] ; ["Offset of field: _PkMediaChangeRequiredClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkMediaChangeRequiredClass , _pk_reserved1) - 176usize] ; ["Offset of field: _PkMediaChangeRequiredClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkMediaChangeRequiredClass , _pk_reserved2) - 184usize] ; ["Offset of field: _PkMediaChangeRequiredClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkMediaChangeRequiredClass , _pk_reserved3) - 192usize] ; ["Offset of field: _PkMediaChangeRequiredClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkMediaChangeRequiredClass , _pk_reserved4) - 200usize] ; ["Offset of field: _PkMediaChangeRequiredClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkMediaChangeRequiredClass , _pk_reserved5) - 208usize] ; } ; unsafe extern "C" { pub fn pk_media_change_required_get_type () -> GType ; } unsafe extern "C" { pub fn pk_media_change_required_new () -> * mut PkMediaChangeRequired ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkPackagePrivate { _unused : [u8 ; 0] , } pub type PkPackagePrivate = _PkPackagePrivate ; pub type PkPackage = _PkPackage ; pub type PkPackageClass = _PkPackageClass ; pub type PkPackage_autoptr = * mut PkPackage ; pub type PkPackage_listautoptr = * mut GList ; pub type PkPackage_slistautoptr = * mut GSList ; pub type PkPackage_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkPackage { pub parent : PkSource , pub priv_ : * mut PkPackagePrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkPackage"] [:: std :: mem :: size_of :: < _PkPackage > () - 40usize] ; ["Alignment of _PkPackage"] [:: std :: mem :: align_of :: < _PkPackage > () - 8usize] ; ["Offset of field: _PkPackage::parent"] [:: std :: mem :: offset_of ! (_PkPackage , parent) - 0usize] ; ["Offset of field: _PkPackage::priv_"] [:: std :: mem :: offset_of ! (_PkPackage , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkPackageClass { pub parent_class : PkSourceClass , pub changed : :: std :: option :: Option < unsafe extern "C" fn (package : * mut PkPackage) > , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkPackageClass"] [:: std :: mem :: size_of :: < _PkPackageClass > () - 224usize] ; ["Alignment of _PkPackageClass"] [:: std :: mem :: align_of :: < _PkPackageClass > () - 8usize] ; ["Offset of field: _PkPackageClass::parent_class"] [:: std :: mem :: offset_of ! (_PkPackageClass , parent_class) - 0usize] ; ["Offset of field: _PkPackageClass::changed"] [:: std :: mem :: offset_of ! (_PkPackageClass , changed) - 176usize] ; ["Offset of field: _PkPackageClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkPackageClass , _pk_reserved1) - 184usize] ; ["Offset of field: _PkPackageClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkPackageClass , _pk_reserved2) - 192usize] ; ["Offset of field: _PkPackageClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkPackageClass , _pk_reserved3) - 200usize] ; ["Offset of field: _PkPackageClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkPackageClass , _pk_reserved4) - 208usize] ; ["Offset of field: _PkPackageClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkPackageClass , _pk_reserved5) - 216usize] ; } ; unsafe extern "C" { pub fn pk_package_get_type () -> GType ; } unsafe extern "C" { pub fn pk_package_new () -> * mut PkPackage ; } unsafe extern "C" { pub fn pk_package_set_id (package : * mut PkPackage , package_id : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_package_parse (package : * mut PkPackage , data : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_package_print (package : * mut PkPackage) ; } unsafe extern "C" { pub fn pk_package_equal (package1 : * mut PkPackage , package2 : * mut PkPackage) -> gboolean ; } unsafe extern "C" { pub fn pk_package_equal_id (package1 : * mut PkPackage , package2 : * mut PkPackage) -> gboolean ; } unsafe extern "C" { pub fn pk_package_get_id (package : * mut PkPackage) -> * const gchar ; } unsafe extern "C" { pub fn pk_package_get_info (package : * mut PkPackage) -> PkInfoEnum ; } unsafe extern "C" { pub fn pk_package_set_info (package : * mut PkPackage , info : PkInfoEnum) ; } unsafe extern "C" { pub fn pk_package_get_summary (package : * mut PkPackage) -> * const gchar ; } unsafe extern "C" { pub fn pk_package_set_summary (package : * mut PkPackage , summary : * const gchar) ; } unsafe extern "C" { pub fn pk_package_get_name (package : * mut PkPackage) -> * const gchar ; } unsafe extern "C" { pub fn pk_package_get_version (package : * mut PkPackage) -> * const gchar ; } unsafe extern "C" { pub fn pk_package_get_arch (package : * mut PkPackage) -> * const gchar ; } unsafe extern "C" { pub fn pk_package_get_data (package : * mut PkPackage) -> * const gchar ; } unsafe extern "C" { pub fn pk_package_get_update_severity (package : * mut PkPackage) -> PkInfoEnum ; } unsafe extern "C" { pub fn pk_package_set_update_severity (package : * mut PkPackage , update_severity : PkInfoEnum) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkItemProgressPrivate { _unused : [u8 ; 0] , } pub type PkItemProgressPrivate = _PkItemProgressPrivate ; pub type PkItemProgress = _PkItemProgress ; pub type PkItemProgressClass = _PkItemProgressClass ; pub type PkItemProgress_autoptr = * mut PkItemProgress ; pub type PkItemProgress_listautoptr = * mut GList ; pub type PkItemProgress_slistautoptr = * mut GSList ; pub type PkItemProgress_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkItemProgress { pub parent : PkSource , pub priv_ : * mut PkItemProgressPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkItemProgress"] [:: std :: mem :: size_of :: < _PkItemProgress > () - 40usize] ; ["Alignment of _PkItemProgress"] [:: std :: mem :: align_of :: < _PkItemProgress > () - 8usize] ; ["Offset of field: _PkItemProgress::parent"] [:: std :: mem :: offset_of ! (_PkItemProgress , parent) - 0usize] ; ["Offset of field: _PkItemProgress::priv_"] [:: std :: mem :: offset_of ! (_PkItemProgress , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkItemProgressClass { pub parent_class : PkSourceClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkItemProgressClass"] [:: std :: mem :: size_of :: < _PkItemProgressClass > () - 216usize] ; ["Alignment of _PkItemProgressClass"] [:: std :: mem :: align_of :: < _PkItemProgressClass > () - 8usize] ; ["Offset of field: _PkItemProgressClass::parent_class"] [:: std :: mem :: offset_of ! (_PkItemProgressClass , parent_class) - 0usize] ; ["Offset of field: _PkItemProgressClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkItemProgressClass , _pk_reserved1) - 176usize] ; ["Offset of field: _PkItemProgressClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkItemProgressClass , _pk_reserved2) - 184usize] ; ["Offset of field: _PkItemProgressClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkItemProgressClass , _pk_reserved3) - 192usize] ; ["Offset of field: _PkItemProgressClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkItemProgressClass , _pk_reserved4) - 200usize] ; ["Offset of field: _PkItemProgressClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkItemProgressClass , _pk_reserved5) - 208usize] ; } ; unsafe extern "C" { pub fn pk_item_progress_get_type () -> GType ; } unsafe extern "C" { pub fn pk_item_progress_new () -> * mut PkItemProgress ; } unsafe extern "C" { pub fn pk_item_progress_get_status (item_progress : * mut PkItemProgress) -> PkStatusEnum ; } unsafe extern "C" { pub fn pk_item_progress_get_percentage (item_progress : * mut PkItemProgress) -> guint ; } unsafe extern "C" { pub fn pk_item_progress_get_package_id (item_progress : * mut PkItemProgress) -> * const gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkProgressPrivate { _unused : [u8 ; 0] , } pub type PkProgressPrivate = _PkProgressPrivate ; pub type PkProgress = _PkProgress ; pub type PkProgressClass = _PkProgressClass ; pub type PkProgress_autoptr = * mut PkProgress ; pub type PkProgress_listautoptr = * mut GList ; pub type PkProgress_slistautoptr = * mut GSList ; pub type PkProgress_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkProgress { pub parent : GObject , pub priv_ : * mut PkProgressPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkProgress"] [:: std :: mem :: size_of :: < _PkProgress > () - 32usize] ; ["Alignment of _PkProgress"] [:: std :: mem :: align_of :: < _PkProgress > () - 8usize] ; ["Offset of field: _PkProgress::parent"] [:: std :: mem :: offset_of ! (_PkProgress , parent) - 0usize] ; ["Offset of field: _PkProgress::priv_"] [:: std :: mem :: offset_of ! (_PkProgress , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkProgressClass { pub parent_class : GObjectClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkProgressClass"] [:: std :: mem :: size_of :: < _PkProgressClass > () - 176usize] ; ["Alignment of _PkProgressClass"] [:: std :: mem :: align_of :: < _PkProgressClass > () - 8usize] ; ["Offset of field: _PkProgressClass::parent_class"] [:: std :: mem :: offset_of ! (_PkProgressClass , parent_class) - 0usize] ; ["Offset of field: _PkProgressClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkProgressClass , _pk_reserved1) - 136usize] ; ["Offset of field: _PkProgressClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkProgressClass , _pk_reserved2) - 144usize] ; ["Offset of field: _PkProgressClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkProgressClass , _pk_reserved3) - 152usize] ; ["Offset of field: _PkProgressClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkProgressClass , _pk_reserved4) - 160usize] ; ["Offset of field: _PkProgressClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkProgressClass , _pk_reserved5) - 168usize] ; } ; unsafe extern "C" { pub fn pk_progress_get_type () -> GType ; } unsafe extern "C" { pub fn pk_progress_new () -> * mut PkProgress ; } pub const PkProgressType_PK_PROGRESS_TYPE_PACKAGE_ID : PkProgressType = 0 ; pub const PkProgressType_PK_PROGRESS_TYPE_TRANSACTION_ID : PkProgressType = 1 ; pub const PkProgressType_PK_PROGRESS_TYPE_PERCENTAGE : PkProgressType = 2 ; pub const PkProgressType_PK_PROGRESS_TYPE_ALLOW_CANCEL : PkProgressType = 3 ; pub const PkProgressType_PK_PROGRESS_TYPE_STATUS : PkProgressType = 4 ; pub const PkProgressType_PK_PROGRESS_TYPE_ROLE : PkProgressType = 5 ; pub const PkProgressType_PK_PROGRESS_TYPE_CALLER_ACTIVE : PkProgressType = 6 ; pub const PkProgressType_PK_PROGRESS_TYPE_ELAPSED_TIME : PkProgressType = 7 ; pub const PkProgressType_PK_PROGRESS_TYPE_REMAINING_TIME : PkProgressType = 8 ; pub const PkProgressType_PK_PROGRESS_TYPE_SPEED : PkProgressType = 9 ; pub const PkProgressType_PK_PROGRESS_TYPE_DOWNLOAD_SIZE_REMAINING : PkProgressType = 10 ; pub const PkProgressType_PK_PROGRESS_TYPE_UID : PkProgressType = 11 ; pub const PkProgressType_PK_PROGRESS_TYPE_PACKAGE : PkProgressType = 12 ; pub const PkProgressType_PK_PROGRESS_TYPE_ITEM_PROGRESS : PkProgressType = 13 ; pub const PkProgressType_PK_PROGRESS_TYPE_TRANSACTION_FLAGS : PkProgressType = 14 ; pub const PkProgressType_PK_PROGRESS_TYPE_INVALID : PkProgressType = 15 ; pub const PkProgressType_PK_PROGRESS_TYPE_SENDER : PkProgressType = 16 ; pub type PkProgressType = :: std :: os :: raw :: c_uint ; pub type PkProgressCallback = :: std :: option :: Option < unsafe extern "C" fn (progress : * mut PkProgress , type_ : PkProgressType , user_data : gpointer) > ; unsafe extern "C" { pub fn pk_progress_set_package_id (progress : * mut PkProgress , package_id : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_package_id (progress : * mut PkProgress) -> * const gchar ; } unsafe extern "C" { pub fn pk_progress_set_item_progress (progress : * mut PkProgress , item_progress : * mut PkItemProgress) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_item_progress (progress : * mut PkProgress) -> * mut PkItemProgress ; } unsafe extern "C" { pub fn pk_progress_set_transaction_id (progress : * mut PkProgress , transaction_id : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_transaction_id (progress : * mut PkProgress) -> * const gchar ; } unsafe extern "C" { pub fn pk_progress_set_percentage (progress : * mut PkProgress , percentage : gint) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_percentage (progress : * mut PkProgress) -> gint ; } unsafe extern "C" { pub fn pk_progress_set_status (progress : * mut PkProgress , status : PkStatusEnum) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_status (progress : * mut PkProgress) -> PkStatusEnum ; } unsafe extern "C" { pub fn pk_progress_set_role (progress : * mut PkProgress , role : PkRoleEnum) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_role (progress : * mut PkProgress) -> PkRoleEnum ; } unsafe extern "C" { pub fn pk_progress_set_allow_cancel (progress : * mut PkProgress , allow_cancel : gboolean) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_allow_cancel (progress : * mut PkProgress) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_set_caller_active (progress : * mut PkProgress , caller_active : gboolean) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_caller_active (progress : * mut PkProgress) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_set_elapsed_time (progress : * mut PkProgress , elapsed_time : guint) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_elapsed_time (progress : * mut PkProgress) -> guint ; } unsafe extern "C" { pub fn pk_progress_set_remaining_time (progress : * mut PkProgress , remaining_time : guint) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_remaining_time (progress : * mut PkProgress) -> guint ; } unsafe extern "C" { pub fn pk_progress_set_speed (progress : * mut PkProgress , speed : guint) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_speed (progress : * mut PkProgress) -> guint ; } unsafe extern "C" { pub fn pk_progress_set_download_size_remaining (progress : * mut PkProgress , download_size_remaining : guint64) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_download_size_remaining (progress : * mut PkProgress) -> guint64 ; } unsafe extern "C" { pub fn pk_progress_set_transaction_flags (progress : * mut PkProgress , transaction_flags : guint64) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_transaction_flags (progress : * mut PkProgress) -> guint64 ; } unsafe extern "C" { pub fn pk_progress_set_uid (progress : * mut PkProgress , uid : guint) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_uid (progress : * mut PkProgress) -> guint ; } unsafe extern "C" { pub fn pk_progress_set_sender (progress : * mut PkProgress , bus_name : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_sender (progress : * mut PkProgress) -> * mut gchar ; } unsafe extern "C" { pub fn pk_progress_set_package (progress : * mut PkProgress , package : * mut PkPackage) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_get_package (progress : * mut PkProgress) -> * mut PkPackage ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkPackageSackPrivate { _unused : [u8 ; 0] , } pub type PkPackageSackPrivate = _PkPackageSackPrivate ; pub type PkPackageSack = _PkPackageSack ; pub type PkPackageSackClass = _PkPackageSackClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkPackageSackResults { _unused : [u8 ; 0] , } pub type PkPackageSackResults = _PkPackageSackResults ; pub type PkPackageSack_autoptr = * mut PkPackageSack ; pub type PkPackageSack_listautoptr = * mut GList ; pub type PkPackageSack_slistautoptr = * mut GSList ; pub type PkPackageSack_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkPackageSack { pub parent : GObject , pub priv_ : * mut PkPackageSackPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkPackageSack"] [:: std :: mem :: size_of :: < _PkPackageSack > () - 32usize] ; ["Alignment of _PkPackageSack"] [:: std :: mem :: align_of :: < _PkPackageSack > () - 8usize] ; ["Offset of field: _PkPackageSack::parent"] [:: std :: mem :: offset_of ! (_PkPackageSack , parent) - 0usize] ; ["Offset of field: _PkPackageSack::priv_"] [:: std :: mem :: offset_of ! (_PkPackageSack , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkPackageSackClass { pub parent_class : GObjectClass , pub changed : :: std :: option :: Option < unsafe extern "C" fn (sack : * mut PkPackageSack) > , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkPackageSackClass"] [:: std :: mem :: size_of :: < _PkPackageSackClass > () - 184usize] ; ["Alignment of _PkPackageSackClass"] [:: std :: mem :: align_of :: < _PkPackageSackClass > () - 8usize] ; ["Offset of field: _PkPackageSackClass::parent_class"] [:: std :: mem :: offset_of ! (_PkPackageSackClass , parent_class) - 0usize] ; ["Offset of field: _PkPackageSackClass::changed"] [:: std :: mem :: offset_of ! (_PkPackageSackClass , changed) - 136usize] ; ["Offset of field: _PkPackageSackClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkPackageSackClass , _pk_reserved1) - 144usize] ; ["Offset of field: _PkPackageSackClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkPackageSackClass , _pk_reserved2) - 152usize] ; ["Offset of field: _PkPackageSackClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkPackageSackClass , _pk_reserved3) - 160usize] ; ["Offset of field: _PkPackageSackClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkPackageSackClass , _pk_reserved4) - 168usize] ; ["Offset of field: _PkPackageSackClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkPackageSackClass , _pk_reserved5) - 176usize] ; } ; pub const PkPackageSackSortType_PK_PACKAGE_SACK_SORT_TYPE_NAME : PkPackageSackSortType = 0 ; pub const PkPackageSackSortType_PK_PACKAGE_SACK_SORT_TYPE_INFO : PkPackageSackSortType = 1 ; pub const PkPackageSackSortType_PK_PACKAGE_SACK_SORT_TYPE_PACKAGE_ID : PkPackageSackSortType = 2 ; pub const PkPackageSackSortType_PK_PACKAGE_SACK_SORT_TYPE_SUMMARY : PkPackageSackSortType = 3 ; pub const PkPackageSackSortType_PK_PACKAGE_SACK_SORT_TYPE_LAST : PkPackageSackSortType = 4 ; pub type PkPackageSackSortType = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn pk_package_sack_get_type () -> GType ; } unsafe extern "C" { pub fn pk_package_sack_new () -> * mut PkPackageSack ; } pub type PkPackageSackFilterFunc = :: std :: option :: Option < unsafe extern "C" fn (package : * mut PkPackage , user_data : gpointer) -> gboolean > ; unsafe extern "C" { pub fn pk_package_sack_clear (sack : * mut PkPackageSack) ; } unsafe extern "C" { pub fn pk_package_sack_get_ids (sack : * mut PkPackageSack) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_package_sack_get_size (sack : * mut PkPackageSack) -> guint ; } unsafe extern "C" { pub fn pk_package_sack_get_array (sack : * mut PkPackageSack) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_package_sack_sort (sack : * mut PkPackageSack , type_ : PkPackageSackSortType) ; } unsafe extern "C" { pub fn pk_package_sack_add_package (sack : * mut PkPackageSack , package : * mut PkPackage) -> gboolean ; } unsafe extern "C" { pub fn pk_package_sack_add_package_by_id (sack : * mut PkPackageSack , package_id : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_package_sack_add_packages_from_file (sack : * mut PkPackageSack , file : * mut GFile , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_package_sack_to_file (sack : * mut PkPackageSack , file : * mut GFile , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_package_sack_remove_package (sack : * mut PkPackageSack , package : * mut PkPackage) -> gboolean ; } unsafe extern "C" { pub fn pk_package_sack_remove_package_by_id (sack : * mut PkPackageSack , package_id : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_package_sack_remove_by_filter (sack : * mut PkPackageSack , filter_cb : PkPackageSackFilterFunc , user_data : gpointer) -> gboolean ; } unsafe extern "C" { pub fn pk_package_sack_find_by_id (sack : * mut PkPackageSack , package_id : * const gchar) -> * mut PkPackage ; } unsafe extern "C" { pub fn pk_package_sack_find_by_id_name_arch (sack : * mut PkPackageSack , package_id : * const gchar) -> * mut PkPackage ; } unsafe extern "C" { pub fn pk_package_sack_filter_by_info (sack : * mut PkPackageSack , info : PkInfoEnum) -> * mut PkPackageSack ; } unsafe extern "C" { pub fn pk_package_sack_filter (sack : * mut PkPackageSack , filter_cb : PkPackageSackFilterFunc , user_data : gpointer) -> * mut PkPackageSack ; } unsafe extern "C" { pub fn pk_package_sack_get_total_bytes (sack : * mut PkPackageSack) -> guint64 ; } unsafe extern "C" { pub fn pk_package_sack_merge_generic_finish (sack : * mut PkPackageSack , res : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_package_sack_resolve_async (sack : * mut PkPackageSack , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_package_sack_get_details_async (sack : * mut PkPackageSack , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_package_sack_get_update_detail_async (sack : * mut PkPackageSack , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback : GAsyncReadyCallback , user_data : gpointer) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkRepoDetailPrivate { _unused : [u8 ; 0] , } pub type PkRepoDetailPrivate = _PkRepoDetailPrivate ; pub type PkRepoDetail = _PkRepoDetail ; pub type PkRepoDetailClass = _PkRepoDetailClass ; pub type PkRepoDetail_autoptr = * mut PkRepoDetail ; pub type PkRepoDetail_listautoptr = * mut GList ; pub type PkRepoDetail_slistautoptr = * mut GSList ; pub type PkRepoDetail_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkRepoDetail { pub parent : PkSource , pub priv_ : * mut PkRepoDetailPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkRepoDetail"] [:: std :: mem :: size_of :: < _PkRepoDetail > () - 40usize] ; ["Alignment of _PkRepoDetail"] [:: std :: mem :: align_of :: < _PkRepoDetail > () - 8usize] ; ["Offset of field: _PkRepoDetail::parent"] [:: std :: mem :: offset_of ! (_PkRepoDetail , parent) - 0usize] ; ["Offset of field: _PkRepoDetail::priv_"] [:: std :: mem :: offset_of ! (_PkRepoDetail , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkRepoDetailClass { pub parent_class : PkSourceClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkRepoDetailClass"] [:: std :: mem :: size_of :: < _PkRepoDetailClass > () - 216usize] ; ["Alignment of _PkRepoDetailClass"] [:: std :: mem :: align_of :: < _PkRepoDetailClass > () - 8usize] ; ["Offset of field: _PkRepoDetailClass::parent_class"] [:: std :: mem :: offset_of ! (_PkRepoDetailClass , parent_class) - 0usize] ; ["Offset of field: _PkRepoDetailClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkRepoDetailClass , _pk_reserved1) - 176usize] ; ["Offset of field: _PkRepoDetailClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkRepoDetailClass , _pk_reserved2) - 184usize] ; ["Offset of field: _PkRepoDetailClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkRepoDetailClass , _pk_reserved3) - 192usize] ; ["Offset of field: _PkRepoDetailClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkRepoDetailClass , _pk_reserved4) - 200usize] ; ["Offset of field: _PkRepoDetailClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkRepoDetailClass , _pk_reserved5) - 208usize] ; } ; unsafe extern "C" { pub fn pk_repo_detail_get_type () -> GType ; } unsafe extern "C" { pub fn pk_repo_detail_new () -> * mut PkRepoDetail ; } unsafe extern "C" { pub fn pk_repo_detail_get_id (repo_detail : * mut PkRepoDetail) -> * const gchar ; } unsafe extern "C" { pub fn pk_repo_detail_get_description (repo_detail : * mut PkRepoDetail) -> * const gchar ; } unsafe extern "C" { pub fn pk_repo_detail_get_enabled (repo_detail : * mut PkRepoDetail) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkRepoSignatureRequiredPrivate { _unused : [u8 ; 0] , } pub type PkRepoSignatureRequiredPrivate = _PkRepoSignatureRequiredPrivate ; pub type PkRepoSignatureRequired = _PkRepoSignatureRequired ; pub type PkRepoSignatureRequiredClass = _PkRepoSignatureRequiredClass ; pub type PkRepoSignatureRequired_autoptr = * mut PkRepoSignatureRequired ; pub type PkRepoSignatureRequired_listautoptr = * mut GList ; pub type PkRepoSignatureRequired_slistautoptr = * mut GSList ; pub type PkRepoSignatureRequired_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkRepoSignatureRequired { pub parent : PkSource , pub priv_ : * mut PkRepoSignatureRequiredPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkRepoSignatureRequired"] [:: std :: mem :: size_of :: < _PkRepoSignatureRequired > () - 40usize] ; ["Alignment of _PkRepoSignatureRequired"] [:: std :: mem :: align_of :: < _PkRepoSignatureRequired > () - 8usize] ; ["Offset of field: _PkRepoSignatureRequired::parent"] [:: std :: mem :: offset_of ! (_PkRepoSignatureRequired , parent) - 0usize] ; ["Offset of field: _PkRepoSignatureRequired::priv_"] [:: std :: mem :: offset_of ! (_PkRepoSignatureRequired , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkRepoSignatureRequiredClass { pub parent_class : PkSourceClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkRepoSignatureRequiredClass"] [:: std :: mem :: size_of :: < _PkRepoSignatureRequiredClass > () - 216usize] ; ["Alignment of _PkRepoSignatureRequiredClass"] [:: std :: mem :: align_of :: < _PkRepoSignatureRequiredClass > () - 8usize] ; ["Offset of field: _PkRepoSignatureRequiredClass::parent_class"] [:: std :: mem :: offset_of ! (_PkRepoSignatureRequiredClass , parent_class) - 0usize] ; ["Offset of field: _PkRepoSignatureRequiredClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkRepoSignatureRequiredClass , _pk_reserved1) - 176usize] ; ["Offset of field: _PkRepoSignatureRequiredClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkRepoSignatureRequiredClass , _pk_reserved2) - 184usize] ; ["Offset of field: _PkRepoSignatureRequiredClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkRepoSignatureRequiredClass , _pk_reserved3) - 192usize] ; ["Offset of field: _PkRepoSignatureRequiredClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkRepoSignatureRequiredClass , _pk_reserved4) - 200usize] ; ["Offset of field: _PkRepoSignatureRequiredClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkRepoSignatureRequiredClass , _pk_reserved5) - 208usize] ; } ; unsafe extern "C" { pub fn pk_repo_signature_required_get_type () -> GType ; } unsafe extern "C" { pub fn pk_repo_signature_required_new () -> * mut PkRepoSignatureRequired ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkRequireRestartPrivate { _unused : [u8 ; 0] , } pub type PkRequireRestartPrivate = _PkRequireRestartPrivate ; pub type PkRequireRestart = _PkRequireRestart ; pub type PkRequireRestartClass = _PkRequireRestartClass ; pub type PkRequireRestart_autoptr = * mut PkRequireRestart ; pub type PkRequireRestart_listautoptr = * mut GList ; pub type PkRequireRestart_slistautoptr = * mut GSList ; pub type PkRequireRestart_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkRequireRestart { pub parent : PkSource , pub priv_ : * mut PkRequireRestartPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkRequireRestart"] [:: std :: mem :: size_of :: < _PkRequireRestart > () - 40usize] ; ["Alignment of _PkRequireRestart"] [:: std :: mem :: align_of :: < _PkRequireRestart > () - 8usize] ; ["Offset of field: _PkRequireRestart::parent"] [:: std :: mem :: offset_of ! (_PkRequireRestart , parent) - 0usize] ; ["Offset of field: _PkRequireRestart::priv_"] [:: std :: mem :: offset_of ! (_PkRequireRestart , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkRequireRestartClass { pub parent_class : PkSourceClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkRequireRestartClass"] [:: std :: mem :: size_of :: < _PkRequireRestartClass > () - 216usize] ; ["Alignment of _PkRequireRestartClass"] [:: std :: mem :: align_of :: < _PkRequireRestartClass > () - 8usize] ; ["Offset of field: _PkRequireRestartClass::parent_class"] [:: std :: mem :: offset_of ! (_PkRequireRestartClass , parent_class) - 0usize] ; ["Offset of field: _PkRequireRestartClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkRequireRestartClass , _pk_reserved1) - 176usize] ; ["Offset of field: _PkRequireRestartClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkRequireRestartClass , _pk_reserved2) - 184usize] ; ["Offset of field: _PkRequireRestartClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkRequireRestartClass , _pk_reserved3) - 192usize] ; ["Offset of field: _PkRequireRestartClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkRequireRestartClass , _pk_reserved4) - 200usize] ; ["Offset of field: _PkRequireRestartClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkRequireRestartClass , _pk_reserved5) - 208usize] ; } ; unsafe extern "C" { pub fn pk_require_restart_get_type () -> GType ; } unsafe extern "C" { pub fn pk_require_restart_new () -> * mut PkRequireRestart ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTransactionPastPrivate { _unused : [u8 ; 0] , } pub type PkTransactionPastPrivate = _PkTransactionPastPrivate ; pub type PkTransactionPast = _PkTransactionPast ; pub type PkTransactionPastClass = _PkTransactionPastClass ; pub type PkTransactionPast_autoptr = * mut PkTransactionPast ; pub type PkTransactionPast_listautoptr = * mut GList ; pub type PkTransactionPast_slistautoptr = * mut GSList ; pub type PkTransactionPast_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTransactionPast { pub parent : PkSource , pub priv_ : * mut PkTransactionPastPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkTransactionPast"] [:: std :: mem :: size_of :: < _PkTransactionPast > () - 40usize] ; ["Alignment of _PkTransactionPast"] [:: std :: mem :: align_of :: < _PkTransactionPast > () - 8usize] ; ["Offset of field: _PkTransactionPast::parent"] [:: std :: mem :: offset_of ! (_PkTransactionPast , parent) - 0usize] ; ["Offset of field: _PkTransactionPast::priv_"] [:: std :: mem :: offset_of ! (_PkTransactionPast , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTransactionPastClass { pub parent_class : PkSourceClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkTransactionPastClass"] [:: std :: mem :: size_of :: < _PkTransactionPastClass > () - 216usize] ; ["Alignment of _PkTransactionPastClass"] [:: std :: mem :: align_of :: < _PkTransactionPastClass > () - 8usize] ; ["Offset of field: _PkTransactionPastClass::parent_class"] [:: std :: mem :: offset_of ! (_PkTransactionPastClass , parent_class) - 0usize] ; ["Offset of field: _PkTransactionPastClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkTransactionPastClass , _pk_reserved1) - 176usize] ; ["Offset of field: _PkTransactionPastClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkTransactionPastClass , _pk_reserved2) - 184usize] ; ["Offset of field: _PkTransactionPastClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkTransactionPastClass , _pk_reserved3) - 192usize] ; ["Offset of field: _PkTransactionPastClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkTransactionPastClass , _pk_reserved4) - 200usize] ; ["Offset of field: _PkTransactionPastClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkTransactionPastClass , _pk_reserved5) - 208usize] ; } ; unsafe extern "C" { pub fn pk_transaction_past_get_type () -> GType ; } unsafe extern "C" { pub fn pk_transaction_past_new () -> * mut PkTransactionPast ; } unsafe extern "C" { pub fn pk_transaction_past_get_cmdline (past : * mut PkTransactionPast) -> * const gchar ; } unsafe extern "C" { pub fn pk_transaction_past_get_data (past : * mut PkTransactionPast) -> * const gchar ; } unsafe extern "C" { pub fn pk_transaction_past_get_id (past : * mut PkTransactionPast) -> * const gchar ; } unsafe extern "C" { pub fn pk_transaction_past_get_timespec (past : * mut PkTransactionPast) -> * const gchar ; } unsafe extern "C" { pub fn pk_transaction_past_get_datetime (past : * mut PkTransactionPast) -> * mut GDateTime ; } unsafe extern "C" { pub fn pk_transaction_past_get_timestamp (past : * mut PkTransactionPast) -> gint64 ; } unsafe extern "C" { pub fn pk_transaction_past_get_succeeded (past : * mut PkTransactionPast) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_past_get_duration (past : * mut PkTransactionPast) -> guint ; } unsafe extern "C" { pub fn pk_transaction_past_get_uid (past : * mut PkTransactionPast) -> guint ; } unsafe extern "C" { pub fn pk_transaction_past_get_role (past : * mut PkTransactionPast) -> PkRoleEnum ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkUpdateDetailPrivate { _unused : [u8 ; 0] , } pub type PkUpdateDetailPrivate = _PkUpdateDetailPrivate ; pub type PkUpdateDetail = _PkUpdateDetail ; pub type PkUpdateDetailClass = _PkUpdateDetailClass ; pub type PkUpdateDetail_autoptr = * mut PkUpdateDetail ; pub type PkUpdateDetail_listautoptr = * mut GList ; pub type PkUpdateDetail_slistautoptr = * mut GSList ; pub type PkUpdateDetail_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkUpdateDetail { pub parent : PkSource , pub priv_ : * mut PkUpdateDetailPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkUpdateDetail"] [:: std :: mem :: size_of :: < _PkUpdateDetail > () - 40usize] ; ["Alignment of _PkUpdateDetail"] [:: std :: mem :: align_of :: < _PkUpdateDetail > () - 8usize] ; ["Offset of field: _PkUpdateDetail::parent"] [:: std :: mem :: offset_of ! (_PkUpdateDetail , parent) - 0usize] ; ["Offset of field: _PkUpdateDetail::priv_"] [:: std :: mem :: offset_of ! (_PkUpdateDetail , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkUpdateDetailClass { pub parent_class : PkSourceClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkUpdateDetailClass"] [:: std :: mem :: size_of :: < _PkUpdateDetailClass > () - 216usize] ; ["Alignment of _PkUpdateDetailClass"] [:: std :: mem :: align_of :: < _PkUpdateDetailClass > () - 8usize] ; ["Offset of field: _PkUpdateDetailClass::parent_class"] [:: std :: mem :: offset_of ! (_PkUpdateDetailClass , parent_class) - 0usize] ; ["Offset of field: _PkUpdateDetailClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkUpdateDetailClass , _pk_reserved1) - 176usize] ; ["Offset of field: _PkUpdateDetailClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkUpdateDetailClass , _pk_reserved2) - 184usize] ; ["Offset of field: _PkUpdateDetailClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkUpdateDetailClass , _pk_reserved3) - 192usize] ; ["Offset of field: _PkUpdateDetailClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkUpdateDetailClass , _pk_reserved4) - 200usize] ; ["Offset of field: _PkUpdateDetailClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkUpdateDetailClass , _pk_reserved5) - 208usize] ; } ; unsafe extern "C" { pub fn pk_update_detail_get_type () -> GType ; } unsafe extern "C" { pub fn pk_update_detail_new () -> * mut PkUpdateDetail ; } unsafe extern "C" { pub fn pk_update_detail_get_package_id (update_detail : * mut PkUpdateDetail) -> * const gchar ; } unsafe extern "C" { pub fn pk_update_detail_get_updates (update_detail : * mut PkUpdateDetail) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_update_detail_get_obsoletes (update_detail : * mut PkUpdateDetail) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_update_detail_get_vendor_urls (update_detail : * mut PkUpdateDetail) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_update_detail_get_bugzilla_urls (update_detail : * mut PkUpdateDetail) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_update_detail_get_cve_urls (update_detail : * mut PkUpdateDetail) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_update_detail_get_restart (update_detail : * mut PkUpdateDetail) -> PkRestartEnum ; } unsafe extern "C" { pub fn pk_update_detail_get_update_text (update_detail : * mut PkUpdateDetail) -> * const gchar ; } unsafe extern "C" { pub fn pk_update_detail_get_changelog (update_detail : * mut PkUpdateDetail) -> * const gchar ; } unsafe extern "C" { pub fn pk_update_detail_get_state (update_detail : * mut PkUpdateDetail) -> PkUpdateStateEnum ; } unsafe extern "C" { pub fn pk_update_detail_get_issued (update_detail : * mut PkUpdateDetail) -> * const gchar ; } unsafe extern "C" { pub fn pk_update_detail_get_updated (update_detail : * mut PkUpdateDetail) -> * const gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkResultsPrivate { _unused : [u8 ; 0] , } pub type PkResultsPrivate = _PkResultsPrivate ; pub type PkResults = _PkResults ; pub type PkResultsClass = _PkResultsClass ; pub type PkResults_autoptr = * mut PkResults ; pub type PkResults_listautoptr = * mut GList ; pub type PkResults_slistautoptr = * mut GSList ; pub type PkResults_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkResults { pub parent : GObject , pub priv_ : * mut PkResultsPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkResults"] [:: std :: mem :: size_of :: < _PkResults > () - 32usize] ; ["Alignment of _PkResults"] [:: std :: mem :: align_of :: < _PkResults > () - 8usize] ; ["Offset of field: _PkResults::parent"] [:: std :: mem :: offset_of ! (_PkResults , parent) - 0usize] ; ["Offset of field: _PkResults::priv_"] [:: std :: mem :: offset_of ! (_PkResults , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkResultsClass { pub parent_class : GObjectClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkResultsClass"] [:: std :: mem :: size_of :: < _PkResultsClass > () - 176usize] ; ["Alignment of _PkResultsClass"] [:: std :: mem :: align_of :: < _PkResultsClass > () - 8usize] ; ["Offset of field: _PkResultsClass::parent_class"] [:: std :: mem :: offset_of ! (_PkResultsClass , parent_class) - 0usize] ; ["Offset of field: _PkResultsClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkResultsClass , _pk_reserved1) - 136usize] ; ["Offset of field: _PkResultsClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkResultsClass , _pk_reserved2) - 144usize] ; ["Offset of field: _PkResultsClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkResultsClass , _pk_reserved3) - 152usize] ; ["Offset of field: _PkResultsClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkResultsClass , _pk_reserved4) - 160usize] ; ["Offset of field: _PkResultsClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkResultsClass , _pk_reserved5) - 168usize] ; } ; unsafe extern "C" { pub fn pk_results_get_type () -> GType ; } unsafe extern "C" { pub fn pk_results_new () -> * mut PkResults ; } unsafe extern "C" { pub fn pk_results_set_exit_code (results : * mut PkResults , exit_enum : PkExitEnum) -> gboolean ; } unsafe extern "C" { pub fn pk_results_set_role (results : * mut PkResults , role : PkRoleEnum) -> gboolean ; } unsafe extern "C" { pub fn pk_results_set_error_code (results : * mut PkResults , item : * mut PkError) -> gboolean ; } unsafe extern "C" { pub fn pk_results_add_package (results : * mut PkResults , item : * mut PkPackage) -> gboolean ; } unsafe extern "C" { pub fn pk_results_add_details (results : * mut PkResults , item : * mut PkDetails) -> gboolean ; } unsafe extern "C" { pub fn pk_results_add_update_detail (results : * mut PkResults , item : * mut PkUpdateDetail) -> gboolean ; } unsafe extern "C" { pub fn pk_results_add_category (results : * mut PkResults , item : * mut PkCategory) -> gboolean ; } unsafe extern "C" { pub fn pk_results_add_distro_upgrade (results : * mut PkResults , item : * mut PkDistroUpgrade) -> gboolean ; } unsafe extern "C" { pub fn pk_results_add_require_restart (results : * mut PkResults , item : * mut PkRequireRestart) -> gboolean ; } unsafe extern "C" { pub fn pk_results_add_transaction (results : * mut PkResults , item : * mut PkTransactionPast) -> gboolean ; } unsafe extern "C" { pub fn pk_results_add_files (results : * mut PkResults , item : * mut PkFiles) -> gboolean ; } unsafe extern "C" { pub fn pk_results_add_repo_signature_required (results : * mut PkResults , item : * mut PkRepoSignatureRequired) -> gboolean ; } unsafe extern "C" { pub fn pk_results_add_eula_required (results : * mut PkResults , item : * mut PkEulaRequired) -> gboolean ; } unsafe extern "C" { pub fn pk_results_add_media_change_required (results : * mut PkResults , item : * mut PkMediaChangeRequired) -> gboolean ; } unsafe extern "C" { pub fn pk_results_add_repo_detail (results : * mut PkResults , item : * mut PkRepoDetail) -> gboolean ; } unsafe extern "C" { pub fn pk_results_get_exit_code (results : * mut PkResults) -> PkExitEnum ; } unsafe extern "C" { pub fn pk_results_get_package_sack (results : * mut PkResults) -> * mut PkPackageSack ; } unsafe extern "C" { pub fn pk_results_get_error_code (results : * mut PkResults) -> * mut PkError ; } unsafe extern "C" { pub fn pk_results_get_role (results : * mut PkResults) -> PkRoleEnum ; } unsafe extern "C" { pub fn pk_results_get_transaction_flags (results : * mut PkResults) -> PkBitfield ; } unsafe extern "C" { pub fn pk_results_get_require_restart_worst (results : * mut PkResults) -> PkRestartEnum ; } unsafe extern "C" { pub fn pk_results_get_package_array (results : * mut PkResults) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_results_get_details_array (results : * mut PkResults) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_results_get_update_detail_array (results : * mut PkResults) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_results_get_category_array (results : * mut PkResults) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_results_get_distro_upgrade_array (results : * mut PkResults) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_results_get_require_restart_array (results : * mut PkResults) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_results_get_transaction_array (results : * mut PkResults) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_results_get_files_array (results : * mut PkResults) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_results_get_repo_signature_required_array (results : * mut PkResults) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_results_get_eula_required_array (results : * mut PkResults) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_results_get_media_change_required_array (results : * mut PkResults) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_results_get_repo_detail_array (results : * mut PkResults) -> * mut GPtrArray ; } pub const PkClientError_PK_CLIENT_ERROR_FAILED : PkClientError = 0 ; pub const PkClientError_PK_CLIENT_ERROR_FAILED_AUTH : PkClientError = 1 ; pub const PkClientError_PK_CLIENT_ERROR_NO_TID : PkClientError = 2 ; pub const PkClientError_PK_CLIENT_ERROR_ALREADY_TID : PkClientError = 3 ; pub const PkClientError_PK_CLIENT_ERROR_ROLE_UNKNOWN : PkClientError = 4 ; pub const PkClientError_PK_CLIENT_ERROR_CANNOT_START_DAEMON : PkClientError = 5 ; pub const PkClientError_PK_CLIENT_ERROR_INVALID_INPUT : PkClientError = 6 ; pub const PkClientError_PK_CLIENT_ERROR_INVALID_FILE : PkClientError = 7 ; pub const PkClientError_PK_CLIENT_ERROR_NOT_SUPPORTED : PkClientError = 8 ; pub const PkClientError_PK_CLIENT_ERROR_DECLINED_SIMULATION : PkClientError = 9 ; pub const PkClientError_PK_CLIENT_ERROR_DECLINED_INTERACTION : PkClientError = 10 ; pub const PkClientError_PK_CLIENT_ERROR_LAST : PkClientError = 11 ; pub type PkClientError = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkClientPrivate { _unused : [u8 ; 0] , } pub type PkClientPrivate = _PkClientPrivate ; pub type PkClient = _PkClient ; pub type PkClientClass = _PkClientClass ; pub type PkClient_autoptr = * mut PkClient ; pub type PkClient_listautoptr = * mut GList ; pub type PkClient_slistautoptr = * mut GSList ; pub type PkClient_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkClient { pub parent : GObject , pub priv_ : * mut PkClientPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkClient"] [:: std :: mem :: size_of :: < _PkClient > () - 32usize] ; ["Alignment of _PkClient"] [:: std :: mem :: align_of :: < _PkClient > () - 8usize] ; ["Offset of field: _PkClient::parent"] [:: std :: mem :: offset_of ! (_PkClient , parent) - 0usize] ; ["Offset of field: _PkClient::priv_"] [:: std :: mem :: offset_of ! (_PkClient , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkClientClass { pub parent_class : GObjectClass , pub changed : :: std :: option :: Option < unsafe extern "C" fn (client : * mut PkClient) > , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkClientClass"] [:: std :: mem :: size_of :: < _PkClientClass > () - 184usize] ; ["Alignment of _PkClientClass"] [:: std :: mem :: align_of :: < _PkClientClass > () - 8usize] ; ["Offset of field: _PkClientClass::parent_class"] [:: std :: mem :: offset_of ! (_PkClientClass , parent_class) - 0usize] ; ["Offset of field: _PkClientClass::changed"] [:: std :: mem :: offset_of ! (_PkClientClass , changed) - 136usize] ; ["Offset of field: _PkClientClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkClientClass , _pk_reserved1) - 144usize] ; ["Offset of field: _PkClientClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkClientClass , _pk_reserved2) - 152usize] ; ["Offset of field: _PkClientClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkClientClass , _pk_reserved3) - 160usize] ; ["Offset of field: _PkClientClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkClientClass , _pk_reserved4) - 168usize] ; ["Offset of field: _PkClientClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkClientClass , _pk_reserved5) - 176usize] ; } ; unsafe extern "C" { pub fn pk_client_error_quark () -> GQuark ; } unsafe extern "C" { pub fn pk_client_get_type () -> GType ; } unsafe extern "C" { pub fn pk_client_new () -> * mut PkClient ; } unsafe extern "C" { pub fn pk_client_generic_finish (client : * mut PkClient , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_resolve_async (client : * mut PkClient , filters : PkBitfield , packages : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_search_names_async (client : * mut PkClient , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_search_details_async (client : * mut PkClient , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_search_groups_async (client : * mut PkClient , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_search_files_async (client : * mut PkClient , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_get_details_async (client : * mut PkClient , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_get_details_local_async (client : * mut PkClient , files : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_get_files_local_async (client : * mut PkClient , files : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_get_update_detail_async (client : * mut PkClient , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_download_packages_async (client : * mut PkClient , package_ids : * mut * mut gchar , directory : * const gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_get_updates_async (client : * mut PkClient , filters : PkBitfield , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_get_old_transactions_async (client : * mut PkClient , number : guint , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_depends_on_async (client : * mut PkClient , filters : PkBitfield , package_ids : * mut * mut gchar , recursive : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_get_packages_async (client : * mut PkClient , filters : PkBitfield , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_required_by_async (client : * mut PkClient , filters : PkBitfield , package_ids : * mut * mut gchar , recursive : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_what_provides_async (client : * mut PkClient , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_get_distro_upgrades_async (client : * mut PkClient , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_get_files_async (client : * mut PkClient , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_get_categories_async (client : * mut PkClient , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_remove_packages_async (client : * mut PkClient , transaction_flags : PkBitfield , package_ids : * mut * mut gchar , allow_deps : gboolean , autoremove : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_refresh_cache_async (client : * mut PkClient , force : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_install_packages_async (client : * mut PkClient , transaction_flags : PkBitfield , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_install_signature_async (client : * mut PkClient , type_ : PkSigTypeEnum , key_id : * const gchar , package_id : * const gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_update_packages_async (client : * mut PkClient , transaction_flags : PkBitfield , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_install_files_async (client : * mut PkClient , transaction_flags : PkBitfield , files : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_accept_eula_async (client : * mut PkClient , eula_id : * const gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_get_repo_list_async (client : * mut PkClient , filters : PkBitfield , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_repo_enable_async (client : * mut PkClient , repo_id : * const gchar , enabled : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_repo_set_data_async (client : * mut PkClient , repo_id : * const gchar , parameter : * const gchar , value : * const gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_repo_remove_async (client : * mut PkClient , transaction_flags : PkBitfield , repo_id : * const gchar , autoremove : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_upgrade_system_async (client : * mut PkClient , transaction_flags : PkBitfield , distro_id : * const gchar , upgrade_kind : PkUpgradeKindEnum , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_repair_system_async (client : * mut PkClient , transaction_flags : PkBitfield , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_adopt_async (client : * mut PkClient , transaction_id : * const gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_get_progress_finish (client : * mut PkClient , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut PkProgress ; } unsafe extern "C" { pub fn pk_client_get_progress_async (client : * mut PkClient , transaction_id : * const gchar , cancellable : * mut GCancellable , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_client_create_helper_argv_envp (argv : * mut * mut * mut gchar , envp_out : * mut * mut * mut gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_client_set_locale (client : * mut PkClient , locale : * const gchar) ; } unsafe extern "C" { pub fn pk_client_get_locale (client : * mut PkClient) -> * const gchar ; } unsafe extern "C" { pub fn pk_client_set_background (client : * mut PkClient , background : gboolean) ; } unsafe extern "C" { pub fn pk_client_get_background (client : * mut PkClient) -> gboolean ; } unsafe extern "C" { pub fn pk_client_set_interactive (client : * mut PkClient , interactive : gboolean) ; } unsafe extern "C" { pub fn pk_client_get_interactive (client : * mut PkClient) -> gboolean ; } unsafe extern "C" { pub fn pk_client_get_idle (client : * mut PkClient) -> gboolean ; } unsafe extern "C" { pub fn pk_client_set_cache_age (client : * mut PkClient , cache_age : guint) ; } unsafe extern "C" { pub fn pk_client_get_cache_age (client : * mut PkClient) -> guint ; } unsafe extern "C" { pub fn pk_client_set_details_with_deps_size (client : * mut PkClient , details_with_deps_size : gboolean) ; } unsafe extern "C" { pub fn pk_client_get_details_with_deps_size (client : * mut PkClient) -> gboolean ; } unsafe extern "C" { pub fn pk_client_resolve (client : * mut PkClient , filters : PkBitfield , packages : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_search_names (client : * mut PkClient , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_search_details (client : * mut PkClient , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_search_groups (client : * mut PkClient , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_search_files (client : * mut PkClient , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_get_details (client : * mut PkClient , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_get_details_local (client : * mut PkClient , files : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_get_files_local (client : * mut PkClient , files : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_get_update_detail (client : * mut PkClient , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_download_packages (client : * mut PkClient , package_ids : * mut * mut gchar , directory : * const gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_get_updates (client : * mut PkClient , filters : PkBitfield , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_get_old_transactions (client : * mut PkClient , number : guint , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_depends_on (client : * mut PkClient , filters : PkBitfield , package_ids : * mut * mut gchar , recursive : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_get_packages (client : * mut PkClient , filters : PkBitfield , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_required_by (client : * mut PkClient , filters : PkBitfield , package_ids : * mut * mut gchar , recursive : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_what_provides (client : * mut PkClient , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_get_distro_upgrades (client : * mut PkClient , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_get_files (client : * mut PkClient , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_get_categories (client : * mut PkClient , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_remove_packages (client : * mut PkClient , transaction_flags : PkBitfield , package_ids : * mut * mut gchar , allow_deps : gboolean , autoremove : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_refresh_cache (client : * mut PkClient , force : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_install_packages (client : * mut PkClient , transaction_flags : PkBitfield , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_install_signature (client : * mut PkClient , type_ : PkSigTypeEnum , key_id : * const gchar , package_id : * const gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_update_packages (client : * mut PkClient , transaction_flags : PkBitfield , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_install_files (client : * mut PkClient , transaction_flags : PkBitfield , files : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_accept_eula (client : * mut PkClient , eula_id : * const gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_get_repo_list (client : * mut PkClient , filters : PkBitfield , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_repo_enable (client : * mut PkClient , repo_id : * const gchar , enabled : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_repo_set_data (client : * mut PkClient , repo_id : * const gchar , parameter : * const gchar , value : * const gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_repo_remove (client : * mut PkClient , transaction_flags : PkBitfield , repo_id : * const gchar , autoremove : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_upgrade_system (client : * mut PkClient , transaction_flags : PkBitfield , distro_id : * const gchar , upgrade_kind : PkUpgradeKindEnum , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_repair_system (client : * mut PkClient , transaction_flags : PkBitfield , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_adopt (client : * mut PkClient , transaction_id : * const gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_client_get_progress (client : * mut PkClient , transaction_id : * const gchar , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut PkProgress ; } unsafe extern "C" { pub fn pk_ptr_array_to_strv (array : * mut GPtrArray) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_iso8601_present () -> * mut gchar ; } unsafe extern "C" { pub fn pk_iso8601_from_date (date : * const GDate) -> * mut gchar ; } unsafe extern "C" { pub fn pk_iso8601_to_date (iso_date : * const gchar) -> * mut GDate ; } unsafe extern "C" { pub fn pk_iso8601_to_datetime (iso_date : * const gchar) -> * mut GDateTime ; } unsafe extern "C" { pub fn pk_get_distro_id () -> * mut gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkControlPrivate { _unused : [u8 ; 0] , } pub type PkControlPrivate = _PkControlPrivate ; pub type PkControl = _PkControl ; pub type PkControlClass = _PkControlClass ; pub type PkControl_autoptr = * mut PkControl ; pub type PkControl_listautoptr = * mut GList ; pub type PkControl_slistautoptr = * mut GSList ; pub type PkControl_queueautoptr = * mut GQueue ; pub const PkControlError_PK_CONTROL_ERROR_FAILED : PkControlError = 0 ; pub const PkControlError_PK_CONTROL_ERROR_CANNOT_START_DAEMON : PkControlError = 1 ; pub type PkControlError = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkControl { pub parent : GObject , pub priv_ : * mut PkControlPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkControl"] [:: std :: mem :: size_of :: < _PkControl > () - 32usize] ; ["Alignment of _PkControl"] [:: std :: mem :: align_of :: < _PkControl > () - 8usize] ; ["Offset of field: _PkControl::parent"] [:: std :: mem :: offset_of ! (_PkControl , parent) - 0usize] ; ["Offset of field: _PkControl::priv_"] [:: std :: mem :: offset_of ! (_PkControl , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkControlClass { pub parent_class : GObjectClass , pub transaction_list_changed : :: std :: option :: Option < unsafe extern "C" fn (control : * mut PkControl , transaction_ids : * mut * mut gchar) > , pub updates_changed : :: std :: option :: Option < unsafe extern "C" fn (control : * mut PkControl) > , pub repo_list_changed : :: std :: option :: Option < unsafe extern "C" fn (control : * mut PkControl) > , pub network_state_changed : :: std :: option :: Option < unsafe extern "C" fn (control : * mut PkControl) > , pub restart_schedule : :: std :: option :: Option < unsafe extern "C" fn (control : * mut PkControl) > , pub locked : :: std :: option :: Option < unsafe extern "C" fn (control : * mut PkControl , is_locked : gboolean) > , pub connection_changed : :: std :: option :: Option < unsafe extern "C" fn (control : * mut PkControl , connected : gboolean) > , pub installed_changed : :: std :: option :: Option < unsafe extern "C" fn (control : * mut PkControl) > , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkControlClass"] [:: std :: mem :: size_of :: < _PkControlClass > () - 232usize] ; ["Alignment of _PkControlClass"] [:: std :: mem :: align_of :: < _PkControlClass > () - 8usize] ; ["Offset of field: _PkControlClass::parent_class"] [:: std :: mem :: offset_of ! (_PkControlClass , parent_class) - 0usize] ; ["Offset of field: _PkControlClass::transaction_list_changed"] [:: std :: mem :: offset_of ! (_PkControlClass , transaction_list_changed) - 136usize] ; ["Offset of field: _PkControlClass::updates_changed"] [:: std :: mem :: offset_of ! (_PkControlClass , updates_changed) - 144usize] ; ["Offset of field: _PkControlClass::repo_list_changed"] [:: std :: mem :: offset_of ! (_PkControlClass , repo_list_changed) - 152usize] ; ["Offset of field: _PkControlClass::network_state_changed"] [:: std :: mem :: offset_of ! (_PkControlClass , network_state_changed) - 160usize] ; ["Offset of field: _PkControlClass::restart_schedule"] [:: std :: mem :: offset_of ! (_PkControlClass , restart_schedule) - 168usize] ; ["Offset of field: _PkControlClass::locked"] [:: std :: mem :: offset_of ! (_PkControlClass , locked) - 176usize] ; ["Offset of field: _PkControlClass::connection_changed"] [:: std :: mem :: offset_of ! (_PkControlClass , connection_changed) - 184usize] ; ["Offset of field: _PkControlClass::installed_changed"] [:: std :: mem :: offset_of ! (_PkControlClass , installed_changed) - 192usize] ; ["Offset of field: _PkControlClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkControlClass , _pk_reserved1) - 200usize] ; ["Offset of field: _PkControlClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkControlClass , _pk_reserved2) - 208usize] ; ["Offset of field: _PkControlClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkControlClass , _pk_reserved3) - 216usize] ; ["Offset of field: _PkControlClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkControlClass , _pk_reserved4) - 224usize] ; } ; unsafe extern "C" { pub fn pk_control_error_quark () -> GQuark ; } unsafe extern "C" { pub fn pk_control_get_type () -> GType ; } unsafe extern "C" { pub fn pk_control_new () -> * mut PkControl ; } unsafe extern "C" { pub fn pk_control_get_tid_async (control : * mut PkControl , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_control_get_tid_finish (control : * mut PkControl , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn pk_control_suggest_daemon_quit_async (control : * mut PkControl , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_control_suggest_daemon_quit_finish (control : * mut PkControl , res : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_control_get_daemon_state_async (control : * mut PkControl , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_control_get_daemon_state_finish (control : * mut PkControl , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn pk_control_set_proxy_async (control : * mut PkControl , proxy_http : * const gchar , proxy_ftp : * const gchar , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_control_set_proxy2_async (control : * mut PkControl , proxy_http : * const gchar , proxy_https : * const gchar , proxy_ftp : * const gchar , proxy_socks : * const gchar , no_proxy : * const gchar , pac : * const gchar , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_control_set_proxy_finish (control : * mut PkControl , res : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_control_get_time_since_action_async (control : * mut PkControl , role : PkRoleEnum , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_control_get_time_since_action_finish (control : * mut PkControl , res : * mut GAsyncResult , error : * mut * mut GError) -> guint ; } unsafe extern "C" { pub fn pk_control_get_transaction_list_async (control : * mut PkControl , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_control_get_transaction_list_finish (control : * mut PkControl , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_control_can_authorize_async (control : * mut PkControl , action_id : * const gchar , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_control_can_authorize_finish (control : * mut PkControl , res : * mut GAsyncResult , error : * mut * mut GError) -> PkAuthorizeEnum ; } unsafe extern "C" { pub fn pk_control_get_properties_async (control : * mut PkControl , cancellable : * mut GCancellable , callback : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_control_get_properties_finish (control : * mut PkControl , res : * mut GAsyncResult , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_control_get_properties (control : * mut PkControl , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_control_get_transaction_list (control : * mut PkControl , cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_control_suggest_daemon_quit (control : * mut PkControl , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_control_set_proxy (control : * mut PkControl , proxy_http : * const gchar , proxy_ftp : * const gchar , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_control_set_proxy2 (control : * mut PkControl , proxy_http : * const gchar , proxy_https : * const gchar , proxy_ftp : * const gchar , proxy_socks : * const gchar , no_proxy : * const gchar , pac : * const gchar , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkDesktopPrivate { _unused : [u8 ; 0] , } pub type PkDesktopPrivate = _PkDesktopPrivate ; pub type PkDesktop = _PkDesktop ; pub type PkDesktopClass = _PkDesktopClass ; pub type PkDesktop_autoptr = * mut PkDesktop ; pub type PkDesktop_listautoptr = * mut GList ; pub type PkDesktop_slistautoptr = * mut GSList ; pub type PkDesktop_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkDesktop { pub parent : GObject , pub priv_ : * mut PkDesktopPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkDesktop"] [:: std :: mem :: size_of :: < _PkDesktop > () - 32usize] ; ["Alignment of _PkDesktop"] [:: std :: mem :: align_of :: < _PkDesktop > () - 8usize] ; ["Offset of field: _PkDesktop::parent"] [:: std :: mem :: offset_of ! (_PkDesktop , parent) - 0usize] ; ["Offset of field: _PkDesktop::priv_"] [:: std :: mem :: offset_of ! (_PkDesktop , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkDesktopClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkDesktopClass"] [:: std :: mem :: size_of :: < _PkDesktopClass > () - 136usize] ; ["Alignment of _PkDesktopClass"] [:: std :: mem :: align_of :: < _PkDesktopClass > () - 8usize] ; ["Offset of field: _PkDesktopClass::parent_class"] [:: std :: mem :: offset_of ! (_PkDesktopClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn pk_desktop_get_type () -> GType ; } unsafe extern "C" { pub fn pk_desktop_new () -> * mut PkDesktop ; } unsafe extern "C" { pub fn pk_desktop_open_database (desktop : * mut PkDesktop , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_desktop_get_files_for_package (desktop : * mut PkDesktop , package : * const gchar , error : * mut * mut GError) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_desktop_get_shown_for_package (desktop : * mut PkDesktop , package : * const gchar , error : * mut * mut GError) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_desktop_get_package_for_file (desktop : * mut PkDesktop , filename : * const gchar , error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn pk_client_error_get_type () -> GType ; } unsafe extern "C" { pub fn pk_control_error_get_type () -> GType ; } unsafe extern "C" { pub fn pk_role_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_status_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_exit_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_network_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_filter_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_restart_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_error_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_group_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_update_state_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_info_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_distro_upgrade_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_sig_type_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_media_type_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_authorize_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_upgrade_kind_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_transaction_flag_enum_get_type () -> GType ; } unsafe extern "C" { pub fn pk_offline_action_get_type () -> GType ; } unsafe extern "C" { pub fn pk_offline_error_get_type () -> GType ; } unsafe extern "C" { pub fn pk_offline_flags_get_type () -> GType ; } unsafe extern "C" { pub fn pk_package_sack_sort_type_get_type () -> GType ; } unsafe extern "C" { pub fn pk_progress_type_get_type () -> GType ; } pub const PkOfflineAction_PK_OFFLINE_ACTION_UNKNOWN : PkOfflineAction = 0 ; pub const PkOfflineAction_PK_OFFLINE_ACTION_REBOOT : PkOfflineAction = 1 ; pub const PkOfflineAction_PK_OFFLINE_ACTION_POWER_OFF : PkOfflineAction = 2 ; pub const PkOfflineAction_PK_OFFLINE_ACTION_UNSET : PkOfflineAction = 3 ; pub const PkOfflineAction_PK_OFFLINE_ACTION_LAST : PkOfflineAction = 4 ; pub type PkOfflineAction = :: std :: os :: raw :: c_uint ; pub const PkOfflineError_PK_OFFLINE_ERROR_FAILED : PkOfflineError = 0 ; pub const PkOfflineError_PK_OFFLINE_ERROR_INVALID_VALUE : PkOfflineError = 1 ; pub const PkOfflineError_PK_OFFLINE_ERROR_NO_DATA : PkOfflineError = 2 ; pub const PkOfflineError_PK_OFFLINE_ERROR_LAST : PkOfflineError = 3 ; pub type PkOfflineError = :: std :: os :: raw :: c_uint ; pub const PkOfflineFlags_PK_OFFLINE_FLAGS_NONE : PkOfflineFlags = 0 ; pub const PkOfflineFlags_PK_OFFLINE_FLAGS_INTERACTIVE : PkOfflineFlags = 1 ; pub type PkOfflineFlags = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn pk_offline_error_quark () -> GQuark ; } unsafe extern "C" { pub fn pk_offline_action_to_string (action : PkOfflineAction) -> * const gchar ; } unsafe extern "C" { pub fn pk_offline_action_from_string (action : * const gchar) -> PkOfflineAction ; } unsafe extern "C" { pub fn pk_offline_get_action (error : * mut * mut GError) -> PkOfflineAction ; } unsafe extern "C" { pub fn pk_offline_get_prepared_ids (error : * mut * mut GError) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_offline_get_prepared_upgrade_name (error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn pk_offline_get_prepared_upgrade_version (error : * mut * mut GError) -> * mut gchar ; } unsafe extern "C" { pub fn pk_offline_get_prepared_sack (error : * mut * mut GError) -> * mut PkPackageSack ; } unsafe extern "C" { pub fn pk_offline_get_prepared_monitor (cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileMonitor ; } unsafe extern "C" { pub fn pk_offline_get_prepared_upgrade_monitor (cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileMonitor ; } unsafe extern "C" { pub fn pk_offline_get_action_monitor (cancellable : * mut GCancellable , error : * mut * mut GError) -> * mut GFileMonitor ; } unsafe extern "C" { pub fn pk_offline_get_results (error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_offline_get_results_mtime (error : * mut * mut GError) -> guint64 ; } unsafe extern "C" { pub fn pk_offline_cancel (cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_offline_cancel_with_flags (flags : PkOfflineFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_offline_clear_results (cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_offline_clear_results_with_flags (flags : PkOfflineFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_offline_trigger (action : PkOfflineAction , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_offline_trigger_with_flags (action : PkOfflineAction , flags : PkOfflineFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_offline_trigger_upgrade (action : PkOfflineAction , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_offline_trigger_upgrade_with_flags (action : PkOfflineAction , flags : PkOfflineFlags , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_package_id_build (name : * const gchar , version : * const gchar , arch : * const gchar , data : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn pk_package_id_check (package_id : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_package_id_split (package_id : * const gchar) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_package_id_to_printable (package_id : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn pk_package_id_equal_fuzzy_arch (package_id1 : * const gchar , package_id2 : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_package_ids_from_id (package_id : * const gchar) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_package_ids_from_string (package_id : * const gchar) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_package_ids_check (package_ids : * mut * mut gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_package_ids_to_string (package_ids : * mut * mut gchar) -> * mut gchar ; } unsafe extern "C" { pub fn pk_package_ids_present_id (package_ids : * mut * mut gchar , package_id : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_package_ids_add_id (package_ids : * mut * mut gchar , package_id : * const gchar) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_package_ids_add_ids (package_ids : * mut * mut gchar , package_ids_new : * mut * mut gchar) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_package_ids_remove_id (package_ids : * mut * mut gchar , package_id : * const gchar) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_package_sack_resolve (package_sack : * mut PkPackageSack , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_package_sack_get_details (package_sack : * mut PkPackageSack , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_package_sack_get_update_detail (package_sack : * mut PkPackageSack , cancellable : * mut GCancellable , error : * mut * mut GError) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTaskPrivate { _unused : [u8 ; 0] , } pub type PkTaskPrivate = _PkTaskPrivate ; pub type PkTask = _PkTask ; pub type PkTaskClass = _PkTaskClass ; pub type PkTask_autoptr = * mut PkTask ; pub type PkTask_listautoptr = * mut GList ; pub type PkTask_slistautoptr = * mut GSList ; pub type PkTask_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTask { pub parent : PkClient , pub priv_ : * mut PkTaskPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkTask"] [:: std :: mem :: size_of :: < _PkTask > () - 40usize] ; ["Alignment of _PkTask"] [:: std :: mem :: align_of :: < _PkTask > () - 8usize] ; ["Offset of field: _PkTask::parent"] [:: std :: mem :: offset_of ! (_PkTask , parent) - 0usize] ; ["Offset of field: _PkTask::priv_"] [:: std :: mem :: offset_of ! (_PkTask , priv_) - 32usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTaskClass { pub parent_class : PkClientClass , pub untrusted_question : :: std :: option :: Option < unsafe extern "C" fn (task : * mut PkTask , request : guint , results : * mut PkResults) > , pub key_question : :: std :: option :: Option < unsafe extern "C" fn (task : * mut PkTask , request : guint , results : * mut PkResults) > , pub eula_question : :: std :: option :: Option < unsafe extern "C" fn (task : * mut PkTask , request : guint , results : * mut PkResults) > , pub media_change_question : :: std :: option :: Option < unsafe extern "C" fn (task : * mut PkTask , request : guint , results : * mut PkResults) > , pub simulate_question : :: std :: option :: Option < unsafe extern "C" fn (task : * mut PkTask , request : guint , results : * mut PkResults) > , pub repair_question : :: std :: option :: Option < unsafe extern "C" fn (task : * mut PkTask , request : guint , results : * mut PkResults) > , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkTaskClass"] [:: std :: mem :: size_of :: < _PkTaskClass > () - 264usize] ; ["Alignment of _PkTaskClass"] [:: std :: mem :: align_of :: < _PkTaskClass > () - 8usize] ; ["Offset of field: _PkTaskClass::parent_class"] [:: std :: mem :: offset_of ! (_PkTaskClass , parent_class) - 0usize] ; ["Offset of field: _PkTaskClass::untrusted_question"] [:: std :: mem :: offset_of ! (_PkTaskClass , untrusted_question) - 184usize] ; ["Offset of field: _PkTaskClass::key_question"] [:: std :: mem :: offset_of ! (_PkTaskClass , key_question) - 192usize] ; ["Offset of field: _PkTaskClass::eula_question"] [:: std :: mem :: offset_of ! (_PkTaskClass , eula_question) - 200usize] ; ["Offset of field: _PkTaskClass::media_change_question"] [:: std :: mem :: offset_of ! (_PkTaskClass , media_change_question) - 208usize] ; ["Offset of field: _PkTaskClass::simulate_question"] [:: std :: mem :: offset_of ! (_PkTaskClass , simulate_question) - 216usize] ; ["Offset of field: _PkTaskClass::repair_question"] [:: std :: mem :: offset_of ! (_PkTaskClass , repair_question) - 224usize] ; ["Offset of field: _PkTaskClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkTaskClass , _pk_reserved1) - 232usize] ; ["Offset of field: _PkTaskClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkTaskClass , _pk_reserved2) - 240usize] ; ["Offset of field: _PkTaskClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkTaskClass , _pk_reserved3) - 248usize] ; ["Offset of field: _PkTaskClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkTaskClass , _pk_reserved4) - 256usize] ; } ; unsafe extern "C" { pub fn pk_task_get_type () -> GType ; } unsafe extern "C" { pub fn pk_task_new () -> * mut PkTask ; } unsafe extern "C" { pub fn pk_task_generic_finish (task : * mut PkTask , res : * mut GAsyncResult , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_install_packages_async (task : * mut PkTask , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_update_packages_async (task : * mut PkTask , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_remove_packages_async (task : * mut PkTask , package_ids : * mut * mut gchar , allow_deps : gboolean , autoremove : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_install_files_async (task : * mut PkTask , files : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_resolve_async (task : * mut PkTask , filters : PkBitfield , packages : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_search_names_async (task : * mut PkTask , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_search_details_async (task : * mut PkTask , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_search_groups_async (task : * mut PkTask , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_search_files_async (task : * mut PkTask , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_get_details_async (task : * mut PkTask , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_get_update_detail_async (task : * mut PkTask , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_download_packages_async (task : * mut PkTask , package_ids : * mut * mut gchar , directory : * const gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_get_updates_async (task : * mut PkTask , filters : PkBitfield , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_depends_on_async (task : * mut PkTask , filters : PkBitfield , package_ids : * mut * mut gchar , recursive : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_get_packages_async (task : * mut PkTask , filters : PkBitfield , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_required_by_async (task : * mut PkTask , filters : PkBitfield , package_ids : * mut * mut gchar , recursive : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_what_provides_async (task : * mut PkTask , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_get_files_async (task : * mut PkTask , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_get_categories_async (task : * mut PkTask , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_refresh_cache_async (task : * mut PkTask , force : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_get_repo_list_async (task : * mut PkTask , filters : PkBitfield , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_repo_enable_async (task : * mut PkTask , repo_id : * const gchar , enabled : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_upgrade_system_async (task : * mut PkTask , distro_id : * const gchar , upgrade_kind : PkUpgradeKindEnum , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_repair_system_async (task : * mut PkTask , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , callback_ready : GAsyncReadyCallback , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_task_user_accepted (task : * mut PkTask , request : guint) -> gboolean ; } unsafe extern "C" { pub fn pk_task_user_declined (task : * mut PkTask , request : guint) -> gboolean ; } unsafe extern "C" { pub fn pk_task_set_simulate (task : * mut PkTask , simulate : gboolean) ; } unsafe extern "C" { pub fn pk_task_get_simulate (task : * mut PkTask) -> gboolean ; } unsafe extern "C" { pub fn pk_task_set_only_download (task : * mut PkTask , only_download : gboolean) ; } unsafe extern "C" { pub fn pk_task_get_only_download (task : * mut PkTask) -> gboolean ; } unsafe extern "C" { pub fn pk_task_set_allow_downgrade (task : * mut PkTask , allow_downgrade : gboolean) ; } unsafe extern "C" { pub fn pk_task_get_allow_downgrade (task : * mut PkTask) -> gboolean ; } unsafe extern "C" { pub fn pk_task_set_allow_reinstall (task : * mut PkTask , allow_reinstall : gboolean) ; } unsafe extern "C" { pub fn pk_task_get_allow_reinstall (task : * mut PkTask) -> gboolean ; } unsafe extern "C" { pub fn pk_task_set_only_trusted (task : * mut PkTask , only_trusted : gboolean) ; } unsafe extern "C" { pub fn pk_task_get_only_trusted (task : * mut PkTask) -> gboolean ; } unsafe extern "C" { pub fn pk_task_remove_packages_sync (task : * mut PkTask , package_ids : * mut * mut gchar , allow_deps : gboolean , autoremove : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_install_packages_sync (task : * mut PkTask , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_update_packages_sync (task : * mut PkTask , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_install_files_sync (task : * mut PkTask , files : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_resolve_sync (task : * mut PkTask , filters : PkBitfield , packages : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_search_names_sync (task : * mut PkTask , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_search_details_sync (task : * mut PkTask , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_search_groups_sync (task : * mut PkTask , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_search_files_sync (task : * mut PkTask , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_get_details_sync (task : * mut PkTask , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_get_update_detail_sync (task : * mut PkTask , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_download_packages_sync (task : * mut PkTask , package_ids : * mut * mut gchar , directory : * const gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_get_updates_sync (task : * mut PkTask , filters : PkBitfield , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_depends_on_sync (task : * mut PkTask , filters : PkBitfield , package_ids : * mut * mut gchar , recursive : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_get_packages_sync (task : * mut PkTask , filters : PkBitfield , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_required_by_sync (task : * mut PkTask , filters : PkBitfield , package_ids : * mut * mut gchar , recursive : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_what_provides_sync (task : * mut PkTask , filters : PkBitfield , values : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_get_files_sync (task : * mut PkTask , package_ids : * mut * mut gchar , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_get_categories_sync (task : * mut PkTask , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_refresh_cache_sync (task : * mut PkTask , force : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_get_repo_list_sync (task : * mut PkTask , filters : PkBitfield , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_repo_enable_sync (task : * mut PkTask , repo_id : * const gchar , enabled : gboolean , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_upgrade_system_sync (task : * mut PkTask , distro_id : * const gchar , upgrade_kind : PkUpgradeKindEnum , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } unsafe extern "C" { pub fn pk_task_repair_system_sync (task : * mut PkTask , cancellable : * mut GCancellable , progress_callback : PkProgressCallback , progress_user_data : gpointer , error : * mut * mut GError) -> * mut PkResults ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTransactionListPrivate { _unused : [u8 ; 0] , } pub type PkTransactionListPrivate = _PkTransactionListPrivate ; pub type PkTransactionList = _PkTransactionList ; pub type PkTransactionListClass = _PkTransactionListClass ; pub type PkTransactionList_autoptr = * mut PkTransactionList ; pub type PkTransactionList_listautoptr = * mut GList ; pub type PkTransactionList_slistautoptr = * mut GSList ; pub type PkTransactionList_queueautoptr = * mut GQueue ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTransactionList { pub parent : GObject , pub priv_ : * mut PkTransactionListPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkTransactionList"] [:: std :: mem :: size_of :: < _PkTransactionList > () - 32usize] ; ["Alignment of _PkTransactionList"] [:: std :: mem :: align_of :: < _PkTransactionList > () - 8usize] ; ["Offset of field: _PkTransactionList::parent"] [:: std :: mem :: offset_of ! (_PkTransactionList , parent) - 0usize] ; ["Offset of field: _PkTransactionList::priv_"] [:: std :: mem :: offset_of ! (_PkTransactionList , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTransactionListClass { pub parent_class : GObjectClass , pub added : :: std :: option :: Option < unsafe extern "C" fn (tlist : * mut PkTransactionList , tid : * const gchar) > , pub removed : :: std :: option :: Option < unsafe extern "C" fn (tlist : * mut PkTransactionList , tid : * const gchar) > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkTransactionListClass"] [:: std :: mem :: size_of :: < _PkTransactionListClass > () - 152usize] ; ["Alignment of _PkTransactionListClass"] [:: std :: mem :: align_of :: < _PkTransactionListClass > () - 8usize] ; ["Offset of field: _PkTransactionListClass::parent_class"] [:: std :: mem :: offset_of ! (_PkTransactionListClass , parent_class) - 0usize] ; ["Offset of field: _PkTransactionListClass::added"] [:: std :: mem :: offset_of ! (_PkTransactionListClass , added) - 136usize] ; ["Offset of field: _PkTransactionListClass::removed"] [:: std :: mem :: offset_of ! (_PkTransactionListClass , removed) - 144usize] ; } ; unsafe extern "C" { pub fn pk_transaction_list_get_type () -> GType ; } unsafe extern "C" { pub fn pk_transaction_list_new () -> * mut PkTransactionList ; } unsafe extern "C" { pub fn pk_transaction_list_get_ids (tlist : * mut PkTransactionList) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_debug_is_verbose () -> gboolean ; } unsafe extern "C" { pub fn pk_debug_get_option_group () -> * mut GOptionGroup ; } unsafe extern "C" { pub fn pk_debug_add_log_domain (log_domain : * const gchar) ; } unsafe extern "C" { pub fn pk_debug_set_verbose (verbose : gboolean) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkClientHelperPrivate { _unused : [u8 ; 0] , } pub type PkClientHelperPrivate = _PkClientHelperPrivate ; pub type PkClientHelper = _PkClientHelper ; pub type PkClientHelperClass = _PkClientHelperClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkClientHelper { pub parent : GObject , pub priv_ : * mut PkClientHelperPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkClientHelper"] [:: std :: mem :: size_of :: < _PkClientHelper > () - 32usize] ; ["Alignment of _PkClientHelper"] [:: std :: mem :: align_of :: < _PkClientHelper > () - 8usize] ; ["Offset of field: _PkClientHelper::parent"] [:: std :: mem :: offset_of ! (_PkClientHelper , parent) - 0usize] ; ["Offset of field: _PkClientHelper::priv_"] [:: std :: mem :: offset_of ! (_PkClientHelper , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkClientHelperClass { pub parent_class : GObjectClass , pub _pk_reserved1 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved2 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved3 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved4 : :: std :: option :: Option < unsafe extern "C" fn () > , pub _pk_reserved5 : :: std :: option :: Option < unsafe extern "C" fn () > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkClientHelperClass"] [:: std :: mem :: size_of :: < _PkClientHelperClass > () - 176usize] ; ["Alignment of _PkClientHelperClass"] [:: std :: mem :: align_of :: < _PkClientHelperClass > () - 8usize] ; ["Offset of field: _PkClientHelperClass::parent_class"] [:: std :: mem :: offset_of ! (_PkClientHelperClass , parent_class) - 0usize] ; ["Offset of field: _PkClientHelperClass::_pk_reserved1"] [:: std :: mem :: offset_of ! (_PkClientHelperClass , _pk_reserved1) - 136usize] ; ["Offset of field: _PkClientHelperClass::_pk_reserved2"] [:: std :: mem :: offset_of ! (_PkClientHelperClass , _pk_reserved2) - 144usize] ; ["Offset of field: _PkClientHelperClass::_pk_reserved3"] [:: std :: mem :: offset_of ! (_PkClientHelperClass , _pk_reserved3) - 152usize] ; ["Offset of field: _PkClientHelperClass::_pk_reserved4"] [:: std :: mem :: offset_of ! (_PkClientHelperClass , _pk_reserved4) - 160usize] ; ["Offset of field: _PkClientHelperClass::_pk_reserved5"] [:: std :: mem :: offset_of ! (_PkClientHelperClass , _pk_reserved5) - 168usize] ; } ; unsafe extern "C" { pub fn pk_client_helper_get_type () -> GType ; } unsafe extern "C" { pub fn pk_client_helper_new () -> * mut PkClientHelper ; } unsafe extern "C" { pub fn pk_client_helper_stop (client_helper : * mut PkClientHelper , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_client_helper_start (client_helper : * mut PkClientHelper , socket_filename : * const gchar , argv : * mut * mut gchar , envp : * mut * mut gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_client_helper_start_with_socket (client_helper : * mut PkClientHelper , socket : * mut GSocket , argv : * mut * mut gchar , envp : * mut * mut gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_client_helper_is_active (client_helper : * mut PkClientHelper) -> gboolean ; } unsafe extern "C" { pub fn pk_console_get_number (question : * const gchar , maxnum : guint) -> guint ; } unsafe extern "C" { pub fn pk_console_get_prompt (question : * const gchar , defaultyes : gboolean) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkProgressBarPrivate { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkProgressBar { pub parent : GObject , pub priv_ : * mut PkProgressBarPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkProgressBar"] [:: std :: mem :: size_of :: < PkProgressBar > () - 32usize] ; ["Alignment of PkProgressBar"] [:: std :: mem :: align_of :: < PkProgressBar > () - 8usize] ; ["Offset of field: PkProgressBar::parent"] [:: std :: mem :: offset_of ! (PkProgressBar , parent) - 0usize] ; ["Offset of field: PkProgressBar::priv_"] [:: std :: mem :: offset_of ! (PkProgressBar , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkProgressBarClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkProgressBarClass"] [:: std :: mem :: size_of :: < PkProgressBarClass > () - 136usize] ; ["Alignment of PkProgressBarClass"] [:: std :: mem :: align_of :: < PkProgressBarClass > () - 8usize] ; ["Offset of field: PkProgressBarClass::parent_class"] [:: std :: mem :: offset_of ! (PkProgressBarClass , parent_class) - 0usize] ; } ; pub type PkProgressBar_autoptr = * mut PkProgressBar ; pub type PkProgressBar_listautoptr = * mut GList ; pub type PkProgressBar_slistautoptr = * mut GSList ; pub type PkProgressBar_queueautoptr = * mut GQueue ; unsafe extern "C" { pub fn pk_progress_bar_get_type () -> GType ; } unsafe extern "C" { pub fn pk_progress_bar_new () -> * mut PkProgressBar ; } unsafe extern "C" { pub fn pk_progress_bar_set_size (progress_bar : * mut PkProgressBar , size : guint) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_bar_set_padding (progress_bar : * mut PkProgressBar , padding : guint) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_bar_set_percentage (progress_bar : * mut PkProgressBar , percentage : gint) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_bar_start (progress_bar : * mut PkProgressBar , text : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_progress_bar_end (progress_bar : * mut PkProgressBar) -> gboolean ; } unsafe extern "C" { pub fn pk_polkit_agent_open () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn pk_polkit_agent_close () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTaskTextPrivate { _unused : [u8 ; 0] , } pub type PkTaskTextPrivate = _PkTaskTextPrivate ; pub type PkTaskText = _PkTaskText ; pub type PkTaskTextClass = _PkTaskTextClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTaskText { pub parent : PkTask , pub priv_ : * mut PkTaskTextPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkTaskText"] [:: std :: mem :: size_of :: < _PkTaskText > () - 48usize] ; ["Alignment of _PkTaskText"] [:: std :: mem :: align_of :: < _PkTaskText > () - 8usize] ; ["Offset of field: _PkTaskText::parent"] [:: std :: mem :: offset_of ! (_PkTaskText , parent) - 0usize] ; ["Offset of field: _PkTaskText::priv_"] [:: std :: mem :: offset_of ! (_PkTaskText , priv_) - 40usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTaskTextClass { pub parent_class : PkTaskClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkTaskTextClass"] [:: std :: mem :: size_of :: < _PkTaskTextClass > () - 264usize] ; ["Alignment of _PkTaskTextClass"] [:: std :: mem :: align_of :: < _PkTaskTextClass > () - 8usize] ; ["Offset of field: _PkTaskTextClass::parent_class"] [:: std :: mem :: offset_of ! (_PkTaskTextClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn pk_task_text_get_type () -> GType ; } unsafe extern "C" { pub fn pk_task_text_new () -> * mut PkTaskText ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTaskWrapperPrivate { _unused : [u8 ; 0] , } pub type PkTaskWrapperPrivate = _PkTaskWrapperPrivate ; pub type PkTaskWrapper = _PkTaskWrapper ; pub type PkTaskWrapperClass = _PkTaskWrapperClass ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTaskWrapper { pub parent : PkTask , pub priv_ : * mut PkTaskWrapperPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkTaskWrapper"] [:: std :: mem :: size_of :: < _PkTaskWrapper > () - 48usize] ; ["Alignment of _PkTaskWrapper"] [:: std :: mem :: align_of :: < _PkTaskWrapper > () - 8usize] ; ["Offset of field: _PkTaskWrapper::parent"] [:: std :: mem :: offset_of ! (_PkTaskWrapper , parent) - 0usize] ; ["Offset of field: _PkTaskWrapper::priv_"] [:: std :: mem :: offset_of ! (_PkTaskWrapper , priv_) - 40usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _PkTaskWrapperClass { pub parent_class : PkTaskClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _PkTaskWrapperClass"] [:: std :: mem :: size_of :: < _PkTaskWrapperClass > () - 264usize] ; ["Alignment of _PkTaskWrapperClass"] [:: std :: mem :: align_of :: < _PkTaskWrapperClass > () - 8usize] ; ["Offset of field: _PkTaskWrapperClass::parent_class"] [:: std :: mem :: offset_of ! (_PkTaskWrapperClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn pk_task_wrapper_get_type () -> GType ; } unsafe extern "C" { pub fn pk_task_wrapper_new () -> * mut PkTaskWrapper ; } unsafe extern "C" { pub fn pk_directory_remove_contents (directory : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_directory_find_files_with_suffix (directory : * const gchar , filename_suffix : * const gchar) -> * mut GPtrArray ; } unsafe extern "C" { pub fn pk_strlen (text : * const gchar , len : guint) -> guint ; } unsafe extern "C" { pub fn pk_strzero (text : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_strtoint (text : * const gchar , value : * mut gint) -> gboolean ; } unsafe extern "C" { pub fn pk_strtouint (text : * const gchar , value : * mut guint) -> gboolean ; } unsafe extern "C" { pub fn pk_strtouint64 (text : * const gchar , value : * mut guint64) -> gboolean ; } unsafe extern "C" { pub fn pk_load_introspection (filename : * const gchar , error : * mut * mut GError) -> * mut GDBusNodeInfo ; } unsafe extern "C" { pub fn pk_util_get_config_filename () -> * mut gchar ; } unsafe extern "C" { pub fn pk_util_set_auto_backend (conf : * mut GKeyFile , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_is_thread_default_real (strloc : * const gchar , strfunc : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_ioprio_set_idle (pid : GPid) -> gboolean ; } unsafe extern "C" { pub fn pk_string_replace (string : * mut GString , search : * const gchar , replace : * const gchar) -> guint ; } unsafe extern "C" { pub fn pk_get_cmdline_for_pid (pid : guint32) -> * mut gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkBackendJobPrivate { _unused : [u8 ; 0] , } pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_ALLOW_CANCEL : PkBackendJobSignal = 0 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_DETAILS : PkBackendJobSignal = 1 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_ERROR_CODE : PkBackendJobSignal = 2 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_DISTRO_UPGRADE : PkBackendJobSignal = 3 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_FINISHED : PkBackendJobSignal = 4 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_PACKAGE : PkBackendJobSignal = 5 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_PACKAGES : PkBackendJobSignal = 6 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_ITEM_PROGRESS : PkBackendJobSignal = 7 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_FILES : PkBackendJobSignal = 8 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_PERCENTAGE : PkBackendJobSignal = 9 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_SPEED : PkBackendJobSignal = 10 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_DOWNLOAD_SIZE_REMAINING : PkBackendJobSignal = 11 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_REPO_DETAIL : PkBackendJobSignal = 12 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_REPO_SIGNATURE_REQUIRED : PkBackendJobSignal = 13 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_EULA_REQUIRED : PkBackendJobSignal = 14 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_MEDIA_CHANGE_REQUIRED : PkBackendJobSignal = 15 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_REQUIRE_RESTART : PkBackendJobSignal = 16 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_STATUS_CHANGED : PkBackendJobSignal = 17 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_LOCKED_CHANGED : PkBackendJobSignal = 18 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_UPDATE_DETAIL : PkBackendJobSignal = 19 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_UPDATE_DETAILS : PkBackendJobSignal = 20 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_CATEGORY : PkBackendJobSignal = 21 ; pub const PkBackendJobSignal_PK_BACKEND_SIGNAL_LAST : PkBackendJobSignal = 22 ; pub type PkBackendJobSignal = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkBackendJob { pub parent : GObject , pub priv_ : * mut PkBackendJobPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkBackendJob"] [:: std :: mem :: size_of :: < PkBackendJob > () - 32usize] ; ["Alignment of PkBackendJob"] [:: std :: mem :: align_of :: < PkBackendJob > () - 8usize] ; ["Offset of field: PkBackendJob::parent"] [:: std :: mem :: offset_of ! (PkBackendJob , parent) - 0usize] ; ["Offset of field: PkBackendJob::priv_"] [:: std :: mem :: offset_of ! (PkBackendJob , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkBackendJobClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkBackendJobClass"] [:: std :: mem :: size_of :: < PkBackendJobClass > () - 136usize] ; ["Alignment of PkBackendJobClass"] [:: std :: mem :: align_of :: < PkBackendJobClass > () - 8usize] ; ["Offset of field: PkBackendJobClass::parent_class"] [:: std :: mem :: offset_of ! (PkBackendJobClass , parent_class) - 0usize] ; } ; pub type PkBackendJob_autoptr = * mut PkBackendJob ; pub type PkBackendJob_listautoptr = * mut GList ; pub type PkBackendJob_slistautoptr = * mut GSList ; pub type PkBackendJob_queueautoptr = * mut GQueue ; unsafe extern "C" { pub fn pk_backend_job_get_type () -> GType ; } unsafe extern "C" { pub fn pk_backend_job_new (conf : * mut GKeyFile) -> * mut PkBackendJob ; } unsafe extern "C" { pub fn pk_backend_job_disconnect_vfuncs (job : * mut PkBackendJob) ; } unsafe extern "C" { pub fn pk_backend_job_get_backend (job : * mut PkBackendJob) -> gpointer ; } unsafe extern "C" { pub fn pk_backend_job_set_backend (job : * mut PkBackendJob , backend : gpointer) ; } unsafe extern "C" { pub fn pk_backend_job_get_cancellable (job : * mut PkBackendJob) -> * mut GCancellable ; } unsafe extern "C" { pub fn pk_backend_job_is_cancelled (job : * mut PkBackendJob) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_job_get_user_data (job : * mut PkBackendJob) -> gpointer ; } unsafe extern "C" { pub fn pk_backend_job_set_user_data (job : * mut PkBackendJob , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_backend_job_get_transaction_flags (job : * mut PkBackendJob) -> PkBitfield ; } unsafe extern "C" { pub fn pk_backend_job_set_transaction_flags (job : * mut PkBackendJob , transaction_flags : PkBitfield) ; } unsafe extern "C" { pub fn pk_backend_job_get_parameters (job : * mut PkBackendJob) -> * mut GVariant ; } unsafe extern "C" { pub fn pk_backend_job_set_parameters (job : * mut PkBackendJob , params : * mut GVariant) ; } unsafe extern "C" { pub fn pk_backend_job_get_background (job : * mut PkBackendJob) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_job_set_background (job : * mut PkBackendJob , background : gboolean) ; } unsafe extern "C" { pub fn pk_backend_job_get_interactive (job : * mut PkBackendJob) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_job_set_interactive (job : * mut PkBackendJob , interactive : gboolean) ; } unsafe extern "C" { pub fn pk_backend_job_set_locked (job : * mut PkBackendJob , locked : gboolean) ; } unsafe extern "C" { pub fn pk_backend_job_get_locked (job : * mut PkBackendJob) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_job_set_role (job : * mut PkBackendJob , role : PkRoleEnum) ; } unsafe extern "C" { pub fn pk_backend_job_get_role (job : * mut PkBackendJob) -> PkRoleEnum ; } unsafe extern "C" { pub fn pk_backend_job_get_exit_code (job : * mut PkBackendJob) -> PkExitEnum ; } unsafe extern "C" { pub fn pk_backend_job_set_exit_code (job : * mut PkBackendJob , exit : PkExitEnum) ; } unsafe extern "C" { pub fn pk_backend_job_has_set_error_code (job : * mut PkBackendJob) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_job_get_runtime (job : * mut PkBackendJob) -> guint ; } unsafe extern "C" { pub fn pk_backend_job_get_is_finished (job : * mut PkBackendJob) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_job_get_is_error_set (job : * mut PkBackendJob) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_job_get_allow_cancel (job : * mut PkBackendJob) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_job_set_proxy (job : * mut PkBackendJob , proxy_http : * const gchar , proxy_https : * const gchar , proxy_ftp : * const gchar , proxy_socks : * const gchar , no_proxy : * const gchar , pac : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_job_set_uid (job : * mut PkBackendJob , uid : guint) ; } unsafe extern "C" { pub fn pk_backend_job_get_uid (job : * mut PkBackendJob) -> guint ; } unsafe extern "C" { pub fn pk_backend_job_set_cmdline (job : * mut PkBackendJob , cmdline : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_job_get_cmdline (job : * mut PkBackendJob) -> * const gchar ; } unsafe extern "C" { pub fn pk_backend_job_set_locale (job : * mut PkBackendJob , code : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_job_set_frontend_socket (job : * mut PkBackendJob , frontend_socket : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_job_set_cache_age (job : * mut PkBackendJob , cache_age : guint) ; } unsafe extern "C" { pub fn pk_backend_job_get_proxy_ftp (job : * mut PkBackendJob) -> * const gchar ; } unsafe extern "C" { pub fn pk_backend_job_get_proxy_http (job : * mut PkBackendJob) -> * const gchar ; } unsafe extern "C" { pub fn pk_backend_job_get_proxy_https (job : * mut PkBackendJob) -> * const gchar ; } unsafe extern "C" { pub fn pk_backend_job_get_proxy_socks (job : * mut PkBackendJob) -> * const gchar ; } unsafe extern "C" { pub fn pk_backend_job_get_no_proxy (job : * mut PkBackendJob) -> * const gchar ; } unsafe extern "C" { pub fn pk_backend_job_get_pac (job : * mut PkBackendJob) -> * const gchar ; } unsafe extern "C" { pub fn pk_backend_job_get_locale (job : * mut PkBackendJob) -> * const gchar ; } unsafe extern "C" { pub fn pk_backend_job_get_frontend_socket (job : * mut PkBackendJob) -> * const gchar ; } unsafe extern "C" { pub fn pk_backend_job_get_cache_age (job : * mut PkBackendJob) -> guint ; } unsafe extern "C" { pub fn pk_backend_job_get_details_with_deps_size (job : * mut PkBackendJob) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_job_set_details_with_deps_size (job : * mut PkBackendJob , details_with_deps_size : gboolean) ; } pub type PkBackendJobVFunc = :: std :: option :: Option < unsafe extern "C" fn (job : * mut PkBackendJob , object : gpointer , user_data : gpointer) > ; unsafe extern "C" { pub fn pk_backend_job_set_vfunc (job : * mut PkBackendJob , signal_kind : PkBackendJobSignal , vfunc : PkBackendJobVFunc , user_data : gpointer) ; } unsafe extern "C" { pub fn pk_backend_job_get_vfunc_enabled (job : * mut PkBackendJob , signal_kind : PkBackendJobSignal) -> gboolean ; } pub type PkBackendJobThreadFunc = :: std :: option :: Option < unsafe extern "C" fn (job : * mut PkBackendJob , params : * mut GVariant , user_data : gpointer) > ; unsafe extern "C" { pub fn pk_backend_job_thread_create (job : * mut PkBackendJob , func : PkBackendJobThreadFunc , user_data : gpointer , destroy_func : GDestroyNotify) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_job_finished (job : * mut PkBackendJob) ; } unsafe extern "C" { pub fn pk_backend_job_package (job : * mut PkBackendJob , info : PkInfoEnum , package_id : * const gchar , summary : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_job_package_full (job : * mut PkBackendJob , info : PkInfoEnum , package_id : * const gchar , summary : * const gchar , update_severity : PkInfoEnum) ; } unsafe extern "C" { pub fn pk_backend_job_packages (job : * mut PkBackendJob , packages : * mut GPtrArray) ; } unsafe extern "C" { pub fn pk_backend_job_repo_detail (job : * mut PkBackendJob , repo_id : * const gchar , description : * const gchar , enabled : gboolean) ; } unsafe extern "C" { pub fn pk_backend_job_update_detail (job : * mut PkBackendJob , package_id : * const gchar , updates : * mut * mut gchar , obsoletes : * mut * mut gchar , vendor_urls : * mut * mut gchar , bugzilla_urls : * mut * mut gchar , cve_urls : * mut * mut gchar , restart : PkRestartEnum , update_text : * const gchar , changelog : * const gchar , state : PkUpdateStateEnum , issued : * const gchar , updated : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_job_update_details (job : * mut PkBackendJob , update_details : * mut GPtrArray) ; } unsafe extern "C" { pub fn pk_backend_job_require_restart (job : * mut PkBackendJob , restart : PkRestartEnum , package_id : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_job_details (job : * mut PkBackendJob , package_id : * const gchar , summary : * const gchar , license : * const gchar , group : PkGroupEnum , description : * const gchar , url : * const gchar , size : gulong) ; } unsafe extern "C" { pub fn pk_backend_job_details_full (job : * mut PkBackendJob , package_id : * const gchar , summary : * const gchar , license : * const gchar , group : PkGroupEnum , description : * const gchar , url : * const gchar , size : gulong , download_size : guint64) ; } unsafe extern "C" { pub fn pk_backend_job_files (job : * mut PkBackendJob , package_id : * const gchar , files : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_job_distro_upgrade (job : * mut PkBackendJob , type_ : PkDistroUpgradeEnum , name : * const gchar , summary : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_job_error_code (job : * mut PkBackendJob , code : PkErrorEnum , details : * const gchar , ...) ; } unsafe extern "C" { pub fn pk_backend_job_repo_signature_required (job : * mut PkBackendJob , package_id : * const gchar , repository_name : * const gchar , key_url : * const gchar , key_userid : * const gchar , key_id : * const gchar , key_fingerprint : * const gchar , key_timestamp : * const gchar , type_ : PkSigTypeEnum) ; } unsafe extern "C" { pub fn pk_backend_job_eula_required (job : * mut PkBackendJob , eula_id : * const gchar , package_id : * const gchar , vendor_name : * const gchar , license_agreement : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_job_media_change_required (job : * mut PkBackendJob , media_type : PkMediaTypeEnum , media_id : * const gchar , media_text : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_job_category (job : * mut PkBackendJob , parent_id : * const gchar , cat_id : * const gchar , name : * const gchar , summary : * const gchar , icon : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_job_set_status (job : * mut PkBackendJob , status : PkStatusEnum) ; } unsafe extern "C" { pub fn pk_backend_job_set_allow_cancel (job : * mut PkBackendJob , allow_cancel : gboolean) ; } unsafe extern "C" { pub fn pk_backend_job_set_percentage (job : * mut PkBackendJob , percentage : guint) ; } unsafe extern "C" { pub fn pk_backend_job_set_item_progress (job : * mut PkBackendJob , package_id : * const gchar , status : PkStatusEnum , percentage : guint) ; } unsafe extern "C" { pub fn pk_backend_job_set_speed (job : * mut PkBackendJob , speed : guint) ; } unsafe extern "C" { pub fn pk_backend_job_set_download_size_remaining (job : * mut PkBackendJob , download_size_remaining : guint64) ; } unsafe extern "C" { pub fn pk_backend_job_set_started (job : * mut PkBackendJob , started : gboolean) ; } unsafe extern "C" { pub fn pk_backend_job_get_started (job : * mut PkBackendJob) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkBackendSpawnPrivate { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkBackendSpawn { pub parent : GObject , pub priv_ : * mut PkBackendSpawnPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkBackendSpawn"] [:: std :: mem :: size_of :: < PkBackendSpawn > () - 32usize] ; ["Alignment of PkBackendSpawn"] [:: std :: mem :: align_of :: < PkBackendSpawn > () - 8usize] ; ["Offset of field: PkBackendSpawn::parent"] [:: std :: mem :: offset_of ! (PkBackendSpawn , parent) - 0usize] ; ["Offset of field: PkBackendSpawn::priv_"] [:: std :: mem :: offset_of ! (PkBackendSpawn , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkBackendSpawnClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkBackendSpawnClass"] [:: std :: mem :: size_of :: < PkBackendSpawnClass > () - 136usize] ; ["Alignment of PkBackendSpawnClass"] [:: std :: mem :: align_of :: < PkBackendSpawnClass > () - 8usize] ; ["Offset of field: PkBackendSpawnClass::parent_class"] [:: std :: mem :: offset_of ! (PkBackendSpawnClass , parent_class) - 0usize] ; } ; unsafe extern "C" { pub fn pk_backend_spawn_get_type () -> GType ; } unsafe extern "C" { pub fn pk_backend_spawn_new (conf : * mut GKeyFile) -> * mut PkBackendSpawn ; } unsafe extern "C" { pub fn pk_backend_spawn_helper (backend_spawn : * mut PkBackendSpawn , job : * mut PkBackendJob , first_element : * const gchar , ...) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_spawn_is_busy (backend_spawn : * mut PkBackendSpawn) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_spawn_kill (backend_spawn : * mut PkBackendSpawn) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_spawn_exit (backend_spawn : * mut PkBackendSpawn) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_spawn_get_name (backend_spawn : * mut PkBackendSpawn) -> * const gchar ; } unsafe extern "C" { pub fn pk_backend_spawn_set_name (backend_spawn : * mut PkBackendSpawn , name : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_spawn_set_allow_sigkill (backend_spawn : * mut PkBackendSpawn , allow_sigkill : gboolean) ; } unsafe extern "C" { pub fn pk_backend_spawn_inject_data (backend_spawn : * mut PkBackendSpawn , job : * mut PkBackendJob , line : * const gchar , error : * mut * mut GError) -> gboolean ; } pub type PkBackendSpawnFilterFunc = :: std :: option :: Option < unsafe extern "C" fn (job : * mut PkBackendJob , data : * const gchar) -> gboolean > ; unsafe extern "C" { pub fn pk_backend_spawn_set_filter_stderr (backend_spawn : * mut PkBackendSpawn , func : PkBackendSpawnFilterFunc) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_spawn_set_filter_stdout (backend_spawn : * mut PkBackendSpawn , func : PkBackendSpawnFilterFunc) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkBackendPrivate { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkBackend { pub parent : GObject , pub priv_ : * mut PkBackendPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkBackend"] [:: std :: mem :: size_of :: < PkBackend > () - 32usize] ; ["Alignment of PkBackend"] [:: std :: mem :: align_of :: < PkBackend > () - 8usize] ; ["Offset of field: PkBackend::parent"] [:: std :: mem :: offset_of ! (PkBackend , parent) - 0usize] ; ["Offset of field: PkBackend::priv_"] [:: std :: mem :: offset_of ! (PkBackend , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkBackendClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkBackendClass"] [:: std :: mem :: size_of :: < PkBackendClass > () - 136usize] ; ["Alignment of PkBackendClass"] [:: std :: mem :: align_of :: < PkBackendClass > () - 8usize] ; ["Offset of field: PkBackendClass::parent_class"] [:: std :: mem :: offset_of ! (PkBackendClass , parent_class) - 0usize] ; } ; pub type PkBackend_autoptr = * mut PkBackend ; pub type PkBackend_listautoptr = * mut GList ; pub type PkBackend_slistautoptr = * mut GSList ; pub type PkBackend_queueautoptr = * mut GQueue ; unsafe extern "C" { pub fn pk_backend_get_type () -> GType ; } unsafe extern "C" { pub fn pk_backend_new (conf : * mut GKeyFile) -> * mut PkBackend ; } unsafe extern "C" { pub fn pk_backend_load (backend : * mut PkBackend , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_unload (backend : * mut PkBackend) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_is_implemented (backend : * mut PkBackend , role : PkRoleEnum) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_get_accepted_eula_string (backend : * mut PkBackend) -> * mut gchar ; } unsafe extern "C" { pub fn pk_backend_repo_list_changed (backend : * mut PkBackend) ; } unsafe extern "C" { pub fn pk_backend_installed_db_changed (backend : * mut PkBackend) ; } unsafe extern "C" { pub fn pk_backend_updates_changed (backend : * mut PkBackend) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_updates_changed_delay (backend : * mut PkBackend , timeout : guint) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_transaction_inhibit_start (backend : * mut PkBackend) ; } unsafe extern "C" { pub fn pk_backend_transaction_inhibit_end (backend : * mut PkBackend) ; } unsafe extern "C" { pub fn pk_backend_is_transaction_inhibited (backend : * mut PkBackend) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_bool_to_string (value : gboolean) -> * const gchar ; } unsafe extern "C" { pub fn pk_backend_is_online (backend : * mut PkBackend) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_convert_uri (proxy : * const gchar) -> * mut gchar ; } unsafe extern "C" { pub fn pk_backend_convert_uri_socks (proxy : * const gchar) -> * mut gchar ; } pub type PkBackendFileChanged = :: std :: option :: Option < unsafe extern "C" fn (backend : * mut PkBackend , data : gpointer) > ; unsafe extern "C" { pub fn pk_backend_watch_file (backend : * mut PkBackend , filename : * const gchar , func : PkBackendFileChanged , data : gpointer) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_get_name (backend : * mut PkBackend) -> * const gchar ; } unsafe extern "C" { pub fn pk_backend_get_description (backend : * mut PkBackend) -> * const gchar ; } unsafe extern "C" { pub fn pk_backend_get_author (backend : * mut PkBackend) -> * const gchar ; } unsafe extern "C" { pub fn pk_backend_get_groups (backend : * mut PkBackend) -> PkBitfield ; } unsafe extern "C" { pub fn pk_backend_get_filters (backend : * mut PkBackend) -> PkBitfield ; } unsafe extern "C" { pub fn pk_backend_get_roles (backend : * mut PkBackend) -> PkBitfield ; } unsafe extern "C" { pub fn pk_backend_get_mime_types (backend : * mut PkBackend) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_backend_supports_parallelization (backend : * mut PkBackend) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_initialize (conf : * mut GKeyFile , backend : * mut PkBackend) ; } unsafe extern "C" { pub fn pk_backend_destroy (backend : * mut PkBackend) ; } unsafe extern "C" { pub fn pk_backend_start_job (backend : * mut PkBackend , job : * mut PkBackendJob) ; } unsafe extern "C" { pub fn pk_backend_stop_job (backend : * mut PkBackend , job : * mut PkBackendJob) ; } unsafe extern "C" { pub fn pk_backend_cancel (backend : * mut PkBackend , job : * mut PkBackendJob) ; } unsafe extern "C" { pub fn pk_backend_download_packages (backend : * mut PkBackend , job : * mut PkBackendJob , package_ids : * mut * mut gchar , directory : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_get_categories (backend : * mut PkBackend , job : * mut PkBackendJob) ; } unsafe extern "C" { pub fn pk_backend_depends_on (backend : * mut PkBackend , job : * mut PkBackendJob , filters : PkBitfield , package_ids : * mut * mut gchar , recursive : gboolean) ; } unsafe extern "C" { pub fn pk_backend_get_details (backend : * mut PkBackend , job : * mut PkBackendJob , package_ids : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_get_details_local (backend : * mut PkBackend , job : * mut PkBackendJob , files : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_get_files_local (backend : * mut PkBackend , job : * mut PkBackendJob , files : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_get_distro_upgrades (backend : * mut PkBackend , job : * mut PkBackendJob) ; } unsafe extern "C" { pub fn pk_backend_get_files (backend : * mut PkBackend , job : * mut PkBackendJob , package_ids : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_required_by (backend : * mut PkBackend , job : * mut PkBackendJob , filters : PkBitfield , package_ids : * mut * mut gchar , recursive : gboolean) ; } unsafe extern "C" { pub fn pk_backend_get_update_detail (backend : * mut PkBackend , job : * mut PkBackendJob , package_ids : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_get_updates (backend : * mut PkBackend , job : * mut PkBackendJob , filters : PkBitfield) ; } unsafe extern "C" { pub fn pk_backend_install_packages (backend : * mut PkBackend , job : * mut PkBackendJob , transaction_flags : PkBitfield , package_ids : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_install_signature (backend : * mut PkBackend , job : * mut PkBackendJob , type_ : PkSigTypeEnum , key_id : * const gchar , package_id : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_install_files (backend : * mut PkBackend , job : * mut PkBackendJob , transaction_flags : PkBitfield , full_paths : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_refresh_cache (backend : * mut PkBackend , job : * mut PkBackendJob , force : gboolean) ; } unsafe extern "C" { pub fn pk_backend_remove_packages (backend : * mut PkBackend , job : * mut PkBackendJob , transaction_flags : PkBitfield , package_ids : * mut * mut gchar , allow_deps : gboolean , autoremove : gboolean) ; } unsafe extern "C" { pub fn pk_backend_resolve (backend : * mut PkBackend , job : * mut PkBackendJob , filters : PkBitfield , packages : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_search_details (backend : * mut PkBackend , job : * mut PkBackendJob , filters : PkBitfield , search : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_search_files (backend : * mut PkBackend , job : * mut PkBackendJob , filters : PkBitfield , search : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_search_groups (backend : * mut PkBackend , job : * mut PkBackendJob , filters : PkBitfield , search : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_search_names (backend : * mut PkBackend , job : * mut PkBackendJob , filters : PkBitfield , search : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_update_packages (backend : * mut PkBackend , job : * mut PkBackendJob , transaction_flags : PkBitfield , package_ids : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_get_repo_list (backend : * mut PkBackend , job : * mut PkBackendJob , filters : PkBitfield) ; } unsafe extern "C" { pub fn pk_backend_repo_enable (backend : * mut PkBackend , job : * mut PkBackendJob , repo_id : * const gchar , enabled : gboolean) ; } unsafe extern "C" { pub fn pk_backend_repo_set_data (backend : * mut PkBackend , job : * mut PkBackendJob , repo_id : * const gchar , parameter : * const gchar , value : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_repo_remove (backend : * mut PkBackend , job : * mut PkBackendJob , transaction_flags : PkBitfield , repo_id : * const gchar , autoremove : gboolean) ; } unsafe extern "C" { pub fn pk_backend_what_provides (backend : * mut PkBackend , job : * mut PkBackendJob , filters : PkBitfield , search : * mut * mut gchar) ; } unsafe extern "C" { pub fn pk_backend_get_packages (backend : * mut PkBackend , job : * mut PkBackendJob , filters : PkBitfield) ; } unsafe extern "C" { pub fn pk_backend_upgrade_system (backend : * mut PkBackend , job : * mut PkBackendJob , transaction_flags : PkBitfield , distro_id : * const gchar , upgrade_kind : PkUpgradeKindEnum) ; } unsafe extern "C" { pub fn pk_backend_repair_system (backend : * mut PkBackend , job : * mut PkBackendJob , transaction_flags : PkBitfield) ; } unsafe extern "C" { pub fn pk_backend_thread_start (backend : * mut PkBackend , job : * mut PkBackendJob , func : gpointer) ; } unsafe extern "C" { pub fn pk_backend_thread_stop (backend : * mut PkBackend , job : * mut PkBackendJob , func : gpointer) ; } unsafe extern "C" { pub fn pk_backend_accept_eula (backend : * mut PkBackend , eula_id : * const gchar) ; } unsafe extern "C" { pub fn pk_backend_is_eula_valid (backend : * mut PkBackend , eula_id : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_backend_get_user_data (backend : * mut PkBackend) -> gpointer ; } unsafe extern "C" { pub fn pk_backend_set_user_data (backend : * mut PkBackend , user_data : gpointer) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkDbusPrivate { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkDbus { pub parent : GObject , pub priv_ : * mut PkDbusPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkDbus"] [:: std :: mem :: size_of :: < PkDbus > () - 32usize] ; ["Alignment of PkDbus"] [:: std :: mem :: align_of :: < PkDbus > () - 8usize] ; ["Offset of field: PkDbus::parent"] [:: std :: mem :: offset_of ! (PkDbus , parent) - 0usize] ; ["Offset of field: PkDbus::priv_"] [:: std :: mem :: offset_of ! (PkDbus , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkDbusClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkDbusClass"] [:: std :: mem :: size_of :: < PkDbusClass > () - 136usize] ; ["Alignment of PkDbusClass"] [:: std :: mem :: align_of :: < PkDbusClass > () - 8usize] ; ["Offset of field: PkDbusClass::parent_class"] [:: std :: mem :: offset_of ! (PkDbusClass , parent_class) - 0usize] ; } ; pub type PkDbus_autoptr = * mut PkDbus ; pub type PkDbus_listautoptr = * mut GList ; pub type PkDbus_slistautoptr = * mut GSList ; pub type PkDbus_queueautoptr = * mut GQueue ; unsafe extern "C" { pub fn pk_dbus_get_type () -> GType ; } unsafe extern "C" { pub fn pk_dbus_new () -> * mut PkDbus ; } unsafe extern "C" { pub fn pk_dbus_connect (dbus : * mut PkDbus , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_dbus_get_uid_pid (dbus : * mut PkDbus , sender : * const gchar , uid : * mut guint32 , pid : * mut guint32) -> gboolean ; } unsafe extern "C" { pub fn pk_dbus_get_uid (dbus : * mut PkDbus , sender : * const gchar) -> guint32 ; } unsafe extern "C" { pub fn pk_dbus_get_pid (dbus : * mut PkDbus , sender : * const gchar) -> guint32 ; } unsafe extern "C" { pub fn pk_dbus_get_session (dbus : * mut PkDbus , sender : * const gchar) -> * mut gchar ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkEnginePrivate { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkEngine { pub parent : GObject , pub priv_ : * mut PkEnginePrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkEngine"] [:: std :: mem :: size_of :: < PkEngine > () - 32usize] ; ["Alignment of PkEngine"] [:: std :: mem :: align_of :: < PkEngine > () - 8usize] ; ["Offset of field: PkEngine::parent"] [:: std :: mem :: offset_of ! (PkEngine , parent) - 0usize] ; ["Offset of field: PkEngine::priv_"] [:: std :: mem :: offset_of ! (PkEngine , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkEngineClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkEngineClass"] [:: std :: mem :: size_of :: < PkEngineClass > () - 136usize] ; ["Alignment of PkEngineClass"] [:: std :: mem :: align_of :: < PkEngineClass > () - 8usize] ; ["Offset of field: PkEngineClass::parent_class"] [:: std :: mem :: offset_of ! (PkEngineClass , parent_class) - 0usize] ; } ; pub type PkEngine_autoptr = * mut PkEngine ; pub type PkEngine_listautoptr = * mut GList ; pub type PkEngine_slistautoptr = * mut GSList ; pub type PkEngine_queueautoptr = * mut GQueue ; pub const PkEngineError_PK_ENGINE_ERROR_DENIED : PkEngineError = 0 ; pub const PkEngineError_PK_ENGINE_ERROR_INVALID_STATE : PkEngineError = 1 ; pub const PkEngineError_PK_ENGINE_ERROR_REFUSED_BY_POLICY : PkEngineError = 2 ; pub const PkEngineError_PK_ENGINE_ERROR_CANNOT_SET_PROXY : PkEngineError = 3 ; pub const PkEngineError_PK_ENGINE_ERROR_NOT_SUPPORTED : PkEngineError = 4 ; pub const PkEngineError_PK_ENGINE_ERROR_CANNOT_ALLOCATE_TID : PkEngineError = 5 ; pub const PkEngineError_PK_ENGINE_ERROR_CANNOT_CHECK_AUTH : PkEngineError = 6 ; pub const PkEngineError_PK_ENGINE_ERROR_LAST : PkEngineError = 7 ; pub type PkEngineError = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn pk_engine_error_quark () -> GQuark ; } unsafe extern "C" { pub fn pk_engine_error_get_type () -> GType ; } unsafe extern "C" { pub fn pk_engine_get_type () -> GType ; } unsafe extern "C" { pub fn pk_engine_new (conf : * mut GKeyFile) -> * mut PkEngine ; } unsafe extern "C" { pub fn pk_engine_get_seconds_idle (engine : * mut PkEngine) -> guint ; } unsafe extern "C" { pub fn pk_engine_load_backend (engine : * mut PkEngine , error : * mut * mut GError) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkTransactionPrivate { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkTransaction { pub parent : GObject , pub priv_ : * mut PkTransactionPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkTransaction"] [:: std :: mem :: size_of :: < PkTransaction > () - 32usize] ; ["Alignment of PkTransaction"] [:: std :: mem :: align_of :: < PkTransaction > () - 8usize] ; ["Offset of field: PkTransaction::parent"] [:: std :: mem :: offset_of ! (PkTransaction , parent) - 0usize] ; ["Offset of field: PkTransaction::priv_"] [:: std :: mem :: offset_of ! (PkTransaction , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkTransactionClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkTransactionClass"] [:: std :: mem :: size_of :: < PkTransactionClass > () - 136usize] ; ["Alignment of PkTransactionClass"] [:: std :: mem :: align_of :: < PkTransactionClass > () - 8usize] ; ["Offset of field: PkTransactionClass::parent_class"] [:: std :: mem :: offset_of ! (PkTransactionClass , parent_class) - 0usize] ; } ; pub type PkTransaction_autoptr = * mut PkTransaction ; pub type PkTransaction_listautoptr = * mut GList ; pub type PkTransaction_slistautoptr = * mut GSList ; pub type PkTransaction_queueautoptr = * mut GQueue ; pub const PkTransactionState_PK_TRANSACTION_STATE_NEW : PkTransactionState = 0 ; pub const PkTransactionState_PK_TRANSACTION_STATE_WAITING_FOR_AUTH : PkTransactionState = 1 ; pub const PkTransactionState_PK_TRANSACTION_STATE_READY : PkTransactionState = 2 ; pub const PkTransactionState_PK_TRANSACTION_STATE_RUNNING : PkTransactionState = 3 ; pub const PkTransactionState_PK_TRANSACTION_STATE_FINISHED : PkTransactionState = 4 ; pub const PkTransactionState_PK_TRANSACTION_STATE_ERROR : PkTransactionState = 5 ; pub const PkTransactionState_PK_TRANSACTION_STATE_UNKNOWN : PkTransactionState = 6 ; pub type PkTransactionState = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn pk_transaction_error_quark () -> GQuark ; } unsafe extern "C" { pub fn pk_transaction_get_type () -> GType ; } unsafe extern "C" { pub fn pk_transaction_new (conf : * mut GKeyFile , introspection : * mut GDBusNodeInfo) -> * mut PkTransaction ; } unsafe extern "C" { pub fn pk_transaction_run (transaction : * mut PkTransaction) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_cancel_bg (transaction : * mut PkTransaction) ; } unsafe extern "C" { pub fn pk_transaction_get_background (transaction : * mut PkTransaction) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_get_role (transaction : * mut PkTransaction) -> PkRoleEnum ; } unsafe extern "C" { pub fn pk_transaction_get_uid (transaction : * mut PkTransaction) -> guint ; } unsafe extern "C" { pub fn pk_transaction_set_backend (transaction : * mut PkTransaction , backend : * mut PkBackend) ; } unsafe extern "C" { pub fn pk_transaction_get_backend_job (transaction : * mut PkTransaction) -> * mut PkBackendJob ; } unsafe extern "C" { pub fn pk_transaction_get_state (transaction : * mut PkTransaction) -> PkTransactionState ; } unsafe extern "C" { pub fn pk_transaction_set_state (transaction : * mut PkTransaction , state : PkTransactionState) ; } unsafe extern "C" { pub fn pk_transaction_state_to_string (state : PkTransactionState) -> * const gchar ; } unsafe extern "C" { pub fn pk_transaction_get_tid (transaction : * mut PkTransaction) -> * const gchar ; } unsafe extern "C" { pub fn pk_transaction_is_exclusive (transaction : * mut PkTransaction) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_is_finished_with_lock_required (transaction : * mut PkTransaction) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_reset_after_lock_error (transaction : * mut PkTransaction) ; } unsafe extern "C" { pub fn pk_transaction_make_exclusive (transaction : * mut PkTransaction) ; } unsafe extern "C" { pub fn pk_transaction_skip_auth_checks (transaction : * mut PkTransaction , skip_checks : gboolean) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkSchedulerPrivate { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkScheduler { pub parent : GObject , pub priv_ : * mut PkSchedulerPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkScheduler"] [:: std :: mem :: size_of :: < PkScheduler > () - 32usize] ; ["Alignment of PkScheduler"] [:: std :: mem :: align_of :: < PkScheduler > () - 8usize] ; ["Offset of field: PkScheduler::parent"] [:: std :: mem :: offset_of ! (PkScheduler , parent) - 0usize] ; ["Offset of field: PkScheduler::priv_"] [:: std :: mem :: offset_of ! (PkScheduler , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkSchedulerClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkSchedulerClass"] [:: std :: mem :: size_of :: < PkSchedulerClass > () - 136usize] ; ["Alignment of PkSchedulerClass"] [:: std :: mem :: align_of :: < PkSchedulerClass > () - 8usize] ; ["Offset of field: PkSchedulerClass::parent_class"] [:: std :: mem :: offset_of ! (PkSchedulerClass , parent_class) - 0usize] ; } ; pub type PkScheduler_autoptr = * mut PkScheduler ; pub type PkScheduler_listautoptr = * mut GList ; pub type PkScheduler_slistautoptr = * mut GSList ; pub type PkScheduler_queueautoptr = * mut GQueue ; unsafe extern "C" { pub fn pk_scheduler_get_type () -> GType ; } unsafe extern "C" { pub fn pk_scheduler_new (conf : * mut GKeyFile) -> * mut PkScheduler ; } unsafe extern "C" { pub fn pk_scheduler_create (scheduler : * mut PkScheduler , tid : * const gchar , sender : * const gchar , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_scheduler_remove (scheduler : * mut PkScheduler , tid : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_scheduler_role_present (scheduler : * mut PkScheduler , role : PkRoleEnum) -> gboolean ; } unsafe extern "C" { pub fn pk_scheduler_get_array (scheduler : * mut PkScheduler) -> * mut * mut gchar ; } unsafe extern "C" { pub fn pk_scheduler_get_state (scheduler : * mut PkScheduler) -> * mut gchar ; } unsafe extern "C" { pub fn pk_scheduler_get_size (scheduler : * mut PkScheduler) -> guint ; } unsafe extern "C" { pub fn pk_scheduler_get_locked (scheduler : * mut PkScheduler) -> gboolean ; } unsafe extern "C" { pub fn pk_scheduler_get_inhibited (scheduler : * mut PkScheduler) -> gboolean ; } unsafe extern "C" { pub fn pk_scheduler_get_transaction (scheduler : * mut PkScheduler , tid : * const gchar) -> * mut PkTransaction ; } unsafe extern "C" { pub fn pk_scheduler_cancel_background (scheduler : * mut PkScheduler) ; } unsafe extern "C" { pub fn pk_scheduler_cancel_queued (scheduler : * mut PkScheduler) ; } unsafe extern "C" { pub fn pk_scheduler_set_backend (scheduler : * mut PkScheduler , backend : * mut PkBackend) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkSpawnPrivate { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkSpawn { pub parent : GObject , pub priv_ : * mut PkSpawnPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkSpawn"] [:: std :: mem :: size_of :: < PkSpawn > () - 32usize] ; ["Alignment of PkSpawn"] [:: std :: mem :: align_of :: < PkSpawn > () - 8usize] ; ["Offset of field: PkSpawn::parent"] [:: std :: mem :: offset_of ! (PkSpawn , parent) - 0usize] ; ["Offset of field: PkSpawn::priv_"] [:: std :: mem :: offset_of ! (PkSpawn , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkSpawnClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkSpawnClass"] [:: std :: mem :: size_of :: < PkSpawnClass > () - 136usize] ; ["Alignment of PkSpawnClass"] [:: std :: mem :: align_of :: < PkSpawnClass > () - 8usize] ; ["Offset of field: PkSpawnClass::parent_class"] [:: std :: mem :: offset_of ! (PkSpawnClass , parent_class) - 0usize] ; } ; pub type PkSpawn_autoptr = * mut PkSpawn ; pub type PkSpawn_listautoptr = * mut GList ; pub type PkSpawn_slistautoptr = * mut GSList ; pub type PkSpawn_queueautoptr = * mut GQueue ; pub const PkSpawnExitType_PK_SPAWN_EXIT_TYPE_SUCCESS : PkSpawnExitType = 0 ; pub const PkSpawnExitType_PK_SPAWN_EXIT_TYPE_FAILED : PkSpawnExitType = 1 ; pub const PkSpawnExitType_PK_SPAWN_EXIT_TYPE_DISPATCHER_CHANGED : PkSpawnExitType = 2 ; pub const PkSpawnExitType_PK_SPAWN_EXIT_TYPE_DISPATCHER_EXIT : PkSpawnExitType = 3 ; pub const PkSpawnExitType_PK_SPAWN_EXIT_TYPE_SIGQUIT : PkSpawnExitType = 4 ; pub const PkSpawnExitType_PK_SPAWN_EXIT_TYPE_SIGKILL : PkSpawnExitType = 5 ; pub const PkSpawnExitType_PK_SPAWN_EXIT_TYPE_UNKNOWN : PkSpawnExitType = 6 ; pub type PkSpawnExitType = :: std :: os :: raw :: c_uint ; pub const PkSpawnArgvFlags_PK_SPAWN_ARGV_FLAGS_NONE : PkSpawnArgvFlags = 0 ; pub const PkSpawnArgvFlags_PK_SPAWN_ARGV_FLAGS_NEVER_REUSE : PkSpawnArgvFlags = 1 ; pub const PkSpawnArgvFlags_PK_SPAWN_ARGV_FLAGS_LAST : PkSpawnArgvFlags = 2 ; pub type PkSpawnArgvFlags = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn pk_spawn_get_type () -> GType ; } unsafe extern "C" { pub fn pk_spawn_new (conf : * mut GKeyFile) -> * mut PkSpawn ; } unsafe extern "C" { pub fn pk_spawn_argv (spawn : * mut PkSpawn , argv : * mut * mut gchar , envp : * mut * mut gchar , flags : PkSpawnArgvFlags , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_spawn_is_running (spawn : * mut PkSpawn) -> gboolean ; } unsafe extern "C" { pub fn pk_spawn_kill (spawn : * mut PkSpawn) -> gboolean ; } unsafe extern "C" { pub fn pk_spawn_exit (spawn : * mut PkSpawn) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkTransactionDbPrivate { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkTransactionDb { pub parent : GObject , pub priv_ : * mut PkTransactionDbPrivate , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkTransactionDb"] [:: std :: mem :: size_of :: < PkTransactionDb > () - 32usize] ; ["Alignment of PkTransactionDb"] [:: std :: mem :: align_of :: < PkTransactionDb > () - 8usize] ; ["Offset of field: PkTransactionDb::parent"] [:: std :: mem :: offset_of ! (PkTransactionDb , parent) - 0usize] ; ["Offset of field: PkTransactionDb::priv_"] [:: std :: mem :: offset_of ! (PkTransactionDb , priv_) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct PkTransactionDbClass { pub parent_class : GObjectClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of PkTransactionDbClass"] [:: std :: mem :: size_of :: < PkTransactionDbClass > () - 136usize] ; ["Alignment of PkTransactionDbClass"] [:: std :: mem :: align_of :: < PkTransactionDbClass > () - 8usize] ; ["Offset of field: PkTransactionDbClass::parent_class"] [:: std :: mem :: offset_of ! (PkTransactionDbClass , parent_class) - 0usize] ; } ; pub type PkTransactionDb_autoptr = * mut PkTransactionDb ; pub type PkTransactionDb_listautoptr = * mut GList ; pub type PkTransactionDb_slistautoptr = * mut GSList ; pub type PkTransactionDb_queueautoptr = * mut GQueue ; unsafe extern "C" { pub fn pk_transaction_db_get_type () -> GType ; } unsafe extern "C" { pub fn pk_transaction_db_new () -> * mut PkTransactionDb ; } unsafe extern "C" { pub fn pk_transaction_db_load (tdb : * mut PkTransactionDb , error : * mut * mut GError) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_db_empty (tdb : * mut PkTransactionDb) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_db_add (tdb : * mut PkTransactionDb , tid : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_db_print (tdb : * mut PkTransactionDb) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_db_set_role (tdb : * mut PkTransactionDb , tid : * const gchar , role : PkRoleEnum) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_db_set_uid (tdb : * mut PkTransactionDb , tid : * const gchar , uid : guint) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_db_set_cmdline (tdb : * mut PkTransactionDb , tid : * const gchar , cmdline : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_db_set_finished (tdb : * mut PkTransactionDb , tid : * const gchar , success : gboolean , runtime : guint) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_db_set_data (tdb : * mut PkTransactionDb , tid : * const gchar , data : * const gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_db_get_list (tdb : * mut PkTransactionDb , limit : guint) -> * mut GList ; } unsafe extern "C" { pub fn pk_transaction_db_action_time_reset (tdb : * mut PkTransactionDb , role : PkRoleEnum) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_db_action_time_since (tdb : * mut PkTransactionDb , role : PkRoleEnum) -> guint ; } unsafe extern "C" { pub fn pk_transaction_db_generate_id (tdb : * mut PkTransactionDb) -> * mut gchar ; } unsafe extern "C" { pub fn pk_transaction_db_get_proxy (tdb : * mut PkTransactionDb , uid : guint , session : * const gchar , proxy_http : * mut * mut gchar , proxy_https : * mut * mut gchar , proxy_ftp : * mut * mut gchar , proxy_socks : * mut * mut gchar , no_proxy : * mut * mut gchar , pac : * mut * mut gchar) -> gboolean ; } unsafe extern "C" { pub fn pk_transaction_db_set_proxy (tdb : * mut PkTransactionDb , uid : guint , session : * const gchar , proxy_http : * const gchar , proxy_https : * const gchar , proxy_ftp : * const gchar , proxy_socks : * const gchar , no_proxy : * const gchar , pac : * const gchar) -> gboolean ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __locale_data { pub _address : u8 , } pub type __builtin_va_list = [__va_list_tag ; 1usize] ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __va_list_tag { pub gp_offset : :: std :: os :: raw :: c_uint , pub fp_offset : :: std :: os :: raw :: c_uint , pub overflow_arg_area : * mut :: std :: os :: raw :: c_void , pub reg_save_area : * mut :: std :: os :: raw :: c_void , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of __va_list_tag"] [:: std :: mem :: size_of :: < __va_list_tag > () - 24usize] ; ["Alignment of __va_list_tag"] [:: std :: mem :: align_of :: < __va_list_tag > () - 8usize] ; ["Offset of field: __va_list_tag::gp_offset"] [:: std :: mem :: offset_of ! (__va_list_tag , gp_offset) - 0usize] ; ["Offset of field: __va_list_tag::fp_offset"] [:: std :: mem :: offset_of ! (__va_list_tag , fp_offset) - 4usize] ; ["Offset of field: __va_list_tag::overflow_arg_area"] [:: std :: mem :: offset_of ! (__va_list_tag , overflow_arg_area) - 8usize] ; ["Offset of field: __va_list_tag::reg_save_area"] [:: std :: mem :: offset_of ! (__va_list_tag , reg_save_area) - 16usize] ; } ;
diff --git a/wrapper.h b/wrapper.h
new file mode 100644
index 000000000..dd2069abf
--- /dev/null
+++ b/wrapper.h
@@ -0,0 +1,55 @@
+/* Auto-generated wrapper header for bindgen */
+/* Generated by header_wrapper_generator.py */
+
+/* Headers from lib/packagekit-glib2 */
+#include <packagekit-glib2/packagekit.h>
+#include <packagekit-glib2/pk-bitfield.h>
+#include <packagekit-glib2/pk-category.h>
+#include <packagekit-glib2/pk-client-helper.h>
+#include <packagekit-glib2/pk-client-sync.h>
+#include <packagekit-glib2/pk-client.h>
+#include <packagekit-glib2/pk-common.h>
+#include <packagekit-glib2/pk-console-shared.h>
+#include <packagekit-glib2/pk-control-sync.h>
+#include <packagekit-glib2/pk-control.h>
+#include <packagekit-glib2/pk-debug.h>
+#include <packagekit-glib2/pk-desktop.h>
+#include <packagekit-glib2/pk-distro-upgrade.h>
+#include <packagekit-glib2/pk-enum.h>
+#include <packagekit-glib2/pk-error.h>
+#include <packagekit-glib2/pk-eula-required.h>
+#include <packagekit-glib2/pk-files.h>
+#include <packagekit-glib2/pk-item-progress.h>
+#include <packagekit-glib2/pk-media-change-required.h>
+#include <packagekit-glib2/pk-offline.h>
+#include <packagekit-glib2/pk-package-id.h>
+#include <packagekit-glib2/pk-package-ids.h>
+#include <packagekit-glib2/pk-package-sack-sync.h>
+#include <packagekit-glib2/pk-package-sack.h>
+#include <packagekit-glib2/pk-package.h>
+#include <packagekit-glib2/pk-progress-bar.h>
+#include <packagekit-glib2/pk-progress.h>
+#include <packagekit-glib2/pk-repo-signature-required.h>
+#include <packagekit-glib2/pk-require-restart.h>
+#include <packagekit-glib2/pk-results.h>
+#include <packagekit-glib2/pk-source.h>
+#include <packagekit-glib2/pk-spawn-polkit-agent.h>
+#include <packagekit-glib2/pk-task-sync.h>
+#include <packagekit-glib2/pk-task-text.h>
+#include <packagekit-glib2/pk-task-wrapper.h>
+#include <packagekit-glib2/pk-task.h>
+#include <packagekit-glib2/pk-transaction-list.h>
+#include <packagekit-glib2/pk-transaction-past.h>
+
+/* Headers from src */
+//#include "src/packagekit-plugin.h"
+#include "src/pk-backend-job.h"
+#include "src/pk-backend-spawn.h"
+#include "src/pk-backend.h"
+#include "src/pk-dbus.h"
+#include "src/pk-engine.h"
+#include "src/pk-scheduler.h"
+#include "src/pk-shared.h"
+#include "src/pk-spawn.h"
+#include "src/pk-transaction-db.h"
+#include "src/pk-transaction.h"
-- 
2.49.1

