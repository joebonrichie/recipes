From 65b5fbdc50b8a973466192736d7544a77f762c56 Mon Sep 17 00:00:00 2001
From: "Derek J. Clark" <derekjohn.clark@gmail.com>
Date: Mon, 29 Dec 2025 20:15:12 -0800
Subject: [PATCH 1/3] fix(Default Profiles): Seperate overlay and full session
 defualt profiles

---
 assets/gamepad/profiles/default_overlay.json  | 80 +++++++++++++++++++
 core/global/launch_manager.gd                 | 26 +++++-
 core/systems/input/input_manager.gd           | 28 ++++++-
 core/systems/input/input_manager.tscn         |  2 +-
 core/systems/input/input_plumber.gd           | 18 -----
 .../input/overlay_mode_input_manager.gd       | 32 +++-----
 .../input/overlay_mode_input_manager.tscn     |  2 +-
 core/systems/launcher/launcher.gd             |  5 +-
 core/ui/card_ui/card_ui.gd                    |  1 +
 core/ui/card_ui/gamepad/gamepad_settings.gd   |  5 +-
 core/ui/card_ui/home/cardui_home.gd           |  2 +-
 core/ui/card_ui/library/library_menu.gd       |  2 +-
 project.godot                                 |  1 +
 13 files changed, 151 insertions(+), 53 deletions(-)
 create mode 100644 assets/gamepad/profiles/default_overlay.json

diff --git a/assets/gamepad/profiles/default_overlay.json b/assets/gamepad/profiles/default_overlay.json
new file mode 100644
index 000000000..4bd1773f7
--- /dev/null
+++ b/assets/gamepad/profiles/default_overlay.json
@@ -0,0 +1,80 @@
+{
+	"version": 1,
+	"kind": "DeviceProfile",
+	"name": "OpenGamepadUI Default",
+	"mapping": [
+		{
+			"name": "LeftTop",
+			"source_event": {
+				"gamepad": {
+					"button": "LeftTop"
+				}
+			},
+			"target_events": [
+				{
+					"gamepad": {
+						"button": "Guide"
+					}
+				},
+				{
+					"gamepad": {
+						"button": "North"
+					}
+				}
+			]
+		},
+		{
+			"name": "RightTop",
+			"source_event": {
+				"gamepad": {
+					"button": "RightTop"
+				}
+			},
+			"target_events": [
+				{
+					"gamepad": {
+						"button": "Guide"
+					}
+				},
+				{
+					"gamepad": {
+						"button": "East"
+					}
+				}
+			]
+		},
+		{
+			"name": "Keyboard",
+			"source_event": {
+				"gamepad": {
+					"button": "Keyboard"
+				}
+			},
+			"target_events": [
+				{
+					"dbus": "ui_osk"
+				}
+			]
+		},
+		{
+			"name": "QuickAccess2",
+			"source_event": {
+				"gamepad": {
+					"button": "QuickAccess2"
+				}
+			},
+			"target_events": [
+				{
+					"gamepad": {
+						"button": "Guide"
+					}
+				},
+				{
+					"gamepad": {
+						"button": "East"
+					}
+				}
+			]
+		},
+	]
+}
diff --git a/core/global/launch_manager.gd b/core/global/launch_manager.gd
index dfc18215c..0cd6bb232 100644
--- a/core/global/launch_manager.gd
+++ b/core/global/launch_manager.gd
@@ -66,7 +66,7 @@ var _ogui_window_id := 0
 var should_manage_overlay := true
 var logger := Log.get_logger("LaunchManager", Log.LEVEL.INFO)
 var _focused_app_id := 0
-
+var _input_manager: InputManager
 
 # Connect to Gamescope signals
 func _init() -> void:
@@ -212,6 +212,15 @@ func _save_persist_data():
 	file.flush()
 
 
+# Get access to nodes from the scene tree and other goodies
+func setup(input_manager: InputManager):
+	if not input_manager:
+		logger.error("No input manager found.")
+		return
+
+	_input_manager = input_manager
+
+
 ## Launches the given application and switches to the in-game state. Returns a
 ## [RunningApp] instance of the application.
 func launch(app: LibraryLaunchItem) -> RunningApp:
@@ -490,11 +499,20 @@ func set_gamepad_profile(path: String, target_gamepad: String = "") -> void:
 
 	# If no profile was specified, unset the gamepad profiles
 	if path == "":
+		# Get the input manager default path
+		var default_path = ""
+		if _input_manager:
+			default_path =  _input_manager.get_default_global_profile_path()
+
 		# Try check to see if there is a global gamepad setting
-		path = settings_manager.get_value("input", "gamepad_profile", InputPlumber.DEFAULT_GLOBAL_PROFILE) as String
-		# Verify we loaded a valid profile, or fallback.
+		path = settings_manager.get_value("input", "gamepad_profile", default_path) as String
+
+		# Verify can load a valid profile, or fallback.
 		if not path.ends_with(".json") or not FileAccess.file_exists(path):
-			path = InputPlumber.DEFAULT_GLOBAL_PROFILE
+			if default_path == "":
+				logger.warn("Unable to set default gamepad profile path from input manager.")
+				return
+			path = default_path
 
 	logger.info("Loading gamepad profile: " + path)
 	if not FileAccess.file_exists(path):
diff --git a/core/systems/input/input_manager.gd b/core/systems/input/input_manager.gd
index 165b3c024..e78817856 100644
--- a/core/systems/input/input_manager.gd
+++ b/core/systems/input/input_manager.gd
@@ -42,10 +42,29 @@ var current_touches := 0
 ## Will show logger events with the prefix InputManager
 var logger := Log.get_logger("InputManager", Log.LEVEL.INFO)
 
+const PROFILES_DIR := "user://data/gamepad/profiles"
+
+
+func _init() -> void:
+	# Ensure the default global profile exists in the user directory.
+	var default_global_profile := get_default_global_profile_path()
+	var default_profile := _get_default_profile_path()
+	if FileAccess.file_exists(default_global_profile):
+		return
+
+	var file := FileAccess.open(default_profile, FileAccess.READ)
+	var content := file.get_as_text()
+	file.close()
+	if DirAccess.make_dir_recursive_absolute(PROFILES_DIR) != OK:
+		var logger := Log.get_logger("InputPlumber", Log.LEVEL.DEBUG)
+		logger.error("Failed to create gamepad profiles directory")
+	var new_file := FileAccess.open(default_global_profile, FileAccess.WRITE)
+	new_file.store_string(content)
+	new_file.close()
+
 
 # Called when the node enters the scene tree for the first time.
 func _ready() -> void:
-	add_to_group("InputManager")
 	input_plumber.composite_device_added.connect(_watch_dbus_device)
 	input_plumber.started.connect(_init_inputplumber)
 	_init_inputplumber()
@@ -55,6 +74,13 @@ func _init_inputplumber() -> void:
 	for device in input_plumber.get_composite_devices():
 		_watch_dbus_device(device)
 
+func _get_default_profile_path() -> String:
+	return "res://assets/gamepad/profiles/default.json"
+
+func get_default_global_profile_path() -> String:
+	return "user://data/gamepad/profiles/global_default.json"
+	
+
 
 ## Returns true if the given event is an InputPlumber event
 static func is_inputplumber_event(event: InputEvent) -> bool:
diff --git a/core/systems/input/input_manager.tscn b/core/systems/input/input_manager.tscn
index 98c46b1b0..49bc122c5 100644
--- a/core/systems/input/input_manager.tscn
+++ b/core/systems/input/input_manager.tscn
@@ -4,7 +4,7 @@
 [ext_resource type="Script" uid="uid://blpngehu3py28" path="res://core/systems/input/input_plumber.gd" id="2_v1kl3"]
 [ext_resource type="InputPlumberInstance" uid="uid://e2bevy4j4rx2" path="res://core/systems/input/input_plumber.tres" id="3_eclcy"]
 
-[node name="InputManager" type="Node"]
+[node name="InputManager" type="Node" groups=["input_manager"]]
 script = ExtResource("1_3s67x")
 
 [node name="InputPlumber" type="Node" parent="."]
diff --git a/core/systems/input/input_plumber.gd b/core/systems/input/input_plumber.gd
index afb8593c3..35ef20f23 100644
--- a/core/systems/input/input_plumber.gd
+++ b/core/systems/input/input_plumber.gd
@@ -7,30 +7,12 @@ class_name InputPlumber
 ## The InputPlumberManager class is responsible for handling dbus messages to and
 ## from the InputPlumber input manager daemon.
 
-const DEFAULT_PROFILE := "res://assets/gamepad/profiles/default.json"
-const DEFAULT_GLOBAL_PROFILE := "user://data/gamepad/profiles/global_default.json"
-const PROFILES_DIR := "user://data/gamepad/profiles"
-
 @export var instance: InputPlumberInstance = load("res://core/systems/input/input_plumber.tres")
 
 # Keep a reference to dbus devices so they are not cleaned up automatically
 var _dbus_devices := {}
 
 
-func _init() -> void:
-	# Ensure the default global profile exists in the user directory.
-	if not FileAccess.file_exists(DEFAULT_GLOBAL_PROFILE):
-		var file := FileAccess.open(DEFAULT_PROFILE, FileAccess.READ)
-		var content := file.get_as_text()
-		file.close()
-		if DirAccess.make_dir_recursive_absolute(PROFILES_DIR) != OK:
-			var logger := Log.get_logger("InputPlumber", Log.LEVEL.DEBUG)
-			logger.error("Failed to create gamepad profiles directory")
-		var new_file := FileAccess.open(DEFAULT_GLOBAL_PROFILE, FileAccess.WRITE)
-		new_file.store_string(content)
-		new_file.close()
-
-
 func _ready() -> void:
 	# Add listeners for any new devices
 	var on_device_added := func(device: CompositeDevice):
diff --git a/core/systems/input/overlay_mode_input_manager.gd b/core/systems/input/overlay_mode_input_manager.gd
index ca1a2f3dc..dcf729d18 100644
--- a/core/systems/input/overlay_mode_input_manager.gd
+++ b/core/systems/input/overlay_mode_input_manager.gd
@@ -1,5 +1,5 @@
 @icon("res://assets/editor-icons/material-symbols-joystick.svg")
-extends Node
+extends InputManager
 class_name OverlayInputManager
 
 ## Manages global input while ion overlay mode
@@ -11,33 +11,11 @@ class_name OverlayInputManager
 ## To include this functionality, add this as a node to the root node in the
 ## scene tree.
 
-## The audio manager to use to adjust the audio when audio input events happen.
-var audio_manager := load("res://core/global/audio_manager.tres") as AudioManager
-## InputPlumber receives and sends DBus input events.
-var input_plumber := load("res://core/systems/input/input_plumber.tres") as InputPlumberInstance
-## LaunchManager provides context on the currently running app so we can switch profiles
-var launch_manager := load("res://core/global/launch_manager.tres") as LaunchManager
-## The Global State Machine
-var state_machine := load("res://assets/state/state_machines/global_state_machine.tres") as StateMachine
-## State machine to use to switch menu states in response to input events.
-var popup_state_machine := (
-	preload("res://assets/state/state_machines/popup_state_machine.tres") as StateMachine
-)
 var menu_state_machine := preload("res://assets/state/state_machines/menu_state_machine.tres") as StateMachine
-var in_game_menu_state := preload("res://assets/state/states/in_game_menu.tres") as State
-var main_menu_state := preload("res://assets/state/states/main_menu.tres") as State
-var quick_bar_state := preload("res://assets/state/states/quick_bar_menu.tres") as State
 var base_state = preload("res://assets/state/states/in_game.tres") as State
 
-var actions_pressed := {}
-
-## Will show logger events with the prefix InputManager(Overlay Mode)
-var logger := Log.get_logger("InputManager(Overlay Mode)", Log.LEVEL.INFO)
-
-
 # Called when the node enters the scene tree for the first time.
 func _ready() -> void:
-	add_to_group("InputManager")
 	input_plumber.composite_device_added.connect(_watch_dbus_device)
 	input_plumber.started.connect(_init_inputplumber)
 	_init_inputplumber()
@@ -48,6 +26,14 @@ func _init_inputplumber() -> void:
 		_watch_dbus_device(device)
 
 
+func _get_default_profile_path() -> String:
+	return "res://assets/gamepad/profiles/default_overlay.json"
+
+
+func get_default_global_profile_path() -> String:
+	return "user://data/gamepad/profiles/global_default_overlay.json"
+
+
 ## Queue a release event for the given action
 func action_release(dbus_path: String, action: String, strength: float = 1.0) -> void:
 	Input.action_release(action)
diff --git a/core/systems/input/overlay_mode_input_manager.tscn b/core/systems/input/overlay_mode_input_manager.tscn
index a6b22c931..c83193228 100644
--- a/core/systems/input/overlay_mode_input_manager.tscn
+++ b/core/systems/input/overlay_mode_input_manager.tscn
@@ -3,7 +3,7 @@
 [ext_resource type="Script" uid="uid://cwuxmp5lmsvgt" path="res://core/systems/input/overlay_mode_input_manager.gd" id="1_fvwoc"]
 [ext_resource type="Script" uid="uid://blpngehu3py28" path="res://core/systems/input/input_plumber.gd" id="2_vf8uv"]
 
-[node name="InputManager" type="Node"]
+[node name="InputManager" type="Node" groups=["input_manager"]]
 script = ExtResource("1_fvwoc")
 
 [node name="InputPlumber" type="Node" parent="."]
diff --git a/core/systems/launcher/launcher.gd b/core/systems/launcher/launcher.gd
index 11271ebe9..eef4521ff 100644
--- a/core/systems/launcher/launcher.gd
+++ b/core/systems/launcher/launcher.gd
@@ -5,7 +5,7 @@ class_name Launcher
 @export var launch_manager := preload("res://core/global/launch_manager.tres") as LaunchManager
 
 @onready var overlay_display = OS.get_environment("DISPLAY")
-
+@onready var input_manager := get_tree().get_first_node_in_group("input_manager") as InputManager
 
 func _init() -> void:
 	launch_manager._load_persist_data()
@@ -18,3 +18,6 @@ func _ready() -> void:
 	timer.wait_time = 1
 	timer.timeout.connect(launch_manager.check_running)
 	add_child(timer)
+
+	# Give the launch manager access to the input manager
+	launch_manager.setup(input_manager)
diff --git a/core/ui/card_ui/card_ui.gd b/core/ui/card_ui/card_ui.gd
index c920516bb..a3f68c255 100644
--- a/core/ui/card_ui/card_ui.gd
+++ b/core/ui/card_ui/card_ui.gd
@@ -33,6 +33,7 @@ var overlay_window_id := 0
 @onready var fade_texture := $%FadeTexture as TextureRect
 @onready var power_timer := $%PowerTimer as Timer
 @onready var settings_menu := $%SettingsMenu as Control
+@onready var input_manager := get_tree().get_first_node_in_group("input_manager") as InputManager
 
 var logger = Log.get_logger("Main", Log.LEVEL.INFO)
 
diff --git a/core/ui/card_ui/gamepad/gamepad_settings.gd b/core/ui/card_ui/gamepad/gamepad_settings.gd
index bd8d50adf..b0e486ff3 100644
--- a/core/ui/card_ui/gamepad/gamepad_settings.gd
+++ b/core/ui/card_ui/gamepad/gamepad_settings.gd
@@ -40,6 +40,7 @@ var logger := Log.get_logger("GamepadSettings", Log.LEVEL.INFO)
 @onready var delete_button := $%DeleteButton as CardIconButton
 @onready var profile_label := $%ProfileNameLabel as Label
 @onready var gamepad_type_dropdown := %GamepadTypeDropdown as Dropdown
+@onready var input_manager := get_tree().get_first_node_in_group("input_manager") as InputManager
 
 
 # Called when the node enters the scene tree for the first time.
@@ -149,7 +150,7 @@ func _on_state_entered(_from: State) -> void:
 	var profile_path: String
 	if not self.library_item:
 		self.profile_label.text = "Global"
-		profile_path = settings_manager.get_value("input", "gamepad_profile", InputPlumber.DEFAULT_GLOBAL_PROFILE) as String
+		profile_path = settings_manager.get_value("input", "gamepad_profile", input_manager.get_default_global_profile_path()) as String
 	else:
 		self.profile_label.text = self.library_item.name
 		profile_path = settings_manager.get_library_value(self.library_item, "gamepad_profile", "") as String
@@ -685,7 +686,7 @@ func _save_profile() -> void:
 func _load_profile(profile_path: String = "") -> InputPlumberProfile:
 	var loaded: InputPlumberProfile
 	if profile_path == "" or not profile_path.ends_with(".json") or not FileAccess.file_exists(profile_path):
-		loaded = InputPlumberProfile.load(InputPlumber.DEFAULT_GLOBAL_PROFILE)
+		loaded = InputPlumberProfile.load(input_manager.get_default_global_profile_path())
 		if not loaded:
 			loaded = InputPlumberProfile.new()
 		if library_item:
diff --git a/core/ui/card_ui/home/cardui_home.gd b/core/ui/card_ui/home/cardui_home.gd
index 1e4b668a4..4e7bf9c3f 100644
--- a/core/ui/card_ui/home/cardui_home.gd
+++ b/core/ui/card_ui/home/cardui_home.gd
@@ -203,7 +203,7 @@ func _on_card_focused(item: LibraryItem, card: Control) -> void:
 	library_banner.visible = false
 
 	# Don't scroll to the card if mouse or touch is being used
-	var input_manager := get_tree().get_first_node_in_group("InputManager")
+	var input_manager := get_tree().get_first_node_in_group("input_manager")
 	if input_manager:
 		if (input_manager as InputManager).current_touches > 0:
 			return
diff --git a/core/ui/card_ui/library/library_menu.gd b/core/ui/card_ui/library/library_menu.gd
index d095e7b0f..ea48b96b7 100644
--- a/core/ui/card_ui/library/library_menu.gd
+++ b/core/ui/card_ui/library/library_menu.gd
@@ -259,7 +259,7 @@ func _on_focus_updated(card: Control, tab: int) -> void:
 	_current_selection[tab] = card
 	
 	# Don't scroll to the card if mouse or touch is being used
-	var input_manager := get_tree().get_first_node_in_group("InputManager")
+	var input_manager := get_tree().get_first_node_in_group("input_manager")
 	if input_manager:
 		if (input_manager as InputManager).current_touches > 0:
 			return
diff --git a/project.godot b/project.godot
index 8c87ef36b..bd0290843 100644
--- a/project.godot
+++ b/project.godot
@@ -56,6 +56,7 @@ import/blender/enabled=false
 
 menu=""
 main=""
+input_manager="The session input manager"
 
 [input]
 

From d7426ac40cb7733aee2ddc24545a91affe1c911a Mon Sep 17 00:00:00 2001
From: "Derek J. Clark" <derekjohn.clark@gmail.com>
Date: Wed, 31 Dec 2025 16:05:52 -0800
Subject: [PATCH 2/3] fix(Overlay Mode): Use NativeEvent Capabilties instead of
 chords for steam events

---
 core/systems/input/input_plumber.gd           | 70 +++++++++----------
 .../input/overlay_mode_input_manager.gd       | 63 +++++++----------
 2 files changed, 62 insertions(+), 71 deletions(-)

diff --git a/core/systems/input/input_plumber.gd b/core/systems/input/input_plumber.gd
index 35ef20f23..afd8c6197 100644
--- a/core/systems/input/input_plumber.gd
+++ b/core/systems/input/input_plumber.gd
@@ -54,6 +54,7 @@ static func load_target_modified_profile(device: CompositeDevice, path: String,
 	if path == "" or not path.ends_with(".json") or not FileAccess.file_exists(path):
 		logger.error("Profile path:", path," is not a valid profile path.")
 		return
+
 	if profile_modifier.is_empty():
 		device.load_profile_path(path)
 		return
@@ -65,41 +66,40 @@ static func load_target_modified_profile(device: CompositeDevice, path: String,
 	var r_pad_cap = "Touchpad:RightPad:Motion"
 	var mouse_cap = "Mouse:Motion"
 
-	if !profile_modifier.is_empty():
-		var mapped_capabilities := profile.to_json()
-		logger.debug("Mapped Capabilities (before):", mapped_capabilities)
-		match profile_modifier:
-				"deck-uhid":
-					logger.debug("Steam Deck Profile")
-					if c_pad_cap not in mapped_capabilities:
-						logger.debug("Map", c_pad_cap)
-						var c_pad_map := InputPlumberMapping.from_source_capability(c_pad_cap)
-						var r_pad_event := InputPlumberEvent.from_capability(r_pad_cap)
-						c_pad_map.target_events = [r_pad_event]
-						profile.mapping.append(c_pad_map)
-
-				"ds5", "ds5-edge":
-					logger.debug("Dualsense Profile")
-					if l_pad_cap not in mapped_capabilities:
-						logger.debug("Map", l_pad_cap)
-						var l_pad_map := InputPlumberMapping.from_source_capability(l_pad_cap)
-						var c_pad_event := InputPlumberEvent.from_capability(c_pad_cap)
-						l_pad_map.target_events = [c_pad_event]
-						profile.mapping.append(l_pad_map)
-					if r_pad_cap not in mapped_capabilities:
-						logger.debug("Map", r_pad_cap)
-						var r_pad_map := InputPlumberMapping.from_source_capability(r_pad_cap)
-						var c_pad_event := InputPlumberEvent.from_capability(c_pad_cap)
-						r_pad_map.target_events = [c_pad_event]
-						profile.mapping.append(r_pad_map)
-
-				_:
-					logger.debug("Target device needs no modifications:", profile_modifier)
-
-		mapped_capabilities = profile.to_json()
-		logger.debug("Mapped Capabilities (after):", mapped_capabilities)
-
-	path = path.rstrip(".json") + profile_modifier + ".json"
+	var mapped_capabilities := profile.to_json()
+	logger.debug("Mapped Capabilities (before):", mapped_capabilities)
+	match profile_modifier:
+			"deck-uhid", "deck":
+				logger.info("Modified current profile with additional Steam Deck capabilities.")
+				if c_pad_cap not in mapped_capabilities:
+					logger.debug("Map", c_pad_cap)
+					var c_pad_map := InputPlumberMapping.from_source_capability(c_pad_cap)
+					var r_pad_event := InputPlumberEvent.from_capability(r_pad_cap)
+					c_pad_map.target_events = [r_pad_event]
+					profile.mapping.append(c_pad_map)
+
+			"ds5", "ds5-edge":
+				logger.info("Modified current profile with additional Dualsense capabilities.")
+				if l_pad_cap not in mapped_capabilities:
+					logger.debug("Map", l_pad_cap)
+					var l_pad_map := InputPlumberMapping.from_source_capability(l_pad_cap)
+					var c_pad_event := InputPlumberEvent.from_capability(c_pad_cap)
+					l_pad_map.target_events = [c_pad_event]
+					profile.mapping.append(l_pad_map)
+				if r_pad_cap not in mapped_capabilities:
+					logger.debug("Map", r_pad_cap)
+					var r_pad_map := InputPlumberMapping.from_source_capability(r_pad_cap)
+					var c_pad_event := InputPlumberEvent.from_capability(c_pad_cap)
+					r_pad_map.target_events = [c_pad_event]
+					profile.mapping.append(r_pad_map)
+
+			_:
+				logger.debug("Target device needs no modifications:", profile_modifier)
+
+	mapped_capabilities = profile.to_json()
+	logger.debug("Mapped Capabilities (after):", mapped_capabilities)
+	path = path.rstrip(".json") + "_" + profile_modifier + ".json"
+
 	if profile.save(path) != OK:
 		logger.error("Failed to save", profile.name, "to", path)
 		return
diff --git a/core/systems/input/overlay_mode_input_manager.gd b/core/systems/input/overlay_mode_input_manager.gd
index dcf729d18..360a621ad 100644
--- a/core/systems/input/overlay_mode_input_manager.gd
+++ b/core/systems/input/overlay_mode_input_manager.gd
@@ -100,8 +100,8 @@ func _input(event: InputEvent) -> void:
 		get_viewport().set_input_as_handled()
 		return
 
-	# Steam chord events
-	if _send_steam_chord(event):
+	# Passthrough underlay supported capability events
+	if _send_capability(event):
 		get_viewport().set_input_as_handled()
 		return
 
@@ -279,7 +279,8 @@ func _guide_input(event: InputEvent) -> void:
 	# Emit the main menu action if this was not a guide action
 	logger.debug("Guide released. Additional events did not use guide action. Sending Guide.")
 	_close_focused_window()
-	_return_chord(["Gamepad:Button:Guide"])
+	logger.debug("Return event chord to InputPlumber: Gamepad:Button:Guide")
+	_send_chord(["Gamepad:Button:Guide"])
 
 
 ## Handle quick bar menu events to open the quick bar menu
@@ -297,56 +298,46 @@ func _quick_bar_input(event: InputEvent) -> void:
 		popup_state_machine.push_state(quick_bar_state)
 
 
-## Handle Steam chord events. Returns true if this was a Steam chord.
-func _send_steam_chord(event: InputEvent) -> bool:
-	var chord: PackedStringArray = ["Gamepad:Button:Guide"]
-	# Block up events from doing weird things. InputPlumber will handle up events.
+## Send a capability back to InputPlumber events. Returns true if the capability is supported.
+func _send_capability(event: InputEvent) -> bool:
+	var capability: String
+
+	# Ignore up events, chords will unpress themselves
 	if not event.is_pressed():
 		return false
 
-	# Steam Quick Bar
-	if event.is_action_pressed("ogui_qam_ov"):
+	if event.is_action("ogui_qam_ov"):
 		logger.debug("Trigger Steam QAM")
-		chord.append("Gamepad:Button:South")
-
-	# Steam On-Screen Keyboard
-	elif event.is_action_pressed("ogui_osk_ov"):
-			logger.debug("Trigger Steam OSK")
-			chord.append("Gamepad:Button:North")
-
-	# Steam Video-Capture
-	elif event.is_action_pressed("ogui_vc_ov"):
-			logger.debug("Trigger Steam VC")
-			chord.append("Gamepad:Button:West")
-
-	# Steam Screenshot
-	elif event.is_action_pressed("ogui_sc_ov"):
-			logger.debug("Trigger Steam Screenshot")
-			chord.append("Gamepad:Button:RightBumper")
-
-	# Not a steam chord
-	else:
+		capability = "Gamepad:Button:QuickAccess"
+		_close_focused_window()
+	elif event.is_action("ogui_osk_ov"):
+		logger.debug("Trigger Steam OSK")
+		capability = "Gamepad:Button:Keyboard"
+		_close_focused_window()
+	elif event.is_action("ogui_sc_ov"):
+		logger.debug("Trigger Steam Screenshot")
+		capability = "Gamepad:Button:Screenshot"
+
+	# Ignore empty events
+	if capability.is_empty():
 		return false
 
-	_close_focused_window()
-	_return_chord(chord)
+	_send_chord([capability])
 	return true
 
 
-func _return_chord(actions: PackedStringArray) -> void:
-	# TODO: Figure out a way to get the device who sent the event through
-	# Input.parse_input_event so we don't do this terrible loop. This is awful.
-	logger.debug("Return events to InputPlumber: " + str(actions))
+## Send an event chord back to InputPlumber, bypassing translation.
+func _send_chord(capabilities: PackedStringArray) -> void:
+	logger.debug("Return events to InputPlumber: " + str(capabilities))
 	for device in input_plumber.get_composite_devices():
 		device.intercept_mode = InputPlumberInstance.INTERCEPT_MODE_PASS
-		device.send_button_chord(actions)
+		device.send_button_chord(capabilities)
 
 
 func _audio_input(event: InputEvent) -> void:
 	# Only act on press events
 	if not event.is_pressed():
 		return
-
 	if event.is_action("ogui_volume_mute"):
 		logger.debug("Mute!")
 		audio_manager.call_deferred("toggle_mute")

From e99c9b3334a3c04f881f95e9f2697e95a69171d4 Mon Sep 17 00:00:00 2001
From: "Derek J. Clark" <derekjohn.clark@gmail.com>
Date: Wed, 31 Dec 2025 16:51:43 -0800
Subject: [PATCH 3/3] feat(InputPlumber): Get target device type, keep device
 default target on first boot

---
 core/systems/input/input_plumber_profile.gd   |   2 +
 core/ui/card_ui/gamepad/gamepad_settings.gd   |  42 +++++--
 extensions/core/src/dbus/inputplumber.rs      |   2 +
 .../core/src/dbus/inputplumber/target.rs      |  36 ++++++
 extensions/core/src/input/inputplumber.rs     |   1 +
 .../input/inputplumber/composite_device.rs    |   4 +-
 .../src/input/inputplumber/gamepad_device.rs  | 119 ++++++++++++++++++
 .../src/input/inputplumber/keyboard_device.rs |  43 +++++--
 .../src/input/inputplumber/mouse_device.rs    |  45 +++++--
 9 files changed, 269 insertions(+), 25 deletions(-)
 create mode 100644 extensions/core/src/dbus/inputplumber/target.rs
 create mode 100644 extensions/core/src/input/inputplumber/gamepad_device.rs

diff --git a/core/systems/input/input_plumber_profile.gd b/core/systems/input/input_plumber_profile.gd
index 6237f3116..7ac5eb378 100644
--- a/core/systems/input/input_plumber_profile.gd
+++ b/core/systems/input/input_plumber_profile.gd
@@ -140,6 +140,8 @@ static func get_target_device(target_device_str: String) -> TargetDevice:
 			target_device = TargetDevice.DualSense
 		"ds5-edge":
 			target_device = TargetDevice.DualSenseEdge
+		"deck":
+			target_device = TargetDevice.SteamDeck
 		"deck-uhid":
 			target_device = TargetDevice.SteamDeck
 		"hori-steam":
diff --git a/core/ui/card_ui/gamepad/gamepad_settings.gd b/core/ui/card_ui/gamepad/gamepad_settings.gd
index b0e486ff3..31313e692 100644
--- a/core/ui/card_ui/gamepad/gamepad_settings.gd
+++ b/core/ui/card_ui/gamepad/gamepad_settings.gd
@@ -74,8 +74,17 @@ func _ready() -> void:
 	# Load the default profile
 	var profile_path = settings_manager.get_value("input", "gamepad_profile", "")
 	self.profile_gamepad = settings_manager.get_value("input", "gamepad_profile_target", "")
-	for composite_device in input_plumber.get_composite_devices():
-			_set_gamepad_profile(composite_device, profile_path)
+	for device: CompositeDevice in input_plumber.get_composite_devices():
+			if not self.profile_gamepad:
+				# Set the current profile_gamepad type to the currently configured CompositeDevice target gamepad
+				var targets = gamepad.get_target_devices()
+				for target in targets:
+					var target_dbus_path: String = target.get("dbus_path")
+					if not target_dbus_path.contains("target/gamepad"):
+						continue
+					self.profile_gamepad = target.get("device_type")
+					break
+			_set_gamepad_profile(device, profile_path)
 
 	# Grab focus when the mapper exits
 	var on_state_changed := func(_from: State, to: State):
@@ -131,7 +140,7 @@ func _on_state_entered(_from: State) -> void:
 	
 	# Set the gamepad name label
 	gamepad_label.text = self.gamepad.name
-	
+
 	# Populate the menu with the source inputs for the given gamepad
 	populate_mappings_for(self.gamepad)
 
@@ -146,17 +155,31 @@ func _on_state_entered(_from: State) -> void:
 	if not self.library_item:
 		self.library_item = launch_manager.get_current_app_library_item()
 
+	# Set the current profile_gamepad type to the currently configured CompositeDevice target gamepad
+	var targets = gamepad.get_target_devices()
+	for target in targets:
+		var target_dbus_path: String = target.get("dbus_path")
+		if not target_dbus_path.contains("target/gamepad"):
+			continue
+		self.profile_gamepad = target.get("device_type")
+		break
+
 	# If no library item was set with the state, then configure the OGUI profile
 	var profile_path: String
 	if not self.library_item:
 		self.profile_label.text = "Global"
 		profile_path = settings_manager.get_value("input", "gamepad_profile", input_manager.get_default_global_profile_path()) as String
+		# Check if we have a profile target, otherwise use the currently set one
+		self.profile_gamepad = settings_manager.get_value("input", "gamepad_profile_target", self.profile_gamepad)
 	else:
 		self.profile_label.text = self.library_item.name
 		profile_path = settings_manager.get_library_value(self.library_item, "gamepad_profile", "") as String
-		self.profile_gamepad = settings_manager.get_library_value(self.library_item, "gamepad_profile_target", "") as String
+		# Check if we have a profile target, otherwise use the currently set one
+		self.profile_gamepad = settings_manager.get_library_value(self.library_item, "gamepad_profile_target", self.profile_gamepad) as String
 
 	self.profile = _load_profile(profile_path)
+	logger.debug("Set profile target gamepad to " + self.profile_gamepad)
+
 	_update_mapping_elements()
 
 	# Clear focus
@@ -196,7 +219,7 @@ func populate_mappings_for(gamepad: CompositeDevice) -> void:
 	# Sort the capabilities
 	capabilities = InputPlumberEvent.sort_capabilities(capabilities)
 	capabilities.reverse()
-	logger.debug("Found capabilities for gamepad: " + str(capabilities))
+	logger.debug("Found capabilities for " + gamepad_name + ": " + str(capabilities))
 
 	# Delete any old UI elements
 	for child in container.get_children():
@@ -390,9 +413,10 @@ func _add_group_for_capability(gamepad_name: String, capability: String, parent:
 
 ## Syncs the UI to the given profile
 func _update_mapping_elements() -> void:
-	if not profile:
+	if not self.profile:
 		return
-	profile_label.text = profile.name
+
+	self.profile_label.text = self.profile.name
 
 	# Update the dropdown based on the profile's target gamepad type
 	if not self.profile_gamepad.is_empty():
@@ -646,8 +670,8 @@ func _save_profile() -> void:
 		settings_manager.set_value("input", "gamepad_profile", path)
 		settings_manager.set_value("input", "gamepad_profile_target", self.profile_gamepad)
 
-		for gamepad in input_plumber.get_composite_devices():
-			_set_gamepad_profile(gamepad, path)
+		for device: CompositeDevice in input_plumber.get_composite_devices():
+			_set_gamepad_profile(device, path)
 
 		logger.debug("Saved global gamepad profile to: " + path)
 		notify.text = "Global gamepad profile saved"
diff --git a/extensions/core/src/dbus/inputplumber.rs b/extensions/core/src/dbus/inputplumber.rs
index e722fce81..c4647b77f 100644
--- a/extensions/core/src/dbus/inputplumber.rs
+++ b/extensions/core/src/dbus/inputplumber.rs
@@ -1,6 +1,8 @@
 pub mod composite_device;
 pub mod dbus_device;
 pub mod event_device;
+pub mod gamepad;
 pub mod input_manager;
 pub mod keyboard;
 pub mod mouse;
+pub mod target;
diff --git a/extensions/core/src/dbus/inputplumber/target.rs b/extensions/core/src/dbus/inputplumber/target.rs
new file mode 100644
index 000000000..4e6502615
--- /dev/null
+++ b/extensions/core/src/dbus/inputplumber/target.rs
@@ -0,0 +1,36 @@
+//! # D-Bus interface proxy for: `org.shadowblip.Input.Gamepad`
+//!
+//! This code was generated by `zbus-xmlgen` `4.1.0` from D-Bus introspection data.
+//! Source: `Interface '/org/shadowblip/InputPlumber/devices/target/gamepad0' from service 'org.shadowblip.InputPlumber' on system bus`.
+//!
+//! You may prefer to adapt it, instead of using it verbatim.
+//!
+//! More information can be found in the [Writing a client proxy] section of the zbus
+//! documentation.
+//!
+//! This type implements the [D-Bus standard interfaces], (`org.freedesktop.DBus.*`) for which the
+//! following zbus API can be used:
+//!
+//! * [`zbus::fdo::PeerProxy`]
+//! * [`zbus::fdo::PropertiesProxy`]
+//! * [`zbus::fdo::IntrospectableProxy`]
+//!
+//! Consequently `zbus-xmlgen` did not generate code for the above interfaces.
+//!
+//! [Writing a client proxy]: https://dbus2.github.io/zbus/client.html
+//! [D-Bus standard interfaces]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces,
+use zbus::proxy;
+#[proxy(
+    interface = "org.shadowblip.Input.Target",
+    default_service = "org.shadowblip.InputPlumber",
+    default_path = "/org/shadowblip/InputPlumber/devices/target/gamepad0"
+)]
+pub trait Target {
+    /// Name property
+    #[zbus(property)]
+    fn name(&self) -> zbus::Result<String>;
+
+    /// Name property
+    #[zbus(property)]
+    fn device_type(&self) -> zbus::Result<String>;
+}
diff --git a/extensions/core/src/input/inputplumber.rs b/extensions/core/src/input/inputplumber.rs
index d244da4f6..a0dd9c77c 100644
--- a/extensions/core/src/input/inputplumber.rs
+++ b/extensions/core/src/input/inputplumber.rs
@@ -1,6 +1,7 @@
 pub mod composite_device;
 pub mod dbus_device;
 pub mod event_device;
+pub mod gamepad_device;
 pub mod keyboard_device;
 pub mod mouse_device;
 
diff --git a/extensions/core/src/input/inputplumber/composite_device.rs b/extensions/core/src/input/inputplumber/composite_device.rs
index 40322020a..c37144e00 100644
--- a/extensions/core/src/input/inputplumber/composite_device.rs
+++ b/extensions/core/src/input/inputplumber/composite_device.rs
@@ -5,6 +5,7 @@ use godot::classes::{ProjectSettings, Resource, ResourceLoader};
 use crate::dbus::inputplumber::composite_device::CompositeDeviceProxyBlocking;
 use crate::dbus::DBusVariant;
 use crate::get_dbus_system_blocking;
+use crate::input::inputplumber::gamepad_device::GamepadDevice;
 
 use super::dbus_device::DBusDevice;
 use super::keyboard_device::KeyboardDevice;
@@ -237,7 +238,8 @@ impl CompositeDevice {
         // Build the Godot object based on the path
         for path in values {
             if path.contains("gamepad") {
-                // TODO
+                let device = GamepadDevice::new(path.as_str());
+                target_devices.push(&device.to_variant());
                 continue;
             }
             if path.contains("keyboard") {
diff --git a/extensions/core/src/input/inputplumber/gamepad_device.rs b/extensions/core/src/input/inputplumber/gamepad_device.rs
new file mode 100644
index 000000000..61c8f4943
--- /dev/null
+++ b/extensions/core/src/input/inputplumber/gamepad_device.rs
@@ -0,0 +1,119 @@
+use godot::{classes::ResourceLoader, prelude::*};
+
+use crate::{
+    dbus::inputplumber::{gamepad::GamepadProxyBlocking, target::TargetProxyBlocking},
+    get_dbus_system_blocking,
+};
+
+use super::INPUT_PLUMBER_BUS;
+
+#[derive(GodotClass)]
+#[class(no_init, base=Resource)]
+pub struct GamepadDevice {
+    base: Base<Resource>,
+    path: String,
+    gamepad_proxy: Option<GamepadProxyBlocking<'static>>,
+    target_proxy: Option<TargetProxyBlocking<'static>>,
+
+    #[allow(dead_code)]
+    #[var(get = get_dbus_path)]
+    dbus_path: GString,
+    #[allow(dead_code)]
+    #[var(get = get_name)]
+    name: GString,
+    #[allow(dead_code)]
+    #[var(get = get_type)]
+    device_type: GString,
+}
+
+#[godot_api]
+impl GamepadDevice {
+    /// Create a new [GamepadDevice] with the given DBus path
+    fn from_path(path: GString) -> Gd<Self> {
+        Gd::from_init_fn(|base| {
+            // Create a connection to DBus
+            let conn = get_dbus_system_blocking().ok();
+
+            // Get a proxy instance to the composite device gamepad interface
+            let gamepad_proxy = if let Some(conn) = conn.as_ref() {
+                let path: String = path.clone().into();
+                GamepadProxyBlocking::builder(conn)
+                    .path(path)
+                    .ok()
+                    .and_then(|builder| builder.build().ok())
+            } else {
+                None
+            };
+
+            // Get a proxy instance to the composite device target interface
+            let target_proxy = if let Some(conn) = conn.as_ref() {
+                let path: String = path.clone().into();
+                TargetProxyBlocking::builder(conn)
+                    .path(path)
+                    .ok()
+                    .and_then(|builder| builder.build().ok())
+            } else {
+                None
+            };
+
+            // Accept a base of type Base<Resource> and directly forward it.
+            Self {
+                base,
+                gamepad_proxy,
+                target_proxy,
+                path: path.clone().into(),
+                dbus_path: path,
+                name: Default::default(),
+                device_type: Default::default(),
+            }
+        })
+    }
+
+    /// Get or create a [GamepadDevice] with the given DBus path. If an instance
+    /// already exists with the given path, then it will be loaded from the resource
+    /// cache.
+    pub fn new(path: &str) -> Gd<Self> {
+        let res_path = format!("dbus://{INPUT_PLUMBER_BUS}{path}");
+
+        // Check to see if a resource already exists for this device
+        let mut resource_loader = ResourceLoader::singleton();
+        if resource_loader.exists(res_path.as_str()) {
+            if let Some(res) = resource_loader.load(res_path.as_str()) {
+                log::debug!("Resource already exists, loading that instead");
+                let device: Gd<GamepadDevice> = res.cast();
+                device
+            } else {
+                let mut device = GamepadDevice::from_path(path.to_string().into());
+                device.take_over_path(res_path.as_str());
+                device
+            }
+        } else {
+            let mut device = GamepadDevice::from_path(path.to_string().into());
+            device.take_over_path(res_path.as_str());
+            device
+        }
+    }
+
+    #[func]
+    pub fn get_dbus_path(&self) -> GString {
+        self.path.clone().into()
+    }
+
+    /// Get the name of the [GamepadDevice]
+    #[func]
+    pub fn get_name(&self) -> GString {
+        let Some(proxy) = self.gamepad_proxy.as_ref() else {
+            return "".into();
+        };
+        proxy.name().unwrap_or_default().into()
+    }
+
+    /// Get the type of the [GamepadDevice]
+    #[func]
+    pub fn get_type(&self) -> GString {
+        let Some(proxy) = self.target_proxy.as_ref() else {
+            return "".into();
+        };
+        proxy.device_type().unwrap_or_default().into()
+    }
+}
diff --git a/extensions/core/src/input/inputplumber/keyboard_device.rs b/extensions/core/src/input/inputplumber/keyboard_device.rs
index f439e9430..4c5682451 100644
--- a/extensions/core/src/input/inputplumber/keyboard_device.rs
+++ b/extensions/core/src/input/inputplumber/keyboard_device.rs
@@ -1,6 +1,9 @@
 use godot::{classes::ResourceLoader, prelude::*};
 
-use crate::{dbus::inputplumber::keyboard::KeyboardProxyBlocking, get_dbus_system_blocking};
+use crate::{
+    dbus::inputplumber::{keyboard::KeyboardProxyBlocking, target::TargetProxyBlocking},
+    get_dbus_system_blocking,
+};
 
 use super::INPUT_PLUMBER_BUS;
 
@@ -9,7 +12,8 @@ use super::INPUT_PLUMBER_BUS;
 pub struct KeyboardDevice {
     base: Base<Resource>,
     path: String,
-    proxy: Option<KeyboardProxyBlocking<'static>>,
+    keyboard_proxy: Option<KeyboardProxyBlocking<'static>>,
+    target_proxy: Option<TargetProxyBlocking<'static>>,
 
     #[allow(dead_code)]
     #[var(get = get_dbus_path)]
@@ -17,6 +21,9 @@ pub struct KeyboardDevice {
     #[allow(dead_code)]
     #[var(get = get_name)]
     name: GString,
+    #[allow(dead_code)]
+    #[var(get = get_type)]
+    device_type: GString,
 }
 
 #[godot_api]
@@ -27,8 +34,8 @@ impl KeyboardDevice {
             // Create a connection to DBus
             let conn = get_dbus_system_blocking().ok();
 
-            // Get a proxy instance to the composite device
-            let proxy = if let Some(conn) = conn.as_ref() {
+            // Get a proxy instance to the composite device keyboard interface
+            let keyboard_proxy = if let Some(conn) = conn.as_ref() {
                 let path: String = path.clone().into();
                 KeyboardProxyBlocking::builder(conn)
                     .path(path)
@@ -38,13 +45,26 @@ impl KeyboardDevice {
                 None
             };
 
+            // Get a proxy instance to the composite device target interface
+            let target_proxy = if let Some(conn) = conn.as_ref() {
+                let path: String = path.clone().into();
+                TargetProxyBlocking::builder(conn)
+                    .path(path)
+                    .ok()
+                    .and_then(|builder| builder.build().ok())
+            } else {
+                None
+            };
+
             // Accept a base of type Base<Resource> and directly forward it.
             Self {
                 base,
-                proxy,
+                keyboard_proxy,
+                target_proxy,
                 path: path.clone().into(),
                 dbus_path: path,
                 name: Default::default(),
+                device_type: Default::default(),
             }
         })
     }
@@ -82,7 +102,7 @@ impl KeyboardDevice {
     /// Get the name of the [KeyboardDevice]
     #[func]
     pub fn get_name(&self) -> GString {
-        let Some(proxy) = self.proxy.as_ref() else {
+        let Some(proxy) = self.keyboard_proxy.as_ref() else {
             return "".into();
         };
         proxy.name().unwrap_or_default().into()
@@ -90,10 +110,19 @@ impl KeyboardDevice {
 
     #[func]
     pub fn send_key(&self, key: GString, value: bool) {
-        let Some(proxy) = self.proxy.as_ref() else {
+        let Some(proxy) = self.keyboard_proxy.as_ref() else {
             return;
         };
         let key_code: String = key.into();
         proxy.send_key(key_code.as_str(), value).ok();
     }
+
+    /// Get the device_type of the [KeyboardDevice]
+    #[func]
+    pub fn get_type(&self) -> GString {
+        let Some(proxy) = self.target_proxy.as_ref() else {
+            return "".into();
+        };
+        proxy.device_type().unwrap_or_default().into()
+    }
 }
diff --git a/extensions/core/src/input/inputplumber/mouse_device.rs b/extensions/core/src/input/inputplumber/mouse_device.rs
index 4bc202537..731bd147a 100644
--- a/extensions/core/src/input/inputplumber/mouse_device.rs
+++ b/extensions/core/src/input/inputplumber/mouse_device.rs
@@ -1,6 +1,9 @@
 use godot::{classes::ResourceLoader, prelude::*};
 
-use crate::{dbus::inputplumber::mouse::MouseProxyBlocking, get_dbus_system_blocking};
+use crate::{
+    dbus::inputplumber::{mouse::MouseProxyBlocking, target::TargetProxyBlocking},
+    get_dbus_system_blocking,
+};
 
 use super::INPUT_PLUMBER_BUS;
 
@@ -9,7 +12,8 @@ use super::INPUT_PLUMBER_BUS;
 pub struct MouseDevice {
     base: Base<Resource>,
     path: String,
-    proxy: Option<MouseProxyBlocking<'static>>,
+    mouse_proxy: Option<MouseProxyBlocking<'static>>,
+    target_proxy: Option<TargetProxyBlocking<'static>>,
 
     #[allow(dead_code)]
     #[var(get = get_dbus_path)]
@@ -17,6 +21,9 @@ pub struct MouseDevice {
     #[allow(dead_code)]
     #[var(get = get_name)]
     name: GString,
+    #[allow(dead_code)]
+    #[var(get = get_type)]
+    device_type: GString,
 }
 
 #[godot_api]
@@ -28,7 +35,7 @@ impl MouseDevice {
             let conn = get_dbus_system_blocking().ok();
 
             // Get a proxy instance to the composite device
-            let proxy = if let Some(conn) = conn.as_ref() {
+            let mouse_proxy = if let Some(conn) = conn.as_ref() {
                 MouseProxyBlocking::builder(conn)
                     .path(path.to_string())
                     .ok()
@@ -37,18 +44,31 @@ impl MouseDevice {
                 None
             };
 
+            // Get a proxy instance to the composite device target interface
+            let target_proxy = if let Some(conn) = conn.as_ref() {
+                let path: String = path.clone().into();
+                TargetProxyBlocking::builder(conn)
+                    .path(path)
+                    .ok()
+                    .and_then(|builder| builder.build().ok())
+            } else {
+                None
+            };
+
             // Accept a base of type Base<Resource> and directly forward it.
             Self {
                 base,
-                proxy,
+                mouse_proxy,
+                target_proxy,
                 path: path.clone().into(),
                 dbus_path: path,
                 name: Default::default(),
+                device_type: Default::default(),
             }
         })
     }
 
-    /// Get or create a [KeyboardDevice] with the given DBus path. If an instance
+    /// Get or create a [MouseDevice] with the given DBus path. If an instance
     /// already exists with the given path, then it will be loaded from the resource
     /// cache.
     pub fn new(path: &str) -> Gd<Self> {
@@ -78,10 +98,10 @@ impl MouseDevice {
         self.path.clone().into()
     }
 
-    /// Get the name of the [KeyboardDevice]
+    /// Get the name of the [MouseDevice]
     #[func]
     pub fn get_name(&self) -> GString {
-        let Some(proxy) = self.proxy.as_ref() else {
+        let Some(proxy) = self.mouse_proxy.as_ref() else {
             return "".into();
         };
         proxy.name().unwrap_or_default().into()
@@ -89,9 +109,18 @@ impl MouseDevice {
 
     #[func]
     pub fn move_cursor(&self, x: i64, y: i64) {
-        let Some(proxy) = self.proxy.as_ref() else {
+        let Some(proxy) = self.mouse_proxy.as_ref() else {
             return;
         };
         proxy.move_cursor(x as i32, y as i32).ok();
     }
+
+    /// Get the device_type of the [MouseDevice]
+    #[func]
+    pub fn get_type(&self) -> GString {
+        let Some(proxy) = self.target_proxy.as_ref() else {
+            return "".into();
+        };
+        proxy.device_type().unwrap_or_default().into()
+    }
 }
